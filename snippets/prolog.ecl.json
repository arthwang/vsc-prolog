{"coverof/3":{"prefix":"coverof","body":"coverof(${1:Term}, ${2:Goal}, ${3:List})$4\n$0","description":"coverof(?Term, +Goal, -List)\n\n   Succeeds if List is the (non-empty) list of all the most general instances\nof Term such that Goal is provable.\n\nArguments\n   Term    Prolog term, usually a variable, a compound term or list    containing variables.\n   Goal    Callable term.\n   List    List or variable.\n\nType\n   All Solutions\n\nDescription\n   Unifies List with the list (not ordered, duplicates removed, pruned) of\n   all instances of Term such that Goal is satisfied.  prune_instances/2 is\n   used on the list of solutions, with the result that no element of List\n   is an instance of any other element.\n\n   The variables appearing in Term should not appear anywhere else in the\n   clause except within Goal.\n\n   The following table illustrates the difference between the all solutions\n   predicates:\n\n    built-in  choice pts  duplicates  sorted pruned *\n    bagof/3   yes    yes    no     no\n    coverof/3 yes    no    no     yes\n    findall/3 no    yes    no     no\n    setof/3   yes    no    yes    no\n   * prune_instances/2 used on list of solutions.\n\n   If Goal is not a callable term, exceptions are raised in call/2.\n\n   coverof/3 should not be used if Term is a variable.  If the resulting\n   list List contains no compound terms or variables, it is usually more\n   efficient to use setof/3.\n\nNote\n   If there are uninstantiated variables in Goal which do not appear in\n   Term, then coverof/3  can be resatisfied.  It generates alternative\n   values for List corresponding to different instantiations of the free\n   variables of Goal not in Term.  Such variables occurring in Goal will\n   not be treated as free if they are explicitly bound within Goal through\n   an existential quantification written as, for example,\n\n   coverof(X, Y^(X likes Y), S).\n\n   Then coverof/3 will not backtrack over Y when getting a list of\n   solutions of X.\n\nModes and Determinism\n   coverof(?, +, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal has no solution\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is instantiated, but not to a compound term.\n    68 --- Goal is an undefined procedure.\n\nExamples\n   \nSuccess:\n\n   % example using existential quantification:\n  [eclipse]: [user].\n   h(f(1,2),g(1,3)).\n   h(f(2,3),g(2,4)).\n   h(f(1,3),g(2,2)).\n   h(f(2,3),g(2,2)).\n   h(f(2,2),g(1,1)).\n   user compiled 900 bytes in 0.00 seconds\n\n  yes.\n  [eclipse]: coverof(f(X,Y),h(f(X,Y),g(W,Z)),L),\n  > writeln((X,Y,W,Z,L)), fail.\n  _g66 , _g72 , 1 , 1 , [f(2, 2)]\n  _g66 , _g72 , 1 , 3 , [f(1, 2)]\n  _g66 , _g72 , 2 , 2 , [f(1, 3), f(2, 3)]\n  _g66 , _g72 , 2 , 4 , [f(2, 3)]\n\n  no (more) solution.\n  [eclipse]: coverof(f(X,Y),g(W,Z)^h(f(X,Y),g(W,Z)),L).\n  X = _g76\n  Y = _g78\n  W = _g70\n  Z = _g72\n  L = [f(1, 2), f(2, 3), f(1, 3), f(2, 2)]\n  yes.\nFail:\n  coverof(Y,current_stream(X,Y,Z),[strin]).\nError:\n  coverof(X,G,L).    (Error 4).\n  coverof(X,\"G\",L).       (Error 5).\n  coverof(X,a,L).    (Error 68).\n\nSee Also\n   bagof / 3, findall / 3, setof / 3"},"findall/3":{"prefix":"findall","body":"findall(${1:Term}, ${2:Goal}, ${3:List})$4\n$0","description":"findall(?Term, +Goal, -List)\n\n   List is the (possibly empty) list of all instances of Term such that Goal\nis provable.\n\nArguments\n   Term    Prolog term, usually a variable, a compound term or list    containing variables.\n   Goal    Callable term.\n   List    List or variable.\n\nType\n   All Solutions\n\nDescription\n   Unifies List with the list (not ordered, duplicates retained, no choice\n   point) of all instances of Term such that Goal is satisfied.  The\n   variables appearing in Term should not appear anywhere else in the\n   clause except within Goal.\n\n   The following table illustrates the difference between the all solutions\n   predicates:\n\n    built-in  choice pts  duplicates  sorted pruned *\n    bagof/3   yes    yes    no     no\n    coverof/3 yes    no    no     yes\n    findall/3 no    yes    no     no\n    setof/3   yes    no    yes    no\n   * prune_instances/2 used on list of solutions.\n\n   If Goal is not a callable term, exceptions are raised in call/2.\n\nNote\n\n 1. Even if there are uninstantiated variables in Goal which do not appear\n    in Term, then unlike bagof/3, findall/3 has no choice points i.e.\n    these variables are taken to be existentially quantified.\n\n 2. findall/3 never fails; if no solution exists, the empty list is\n    returned.\n\nModes and Determinism\n   findall(?, +, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is instantiated, but not to a compound term.\n    68 --- Goal is an undefined procedure.\n\nExamples\n   \nSuccess:\n\n   % all variables are taken to be existentially quantified:\n  [eclipse]: findall(Name,current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , _g78 , _g84 , [user, user, error, debug_input, null, \"\"]\n  no (more) solution.\n\n  [eclipse]: [user].\n   h(f(1,2)).\n   h(f(1,2)).\n   h(f(1,X)).\n   h(f(X,Y)).   % instances of this element...\n   user compiled 476 bytes in 0.00 seconds\n  yes.\n  [eclipse]: findall(X,h(X),L).\n  X = _g58\n  L = [f(1, 2), f(1,2), f(1, _g116), f(_g100, _g102)]\n  yes.  % ...all bagged; includes duplicates.\n\n  [eclipse]: findall(X,current_built_in(X),L).\n  X = _g58\n  L = [findall/3, !/0, delayed_goals/1, delayed_goals/2,\n  '.'/2, (;)/2, (<)/2, (;)/4, (;)/5, error/2, error/3,\n  (',')/2, (',')/4, close_window/0, (=)/2, op/3, (>)/2,\n  array/3, (spied)/1, ... / ..., ...]\n  yes.\n\n  [eclipse]: findall(X,append_strings(X,Y,\"abc\"),L).\n  X = _g58\n  Y = _g66\n  L = [\"\", \"a\", \"ab\", \"abc\"]\n\nFail:\n  findall(Y,current_stream(X,Y,Z),[strin]).\n\nError:\n  findall(X,G,L).    (Error 4).\n  findall(X,\"G\",L).       (Error 5).\n  findall(X,a,L).    (Error 68).\n  findall(X,a(X),L).      (Error 68).\n\nSee Also\n   bagof / 3, coverof / 3, setof / 3"},"bagof/3":{"prefix":"bagof","body":"bagof(${1:Term}, ${2:Goal}, ${3:List})$4\n$0","description":"bagof(?Term, +Goal, -List)\n\n   Succeeds if List is the (non-empty) list of all instances of Term such that\nGoal is provable.\n\nArguments\n   Term    Prolog term, usually a variable, a compound term or list    containing variables.\n   Goal    Callable term.\n   List    List or variable.\n\nType\n   All Solutions\n\nDescription\n   Unifies List with the list (not ordered, duplicates retained) of all\n   instances of Term such that Goal is satisfied.  The variables appearing\n   in Term should not appear anywhere else in the clause except within\n   Goal.\n\n   The following table illustrates the difference between the all solutions\n   predicates:\n\n    built-in  choice pts  duplicates  sorted pruned *\n    bagof/3   yes    yes    no     no\n    coverof/3 yes    no    no     yes\n    findall/3 no    yes    no     no\n    setof/3   yes    no    yes    no\n   * prune_instances/2 used on list of solutions.\n\n   If Goal is not a callable term, exceptions are raised in call/2.\n\nNote\n   If there are uninstantiated variables in Goal which do not appear in\n   Term, then bagof/3 can be resatisfied.  It generates alternative values\n   for List corresponding to different instantiations of the free variables\n   of Goal not in Term.  Such variables occurring in Goal will not be\n   treated as free if they are explicitly bound within Goal through an\n   existential quantification written as, for example,\n\n   bagof(X, Y^(X likes Y), S).\n\n   Then bagof/3 will not backtrack over Y when getting a bag of solutions\n   of X.\n\nModes and Determinism\n   bagof(?, +, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal has no solution\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is instantiated, but not to a compound term.\n    68 --- Goal is an undefined procedure.\n\nExamples\n   \nSuccess:\n\n   % example using existential quantification:\n  [eclipse]: bagof(Name,Num^current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , read , _g84 , [user, debug_input]  % does not\n  _g72 , string , _g84 , [\"\"]    % backtrack over\n  _g72 , update , _g84 , [null]    % Num.\n  _g72 , write , _g84 , [user, error]\n\n  no (more) solution.\n  [eclipse]: bagof(Name,current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , read , 0 , [user]    % backtracks over Num.\n  _g72 , read , 3 , [debug_input]\n  _g72 , string , 5 , [\"\"]\n  _g72 , update , 4 , [null]\n  _g72 , write , 1 , [user]\n  _g72 , write , 2 , [error]\n\n  no (more) solution.\n  [eclipse]: bagof(Name,(Mode,Num)^current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , _g78 , _g84 , [user, user, error, debug_input, null, \"\"]\n\n  no (more) solution. % retains duplicates; not sorted.\n\n  [eclipse]: [user].\n   h(f(1,2)).\n   h(f(1,2)).\n   h(f(1,X)).\n   h(f(X,Y)).   % instances of this element...\n   user compiled 476 bytes in 0.00 seconds\n  yes.\n  [eclipse]: bagof(X,h(X),L).\n  X = _g58\n  L = [f(1, 2), f(1,2), f(1, _g116), f(_g100, _g102)]\n  yes.  % ...all bagged; includes duplicates.\n\nFail:\n  bagof(Y,current_stream(X,Y,Z),[strin]).\n\nError:\n  bagof(X,G,L).    (Error 4).\n  bagof(X,\"G\",L).       (Error 5).\n  bagof(X,a,L).    (Error 68).\n  bagof(X,a(X),L).      (Error 68).\n\nSee Also\n   coverof / 3, findall / 3, setof / 3"},"abs/2":{"prefix":"abs","body":"abs(${1:Number}, ${2:Result})$3\n$0","description":"abs(+Number, -Result)\n\n   Unifies the absolute value of Number with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or a number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to abs(Number, Result) is\n   equivalent to\n\n    Result is abs(Number)\n\n   which should be preferred for portability.\n\n   Number and Result have to be of the same type.\n\n   In coroutining mode, if Number is uninstantiated, the call to abs/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   abs(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      abs(1, 1).\n      abs(-5, Result).    (gives Result = 5)\n      abs(-6.2, Result).    (gives Result = 6.2)\nFail:\n      abs(1, 0).\n      abs(1, 1.0).\n      abs(-1.0, 1).\n      abs(1, r).\nError:\n      abs(A, 6).    (Error 4).\n      abs(4 + 2, 6).    (Error 24).\n\nSee Also\n   is / 2"},"acos/2":{"prefix":"acos","body":"acos(${1:Number}, ${2:Result})$3\n$0","description":"acos(+Number, -Result)\n\n   Evaluates the trigonometric function acos(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to acos(Number, Result) is\n   equivalent to\n\n    Result is acos(Number)\n\n   which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to acos/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   acos(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n    20 --- Illegal arithmetic operation: Number is greater than 1 or less than -1.\n   141 --- Argument is of type breal\n\nExamples\n   \nSuccess:\n      acos(1.0, 0.0).\n      acos(-0.5, Result).       (gives Result = 2.0944)\n      acos(0, Result).    (gives Result = 1.5708)\nFail:\n      acos(1, 1.0).\n      acos(1, r).\n      acos(1, 0).\nError:\n      acos(A, 6.0).    (Error 4).\n      acos(2, Result).    (Error 20).\n      acos(4 - 3, 0.0).    (Error 24).\n\nSee Also\n   is / 2"},"asin/2":{"prefix":"asin","body":"asin(${1:Number}, ${2:Result})$3\n$0","description":"asin(+Number, -Result)\n\n   Evaluates the trigonometric function asin(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to asin(Number, Result) is\n   equivalent to\n\n    Result is asin(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to asin/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   asin(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n    20 --- Illegal arithmetic operation: Number is greater than 1 or less than -1.\n   141 --- Argument is of type breal\n\nExamples\n   \nSuccess:\n      asin(1.0, Result).    (gives Result = 1.5708)\n      asin(-0,5, Result).    (gives Result = -0.523599)\nFail:\n      asin(1, 0.0).\n      asin(1, 3).\n      asin(1, r).\nError:\n      asin(A, 6.0).    (Error 4).\n      asin(2, Result).    (Error 20).\n      asin(4 + 2, -0.279415).    (Error 24).\n\nSee Also\n   is / 2"},"atan/2":{"prefix":"atan","body":"atan(${1:Number}, ${2:Result})$3\n$0","description":"atan(+Number, -Result)\n\n   Evaluates the trigonometric function atan(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to atan(Number, Result) is\n   equivalent to\n\n    Result is atan(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to atan/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   atan(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      atan(0.0, 0.0).\n      atan(1.0, Result).       (gives Result = 0.785398)\n      atan(-8, Result).    (gives Result = -1.44644)\nFail:\n      atan(1, 0.0).\n      atan(1.55741, 1).\n      atan(5, r).\nError:\n      atan(A, 6.0).    (Error 4).\n      atan(1 + 0.55741, 1.0).    (Error 24).\n\nSee Also\n   is / 2"},"atan/3":{"prefix":"atan","body":"atan(${1:Y}, ${2:X}, ${3:Result})$4\n$0","description":"atan(+Y, +X, -Result)\n\n   Computes the arc tangent function of two variables and unifies the resulting value with Result.\n\nArguments\n   Y    A number.\n   X    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to atan(Y, X, Result) is\n   equivalent to\n\n    Result is atan(Y, X)\n\n    which should be preferred for portability.\n\n    It is similar to calculating the arc tangent of Y/X, except that the\n    signs of both arguments are used to determine the quadrant of the result.\n    The result lies in the interval -pi..pi. The operation is valid even if\n    X is zero, in which case the result is pi/2 or -pi/2.  One application\n    is the conversion of cartesian to polar coordinates, where this function\n    computes the angle component (in radians).\n\n   In coroutining mode, if X or Y is uninstantiated, the call to atan/3 is\n   delayed until both variables are instantiated.\n\nModes and Determinism\n   atan(+, +, -) is det\n\nExceptions\n     4 --- X or Y is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      atan( 0.0, -1.0, Result).\t(gives Result =  3.141592)\n      atan( 1.0, -1.0, Result).\t(gives Result =  2.356194)\n      atan( 1.0,  0.0, Result).\t(gives Result =  1.570796)\n      atan( 1.0,  1.0, Result).\t(gives Result =  0.785398)\n      atan( 0.0,  0.0, Result).\t(gives Result =  0.0)\n      atan(-1.0,  1.0, Result).\t(gives Result = -0.785398)\n      atan(-1.0,  0.0, Result).\t(gives Result = -1.570796)\n      atan(-1.0, -1.0, Result).\t(gives Result = -2.356194)\n      atan(-0.0, -1.0, Result).\t(gives Result = -3.141592)\n\n      atan( 7.0,  7.0, Result).\t(gives Result =  0.785398)\n\nFail:\n      atan(1.55741, 0.0, 1).\n\nError:\n      atan(A, 0.0, 6.0).    (Error 4).\n      atan(1 + 0.55741, 1.0, R).      (Error 24).\n\nSee Also\n   is / 2"},"setof/3":{"prefix":"setof","body":"setof(${1:Term}, ${2:Goal}, ${3:List})$4\n$0","description":"setof(?Term, +Goal, -List)\n\n   Succeeds if List is the (non-empty) ordered list of all instances of Term\nsuch that Goal is provable.\n\nArguments\n   Term    Prolog term, usually a variable, a compound term or list    containing variables.\n   Goal    Callable term.\n   List    List or variable.\n\nType\n   All Solutions\n\nDescription\n   Unifies List with the ordered list (no duplicates) of all instances of\n   Term such that Goal is satisfied.  The variables appearing in Term\n   should not appear anywhere else in the clause except within Goal.\n\n   The following table illustrates the difference between the all solutions\n   predicates:\n\n    built-in  choice pts  duplicates  sorted pruned *\n    bagof/3   yes    yes    no     no\n    coverof/3 yes    no    no     yes\n    findall/3 no    yes    no     no\n    setof/3   yes    no    yes    no\n   * prune_instances/2 used on list of solutions.\n\n   If Goal is not a callable term, exceptions are raised in call/2.\n\nNote\n   If there are uninstantiated variables in Goal which do not appear in\n   Term, then setof/3 can be resatisfied.  It generates alternative values\n   for List corresponding to different instantiations of the free variables\n   of Goal not in Term.  Such variables occurring in Goal will not be\n   treated as free if they are explicitly bound within Goal through an\n   existential quantification written as, for example,\n\n   setof(X, Y^(X likes Y), S).\n\n   Then setof/3 will not backtrack over Y when getting a set of solutions\n   of X.\n\nModes and Determinism\n   setof(?, +, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal has no solution\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is instantiated, but not to a compound term.\n    68 --- Goal is an undefined procedure.\n\nExamples\n   \nSuccess:\n\n   % example using existential quantification:\n  [eclipse]: setof(Name,Num^current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , read , _g84 , [debug_input, user] % does not\n  _g72 , string , _g84 , [\"\"]    % backtrack over\n  _g72 , update , _g84 , [null]    & Num.\n  _g72 , write , _g84 , [error, user]\n\n  no (more) solution.\n  [eclipse]: setof(Name,current_stream(Name,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , read , 0 , [user]    % backtracks over Num.\n  _g72 , read , 3 , [debug_input]\n  _g72 , string , 5 , [\"\"]\n  _g72 , update , 4 , [null]\n  _g72 , write , 1 , [user]\n  _g72 , write , 2 , [error]\n\n  no (more) solution.\n  [eclipse]: setof(N,(Mode,Num)^current_stream(N,Mode,Num),L),\n  > writeq((Name,Mode,Num,L)), nl, fail.\n  _g72 , _g78 , _g84 , [\"\", debug_input, error, null, user]\n\n  no (more) solution. % removes duplicates; sorted.\n\n  [eclipse]: [user].\n   h(f(1,2)).\n   h(f(1,2)).\n   h(f(1,X)).\n   h(f(X,Y)).   % instances of this element...\n   user compiled 476 bytes in 0.00 seconds\n  yes.\n  [eclipse]: setof(X,h(X),L).\n  X = _g58\n  L = [f(_g86, _g88), f(1, _g102), f(1, 2)]\n  yes.   % ...all bagged; removes duplicates; sorted.\n\nFail:\n  setof(Y,current_stream(X,Y,Z),[strin]).\n\nError:\n  setof(X,G,L).    (Error 4).\n  setof(X,\"G\",L).       (Error 5).\n  setof(X,a,L).    (Error 68).\n  setof(X,a(X),L).      (Error 68).\n\nSee Also\n   bagof / 3, coverof / 3, findall / 3"},"between/4":{"prefix":"between","body":"between(${1:From}, ${2:To}, ${3:Step}, ${4:Result})$5\n$0","description":"between(+From, +To, +Step, -Result)\n\n   Generate integer values between From and To with Step increment.\n\nArguments\n   From    Integer\n   To    Integer\n   Step    Integer\n   Result    A variable or an integer\n\nType\n   Arithmetic\n\nDescription\n   When first called, this predicate checks that From is less than or equal\n   to To (or greater than or equal if Step is negative) and if so, it binds\n   Result to From.  On backtracking it increments Result by Step until it\n   is greater than To (less than To is Step is negative) and then it fails.\n\nModes and Determinism\n   between(+, +, +, -) is nondet\n\nFail Conditions\n   Fails if To is less than From (for positive Step), or From less than To (for negative Step)\n\nExceptions\n     4 --- Input arguments are not instantiated.\n     5 --- An argument is not an integer.\n     6 --- Step is zero.\n    24 --- An argument is not a number.\n\nExamples\n   \nSuccess:\n      between(1, 4, 1, X).\n      between(5, 0, -2, X).\n      between(2, 10, 3, 8).\n      between(3, 3, 1, X).\nFail:\n      between(2, 0, 1, X).\nError:\n      between(1, 4, S, X).    (Error 4)\n      between(1, 4, 0.1, X).       (Error 5)\n      between(1, 4, 0, X).    (Error 6)\n      between(1, 4, 1, a).    (Error 24)\n\nSee Also"},"breal_bounds/3":{"prefix":"breal_bounds","body":"breal_bounds(${1:Number}, ${2:Min}, ${3:Max})$4\n$0","description":"breal_bounds(+Number, -Min, -Max)\n\n   Extracts lower and upper floating point bounds of Number\n\nArguments\n   Number    A number.\n   Min    A variable or float.\n   Max    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n    A bounded real is a real number represented by a lower and upper\n    bound in floating point format. This predicate extracts both bounds\n    and unifies them with Min and Max respectively. If Number is not a\n    bounded real, the result returned is equivalent to converting it to\n    a bounded real first.\n\nModes and Determinism\n   breal_bounds(+, -, -) is det\n\nExceptions\n     4 --- Number is not instantiated\n    24 --- Number is a not a number.\n\nExamples\n   \nSuccess:\n    ?- breal_bounds(0.99__1.01, Min, Max).\n    Min = 0.99\n    Max = 1.01\n\n    ?- breal(1.0, One), breal_bounds(One, Min, Max).\n    One = 1.0__1.0\n    Min = 1.0\n    Max = 1.0\n\n    ?- breal(1, One), breal_bounds(One, Min, Max).\n    One = 1.0__1.0\n    Min = 1.0\n    Max = 1.0\n\n    ?- breal_bounds(1, Min, Max).\n    Min = 1.0\n    Max = 1.0\n\n    ?- breal_bounds(1.0, Min, Max).\n    Min = 1.0\n    Max = 1.0\n\n    ?- breal_bounds(1_10, Min, Max).\n    Min = 0.099999999999999992\n    Max = 0.10000000000000002\n\nError:\n    ?- breal_bounds(\"a\", Min, Max).\n    number expected in breal_bounds(\"a\", Min, Max)\n\n    ?- breal_bounds(2 + 4, Min, Max).\n    number expected in breal_bounds(2 + 4, Min, Max)\n\nSee Also\n   breal / 1, breal / 2, breal_min / 2, breal_max / 2, breal_from_bounds / 3, is / 2"},"breal_from_bounds/3":{"prefix":"breal_from_bounds","body":"breal_from_bounds(${1:Lo}, ${2:Hi}, ${3:Result})$4\n$0","description":"breal_from_bounds(+Lo, +Hi, -Result)\n\n   Constructs a bounded real from the given floating point bounds\n\nArguments\n   Lo    A number.\n   Hi    A number.\n   Result    A variable.\n\nType\n   Arithmetic\n\nDescription\n    This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So a call to breal_from_bounds(Lo, Hi, Result)\n    is equivalent to\n\n    Result is breal_from_bounds(Lo, Hi).\n\n    This predicate constructs a new bounded real number with the specified\n    bounds. In effect, the bounds are first cast to bounded reals, and then\n    the new bounded real is constructed from the lower bound of Lo and the\n    upper bound of Hi.\n\nModes and Determinism\n   breal_from_bounds(+, +, -) is det\n\nExceptions\n     4 --- Lo or Hi are not instantiated.\n    20 --- The lower bound of Lo is greater than the upper bound of Hi.\n    24 --- Lo or Hi are not numbers.\n\nExamples\n   \nSuccess:\n      ?- breal_from_bounds(0.99, 1.01, X).\n      X = 0.99__1.01\n\n      ?- breal_from_bounds(1_3, 2_3, X).\n      X = 0.33333333333333326__0.66666666666666674\n\nError:\n      ?- breal_from_bounds(1, H, X).\n      instantiation fault in breal_from_bounds(1, H, X)\n\n      ?- breal_from_bounds(\"a\", 2.0, X).\n      number expected in breal_from_bounds(\"a\", 2.0, X)\n\n      ?- breal_from_bounds(2 + 4, 3 + 5, Z).\n      number expected in breal_from_bounds(2 + 4, 3 + 5, Z)\n\n      ?- breal_from_bounds(1.0, 2.0, 1.0__2.0).\n      type error in breal_from_bounds(1.0, 2.0, 1.0__2.0)\n\n      ?- breal_from_bounds(1.1, 0.9, X).\n      arithmetic exception in breal_from_bounds(1.1, 0.9, X)\n\nSee Also\n   breal_min / 2, breal_max / 2, breal / 1, breal / 2, breal_bounds / 3, is / 2"},"clrbit/3":{"prefix":"clrbit","body":"clrbit(${1:Number}, ${2:Index}, ${3:Result})$4\n$0","description":"clrbit(+Number, +Index, -Result)\n\n   Result is Number with the Index'th bit cleared.\n\nArguments\n   Number    Integer.\n   Index    Non-negative integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   Clear the Index'th bit in Number giving Result. The least significant\n   bit has index zero. Two's complement representation is assumed.\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to clrbit(Number, Index, Result) is\n   equivalent to\n\n    Result is clrbit(Number, Index)\n\n   which should be preferred.\n\n   In coroutining mode, if Number or Index are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\nModes and Determinism\n   clrbit(+, +, -) is det\n\nExceptions\n     4 --- Number or Index is not instantiated (non-coroutining mode    only).\n     5 --- Number or Index is a number but not an integer.\n    24 --- Number or Index is not of a numeric type.\n\nExamples\n   \nSuccess:\n      clrbit(15, 3, 7).\n      clrbit(40, 3, X).    gives X=32.\n      X is clrbit(setbit(0,5),5).  gives X=0.\n\nSee Also\n   is / 2, setbit / 3, getbit / 3"},"breal/2":{"prefix":"breal","body":"breal(${1:Number}, ${2:Result})$3\n$0","description":"breal(+Number, -Result)\n\n   Converts Number into a breal number and unifies it with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or bounded real number.\n\nType\n   Arithmetic\n\nDescription\n    This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So the call to breal(Number, Result) is\n    equivalent to\n\n    Result is breal(Number)\n\n    which should be preferred.\n\nModes and Determinism\n   breal(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n    ?- breal(25, X).\n    X = 25.0__25.0\n\n    ?- breal(1.5, X).\n    X = 1.5__1.5\n\n    ?- breal(3_4, X).\n    X = 0.74999999999999989__0.75000000000000011\n\n    ?- breal(1.0__1.01, X).\n    X = 1.0__1.01\n\nFail:\n    ?- breal(1.0, 0.9__1.1).\n    No (0.00s cpu)\n\n    ?- breal(3, 3).\n    No (0.00s cpu)\n\n    ?- breal(1, r).\n    No (0.00s cpu)\n\nError:\n    ?- breal(A, X).\n    instantiation fault in breal(A, X)\n\n    ?- breal(4 + 2, X).\n    number expected in breal(4 + 2, X)\n\nSee Also\n   integer / 2, float / 2, rational / 2, is / 2, breal_min / 2, breal_max / 2, breal_bounds / 3, breal_from_bounds / 3, breal / 1"},"ceiling/2":{"prefix":"ceiling","body":"ceiling(${1:Number}, ${2:Result})$3\n$0","description":"ceiling(+Number, -Result)\n\n   Unifies Result with the least integral value that is greater than or equal to\nNumber and of the same numeric type as Number.\n\nArguments\n   Number    A number.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to ceiling(Number, Result) is\n   equivalent to\n\n    Result is ceiling(Number)\n\n    which should be preferred.\n\n   This operation works on all numeric types.  The result value is the\n   smallest integral value that is greater than Number (rounding up\n   towards positive infinity).\n\n   The result type is the same as the argument type.  To convert the\n   type to integer, use integer/2.\n\n   In coroutining mode, if Number is uninstantiated, the call to ceiling/2\n   is delayed until this variable is instantiated.\n\nModes and Determinism\n   ceiling(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      ceiling(1.8, 2.0).\n      ceiling(-1.8, -1.0).\n      ceiling(5, 5).\n      ceiling(-6.4, Result).      (gives Result = -6.0)\nFail:\n      ceiling(0.0, 1.0).\n      ceiling(0.5, 0).\n      ceiling(1, r).\nError:\n      ceiling(A, 6.0).    (Error 4).\n      ceiling(4 + 2.3, 6.0).    (Error 24).\n\nSee Also\n   is / 2, floor / 2, round / 2, truncate / 2, integer / 2"},"arithmetic_desc":{"prefix":"lib","body":"lib(${1:arithmetic})$2\n$0","description":"lib(arithmetic)\n\nSee also the User Manual chapter on Arithmetic"},"cos/2":{"prefix":"cos","body":"cos(${1:Number}, ${2:Result})$3\n$0","description":"cos(+Number, -Result)\n\n   Evaluates the trigonometric function cos(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to cos(Number, Result) is\n   equivalent to\n\n    Result is cos(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to cos/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   cos(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      cos(0, 1.0).\n      cos(1.2, Result).    (gives Result = 0.362358)\n      cos(-33, Result).    (gives Result = -0.0132767)\nFail:\n      cos(1, 0.0).\n      cos(0, 1).\n      cos(5, r).\nError:\n      cos(A, 6.0).    (Error 4).\n      cos(4 + 2, 0.96017).    (Error 24).\n\nSee Also\n   is / 2"},"denominator/2":{"prefix":"denominator","body":"denominator(${1:Number}, ${2:Result})$3\n$0","description":"denominator(+Number, -Result)\n\n   Extracts the denominator of the rational Number and unifies the resulting\ninteger with Result.\n\nArguments\n   Number    An integer or rational number.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to denominator(Number, Result) is\n   equivalent to\n\n    Result is denominator(Number)\n\n    which should be preferred.\n\n   In coroutining mode, if Number is uninstantiated, the call to\n   denominator/2 is delayed until this variable is instantiated.\n\nModes and Determinism\n   denominator(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n     5 --- Number is a float or breal.\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      denominator(3_4, 4).\n      denominator(9_12, 4).\n      denominator(-3_4, 4).\n      denominator(25, 1).\nFail:\n      denominator(3_4, 3).\n      denominator(3.1, 3).\n      denominator(3_4, 3_1).\n      denominator(3_4, r).\nError:\n      denominator(A, 3).    (Error 4).\n      denominator(1_3 + 3_4, 12).    (Error 24).\n\nSee Also\n   is / 2, numerator / 2, rational / 2"},"div/3":{"prefix":"div","body":"div(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"div(+Number1, +Number2, -Result)\n\n   Evaluates the integer quotient Number1 div Number2 and unifies the resulting\nvalue with Result.\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to div(Number1, Number2, Result) is\n   equivalent to\n\n    Result is Number1 div Number2\n\n    which should be preferred for portability.\n\n    This division operates on integer arguments, and delivers an\n    integer result rounded down towards negative infinity (floored). \n    The corresponding remainder is computed by the mod operation, such\n    that the following equivalence always holds:\n\n    X =:= (X mod Y) + (X div Y) * Y.\n\n    The relationship with floating-point division is:\n\n    X div Y =:= integer(floor(X/Y)).\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to (div)/3 is delayed until these variables are instantiated.\n\nModes and Determinism\n   div(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    24 --- Number1 or Number2 is not of a numeric type.\n    20 --- Illegal arithmetic operation:  division by 0\n\nExamples\n   \nSuccess:\n      X is 10 div 3.\t\t( gives X = 3)\n\n      div( 10,  3,  3).\n      div(-10,  3, -4).\n      div( 10, -3, -4).\n      div(-10, -3,  3).\nFail:\n      div(1, 2, 3).\n      div(6, 2, 3.0).\n      div(5, 2, r).\nError:\n      div(A, 2, 6).    (Error 4).\n      div(6, 2.0, 3.0).    (Error 5).\n      div(2, 0, Result).    (Error 20).\n      div(4 + 2, 2, 12).    (Error 24).\n\nSee Also\n   is / 2, // / 3, mod / 3"},"eval/2":{"prefix":"eval","body":"eval(${1:Expression}, ${2:Result})$3\n$0","description":"eval(+Expression, -Result)\n\n   Used to evaluate eval/1 terms in arithmetic expressions.\n\nArguments\n   Expression    An arithmetic expression.\n   Result    A variable or a number.\n\nType\n   Arithmetic\n\nDescription\n   This is one of the predicates used by the ECLiPSe compiler to expand\n   arithmetic expressions. If an expression contains a subexpression that\n   is not known at compile time, it must be wrapped in eval/1, e.g.\n\n   X is eval(Expr)+1\n\n   This will be compiled into the sequence\n\n   eval(Expr,T1), +(T1,1,X)\n\n   and eval/2 will interpret the expression Expr at runtime.\n\nModes and Determinism\n   eval(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Expression is uninstantiated.\n    21 --- An evaluation predicate in the expression is not defined.\n    24 --- Expression is not a valid arithmetic expression.\n\nExamples\n   \n\nSee Also\n   is / 2"},"fix/2":{"prefix":"fix","body":"fix(${1:Number}, ${2:Result})$3\n$0","description":"fix(+Number, -Result)\n\n   Unifies the integer part of Number with Result (Truncation towards zero).\n\nArguments\n   Number    A number.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to fix(Number, Result) is\n   equivalent to\n\n    Result is fix(Number)\n\n    which should be preferred for portability.\n\n    This function is deprecated. For clearer code, please use\n\n    Result is integer(truncate(Number)).\n\n   In coroutining mode, if Number is uninstantiated, the call to fix/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   fix(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n     5 --- Number is of type breal.\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      fix(1.5, 1).\n      fix(-6.4, -6).\nFail:\n      fix(1, 0).\n      fix(0.0, 0.0).\n      fix(1, r).\nError:\n      fix(A, 6.0).    (Error 4).\n      fix(4 + 2.3, 6).    (Error 24).\n\nSee Also\n   is / 2, integer / 2, truncate / 2, floor / 2, ceiling / 2, round / 2"},"exp/2":{"prefix":"exp","body":"exp(${1:Number}, ${2:Result})$3\n$0","description":"exp(+Number, -Result)\n\n   Evaluates the exponential function exp(Number) (\"e to the power of Number\")\nand unifies the resulting value with Result.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to exp(Number, Result) is\n   equivalent to\n\n    Result is exp(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to exp/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   exp(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      exp(0.0, Result).       (gives Result = 1.0)\n      exp(-6, Result).    (gives Result = 0.00247875)\nFail:\n      exp(1, 0.0).\n      exp(0, 1).\n      exp(1, r).\nError:\n      exp(A, 6.0).    (Error 4).\n      exp(4 + 2, 403.429).    (Error 24).\n\nSee Also\n   is / 2"},"float/2":{"prefix":"float","body":"float(${1:Number}, ${2:Result})$3\n$0","description":"float(+Number, -Result)\n\n   Converts Number to float and unifies the resulting value with\nResult.\n\nArguments\n   Number    A number.\n   Result    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to float(Number, Result) is\n   equivalent to\n\n    Result is float(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to float/2\n   is delayed until this variable is instantiated.\n\nModes and Determinism\n   float(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      float(1, 1.0).\n      float(-6, Result).    (gives Result = -6.0)\nFail:\n      float(1, 0.0).\n      float(0, 0).\n      float(1, r).\nError:\n      float(A, 6.0).    (Error 4).\n      float(4 + 2, 6.0).    (Error 24).\n\nSee Also\n   is / 2"},"floor/2":{"prefix":"floor","body":"floor(${1:Number}, ${2:Result})$3\n$0","description":"floor(+Number, -Result)\n\n   Unifies Result with the greatest integral value that is less or equal than\nNumber and of the same numeric type as Number.\n\nArguments\n   Number    A number.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to floor(Number, Result) is\n   equivalent to\n\n    Result is floor(Number)\n\n   which should be preferred for portability.\n\n   This operation works on all numeric types. The result value is the\n   largest integral value that is smaller that Number (rounding down\n   towards minus infinity).\n\n   The result type is the same as the argument type.  To convert the\n   type to integer, use integer/2.\n\n   In coroutining mode, if Number is uninstantiated, the call to floor/2\n   is delayed until this variable is instantiated.\n\nModes and Determinism\n   floor(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      floor(1.8, 1.0).\n      floor(-1.8, -2.0).\n      floor(5, 5).\n      floor(-6.4, Result).      (gives Result = -7.0)\nFail:\n      floor(1.0, 0.0).\n      floor(0.5, 0).\n      floor(1, r).\nError:\n      floor(A, 6.0).    (Error 4).\n      floor(4 + 2.3, 6.0).    (Error 24).\n\nSee Also\n   is / 2, ceiling / 2, round / 2, truncate / 2, integer / 2"},"gcd/3":{"prefix":"gcd","body":"gcd(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"gcd(+Number1, +Number2, -Result)\n\n   Unifies Results with the Greatest Common Divisor of Number1 and Number2\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to gcd(Number1, Number2, Result) is\n   equivalent to\n\n    Result is gcd(Number1, Number2)\n\n    which should be preferred for portability.\n\n   The Greatest Common Divisor operation is only defined on integer arguments.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\nModes and Determinism\n   gcd(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      gcd(9, 15, 3).\n      gcd(-9, 15, 3).\n      gcd(2358352782,97895234896224,X).  ( gives X = 6 )\n\nFail:\n      gcd(1, 2, 3.0).\nError:\n      gcd(A, 2, 6).    (Error 4).\n      gcd(1.0, 2, 3.0).    (Error 5).\n      gcd(4 + 2, 2, 12).    (Error 24).\n\nSee Also\n   gcd / 5, lcm / 3, is / 2"},"getbit/3":{"prefix":"getbit","body":"getbit(${1:Number}, ${2:Index}, ${3:Result})$4\n$0","description":"getbit(+Number, +Index, -Result)\n\n   Result is the Index'th bit of Number.\n\nArguments\n   Number    Integer.\n   Index    Non-negative integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   Returns the Index'th bit of Number, assuming binary two's complement\n   representation.  The least significant bit has index zero.\n   The result is either 0 or 1.\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to getbit(Number, Index, Result) is\n   equivalent to\n\n    Result is getbit(Number, Index)\n\n   which should be preferred.\n\n   In coroutining mode, if Number or Index are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\nModes and Determinism\n   getbit(+, +, -) is det\n\nExceptions\n     4 --- Number or Index is not instantiated (non-coroutining mode    only).\n     5 --- Number or Index is a number but not an integer.\n    24 --- Number or Index is not of a numeric type.\n\nExamples\n   \nSuccess:\n      getbit(10, 3, 1).\n      getbit(10, 2, 0).\n      getbit(10, 99, 0).\n\nSee Also\n   is / 2, clrbit / 3, setbit / 3"},"gcd/5":{"prefix":"gcd","body":"gcd(${1:Number1}, ${2:Number2}, ${3:U}, ${4:V}, ${5:GCD})$6\n$0","description":"gcd(+Number1, +Number2, -U, -V, -GCD)\n\n   Unifies GCD with the Greatest Common Divisor of\n\tNumber1 and Number2, and gives appropriate coefficients U and\n\tV for the corresponding Bezout equation\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   U    A variable of integer.\n   V    A variable or integer.\n   GCD    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n\n   The Greatest Common Divisor operation is only defined on integer arguments.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\n   The Bezout equation is Number1*U + Number2*V = GCD.  These\n   coefficients are calculated by an extended version of Euclid's\n   algorithm.\n\nModes and Determinism\n   gcd(+, +, -, -, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      gcd(9, 15, 2, -1, 3).\n      gcd(-9, 15, -2, -1, 3).\n      gcd(2358352782,97895234896224,U,V,G).  ( gives U = 2130001290117, V = -51312962, G = 6 )\n\nFail:\n      gcd(1, 2, U, V, 3.0).\nError:\n      gcd(A, 2, U, V, 6).    (Error 4).\n      gcd(1.0, 2, U, V, 3.0).    (Error 5).\n      gcd(4 + 2, 2, U, V, 12).    (Error 24).\n\nSee Also\n   gcd / 3, lcm / 3, is / 2"},"integer/2":{"prefix":"integer","body":"integer(${1:Number}, ${2:Result})$3\n$0","description":"integer(+Number, -Result)\n\n   Convert an integral number of any type to an integer\n\nArguments\n   Number    A number.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to integer(Number, Result) is\n   equivalent to\n\n    Result is integer(Number)\n\n    which should be preferred for portability.\n\n    This is a pure type conversion operation. If Number has an integral value\n    of any type, Result is that same value, but represented as an integer.\n    If Number does not have an integral value, an exception is raised.\n    This function should therefore normally be applied to the result of\n    one of the rounding operations floor, ceiling, round or truncate.\n\n   In coroutining mode, if Number is uninstantiated, the call to integer/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   integer(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n     5 --- Number is of type breal.\n    20 --- Number is not integral.\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      X is integer(5.0).    (gives X = 5)\n\n      integer(5, 5).\n      integer(5.0, 5).\n      integer(5_1, 5).\n      integer(5.0__5.0, 5).\n\nFail:\n      integer(0.0, 0.0).\n      integer(1, r).\n\nError:\n      integer(1.1, X).    (Error 20)\n      integer(5_4, X).    (Error 20)\n      integer(0.99__1.01, X).    (Error 20)\n      integer(A, 6.0).    (Error 4).\n      integer(4 + 2.3, 6).    (Error 24).\n\nSee Also\n   is / 2, floor / 2, ceiling / 2, round / 2, truncate / 2"},"lcm/3":{"prefix":"lcm","body":"lcm(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"lcm(+Number1, +Number2, -Result)\n\n   Unifies Results with the Least Common Multiple of Number1 and Number2\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to lcm(Number1, Number2, Result) is\n   equivalent to\n\n    Result is lcm(Number1, Number2)\n\n    which should be preferred for portability.\n\n   The Least Common Multiple operation is only defined on integer arguments.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\nModes and Determinism\n   lcm(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      lcm(9, 15, 45).\n      lcm(-9, 15, 45).\n      lcm(2358352782,97895234896224,X).  ( gives X = 38478583260342225282528 )\n\nFail:\n      lcm(1, 2, 3.0).\nError:\n      lcm(A, 2, 6).    (Error 4).\n      lcm(1.0, 2, 3.0).    (Error 5).\n      lcm(4 + 2, 2, 12).    (Error 24).\n\nSee Also\n   gcd / 3, gcd / 5, is / 2"},"breal_min/2":{"prefix":"breal_min","body":"breal_min(${1:Number}, ${2:Result})$3\n$0","description":"breal_min(+Number, -Result)\n\n   Extracts the lower floating point bound of Number\n\nArguments\n   Number    A number.\n   Result    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n    This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So a call to breal_min(Number, Result) is\n    equivalent to\n\n    Result is breal_min(Number).\n\n    A bounded real is a real number represented by a lower and upper\n    bound in floating point format. This predicate extracts the lower\n    bound and unifies it with Result. If Number is not a bounded real,\n    the result returned is equivalent to converting it to a bounded real\n    first.\n\nModes and Determinism\n   breal_min(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated\n    24 --- Number is a not a number.\n\nExamples\n   \nSuccess:\n      ?- breal_min(0.99__1.01, X).\n      X = 0.99\n\n      ?- breal_min(1, X).\n      X = 1.0\n\n      ?- breal_min(1.0, X).\n      X = 1.0\n\n      ?- breal_min(1_10, X).\n      X = 0.099999999999999992\n\nError:\n      ?- breal_min(\"a\", Z).\n      number expected in breal_min(\"a\", Z)\n\n      ?- breal_min(2 + 4, Z).\n      number expected in breal_min(2 + 4, Z)\n\nSee Also\n   breal_max / 2, breal / 1, breal / 2, breal_bounds / 3, breal_from_bounds / 3, is / 2"},"breal_max/2":{"prefix":"breal_max","body":"breal_max(${1:Number}, ${2:Result})$3\n$0","description":"breal_max(+Number, -Result)\n\n   Extracts the upper floating point bound of Number\n\nArguments\n   Number    A number.\n   Result    A variable or float.\n\nType\n   Arithmetic\n\nDescription\n    This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So a call to breal_max(Number, Result) is\n    equivalent to\n\n    Result is breal_max(Number).\n\n    A bounded real is a real number represented by a lower and upper\n    bound in floating point format. This predicate extracts the upper\n    bound and unifies it with Result. If Number is not a bounded real,\n    the result returned is equivalent to converting it to a bounded real\n    first.\n\nModes and Determinism\n   breal_max(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated\n    24 --- Number is a not a number.\n\nExamples\n   \nSuccess:\n      ?- breal_max(0.99__1.01, X).\n      X = 1.01\n\n      ?- breal_max(1, X).\n      X = 1.0\n\n      ?- breal_max(1.0, X).\n      X = 1.0\n\n      ?- breal_max(1_10, X).\n      X = 0.10000000000000002\n\nError:\n      ?- breal_max(\"a\", Z).\n      number expected in breal_max(\"a\", Z)\n\n      ?- breal_max(2 + 4, Z).\n      number expected in breal_max(2 + 4, Z)\n\nSee Also\n   breal_min / 2, breal / 1, breal / 2, breal_bounds / 3, breal_from_bounds / 3, is / 2"},"max/2":{"prefix":"max","body":"max(${1:ExprList}, ${2:Result})$3\n$0","description":"max(+ExprList, -Result)\n\n   Evaluates the the arithmetic expressions in ExprList and unifies their maximum\nwith Result.\n\nArguments\n   ExprList    A list of arithmetic expressions.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So the call to max(ExprList, Result) is\n    equivalent to\n\n    Result is max(ExprList)\n\n    which should be preferred.\n\n   In coroutining mode, if the list is only partly instantiated, the\n   predicate delays until the list is complete.\n\nModes and Determinism\n   max(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ExprList is a partial list (non-coroutining mode only).\n     5 --- ExprList is not a proper list.\n\nExamples\n   \nSuccess:\n      X is max([1,2,3]).    % gives X = 3\n      X is max([1,2.0,3]).  % gives X = 3.0\n\nSee Also\n   is / 2, max / 3, min / 2"},"max/3":{"prefix":"max","body":"max(${1:Number1}, ${2:Number2}, ${3:Maximum})$4\n$0","description":"max(+Number1, +Number2, -Maximum)\n\n   Unifies the maximum of Number1 and Number2 with Maximum.\n\nArguments\n   Number1    A number.\n   Number2    A number.\n   Maximum    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to max(Number1, Number2, Maximum)\n   is equivalent to\n\n\tMaximum is max(Number1, Number2)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to max/3 is delayed until these variables are instantiated.\n\nModes and Determinism\n   max(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      max(5, 2, 5).\n      max(2_3, 3_4, 3_4).\n      max(5.0 , 2.0, 5.0).\n      max(5, 2.0, 5.0).    (The types are adjusted)\n      max(5, 2_0, 5_0).    (The types are adjusted)\nFail:\n      max(1, 2, 3).\n      max(1, 2, 2.0).\n      max(5, 2, r).\n      max(5, 2.0, 5).\nError:\n      max(A, 2, 6).    (Error 4).\n      max(4 - 2, 3, 3).    (Error 24).\n\nSee Also\n   is / 2"},"min/2":{"prefix":"min","body":"min(${1:ExprList}, ${2:Result})$3\n$0","description":"min(+ExprList, -Result)\n\n   Evaluates the the arithmetic expressions in ExprList and unifies their minimum\nwith Result.\n\nArguments\n   ExprList    A list of arithmetic expressions.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So the call to min(ExprList, Result) is\n    equivalent to\n\n    Result is min(ExprList)\n\n    which should be preferred.\n\n   In coroutining mode, if the list is only partly instantiated, the\n   predicate delays until the list is complete.\n\nModes and Determinism\n   min(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ExprList is a partial list (non-coroutining mode only).\n     5 --- ExprList is not a proper list.\n\nExamples\n   \nSuccess:\n      X is min([1,2,3]).    % gives X = 1\n      X is min([1,2.0,3]).  % gives X = 1.0\n\nSee Also\n   is / 2, min / 3, max / 2"},"frandom/1":{"prefix":"frandom","body":"frandom(${1:F})$2\n$0","description":"frandom(-F)\n\n   Generates a random floating-point number F in the range <0, 1>.\n\nArguments\n   F    Floating-point number or variable.\n\nType\n   Arithmetic\n\nDescription\n   frandom/1 unifies F with a random floating-point number between 0 and 1.\n   The code is taken from random2.c by John Burton, available from the net.\n   Part of original comment:\n\n *\n * PMMMLCG - Prime Modulus M Multiplicative Linear Congruential Generator   *\n *  Modified version of the Random number generator proposed by    *\n *  Park & Miller in \"Random Number Generators: Good Ones Are Hard to Find\" *\n *  CACM October 1988, Vol 31, No. 10    *\n *   - Modifications proposed by Park to provide better statistical    *\n *     properties (i.e. more \"random\" - less correlation between sets of    *\n *     generated numbers    *\n *   - generator is of the form    *\n *    x = ( x * A) % M    *\n *   - Choice of A & M can radically modify the properties of the generator *\n *     the current values were chosen after followup work to the original   *\n *     paper mentioned above.    *\n *   - The generator has a period of 0x3fffffff with numbers generated in   *\n *     the range of 0 < x < M    *\n *   - The generator can run on any machine with a 32-bit integer, without  *\n *     overflow.    *\n\nModes and Determinism\n   frandom(-) is det\n\nExceptions\n     5 --- F is instantiated, but not to a floating-point number.\n\nExamples\n   \nSuccess:\n      [eclipse]: frandom(F1), frandom(F2).\n      F1 = 0.900086582\n      F2 = 0.0795856342\n      yes.\n\n      [eclipse]: seed(1), frandom(F).\n      F = 2.2477936e-05\n      yes.\n      [eclipse]: seed(1), frandom(F).\n      F = 2.2477936e-05\n      yes.\n\nFail:\n      frandom(123.45).\n\nError:\n      frandom(1234).    (Error 5).\n\nSee Also\n   seed / 1, random / 1"},"numerator/2":{"prefix":"numerator","body":"numerator(${1:Number}, ${2:Result})$3\n$0","description":"numerator(+Number, -Result)\n\n   Extracts the numerator of the rational Number and unifies the resulting\ninteger with Result.\n\nArguments\n   Number    An integer or rational number.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to numerator(Number, Result) is\n   equivalent to\n\n    Result is numerator(Number)\n\n   which should be preferred.\n\n   In coroutining mode, if Number is uninstantiated, the call to\n   numerator/2 is delayed until this variable is instantiated.\n\nModes and Determinism\n   numerator(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n     5 --- Number is a float or breal.\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      numerator(3_4, 3).\n      numerator(9_12, 3).\n      numerator(-3_4, -3).\n      numerator(25, 25).\nFail:\n      numerator(3_4, 4).\n      numerator(3_4, 3_1).\n      numerator(3_4, r).\nError:\n      numerator(A, 3).    (Error 4).\n      numerator(3.1, 3).    (Error 5).\n      numerator(1_3 + 3_4, 13).    (Error 24).\n\nSee Also\n   is / 2, denominator / 2, rational / 2"},"ln/2":{"prefix":"ln","body":"ln(${1:Number}, ${2:Result})$3\n$0","description":"ln(+Number, -Result)\n\n   Evaluates the natural logarithm ln(Number) and unifies the resulting value\nwith Result.\n\nArguments\n   Number    A number.\n   Result    A variable float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to ln(Number, Result) is equivalent\n   to\n\n    Result is ln(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to ln/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   ln(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n    20 --- Illegal arithmetic operation:  Number is 0 or less.\n\nExamples\n   \nSuccess:\n      ln(2.0, Result).    (gives Result = 0.693147)\n      ln(1, Result).    (gives Result = 0.0)\nFail:\n      ln(1, 1.0).\n      ln(1, 0).\n      ln(1, r).\nError:\n      ln(A, 6.0).    (Error 4).\n      ln(-2, Result).    (Error 20).\n      ln(0, Result).    (Error 20).\n      ln(4 + 2, 1.79176).    (Error 24).\n\nSee Also\n   is / 2"},"plus/3":{"prefix":"plus","body":"plus(${1:Add1}, ${2:Add2}, ${3:Sum})$4\n$0","description":"plus(?Add1, ?Add2, ?Sum)\n\n   Succeeds if Sum is the sum of integer arguments Add1 and Add2.\n\nArguments\n   Add1    an integer or a variable\n   Add2    an integer or a variable\n   Sum    an integer or a variable\n\nType\n   Arithmetic\n\nDescription\n   Defines the arithmetic relation Add1 + Add2 = Sum.  If all arguments are\n   instantiated plus/3 succeeds if this relation holds.  If one of the\n   arguments is uninstantiated, it is bound to an integer such that the\n   relation holds.  If the system is in coroutining mode and more than one\n   argument is uninstantiated, plus/3 delays until at least two of the\n   arguments are known.\n\nModes and Determinism\n   plus(+, +, -) is det\n   plus(+, -, +) is det\n   plus(-, +, +) is det\n\nExceptions\n     5 --- an argument is neither an integer nor a variable\n     4 --- more than one argument is uninstantiated (non-coroutining    mode only)\n\nExamples\n   \n   Success:\n   plus(1, 2, 3).\n   plus(3, 4, Z).    (gives Z=7)\n   plus(X, 4, 7).    (gives X=3)\n   plus(3, Y, 7).    (gives Y=4)\n   Fail:\n   plus(3, 4, 5).\n   Error:\n   plus(3.0, 4.0, 7.0).    (error 5)\n   plus(2 + 3, 1, 6).    (error 5)\n   plus(X, 1, Z).    (error 4)\n\nSee Also\n   times / 3"},"min/3":{"prefix":"min","body":"min(${1:Number1}, ${2:Number2}, ${3:Minimum})$4\n$0","description":"min(+Number1, +Number2, -Minimum)\n\n   Unifies the minimum of Number1 and Number2 with Minimum.\n\nArguments\n   Number1    A number.\n   Number2    A number.\n   Minimum    A variable or a number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to min(Number1, Number2, Minimum)\n   is equivalent to\n\n\tMinimum is min(Number1, Number2)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to min/3 is delayed until these variables are instantiated.\n\nModes and Determinism\n   min(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      min(5, 2, 2).\n      min(2_3, 3_4, 2_3).\n      min(5.0 , 2.0, 2.0).\n      min(5.0, 2, 2.0).    (The types are adjusted)\n      min(5_0, 2, 2_0).    (The types are adjusted)\nFail:\n      min(1, 2, 3).\n      min(1, 2, 2.0).\n      min(5, 2.0, 5).\n      min(5, 2, r).\nError:\n      min(A, 2, 6).    (Error 4).\n      min(4 - 2, 3, 3).    (Error 24).\n\nSee Also\n   is / 2"},"rational/2":{"prefix":"rational","body":"rational(${1:Number}, ${2:Result})$3\n$0","description":"rational(+Number, -Result)\n\n   Converts Number into a rational number and unifies it with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or rational number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to rational(Number, Result) is\n   equivalent to\n\n    Result is rational(Number)\n\n    which should be preferred.\n\n   When Number is an integer, Result is a rational with denominator 1.\n\n   When Number is already a rational, Result is identical to Number.\n\n   When Number is a float, Result is a rational whose value is exactly equal\n   to the value of the floating-point number. Since floats are usually\n   approximations of the intended value, the results may look unintuitive\n   and have unnecessarily large numerators and denominators. Use rationalize/2\n   to produce the most compact rational that still converts back into the\n   original float. rational/2 is usually faster than rationalize/2.\n\n   Bounded reals cannot be converted to rationals.\n\n   In coroutining mode, if Number is uninstantiated, the call to\n   rational/2 is delayed until this variable is instantiated.\n\nModes and Determinism\n   rational(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n   141 --- Number is a bounded real\n\nExamples\n   \nSuccess:\n      rational(25, 25_1).\n      rational(1.5, 3_2).\n      rational(3_4,3_4).\n      rational(9_12,3_4).\n      rational(-6, Result).      (gives Result = -6_1)\n      rational(0.1, Result).     (gives Result = 3602879701896397_36028797018963968)\nFail:\n      rational(1, 2_1).\n      rational(3, 3).\n      rational(1, r).\nError:\n      rational(A, 1_3).    (Error 4).\n      rational(4 + 2, 6_1).    (Error 24).\n      rational(0.9__1.1, X).    (Error 141).\n\nSee Also\n   rationalize / 2, is / 2"},"random/1":{"prefix":"random","body":"random(${1:N})$2\n$0","description":"random(-N)\n\n   Generates a random integer N.\n\nArguments\n   N    Integer or Variable.\n\nType\n   Arithmetic\n\nDescription\nrandom/1 unifies N with a random integer between 0 and 2^31-1\n   (returned by the C library function random(), whose initialization\n   has been made using the pid of the running ECLiPSe ).\n\n   If it is required that the sequence produced by successive calls of\n   random/1 be reproducible, seed(Seed) can be called to initialise the\n   calls with the integer Seed. Do not assume that the same sequence will\n   be produced for the same seed on different platforms, because the C \n   library's implementation of random() may differ.\n\nModes and Determinism\n   random(-) is det\n\nExceptions\n     5 --- N is instantiated, but not to an integer.\n\nExamples\n   \nSuccess:\n      [eclipse]: random(N1), random(N2).\n      N1 = 464880439\n      N2 = 285401533\n      yes.\n\n      [eclipse]: seed(1), random(N).\n      N = 2078917053\n      yes.\n      [eclipse]: seed(1), random(N).\n      N = 2078917053\n      yes.\n\nFail:\n      random(12345).\n\nError:\n      random(12.34).    (Error 5).\n\nSee Also\n   frandom / 1, seed / 1"},"rationalize/2":{"prefix":"rationalize","body":"rationalize(${1:Number}, ${2:Result})$3\n$0","description":"rationalize(+Number, -Result)\n\n   Converts Number into a compact rational number and unifies it with Result.\n\nArguments\n   Number    A number.\n   Result    A variable or rational number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to rationalize(Number, Result) is\n   equivalent to\n\n    Result is rationalize(Number)\n\n    which should be preferred.\n\n   When Number is an integer, Result is a rational with denominator 1.\n\n   When Number is already a rational, Result is identical to Number.\n\n   When Number is a float, Result is a rational whose value approximates\n   the value of the float to the accuracy of the float representation.\n   rationalize/2 usually produces more compact rationals that rational/2.\n   Both rationalize/2 and rational/2 produce results that convert back into\n   the original float. rational/2 is usually faster than rationalize/2.\n\n   Bounded reals cannot be converted to rationals.\n\n   In coroutining mode, if Number is uninstantiated, the call to\n   rationalize/2 is delayed until this variable is instantiated.\n\nModes and Determinism\n   rationalize(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n   141 --- Number is a bounded real\n\nExamples\n   \nSuccess:\n      rationalize(25, 25_1).\n      rationalize(1.5, 3_2).\n      rationalize(3_4,3_4).\n      rationalize(9_12,3_4).\n      rationalize(-6, Result).      (gives Result = -6_1)\n      rationalize(0.1, Result).     (gives Result = 1_10)\nFail:\n      rationalize(1, 2_1).\n      rationalize(3, 3).\n      rationalize(1, r).\nError:\n      rationalize(A, 1_3).    (Error 4).\n      rationalize(4 + 2, 6_1).    (Error 24).\n      rationalize(0.9__1.1, X).    (Error 141).\n\nSee Also\n   rational / 2, is / 2"},"round/2":{"prefix":"round","body":"round(${1:Number}, ${2:Result})$3\n$0","description":"round(+Number, -Result)\n\n   Rounds Number to the nearest integral value of the same type\n\nArguments\n   Number    A number.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to round(Number, Result) is\n   equivalent to\n\n    Result is round(Number)\n\n    which should be preferred for portability.\n\n   This operation works on all numeric types. The result value is the\n   integral value that is closest to Number (rounding to nearest). If\n   Number is exactly in the middle between two integers, the result\n   is the even one.\n\n   The result type is the same as the argument type.  To convert the\n   type to integer, use integer/2.\n\n   In coroutining mode, if Number is uninstantiated, the call to round/2\n   is delayed until this variable is instantiated.\n\nModes and Determinism\n   round(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      round(1.49, 1.0).\n      round(1.5, 2.0).    (odd integer part)\n      round(2.5, 2.0).\n      round(2.51, 3.0).    (even integer part)\n      round(3.5, 4.0).\n      round(-6.4, Result).      (gives Result = -6.0)\n      round(3, 3).\nFail:\n      round(1, 0.0).\n      round(0.5, 0).\n      round(1, r).\nError:\n      round(A, 6.0).    (Error 4).\n      round(4 + 2.3, 6.0).    (Error 24).\n\nSee Also\n   is / 2, floor / 2, ceiling / 2, truncate / 2, integer / 2"},"sgn/2":{"prefix":"sgn","body":"sgn(${1:Number}, ${2:Result})$3\n$0","description":"sgn(+Number, -Result)\n\n   Unifies Result with the sign of Number which is either -1, 0 or 1.\n\nArguments\n   Number    A number.\n   Result    A variable or an integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to sgn(Number, Result) is\n   equivalent to\n\n    Result is sgn(Number)\n\n    which should be preferred for portability.\n\n   sgn/2 gives the integer -1 if Number is negative, 0 if it is zero and 1\n   if it is greater than zero.  It is always true that\n\n    X =:= sgn(X) * abs(X)\n\n   In coroutining mode, if Number is uninstantiated, the call to sgn/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   sgn(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      sgn(42, 1).\n      sgn(-5, Result).    (gives Result = -1)\n      sgn(-6.2, Result).    (gives Result = -1)\n      sgn(0.0, 0).\nFail:\n      sgn(1, 0).\n      sgn(1, 1.0).\n      sgn(1, r).\nError:\n      sgn(A, 6).    (Error 4).\n      sgn(4 + 2, 6).    (Error 24).\n\nSee Also\n   is / 2"},"rem/3":{"prefix":"rem","body":"rem(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"rem(+Number1, +Number2, -Result)\n\n   Evaluates the remainder Number1 rem Number2 and unifies the resulting value\nwith Result.\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to rem(Number1, Number2, Result) is\n   equivalent to\n\n    Result is Number1 rem Number2\n\n    which should be preferred for portability.\n\n    The modulus operation computes the remainder corresponding to the\n    truncating division //.  The following relation always holds:\n\n    X =:= (X rem Y) + (X // Y) * Y.\n\n    The result Result is either zero, or has the same sign as Number1.  The\n    absolute value of Result does not depend on the signs of the arguments.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to rem/3 is delayed until these variables are instantiated.\n\n   See also the mod operation, whose result only differs when the arguments\n   have opposite signs.\n\nModes and Determinism\n   rem(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    20 --- Illegal arithmetic operation: Number2 is zero\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      X is 10 rem 3.\t\t(gives X = 1)\n\n      rem( 10,  3,  1).\n      rem(-10,  3, -1).\n      rem( 10, -3,  1).\n      rem(-10, -3, -1).\n\n      rem( 11,  3,  2).\nFail:\n      rem(1, 2, 3).\n      rem(6, 2.0, 3.0).\n      rem(5, 2, r).\nError:\n      rem(A, 2, 6).    (Error 4).\n      rem(2, 0, Result).    (Error 20).\n      rem(4 + 2, 2, 12).    (Error 24).\n\nSee Also\n   is / 2, // / 3, mod / 3"},"seed/1":{"prefix":"seed","body":"seed(${1:Seed})$2\n$0","description":"seed(+Seed)\n\n   Sets the initial seed Seed for generating random numbers with random/1 or\nfrandom/1.\n\nArguments\n   Seed    Integer.\n\nType\n   Arithmetic\n\nDescription\n   Used to initialise the seed which is used for the generation of random\n   numbers by random/1 or frandom/1.  Setting the same seed value with\n   seed/1 enables the generation of a repeatable random sequence with\n   random/1 ie.  pseudo-random number generation.\n\n   The seed value should be an integer in the range 1 .. 2^31-1.\n\nModes and Determinism\n   seed(+) is det\n\nExceptions\n     4 --- Seed is not instantiated.\n     5 --- Seed is instantiated, but not to an integer.\n\nExamples\n   \nSuccess:\n      [eclipse]: repeat, random(S).\n      S = 464880439   More? (;)\n      S = 285401533   More? (;)\n      yes.\n      [eclipse]: seed(1), repeat, random(S).\n      S = 2078917053   More? (;)\n      S = 143302914   More? (;)\n      yes.\n      [eclipse]: seed(1), repeat, random(S).\n      S = 2078917053   More? (;)\n      S = 143302914   More? (;)\n      yes.\n\nSee Also\n   random / 1"},"sin/2":{"prefix":"sin","body":"sin(${1:Number}, ${2:Result})$3\n$0","description":"sin(+Number, -Result)\n\n   Evaluates the trigonometric function sin(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to sin(Number, Result) is\n   equivalent to\n\n    Result is sin(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to sin/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   sin(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      sin(1.5708, 1.0).\n      sin(-1.5708, Result).     (gives Result = -1.0)\n      sin(0, Result).    (gives Result = 0.0)\nFail:\n      sin(1, 0.0).\n      sin(6, 3).\n      sin(5, r).\nError:\n      sin(A, 6.0).    (Error 4).\n      sin(4 + 2, -0.279415).    (Error 24).\n\nSee Also\n   is / 2"},"sqrt/2":{"prefix":"sqrt","body":"sqrt(${1:Number}, ${2:Result})$3\n$0","description":"sqrt(+Number, -Result)\n\n   Evaluates the square root sqrt(Number) and unifies the resulting value with\nResult.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to sqrt(Number, Result) is\n   equivalent to\n\n    Result is sqrt(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to sqrt/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   sqrt(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n    20 --- Illegal arithmetic operation:  Number is negative.\n\nExamples\n   \nSuccess:\n      sqrt(1.0, 1.0).\n      sqrt(1.0, Result).      (gives Result = 1.0)\n      sqrt(49, Result).       (gives Result = 7.0)\nFail:\n      sqrt(1, 0.0).\n      sqrt(1, 1).\n      sqrt(1, r).\nError:\n      sqrt(A, 6.0).    (Error 4).\n      sqrt(-2, Result).    (Error 20).\n      sqrt(4 + 2, 2.44949).    (Error 24).\n\nSee Also\n   is / 2"},"sum/2":{"prefix":"sum","body":"sum(${1:ExprList}, ${2:Result})$3\n$0","description":"sum(+ExprList, -Result)\n\n   Evaluates the the arithmetic expressions in ExprList and unifies their sum\nwith Result.\n\nArguments\n   ExprList    A list of arithmetic expressions.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n    arithmetic expressions.  So the call to sum(ExprList, Result) is\n    equivalent to\n\n    Result is sum(ExprList)\n\n    which should be preferred.\n\n   In coroutining mode, if the list is only partly instantiated, the\n   predicate delays until the list is complete.\n\nModes and Determinism\n   sum(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ExprList is a partial list (non-coroutining mode only).\n     5 --- ExprList is not a proper list.\n\nExamples\n   \nSuccess:\n      X is sum([1,2,3]).  % gives X = 6\n\nSee Also\n   is / 2, + / 3"},"succ/2":{"prefix":"succ","body":"succ(${1:X}, ${2:Y})$3\n$0","description":"succ(?X, ?Y)\n\n   Successor relation over natural numbers.\n\nArguments\n   X    an integer or a variable\n   Y    an integer or a variable\n\nType\n   Arithmetic\n\nDescription\n   Successor relation over natural numbers.  Succeeds if X is an\n   integer greater or equal to zero, and Y is one greater than X.\n   If one of the arguments is uninstantiated, it gets computed from\n   the other by adding or subtracting 1, respectively.\n\n   If the system is in coroutining mode and both arguments are\n   uninstantiated, succ/2 delays until at least one argument is known.\n\nModes and Determinism\n   succ(+, -) is semidet\n   succ(-, +) is semidet\n\nFail Conditions\n   Fails if X or Y are negative integers, or if Y is 0\n\nExceptions\n     5 --- an argument is a non-integer number\n     4 --- both arguments are uninstantiated (non-coroutining mode only)\n    24 --- X or Y is not a number\n\nExamples\n   \n   Success:\n   \tsucc(0, 1).\n   \tsucc(7, 8).\n   \tsucc(10000000000000000000, 10000000000000000001).\n   \tsucc(0, Y).\t\t(gives Y=1)\n   \tsucc(X, 3).\t\t(gives X=2)\n\n   Fail:\n   \tsucc(X, 0).\n   \tsucc(X, -5).\n   \tsucc(-1, Y).\n\n   Error:\n   \tsucc(X, Y).\t\t(error 4)\n   \tsucc(0.0, Y).\t\t(error 5)\n   \tsucc(a, Y).\t\t(error 24)\n\nSee Also\n   plus / 3, + / 3, - / 3"},"tan/2":{"prefix":"tan","body":"tan(${1:Number}, ${2:Result})$3\n$0","description":"tan(+Number, -Result)\n\n   Evaluates the trigonometric function tan(Number) and unifies the resulting\nvalue with Result.\n\nArguments\n   Number    A number.\n   Result    A variable, float or breal.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to tan(Number, Result) is\n   equivalent to\n\n    Result is tan(Number)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number is uninstantiated, the call to tan/2 is\n   delayed until this variable is instantiated.\n\nModes and Determinism\n   tan(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n    20 --- Illegal arithmetic operation:  Number is (2k +1) * pi/2 for    every integer k.\n\nExamples\n   \nSuccess:\n      tan(0, 0.0).\n      tan(12.3, Result).      (gives Result = -0.272854)\n      tan(-1, Result).    (gives Result = -1.55741)\nFail:\n      tan(1, 0.0).\n      tan(0, 0).\n      tan(5, r).\nError:\n      tan(A, 6.0).    (Error 4).\n      X is pi/2, tan(X, Result).    (Error 20).\n      tan(10.3 + 2, -0.272854).    (Error 24).\n\nSee Also\n   is / 2"},"mod/3":{"prefix":"mod","body":"mod(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"mod(+Number1, +Number2, -Result)\n\n   Evaluates the modulus Number1 mod Number2 and unifies the resulting value\nwith Result.\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to mod(Number1, Number2, Result) is\n   equivalent to\n\n    Result is Number1 mod Number2\n\n    which should be preferred for portability.\n\n    The modulus operation computes the remainder corresponding to the\n    flooring division div.  The following relation always holds:\n\n    X =:= (X mod Y) + (X div Y) * Y.\n\n    The result Result is either zero, or has the same sign as Number2.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to mod/3 is delayed until these variables are instantiated.\n\n   CAUTION: The behaviour of mod was changed for standard compliance!\n   In ECLiPSe versions up to 5.8, mod computed the remainder corresponding\n   to the truncating division //, and thus gave different results for\n   arguments with opposite signs.  Moreover, the operator precedence was\n   changed from op(300,xfx,mod) to op(400,yfx,mod), which means that\n   a*b mod c is now parsed as (a*b)mod c rather than a*(b mod c).\n\nModes and Determinism\n   mod(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    20 --- Illegal arithmetic operation: Number2 is zero\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      X is 10 mod 3.\t\t(gives X = 1)\n\n      mod( 10,  3,  1).\n      mod(-10,  3,  2).\n      mod( 10, -3, -2).\n      mod(-10, -3, -1).\n\n      mod( 11,  3,  2).\nFail:\n      mod(1, 2, 3).\n      mod(6, 2.0, 3.0).\n      mod(5, 2, r).\nError:\n      mod(A, 2, 6).    (Error 4).\n      mod(2, 0, Result).    (Error 20).\n      mod(4 + 2, 2, 12).    (Error 24).\n\nSee Also\n   is / 2, div / 3, rem / 3"},"times/3":{"prefix":"times","body":"times(${1:Factor1}, ${2:Factor2}, ${3:Product})$4\n$0","description":"times(?Factor1, ?Factor2, ?Product)\n\n   Succeeds if Product is the result of multiplying integer arguments Factor1\nand Factor2.\n\nArguments\n   Factor1    An integer or a variable.\n   Factor2    An integer or a variable.\n   Product    An integer or a variable.\n\nType\n   Arithmetic\n\nDescription\n   Defines the arithmetic relation Factor1 * Factor2 = Product.  If all\n   arguments are instantiated times/3 succeeds if this relation holds.  If\n   one of the arguments is uninstantiated, it is bound to an integer such\n   that the relation holds.  Note that this is not always possible.  If the\n   system is in coroutining mode and more than one argument is\n   uninstantiated, times/3 delays until at least two of the arguments are\n   known.\n\nModes and Determinism\n   times(+, +, -) is det\n   times(+, -, +) is semidet\n   times(-, +, +) is semidet\n\nFail Conditions\n   Fails if it is impossible to find an integer instantiation such that\n   Factor1 * Factor2 = Product holds\n\nExceptions\n     4 --- more than one argument is uninstantiated (non-coroutining    mode only)\n     5 --- an argument is neither an integer nor a variable\n\nExamples\n   \n   Success:\n   times(2, 3, 6).\n   times(2, 3, Z).    (gives Z=6)\n   times(X, 3, 6).    (gives X=2)\n   times(2, Y, 6).    (gives Y=3)\n   Fail:\n   times(3, 4, 5).\n   times(3, X, 5).\n   Error:\n   times(2.0, 3.0, 6.0).    (error 5)\n   times(1 + 4, 2, 10).    (error 5)\n   times(X, 1, Z).    (error 4)\n\nSee Also\n   plus / 3"},"truncate/2":{"prefix":"truncate","body":"truncate(${1:Number}, ${2:Result})$3\n$0","description":"truncate(+Number, -Result)\n\n   Unifies Result with the closest integer value between 0 and\nNumber, and of the same numeric type as Number.\n\nArguments\n   Number    A number.\n   Result    A variable or number.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to truncate(Number, Result) is\n   equivalent to\n\n    Result is truncate(Number)\n\n   which should be preferred for portability.\n\n   This operation works on all numeric types. The result value is the\n   closest integral value that lies between 0 and Number (rounding\n   towards zero).\n\n   The result type is the same as the argument type.  To convert the\n   type to integer, use integer/2.\n\n   In coroutining mode, if Number is uninstantiated, the call to truncate/2\n   is delayed until this variable is instantiated.\n\nModes and Determinism\n   truncate(+, -) is det\n\nExceptions\n     4 --- Number is not instantiated (non-coroutining mode only).\n    24 --- Number is not of a numeric type.\n\nExamples\n   \nSuccess:\n      X is truncate(1.8).\t   (gives Result = 1.0)\n\n      truncate(1.8, 1.0).\n      truncate(-1.8, -1.0).\n      truncate(5, 5).\n      truncate(-6.4, Result).      (gives Result = -6.0)\nFail:\n      truncate(1.0, 0.0).\n      truncate(0.5, 0).\n      truncate(1, r).\nError:\n      truncate(A, 6.0).    (Error 4).\n      truncate(4 + 2.3, 6.0).    (Error 24).\n\nSee Also\n   is / 2, floor / 2, ceiling / 2, round / 2, integer / 2, fix / 2"},"xor/3":{"prefix":"xor","body":"xor(${1:Number1}, ${2:Number2}, ${3:Result})$4\n$0","description":"xor(+Number1, +Number2, -Result)\n\n   Evaluates the bitwise exclusive disjunction Number1 xor Number2 and unifies\nthe resulting value with Result.\n\nArguments\n   Number1    Integer.\n   Number2    Integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to xor(Number1, Number2, Result) is\n   equivalent to\n\n    Result is xor(Number1, Number2)\n\n    which should be preferred for portability.\n\n   In coroutining mode, if Number1 or Number2 are uninstantiated, the call\n   to xor/3 is delayed until these variables are instantiated.\n\nModes and Determinism\n   xor(+, +, -) is det\n\nExceptions\n     4 --- Number1 or Number2 is not instantiated (non-coroutining mode    only).\n     5 --- Number1 or Number2 is a number but not an integer.\n    24 --- Number1 or Number2 is not of a numeric type.\n\nExamples\n   \nSuccess:\n      xor(11, 7, 12).\n      xor(11, -7, Result).     (gives Result = -14)\nFail:\n      xor(1, 2, 4).\n      xor(6, 2, 4.0).\n      xor(5, 2, r).\nError:\n      xor(A, 2, 6).    (Error 4).\n      xor(6, 2.0, 4.0).    (Error 5).\n      xor(4 + 2, 2, 4).    (Error 24).\n\nSee Also\n   is / 2"},"abolish/1":{"prefix":"abolish","body":"abolish","description":"abolish +SpecList\n\n   Remove the definition of the predicates specified in SpecList.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Removes the definition of the predicates specified in SpecList. These\n   predicates must have their definition (clauses) in the caller module.\n\n   Predicates that are defined elsewhere (i.e. imported or reexported\n   predicates) cannot be abolished. They can only be abolished from their\n   definition module.\n\n   After a predicate has been abolished, any attempt to invoke it will\n   give rise to an error 68 (calling an undefined procedure).\n\n   Certain declarations about properties of a predicate will remain in\n   effect even after abolishing the predicate. These include declarations\n   that affect the predicate's calling convention (modes, demon, parallel,\n   tool).  Moreover, the predicate's visibility (local, exported) is not\n   affected, i.e. if the predicate was exported, it will remain exported.\n\n   Predicates can be abolished, no matter whether they are static or\n   dynamic. For dynamic predicates, the difference between retractall/1\n   and abolish/1 is that retractall/1 leaves the predicates with no\n   clauses (call of the predicate will fail) and the predicate retains\n   its dynamic-property.  In contrast, abolish/1 makes the predicates\n   undefined (calls will raise and error) and the predicate loses its\n   dynamic-property.\n\n   Error 60 (``referring to an undefined procedure'') is raised when no\n   predicate of name SpecList is visible.  Error 100 (``accessing a\n   procedure defined in another module'') is raised if the visible\n   predicate is defined or declared in a different module than the\n   caller module.\n\n   abolish/1 satisfies the logical update semantics.  Abolishing a\n   predicate will not, in any way, affect previous calls to it (when\n   backtracking).\n\nModes and Determinism\n   abolish(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated\n     5 --- SpecList is instantiated, but not to a sequence of expressions of the form Atom/Integer\n    60 --- SpecList is undefined in the caller module\n   100 --- SpecList is not defined in the caller module\n\nExamples\n   \n[eclipse 1]: [user].\n p :- writeln(hello).\nYes (0.00s cpu)\n\n[eclipse 2]: p.\nhello\nYes (0.00s cpu)\n\n[eclipse 3]: abolish p/0.\nYes (0.00s cpu)\n\n[eclipse 4]: p.\ncalling an undefined procedure p in module eclipse\nAbort\n\n[eclipse 5]: abolish writeln/1.\naccessing a procedure defined in another module in abolish writeln / 1\nAbort\n\n[eclipse 6]: abolish foo/33.\nreferring to an undefined procedure in abolish foo / 33 in module eclipse\nAbort\n\nLogical semantics :\n\nIf the following clauses are in the database :\n    p(1) :- abolish(p/1).\n    p(2).\n\nThe call p(X). will produce all the solutions visible when it started\nexecuting :\n\n    [eclipse]: p(X).\n    X = 1     More? (;)\n    X = 2\n    yes.\n\nSee Also\n   retractall / 1"},"compile/1":{"prefix":"compile","body":"compile(${1:File})$2\n$0","description":"compile(++File)\n\n   Compile specified file, or list of files, with default options\n\nArguments\n   File    Atom, structure or string, or a list of them.\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n    Compiles the specified ECLiPSE source file or list of source files.\n    The default options are used, and the resulting code is directly\n    loaded into memory and ready for execution.  See compile/2 for details.\n\nModes and Determinism\n   compile(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- File is not instantiated.\n     5 --- File is instantiated, but not to an atom or string, or a list of atoms or strings.\n    61 --- A predicate that was already defined is later declared to be a tool.\n    62 --- Illegal attempt to change a predicate's properties like: tool, dynamic, demon, parallel, calling convention.\n    82 --- The module in which the clauses should be compiled is locked.\n    94 --- There is already am imported predicate of the same name.\n   130 --- The head of a clause is not an atom or a compound term.\n   131 --- A subgoal in the body of a clause is not an atom, a compound term or a variable.\n   134 --- The clauses of a procedure are not consecutive.\n   137 --- A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.\n   139 --- This event is invoked at the end of each compiled file, by default it prints the compilation time and size of compiled code.\n   143 --- A query in the compiled file has failed. This is by default ignored and the compilation continues.\n   145 --- A procedure is being redefined in another file than the original one.\n   147 --- This event is raised just before a compilation is aborted because of an error.\n   148 --- An unrecognised pragma was used in the code.\n   171 --- File does not exist.\n\nExamples\n   \nSuccess:\n   [hanoi].    % compiles the file hanoi.pl\n\n   [eclipse]: sh('cat file1').\n   p:-q(hello).\n   yes.\n   [eclipse]: sh('cat file2').\n   q(X) :- writeln(X).\n   yes.\n   [eclipse]: compile(user), p.\n    p :- writeln(hi).\n    user compiled 92 bytes in 0.00 seconds\n   hi\n   yes.\n   [eclipse]: compile([file1, file2]), p.\n   /home/lp/user/file1 compiled 32 bytes in 0.02 seconds\n   /home/lp/user/file2 compiled 92 bytes in 0.00 seconds\n   hello\n   yes.\n\n   % example showing use of relative pathnames.\n   [eclipse]: sh('ls -FR /home/lp/user/pl').\n   a.pl    util/\n\n   /home/lp/user/pl/util:\n   b.pl    c.pl\n\n   yes.\n   [eclipse]: sh('cat /home/lp/user/pl/a.pl').\n   :- compile('util/b').\n   p.\n\n   yes.\n   [eclipse]: compile('/home/lp/user/pl/a').\n   /home/lp/user/pl/util/b.pl compiled 92 bytes in 0.00 seconds\n   /home/lp/user/pl/a.pl compiled 28 bytes in 0.00 seconds\n   yes.\n\nError:\n   compile(F).    (Error 4).\n   compile(file1/1).      (Error 5).\n   compile(file).    (Error 171).\n\nSee Also\n   compile / 2, compile_stream / 1, compile_term / 1, compile_term / 2, ensure_loaded / 1, lib / 1, use_module / 1, pragma / 1, fcompile : fcompile / 1"},"compile_stream/1":{"prefix":"compile_stream","body":"compile_stream(${1:Stream})$2\n$0","description":"compile_stream(+Stream)\n\n   Compile the given stream Stream with default options\n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n    Compile from an (already opened) input stream with default options.\n    The resulting code is directly loaded into memory and ready for execution.\n    Equivalent to\n    \n\tcompile(stream(Stream), [])\n    \n   Stream may be a stream handle or a reserved or user-defined\n   symbolic stream name.  The stream can be of any type, e.g. file, tty,\n   socket, queue, string, etc.\n\n   If Stream is an opened input stream, its content is read and compiled as\n   in compile/1.  The compilation stops at the stream end, but the stream\n   remains open.\n\nModes and Determinism\n   compile_stream(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or stream handle.\n   192 --- Stream is in an illegal stream mode.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \ncompile_string(String) :-\n\topen(string(String), read, S),\n\tcompile_stream(S),\n\tclose(S).\n\nError:\n     compile_stream(X).      (Error 4).\n     compile_stream(1.0).    (Error 5).\n     compile_stream(1).      (Error 192).\n     compile_stream(2).      (Error 192).\n     compile_stream(20).     (Error 192).\n     compile_stream(a).      (Error 193).\n\nSee Also\n   compile / 1, compile / 2, compile_term / 1, pragma / 1"},"compile/2":{"prefix":"compile","body":"compile(${1:Source}, ${2:Options})$3\n$0","description":"compile(++Source, ++Options)\n\n   Compile specified file, or list of files, with given options\n\nArguments\n   Source    Source file name (atom or string) or structure stream(Stream)\n   Options    List of compiler options (name:value pairs)\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n   Compiles the specified ECLiPSE source file or list of source files,\n   with the given options.  See below for a detailed description of the\n   options.\n\nSource Location\n   The atom or string File must be instantiated to a legitimate\n   specification for an existing file except for the suffix.\n   The predicate tries to add to it the source suffixes from the list\n   specified in the global flag prolog_suffix, and look for an existing and\n   readable file.  As soon as a file is found which exists, it is taken as\n   the input file name.  The default source suffixes are empty suffix,\n   .ecl and .pl.\n\n   If File is of the form library(Name), the predicates looks for the file\n   in the directories from the library_path flag.\n\n   If File is the special atom 'user', the source will be taken from\n   the current 'input' stream, i.e. will usually generate a prompt\n   at which clauses can be typed in.  In this case, input must be\n   terminated either by typing CTRL-D (on Unix), CTRL-Z + RETURN\n   (on Windows), or with the single atom end_of_file, followed by\n   a fullstop/period.\n\n   If File is the special form stream(Stream), then the source is taken\n   from the given stream (which must be already opened).  The stream\n   content is compiled until the end of stream, but the stream is not\n   closed.\n\n   When File is not in the current directory, ECLiPSe first changes the\n   current directory to that of the file.  Consequently, recursive\n   compile/1 calls inside compiled files can use relative pathnames.  This\n   makes it possible to compile the top program files from any directory\n   and still use only local file names inside.  At the end of the compilation,\n   the current directory is changed back to the initial one.  This has the\n   side effect that all calls to cd/1 in queries in the compiled file are\n   ignored.\n\nOption Syntax\n    Options is a possibly empty list of OptionName:OptionValue pairs.\n\nCode Generation Options\n\ndebug:\n    This option (off/on) determines whether the resulting code contains\n    debugging information.  If off, subgoals of the compiled predicates will\n    not be visible to the debugger, the code will be significantly smaller,\n    and slightly faster.\n    The default value is taken from the global flag debug_compile.\n    The setting can be changed via a pragma (debug/nodebug) in the code.\n\nexpand_goals:\n    This option (off/on, default taken from global flag goal_expansion)\n    determines whether inlining (a.k.a. goals macros) is performed.\n    The default value is taken from the global flag goal_expansion.\n    The setting can be changed via a pragma (expand/noexpand) in the code.\n    Should only be switched off if a problem with inlining is suspected,\n    or to get a debugger trace that is closer to the source code.\n\nopt_level:\n    Currently the integer 0 or 1, with 1 the default. Setting this to 0\n    will disable certain compiler optimizations and usually reduce performance.\n\nOutput Options\n\nload:\n    When loading is requested, the abstract machine code produced by the\n    compiler gets assembled and loaded into memory as executable code.\n    Values for the 'load' option are:\n    \n    all (default)\n    Load and replace code in memory, create/re-create all modules,\n    interpret pragmas, and execute all directives and queries.\n    none\n    Do not load any code into memory, do not execute queries,\n    but interpret pragmas and execute directives.\n    Do not re-create modules, but create new ones and erase them\n    again after compilation.\n    new\n    Do not overwrite any code in memory, but load new predicates.\n    Do not execute queries, but interpret pragmas and execute directives.\n    Do not re-create modules, but create new ones and erase them\n    again after compilation. For existing modules, erase pragmas.\n    \n\noutput:\n    The abstract machine code which is the result of the compilation can\n    be output in various forms.  Values for 'output' option (default: none):\n    \n    none\n    no output (but code may be loaded, see load option),\n    asm\n    output compiled code in asm format to input file with .asm suffix.\n    This format represents the code as WAM code that can be loaded back\n    into ECLiPSe using the assembler (lib(asm)).  \n    asm(File)\n    output compiled code in asm format to File.\n    eco\n    output compiled code in eco format to input file with .eco suffix\n    This format can be loaded using ensure_loaded/1 or the compiler\n    itself.\n    eco(File)\n    output compiled code in eco format,\n    print\n    print resulting WAM code to the output stream,\n    print(Stream)\n    print WAM code to Stream,\n    listing\n    print WAM code to input file with .lst suffix,\n    listing(File)\n    print WAM code to File,\n    \n\noutdir:\n    Value is the destination directory for all output files.\n    The default is the empty string \"\", meaning that all output files\n    go into the same directory as the corresponding input file.\n\nInformation Options\n\nverbose:\n    This option controls whether the compiler produces any log messages to\n    the log_output stream. The value is a positive integer. Level 0 is the\n    most silent, 1 is quiet, 2 is verbose.  Level 1 produces a log of all\n    compiled predicates. Default: 0.\n\nwarnings:\n    Controls (on/off) whether warnings are printed during compilation.\n    Default: on.\n    The setting can be changed via a pragma (warnings/nowarnings) in the code.\n\nExpert Options\n\nexpand_clauses:\n    This option (off/on, default:on) determines whether clause macros, such\n    as DCGs and delay clauses are being expanded.  Should not be switched off.\n\nprint_normalised:\n    Print result of the normalisation pass (on/off, default:off).\n\nprint_indexes:\n    Print result of indexing  analysis (on/off, default:off).\n\nprint_lifetimes:\n    Print result of the variable lifetime analysis (on/off, default:off).\n\nprint_raw_code:\n    Print annotated WAM code before register allocation (on/off, default:off).\n\nprint_final_code:\n    Print annotated WAM code after register allocation (on/off, default:off).\n\nskip:\n    This option (off/on, default:off) determines whether all compiled\n    predicates have their 'skip' flag set by default.  This means that\n    subgoals of these predicates will be hidden in the debugger trace,\n    unless the flag is reset at runtime.\n    The setting can be changed via a pragma (skip/noskip) in the code.\n\nsrcroot:\n    This is used to make the compilation result (e.g. .eco files) independent\n    of absolute source file names: when the option is set to a non-empty string,\n    wich is a parent directory of a source file, the source file property of the\n    compiled predicates will be set as a pathname relative to the given\n    root directory.\n\nsystem:\n    This option (off/on, default:off) causes all compiled predicates to\n    have their type-flag set to 'built_in'.  This is used for compiling\n    system files.  Same effect as a system-pragma in the code.\n\nCompiling Modules\n   In the absence of module-directives (module/1,3) within the file, the\n   file content is compiled into the module from which compile/2 itself\n   was called.  This context module may be modified using the @/2 notation,\n   i.e. compile(File,Options)@Module.  Existing static predicates will\n   be redefined, and clauses for dynamic predicates appended to the\n   existing ones (unless the 'load' option requests otherwise).\n\n   If the compiled file contains module directives (module/1,3), these\n   specify to which module(s) the compiled code belongs.  Module directives\n   are effective from the point where they occur until the next module\n   directive, or until the end of file.  If a module directive refers\n   to a module that exists already, this module is erased and redefined\n   (unless the 'load' option requests otherwise).\n\n   For backward compatibility with older ECLiPSe versions, we allow a\n   module name in place of the Options-list.  If this module does not exist,\n   compile/2 will create such a module and compile the content of file\n   into this module, as with compile(File)@Module.\n\n   In addition to the exceptions listed below, any exception can occur during\n   compilation, because general code may be executed in directives (:-/2), file\n   queries (?-/2), macro transformations and inline expansion code.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either File or Options is not instantiated.\n     5 --- File is instantiated, but not to a valid source specification.\n     5 --- Options is not a valid options list, nor a module name.\n    61 --- A predicate that was already defined is later declared to be a tool.\n    62 --- Illegal attempt to change a predicate's properties like: tool, dynamic, demon, parallel, calling convention.\n    82 --- The module in which the clauses should be compiled is locked.\n    94 --- There is already am imported predicate of the same name.\n   130 --- The head of a clause is not an atom or a compound term.\n   131 --- A subgoal in the body of a clause is not an atom, a compound term or a variable.\n   134 --- The clauses of a procedure are not consecutive.\n   136 --- Attempt to redefine a built-in predicate without declaring it first.\n   137 --- A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.\n   139 --- This event is invoked at the end of each compiled file, by default it prints the compilation time and size of compiled code.\n   143 --- A query in the compiled file has failed. This is by default ignored and the compilation continues.\n   145 --- A procedure is being redefined in another file than the original one.\n   147 --- This event is raised just before a compilation is aborted because of an error.\n   148 --- An unrecognised pragma was used in the code.\n   171 --- File does not exist.\n\nExamples\n   \n    ?- compile(myfile, [debug:off]).\n\n    ?- compile(\"MyFile.ecl\", [output:eco]).\n\n    ?- compile(\"MyFile\", [verbose:1,opt_level:0]).\n\nSee Also\n   compile / 1, compile_stream / 1, compile_term / 1, compile_term / 2, ensure_loaded / 1, lib / 1, use_module / 1, pragma / 1, fcompile : fcompile / 1"},"setbit/3":{"prefix":"setbit","body":"setbit(${1:Number}, ${2:Index}, ${3:Result})$4\n$0","description":"setbit(+Number, +Index, -Result)\n\n   Result is Number with the Index'th bit set.\n\nArguments\n   Number    Integer.\n   Index    Non-negative integer.\n   Result    A variable or integer.\n\nType\n   Arithmetic\n\nDescription\n   Set the Index'th bit in Number giving Result. The least significant\n   bit has index zero. Two's complement representation is assumed.\n   This predicate is used by the ECLiPSe compiler to expand evaluable\n   arithmetic expressions.  So the call to setbit(Number, Index, Result) is\n   equivalent to\n\n    Result is setbit(Number, Index)\n\n   which should be preferred.\n\n   In coroutining mode, if Number or Index are uninstantiated, the call\n   is delayed until these variables are instantiated.\n\nModes and Determinism\n   setbit(+, +, -) is det\n\nExceptions\n     4 --- Number or Index is not instantiated (non-coroutining mode    only).\n     5 --- Number or Index is a number but not an integer.\n    24 --- Number or Index is not of a numeric type.\n\nExamples\n   \nSuccess:\n      setbit(0, 3, 8).\n      setbit(1, 8, X).    gives X=257.\n      X is setbit(setbit(0,3),5).  gives X=40.\n\nSee Also\n   is / 2, clrbit / 3, getbit / 3"},"compile_term/1":{"prefix":"compile_term","body":"compile_term(${1:Clauses})$2\n$0","description":"compile_term(+Clauses)\n\n   Compile a list of clauses using the default options\n\nArguments\n   Clauses    List of clauses and/or directives\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n    Compile a list of clauses and directives/queries using the default compiler\n    options. See compile_term/2 for details.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   compile / 1, compile / 2, compile_stream / 1, compile_term / 2, compile_term_annotated / 3"},"compile_term/2":{"prefix":"compile_term","body":"compile_term(${1:Clauses}, ${2:Options})$3\n$0","description":"compile_term(+Clauses, ++Options)\n\n   Compile specified clause or list of clauses, with the given options\n\nArguments\n   Clauses    List of clauses and/or directives\n   Options    List of compiler options\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Compiles the specified clause, or list of clauses, similar to\n   compilation from a file.  If the clauses are for a predicate that\n   was undefined so far, a new static predicate will be created.  If\n   the clauses are for an existing static predicate, the new clauses\n   will replace the old definition of the predicate.  If the clauses\n   are for an existing dynamic predicate, the new clauses will be\n   added to the exiting ones for the dynamic predicate.\n\n   If Clause is a list, the list elements are interpreted as consecutive\n   clauses.  Otherwise, Clause will be taken as a single clause.\n   Each clause may be a fact or a rule.\n\n   As with source files, the list may also contain directives (:- xxx)\n   but their handling is slightly different: include/1, if/1, elif/1,\n   else/0, endif/0 and module directives are not allowed.  Pragmas are\n   interpreted.  All others, as well as file queries (?- xxx) are\n   called as goals.\n\n   This predicate works almost as if all the clauses in the list\n   were written into a file and this file was then compiled using\n   compile/1.  Unlike in earlier releases, clause and goal expansion\n   is performed, according to the default compiler options.\n   General macro-expansion is not performed, since this is normally\n   the responsibility of the parser.  If required, it must be done\n   explicitly via expand_macros/2.\n\n   The difference between compile_term/1 and assert/1 is that\n   the predicates for which clauses are compiled are not necessarily\n   dynamic with compile_term/1, unless explicitly declared as such.\n   Therefore clauses compiled with compile_term/1 usually replace the\n   existing ones for the same predicate, moreover their source form is not\n   available.  Therefore, it can be used instead of assert/1 if the\n   properties of dynamic procedures are not required.\n\n   Unlike compiling a file, when an event occurs which is not just a\n   warning, the following clauses are not compiled, the compilation is\n   aborted.\n\n   See compile/2 for a description of compiler options and a exceptions.\n\nModes and Determinism\n   compile_term(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Clause is a partial list.\n     5 --- Clause is a list whose tail is neither nil nor a variable.\n    82 --- The module in which the clauses should be compiled is locked.\n    94 --- There is already am imported predicate of the same name.\n   130 --- The head of a clause is not an atom or a compound term.\n   131 --- A subgoal in the body of a clause is not an atom, a compound term or a variable.\n   134 --- The clauses of a procedure are not consecutive.\n   136 --- Trying to redefine a built-in predicate without having declared it.\n   137 --- A procedure which was previously referenced as built-in or external is now defined as a regular one, or vice versa.\n   143 --- One of the clauses was a query and it failed.\n\nExamples\n   \nSuccess:\n   % several facts for different predicates\n   ?- compile_term([p(a), p(b), q(1), r(\"abc\")]).\n\n   % a single clause\n   ?- compile_term(p(X) :- q(X)).\n\n   % two clauses for the same predicate\n   ?- compile_term([p([]), (p([X|Xs]) :- writeln(X), p(Xs))]).\n\n   % a declaration and two clauses\n   ?- compile_term([(:- export p/1), p(a), p(b)]).\n\nError:\n\n   compile_term([p|X]).    (Error 4).\n   compile_term([a|b]).    (Error 5).\n   compile_term([[a]]).    (Error 94).\n   compile_term([(p :- write(a)), write(b)]).      (Error 94).\n   compile_term(\"a\").    (Error 130).\n   compile_term([\"a\" :- b]).   (Error 130).\n   compile_term([p(X) :- 1]).    (Error 131).\n   compile_term([a, b, a]).      (Error 134).\n   compile_term(!).    (Error 135).\n   compile_term(:- var(a)).      (Error 143).\n\nSee Also\n   compile / 1, compile / 2, . / 2, compile_stream / 1, compile_term / 2, compile_term_annotated / 3, assert / 1, expand_macros / 2, set_flag / 2, pragma / 1"},"als/1":{"prefix":"als","body":"als(${1:PredSpec})$2\n$0","description":"als(++PredSpec)\n\n   Outputs the abstract code for the compiled predicate PredSpec.\n\nArguments\n   PredSpec    Atom/Integer or just Atom.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   If PredSpec is a predicate compiled into a sequence of abstract\n   instructions, this predicate will list on the current output stream this\n   abstract code.  The ECLiPSe abstract machine is a modification of the\n   Warren Abstract Machine.\n\nModes and Determinism\n   als(++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if PredSpec is not a predicate compiled into the WAM\n\nExceptions\n     4 --- PredSpec is not instantiated.\n     5 --- PredSpec is not of the form Atom/Integer or Atom.\n    60 --- PredSpec does not exist.\n\nExamples\n   \nSuccess:\n    [eclipse 1]: als(true).\n\n    true/0 :\n    Debug_exit\n    Retd\n\n    yes.\n\nError:\n    als(X).    (Error 4).\n    als(a/a).    (Error 5).\n    als(undef/3).    (Error 60).\n\nSee Also\n   asm : disasm / 2, asm : wam / 1"},"compiled_stream/1":{"prefix":"compiled_stream","body":"compiled_stream(${1:Stream})$2\n$0","description":"compiled_stream(-Stream)\n\n   Succeeds if the I/O stream currently being compiled is Stream.\n\nArguments\n   Stream    Atom, stream handle or variable.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to find the stream that is currently being compiled.\n   The stream handle can be used to get other information about the source\n   being compiled, e.g. file name and position.  If nothing is currently being\n   compiled, or if a non-textual source is being compiled (compile_term/1,2),\n   this predicate fails.\n\n   compiled_stream/1 is meaningful mainly in queries inside a compiled\n   file, or in event handlers for compilation events.\n\nModes and Determinism\n   compiled_stream(-) is semidet\n\nFail Conditions\n   Fails if no compilation from a stream is currently active\n\nExceptions\n     5 --- Stream is instantiated, but not to an atom or stream handle.\n\nExamples\n   \n    [eclipse]: [user].\n     a.\n     :- compiled_stream(S), get_stream_info(S, name, File),\n    printf(\"Compiling stream %d, file %s\\n\", [S, File]).\n    Compiling stream 0, file user\n    ^D\n     user       compiled traceable 28 bytes in 0.00 seconds\n\n    yes.\n    [eclipse]: exec('cat a.pl', []).\n    a.\n    :- compiled_stream(S), get_stream_info(S, name, File),\n       printf(\"Compiling stream %d, file %s\\n\", [S, File]).\n\n    yes.\n    [eclipse]: [a].\n    Compiling stream 5, file /home/joe/a.pl\n    a.pl       compiled traceable 28 bytes in 0.00 seconds\n\n    yes.\n\nSee Also\n   compile / 1, compile / 2, compile_stream / 1"},"current_pragma/1":{"prefix":"current_pragma","body":"current_pragma(${1:Pragma})$2\n$0","description":"current_pragma(?Pragma)\n\n   Retrieves pragmas that are currently in effect for the context module\n\nArguments\n   Pragma    A variable, atom or compound term\n\nType\n   Predicate Database and Compiler\n\nDescription\n    Used to test or enumerate currently set pragmas in the context module.\n    This is typically only meaningful during the compilation process or\n    during some other kind of source processing.\n    \n    Source processing tools (or code invoked from source-processing tools,\n    e.g. inline-transformations) can exploit the pragma facility to make\n    their behaviour user-configurable. All they need to do is document the\n    pragma names/structures and check for them using current_pragma/1.\n    \n    Pragma recording works as follows: if the argument of the pragma directive\n    is a structure, the new structure overwrites any previously recorded\n    structure with the same functor.  If the argument is an atom, e.g.\n    'xxx', then a previously recorded atom 'noxxx' is erased and 'xxx'\n    recorded instead, and vice versa.\n    \n\nModes and Determinism\n   current_pragma(+) is semidet\n   current_pragma(-) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Pragma is not a variable, atom or compound term.\n\nExamples\n   \n    :- pragma(blah).\n\n    ?- findall(P, current_pragma(P), L), writeln(L).\n    [blah]\n\n    :- pragma(myoption(on)).\n\n    ?- findall(P, current_pragma(P), L), writeln(L).\n    [blah, myoption(on)]\n\n    :- pragma(myoption(off)).\n\n    ?- findall(P, current_pragma(P), L), writeln(L).\n    [blah, myoption(off)]\n\n    :- pragma(noblah).\n\n     ?- findall(P, current_pragma(P), L), writeln(L).\n    [noblah, myoption(off)]\n\n     ?- current_pragma(myoption(off)).\n     Yes.\n\nSee Also\n   compile / 1, inline / 1, inline / 2, pragma / 1, library(source_processor)"},"compile_term_annotated/3":{"prefix":"compile_term_annotated","body":"compile_term_annotated(${1:Clauses}, ${2:Annotated}, ${3:Options})$4\n$0","description":"compile_term_annotated(+Clauses, ?Annotated, ++Options)\n\n   Compile a list of terms, possibly annotated with source information\n\nArguments\n   Clauses    List of clauses and/or directives\n   Annotated    Annotated form of Clauses, or variable\n   Options    List of compiler options\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n    Compile a list of clauses and queries, when source location information\n    is available.  Such annotated source clauses occur inside inlining\n    transformations (inline/2) or macro transformations (macro/3), when\n    using library(source_processor), or when using read_annotated/3.\n    Code compiled with source location annotations can be traced more\n    easily in the debugger.\n\n    If Annotated is a variable, then no source information is available,\n    and the predicate behaves exactly like compile_term/2. If Annotated\n    is instantiated, it must corresponded to the annotated form of Clauses,\n    i.e. as if returned by read_annotated/2,3.\n\n    See compile_term/2 for details.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   compile / 1, compile_term / 2, compile / 2, compile_term / 1, read_annotated / 2, read_annotated / 3"},"current_compiled_file/3":{"prefix":"current_compiled_file","body":"current_compiled_file(${1:File}, ${2:Time}, ${3:Module})$4\n$0","description":"current_compiled_file(?File, -Time, -Module)\n\n   Succeeds if File is a file that has been compiled into the system.\n\nArguments\n   File    Atom or variable.\n   Time    Integer or variable.\n   Module    Atom or variable.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   This predicate enumerates all files that have been compiled during this\n   ECLiPSe session.  Time is the modification time of the file at the time\n   it was compiled, and Module is the module from where it was compiled\n   (the latter is irrelevant if the file contains a module itself).  The\n   information can be used to determine if a file needs to be recompiled.\n\nModes and Determinism\n   current_compiled_file(-, -, -) is nondet\n   current_compiled_file(+, -, -) is semidet\n\nExceptions\n     5 --- File instantiated, but not to an atom.\n     5 --- Time instantiated, but not to an integer.\n     5 --- Module instantiated, but not to an atom.\n\nExamples\n   \nmake :- current_compiled_file(File, Time, Module),\n    get_file_info(File, mtime) =\\= Time,\n    compile(File, Module),\n    fail.\nmake.\n\nSee Also\n   compile / 1, compile / 2, ensure_loaded / 1, make / 0"},"demon/1":{"prefix":"demon","body":"demon","description":"demon +SpecList\n\n   Declares the procedure(s) specified by SpecList to be demons.\n\nArguments\n   SpecList    Comma-separated sequence of expressions of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   The demon annotation specifies that the listed predicates are to\n   be treated as demons. The only difference between a normal predicate\n   and a demon is the behaviour on waking: When a normal predicate is\n   delayed and gets woken, the delayed goal disappears. When a delayed\n   demon gets woken, the delayed goal stays around.\n   The only way to remove a demon is to explicitly kill it.\n\nModes and Determinism\n   demon(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is\n\tinstantiated, but not to a sequence of    expressions of the form Atom/Integer.\n    62 --- Predicate in SpecList already defined and is not a demon\n\nExamples\n   \n     % A demon that wakes whenever X becomes more constrained\n     report(X) :-\n\t     suspend(report(X, Susp), 1, X->constrained, Susp).\n\n     :- demon report/2.\n     report(X, _Susp) :-\n\t     var(X),\n\t     writeln(constrained(X)).  % implicitly re-suspend\n     report(X, Susp) :-\n\t     nonvar(X),\n\t     writeln(instantiated(X)),\n    kill_suspension(Susp).    % remove from the resolvent\n\n     [eclipse 1]:  report(X),\n    notify_constrained(X), wake,\n    notify_constrained(X), wake.\n     constrained(X)\n     constrained(X)\n\n     X = X\n\n     Delayed goals:\n    report(X)\n     yes.\n\n     [eclipse 2]:  report(X),\n    notify_constrained(X), wake,\n    X=123.\n     constrained(X)\n     instantiated(123)\n\n     X = 123\n     yes.\n\nSee Also\n   kill_suspension / 1, make_suspension / 3, notify_constrained / 1, schedule_suspensions / 2, set_suspension_data / 3, get_suspension_data / 3"},"deprecated/2":{"prefix":"deprecated","body":"deprecated(${1:PredSpec}, ${2:Advice})$3\n$0","description":"deprecated(++PredSpec, +Advice)\n\n   Declares the specified procedure as deprecated\n\nArguments\n   PredSpec    A term of the form Atom/Integer\n   Advice    A string\n\nType\n   Predicate Database and Compiler\n\nDescription\n   This declaration marks a predicate as deprecated. This means that a\n   compile-time warning will be raised when a call to this predicate is\n   compiled or when the predicate is explicitly imported. The warning\n   will include the Advice-string, which is supposed to tell the user\n   how to replace the deprecated predicate with a better equivalent.\n   \n   Deprecation warnings can be suppressed using the pragma\n   \n   :- pragma(deprecated_warnings(off)).\n   \n\nModes and Determinism\n   deprecated(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- PredSpec or a component of it is not instantiated.\n     4 --- Advice is not instantiated.\n     5 --- PredSpec is instantiated, but not to a term of the form Atom/Integer.\n     5 --- Advice is instantiated, but not to a string.\n\nExamples\n   \n    :- deprecated(foo/1, \"Please use bar/2 instead\").\n    foo(99).\n\nSee Also\n   compile / 1, pragma / 1, get_flag / 3"},"current_built_in/1":{"prefix":"current_built_in","body":"current_built_in(${1:PredSpec})$2\n$0","description":"current_built_in(?PredSpec)\n\n   Succeeds if the predicate defined by PredSpec is a visible built-in\npredicate.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer or variable.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to check that PredSpec is a built-in predicate visible from the\n   caller module, or else to return on backtracking all the visible\n   built-in predicates.\n\nModes and Determinism\n   current_built_in(++) is semidet\n   current_built_in(-) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the predicate defined by PredSpec is not a visible built-in\n   predicate\n\nExceptions\n     5 --- PredSpec is instantiated, but not to the form Atom/Integer.\n\nExamples\n   \nSuccess:\n     [eclipse]: current_built_in(X/Y),!.\n     X = findall\n     Y = 3\n     yes.\n\n     [eclipse]: current_built_in(X).\n     X = findall / 3     More? (;)\n     X = ! / 0     More? (;)\n     X = delayed_goals / 1     More? (;)\n     X = delayed_goals / 2     More? (;)   % type <cr>\n     yes.\nFail:\n     current_built_in(assertz/1).\n     current_built_in(reverse/2).\n\n     [eclipse]: [user].\n      p.\n      user compiled 28 bytes in 0.00 seconds\n     yes.\n     [eclipse]: get_flag(p/0, type, T).\n     T = user\n     yes.\n     [eclipse]: current_built_in(p/0).\n     no.\nError:\n     current_built_in(a/a).    (Error 5).\n\nSee Also\n   current_predicate / 1, current_module_predicate / 2, is_predicate / 1"},"discontiguous/1":{"prefix":"discontiguous","body":"discontiguous(${1:SpecList})$2\n$0","description":"discontiguous(++SpecList)\n\n   Declares the procedure(s) specified by SpecList as discontiguous\n\nArguments\n   SpecList    term of the form Atom/Integer, or a comma-separated sequence of such terms, or a list of such terms\n\nType\n   Predicate Database and Compiler\n\nDescription\n   The discontiguous declaration specifies that clauses for the declared\n   predicate need not be together (contiguous) in the source file which contains\n   them, but can be interleaved with clauses for other predicates. All clauses\n   must be in a single file, though.\n\n   A discontiguous declaration must textually occur in the same file and before\n   any clauses for the predicate. Multiple discontiguous declarations for the\n   same predicate are silently accepted.\n\nModes and Determinism\n   discontiguous(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList or a component of it is not instantiated.\n     5 --- SpecList is instantiated, but not to a sequence or list of expressions of the form Atom/Integer.\n    65 --- SpecList specifies a predicate which is already defined\n\nExamples\n   \n  [eclipse 1]: [user].\n   :- discontiguous(p/1).\n   p(a).\n   q(1).\n   p(b).\n  user       compiled traceable 220 bytes in 0.02 seconds\n  yes.\n\nSee Also\n   compile / 1"},"current_predicate/1":{"prefix":"current_predicate","body":"current_predicate(${1:PredSpec})$2\n$0","description":"current_predicate(?PredSpec)\n\n   Succeeds if PredSpec is a visible predicate defined by the user, or a\nvisible library predicate.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer or variable.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to check that PredSpec is a user or library predicate visible from\n   the caller module, or else to return on backtracking all the current\n   visible predicates.\n\nModes and Determinism\n   current_predicate(++) is semidet\n   current_predicate(-) is multi\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if PredSpec is not a visible (user or library) predicate\n\nExceptions\n     5 --- PredSpec is instantiated, but not to the form Atom/Integer.\n\nExamples\n   \nSuccess:\n     [eclipse]: current_predicate(X/Y).\n     X = intersection\n     Y = 3     More? (;)\n     yes.\n     [eclipse]: current_predicate(X).\n     X = (^) / 2     More? (;)\n     X = intersection / 3     More? (;)\n     X = subtract / 3     More? (;)\n     X = append / 3     More? (;)\n     yes.\n\n     [eclipse]: [user].\n      p.\n      user compiled 28 bytes in 0.00 seconds\n     yes.\n     [eclipse]: current_predicate(p/0).\n     yes.\nFail:\n     current_predicate(assert/1).\nError:\n     current_predicate(a/a).    (Error 5).\n\nSee Also\n   current_module_predicate / 2, current_built_in / 1, is_predicate / 1, get_flag / 3"},"ensure_loaded/1":{"prefix":"ensure_loaded","body":"ensure_loaded(${1:Files})$2\n$0","description":"ensure_loaded(++Files)\n\n   Compile or load the specified Files if necessary.\n\nArguments\n   Files    Atom, string, library(Atom) or a list thereof.\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n\tCompiles the specified files or libraries if they haven't been compiled\n\tyet or if they have been modified since the last compilation.\n\tThe file name expansion rules are the same as for compile/1,\n\texcept that it tries to load a precompiled file (with the\n\teclipse_object_suffix) before looking for source files.\n\nModes and Determinism\n   ensure_loaded(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Files is not instantiated.\n     5 --- File is instantiated but not to a (list of) files.\n\nExamples\n   \n    ensure_loaded(prog).\n    ensure_loaded('dir/file').\n    ensure_loaded([file1, 'file2.pl']).\n    ensure_loaded(library(lists)).\n\nSee Also\n   . / 2, compile / 1, compile / 2, current_compiled_file / 3, fcompile : fcompile / 1, get_flag / 2"},"current_module_predicate/2":{"prefix":"current_module_predicate","body":"current_module_predicate(${1:Property}, ${2:PredSpec})$3\n$0","description":"current_module_predicate(+Property, ?PredSpec)\n\n   Used to enumerate all predicates with given property in the caller module\n\nArguments\n   Property    An atom.\n   PredSpec    A variable or an expression of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n    This predicate is mainly used to enumerate all predicates in the caller\n    module with one of the following properties (for testing, use get_flag/3):\n\nundeclared\n    predicates that have been referenced but are neither\n    declared nor defined in this module.\nno_module\n    predicates whose module of origin is known (through import or qualified\n    reference), but that module does not exist.\nno_export\n    predicates whose module of origin exists, but the predicate is not\n    exported from there.\nlocal\n    defined predicates that are local\nexported\n    defined predicates that are exported\nreexported\n    defined predicates that are reexported\nexported_reexported\n    defined predicates that are exported or reexported\ndefined\n    predicates defined in this module (local or exported)\nundefined\n    local or exported predicates that have not been defined (no clauses)\ndeprecated\n    predicates that are imported or referenced via qualification, but have\n    their deprecated-flag set.\n\n    This predicate is more efficient than current_predicate/1 and\n    current_built_in/1 when one is not interested in imported predicates.\n    In particular, it does not complain about ambiguous imports.\n\nModes and Determinism\n   current_module_predicate(+, -) is nondet\n   current_module_predicate(+, ++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if there is no predicate with the given property\n\nExceptions\n     4 --- Property is not instantiated\n     5 --- Property is not an atom\n     5 --- PredSpec is instantiated, but not to the form Atom/Integer.\n\nExamples\n   \n    [eclipse 1]: [user].\n     :- local r/0.\n     p :- q, r.\n    yes.\n\n    [eclipse 2]: current_module_predicate(defined,P).\n    P = p / 0\n    yes.\n\n    [eclipse 3]: current_module_predicate(undefined,P).\n    P = r / 0\n    yes.\n\n    [eclipse 4]: current_module_predicate(undeclared,P).\n    P = q / 0\n    yes.\n\nSee Also\n   current_built_in / 1, current_predicate / 1, get_flag / 3"},"get_flag/3":{"prefix":"get_flag","body":"get_flag(${1:PredSpec}, ${2:Flag}, ${3:Value})$4\n$0","description":"get_flag(++PredSpec, ?Flag, -Value)\n\n   Succeeds if the flag Flag of the procedure specified by PredSpec has the\nvalue Value.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer.\n   Flag    Atom or variable.\n   Value    Atom, integer, compound_term or variable.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to get the value Value of the flag Flag of the procedure specified\n   by PredSpec.  The values of certain flags may be set using set_flag/3.\n   It can also be used to test if a procedure with a given functor exists\n   or has certain properties.\n\n   The possible flags, their values and their meanings are:\n\n    Flags    Values    Description\n   ----------------------------------------------------------------------\n    auxiliary    on,off    predicate is a compiler auxiliary\n\n    break_lines    list of    list of predicate source File:Line\n    atom:integer     that currently have breakpoints set\n\n    call_type    prolog,    predicate calling external convention\n\n    code_size    an integer       size of abstract machine\n    code in words (32/64 bits)\n\n    debugged    on, off    compiled in debugging mode\n\n    declared    on, off    predicate was declared\n\n    defined    on, off    predicate code exists\n\n    definition_module  an atom    where the procedure is defined\n\n    demon    on, off    predicate is a demon\n\n    deprecated    on, off    predicate is deprecated,\n    warning on use\n\n    leash    stop,print,      see below\n    notrace\n\n    meta_predicate     pred(Prop1,...)  the meta-arguments of the predicate\n    (from a meta_predicate/1 declaration)\n\n    mode    pred(Mode1,...)  the mode of the predicate (from a\n    mode/1 or meta_predicate/1 declaration)\n\n    parallel    on, off    clauses may be executed in parallel\n\n    port_calls    list of    list of DefModule:Name/Arity for\n    atom:atom/int    the predicate's body goals where \n    breakpoints can be added. The \n    port_lines option returns the source\n    information for these ports, in the \n    same order\n\n    port_lines    list of    list of predicate source File:Line\n    atom:integer     where breakpoints can be added. The\n    port_calls option returns the goal\n    information for these ports, in the \n    same order \n\n    priority    1..12    waking priority\n\n    run_priority       1..12    execution priority when woken\n\n    skip    on, off    procedure will be traced,\n    but its children will not\n\n    spy    on, off    procedure has a spypoint\n\n    stability    static,dynamic   is the procedure dynamic?\n\n    tool    on, off    tool property\n\n    type    built-in,user    type of predicate\n\n    visibility    local,exported   module scope\n    reexported,\n    imported\n\n    source_file    an atom    the file where defined\n\n    source_line    an integer       starting line number in the file\n\n    source_offset      an integer       byte offset at which the procedure\n    definition starts in its source file\n\n   The possible values of leash and their meanings are:\n\n   -----------------------------------------------------\n   | Values   Description    |\n   |--------------------------------------------------  |\n   | stop     procedure ports are printed and the       |\n   |    debugger stops on them    |\n   | print    procedure ports are printed and the       |\n   |    debugger does not stop on them    |\n   | notrace  procedure ports will not be shown, but    |\n   |    its childrens's ports will    |\n   -----------------------------------------------------|\n\nModes and Determinism\n   get_flag(++, -, -) is nondet\n   get_flag(++, +, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the flag Flag of the procedure specified by PredSpec does not\n   have the value Value, if its value is unknown or if the procedure does\n   not exist\n\nExceptions\n     4 --- PredSpec is not instantiated\n     5 --- PredSpec is not an expression of the form Atom/Integer.\n     5 --- Flag is instantiated but not to an atom.\n     5 --- Value is not an atom.\n\nExamples\n   \nSuccess:\n    [eclipse]: get_flag(member/2, F, V),\n    printf(\"%-20s%w\\n\", [F, V]), fail.\n\n    mode    member(?, ?)\n    visibility    imported\n    definition_module   sepia_kernel\n    declared    on\n    defined    on\n    autoload    off\n    auxiliary    off\n    call_type    prolog\n    demon    off\n    deprecated    off\n    parallel    off\n    priority    2\n    run_priority    2\n    stability    static\n    tool    off\n    type    built_in\n    debugged    off\n    leash    stop\n    skip    off\n    spy    off\n    start_tracing       off\n    source_file    Kernel/lib/kernel.pl\n    code_size    14\n\nFail:\n    get_flag(true/0, defined, off).\n    get_flag(undef/0, F, V).\nError:\n    get_flag(X, spy, on).    (Error 4).\n    get_flag(\"a\", spy, on).    (Error 5).\n\nSee Also\n   pred / 1, set_flag / 3, current_module_predicate / 2"},"inline/1":{"prefix":"inline","body":"inline(${1:Pred})$2\n$0","description":"inline(++Pred)\n\n   Declares Pred as a candidate for inlining (unfolding).\n\nArguments\n   Pred    Expression of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   If a predicate is declared inline, the compiler will attempt to\n   textually insert the predicate's definition everywhere the\n   predicate is called.  This is also known as unfolding.  \n   Inlining will usually improve efficiency, in particular when the\n   inlined predicate is short or has many arguments.\n\n   If the inlined predicate has multiple clauses, they will be inlined\n   in the form of a disjunction (note that indexing will be preserved).\n\n   If inlining is applied to an exported predicate, one must be aware that\n   the definition will be textually substituted for the original goal in\n   an unknown module context.  Although the expansion mechanism will add\n   module qualifications to the expanded source, it means that all\n   predicates called by the expanded source must be exported from their\n   definition module in order to be accessible from elsewhere.\n\n   The inline/1 directive must be issued from the definition module\n   of Pred, and should occur before Pred's definition.  Only calls that\n   textually follow the definition will be inlined.\n\n   Note that inline/1 is a special system-defined case of inline/2,\n   using a transformation predicate called unfold/6.  Therefore\n   get_flag(Pred, inline, unfold/6) can be used to test whether a\n   predicate has been declared with inline/1.\n\n   Inlining can be disabled for debugging purposes by adding\n\n    :- pragma(noexpand).\n\n   to the code containing calls, or by setting the global flag\n\n    :- set_flag(goal_expansion, off).\n\n    The global flag also controls whether transformations are applied\n    to goals entered at the interactive toplevel prompt.\n\nModes and Determinism\n   inline(++) is det\n\nExceptions\n     4 --- Pred is not fully instantiated.\n     5 --- Pred is not of the form Atom/Integer.\n   100 --- Pred is not defined is this module.\n\nExamples\n   \n    :- inline(double/2).\n    double(X, Y) :- Y is 2*X.\n\n    % The predicate\n    sample :- ..., double(A, B), ...\n    % will be compiled as\n    sample :- ..., B is 2*A, ...\n\n    :- inline(yesno/1).\n    yesno(yes).\n    yesno(no).\n\n    % The predicate\n    sample :- ..., yesno(X), ...\n    % will be compiled as\n    sample :- ..., (X=yes;X=no), ...\n\nSee Also\n   inline / 2, expand_goal / 2, get_flag / 2, pragma / 1, compile / 1"},"expand_goal/2":{"prefix":"expand_goal","body":"expand_goal(${1:Term}, ${2:TransTerm})$3\n$0","description":"expand_goal(+Term, -TransTerm)\n\n   Apply goal inline expansion to Term\n\nArguments\n   Term    A callable term.\n   TransTerm    A variable or callable term.\n\nType\n   Predicate Database and Compiler\n\nDescription\n    Applies a goal inline expansion to Term, if any is visible in the\n    caller module. If no inline/1 or inline/2 declaration is visible,\n    TransTerm is identical to Term.\n    \n    Normally, goal inline expansion is performed implicitly by the compiler.\n    For certain meta-programming applications (e.g. for writing other\n    compilers) it can be performed explicitly using expand_goal/2.\n    Goal inline expansion is the third transformation which is applied during\n    the compilation process: macro expansion, then clause expansion, then\n    goal inline expansion.\n\nModes and Determinism\n   expand_goal(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    [eclipse 1]: lib(fd).\n    yes.\n\n    [eclipse 5]: expand_goal(X#>Y, G).\n    X = X\n    Y = Y\n    G = fd_arith : fd_gec(X, -1, Y, -1, 0)\n    yes.\n\nSee Also\n   inline / 1, inline / 2, portray / 3, expand_clause / 2"},"is_predicate/1":{"prefix":"is_predicate","body":"is_predicate(${1:PredSpec})$2\n$0","description":"is_predicate(++PredSpec)\n\n   Succeeds if PredSpec is a defined predicate.\n\nArguments\n   PredSpec    Predicate of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to test whether PredSpec is defined as a user or a built-in\n   predicate.\n\nModes and Determinism\n   is_predicate(++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if PredSpec is not a valid predicate\n\nExceptions\n     4 --- PredSpec is not fully instantiated.\n     5 --- PredSpec is not in the format Atom/Integer.\n\nExamples\n   \nSuccess:\n[eclipse]: [user].\n    a(1).\n    a(1,2).\n    a(1,2,3).\n    user compiled 144 bytes in 0.00 seconds\n   yes.\n   [eclipse]: is_predicate(a/1).\n   yes.\n   [eclipse]: is_predicate(a/2).\n   yes.\n   [eclipse]: is_predicate(nl/0).\n   yes.\n   [eclipse]: is_predicate(a/2).\n   yes.\nFail:\n   is_predicate(a/0).    % Fails if a/0 is not a predicate\nError:\n   is_predicate(X).    (Error 4).\n   is_predicate(a/X).    (Error 4).\n   is_predicate(a).    (Error 5).\n   is_predicate(1).    (Error 5).\n\nSee Also\n   get_flag / 3, pred / 1, current_predicate / 1, current_built_in / 1"},"inline/2":{"prefix":"inline","body":"inline(${1:Pred}, ${2:TransPred})$3\n$0","description":"inline(++Pred, ++TransPred)\n\n   Declares TransPred as the predicate to be used to do compile-time\ntransformation (e.g. inlining) of calls to Pred.\n\nArguments\n   Pred    Expression of the form Atom/Integer.\n   TransPred    Expression of the form Atom/Integer, Integer is 2 to 5.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   To improve efficiency, calls to user-defined predicates can be\n   preprocessed and transformed at compile time.  The directive\n\n    :- inline(mypred/1, mytranspred/2).\n\n   arranges for mytranspred/2 to be invoked at compile time for each \n   call to the predicate mypred/1 before it is being compiled.\n\n   The transformation predicate receives the original call to mypred/1\n   as its first argument, and is expected to return a replacement goal\n   in its second argument. This replacement goal replaces the original\n   call in the compiled code. Usually, the replacement goal would be\n   semantically equivalent, but more efficient than the original goal.\n   When the transformation predicate fails, the original goal is not\n   replaced.\n\n   A transformation predicate can have an optional third argument which\n   supplies the module in which the substitution takes place:\n\n      trans_pred(OldGoal, NewGoal [, Module]) :- ...\n\n   Moreover, a transformation predicate can be source annotation aware;\n   it is then of arity 4 or 5, and should look as follows:\n\n      trans_pred(OldGoal, NewGoal, OldAnnGoal, NewAnnGoal [, Module]) :- ...\n\n   In this setting, the annotated version of the original goal term\n   (see read_annotated/2,3) is passed in the third argument, and the\n   transformation should bind the fourth argument to the annotated\n   transformed goal term.  If no source annotation information was\n   available for the original goal, the third argument is passed in as\n   a free variable, and the transformation should not bind the fourth\n   argument.  The optional last argument is again the module in which\n   the substitution takes place, i.e. where the goal was called.\n\n   If inlining is applied to an exported predicate, one must be aware that\n   the replacement goal will be textually substituted for the original\n   goal in an unknown module context.  That means that the replacement goal\n   should only contain calls to builtins or explicitly qualified calls to\n   other exported predicates, since the visibility of predicates generally\n   cannot be guaranteed in the module where the substitution takes place.\n\n   The inline/2 directive must be issued from the definition module\n   of Pred, and TransPred must be visible from (and is usually defined\n   in) this same module.\n\n   The transformation predicate for a predicate can be queried by\n   calling get_flag(Pred, inline, TransPred).\n\n   Setting TransPred to =/2 will erase any previously attached\n   transformation predicate.\n\n   Transformation can be disabled for debugging purposes by adding\n\n      :- pragma(noexpand).\n\n   to the compiled file, or by setting the global flag\n\n      :- set_flag(goal_expansion, off).\n\n    The global flag also controls whether transformations are applied\n    to goals entered at the interactive toplevel prompt.\n\nModes and Determinism\n   inline(++, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Pred or TransPred are not fully instantiated.\n     5 --- Pred or TransPred are not of the form Atom/Integer.\n     6 --- The arity of TransPred is not between 2 and 5.\n   100 --- Pred is not defined is this module.\n\nExamples\n   \n    :- inline(double/2, trans_double/2).\n\n    double(X, Y) :-\n    Y is 2*X.\n\n    trans_double(double(X, Y), Y=Result) :-\n    ground(X),    % if X already known at compile time:\n    Result is 2*X.       % do calculation at compile time!\n\n    % If we now compile the following predicate involving double/2:\n\n    sample :-\n    double(12,Y),    % will be transformed into: Y=24\n    ...\n    double(Y,Z).    % will be compiled as is\n\nSee Also\n   inline / 1, expand_goal / 2, macro / 3, get_flag / 2, set_flag / 2, pragma / 1, compile / 1, read_annotated / 3"},"lib/1":{"prefix":"lib","body":"lib(${1:LibraryName})$2\n$0","description":"lib(+LibraryName)\n\n   Makes the library LibraryName available in the current module if not loaded\nalready.\n\nArguments\n   LibraryName    String or atom.\n\nType\n   Predicate Database and Compiler\n\nDescription\n\n   This is a shorthand: lib(Lib) is identical to use_module(library(Lib)).\n\n   Used to load the library LibraryName into the system if it has not\n   already been loaded.  The currently used Prolog suffix(es) is appended\n   to LibraryName and the resulting library is loaded if it exists.\n\n   The search path used when loading libraries is specified by the global\n   flag library_path using the get_flag/2 and set_flag/2 predicates.  This\n   flag contains a list of strings containing the pathnames of the\n   directories to be searched when loading a library file.  User libraries\n   may be added to the system simply by copying the desired file into the\n   ECLiPSe library directory.  Alternatively the library_path flag may be\n   updated to point at a number of user specific directories.\n\nModes and Determinism\n   lib(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- LibraryName is not instantiated.\n     5 --- LibraryName is neither a string nor an atom.\n    80 --- Library file does not contain a matching module.\n   173 --- Library file LibraryName not found.\n\nExamples\n   \nSuccess:\n   [eclipse]: lib(sorts).\n   loading the library /usr/local/ECLIPSE/lib/sorts.pl\n   yes.\n   [eclipse]: lib(sorts).\n   yes.    % library already loaded - succeeds\nError:\n   lib(X).    (Error 4).\n   lib(1).    (Error 5).\n   lib(no_lib).       (Error 173).\n\nSee Also\n   ensure_loaded / 1, existing_file / 4, get_flag / 2, set_flag / 2, use_module / 1"},"meta_predicate/1":{"prefix":"meta_predicate","body":"meta_predicate(${1:MetaSpecs})$2\n$0","description":"meta_predicate(++MetaSpecs)\n\n   Specifies the meta-arguments for the given predicates\n\nArguments\n   MetaSpecs    Callable term with meta-argument indicators, or a comma-separated list of such.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   This declaration is normally used as a directive in compiled code,\n   to specify if and how the arguments of a predicate refer to other\n   predicates (meta-arguments).  In ECLiPSe 6.1, this declaration does\n   not affect the semantics of the program, and is only used by\n   development tools like the cross-referencer or coverage analyser. \n   In future releases, the compiler may make use of the information.\n\n   The meta-argument indicators describes the control flow through the\n   arguments of a meta-predicate.  The functor and arity of MetaSpec\n   correspond to the functor and arity of the meta-predicate. The arguments\n   are each populated with one of the following atomic descriptors:\n\n    0\n\tA goal that is called as a subgoal of the declared predicate.\n\n    A positive integer\n\tA subgoal is constructed by appending the number of specified\n\targuments, and then called.\n\n    :-\n\tA clause (a fact or a rule).\n\n    /\n\tA PredSpec of the form Name/Arity.\n\n    :\n\tA module-sensitive argument, but none of the above.\n\n    *\n\tAn argument that is not one of the above.\n\n    Instead of the '*', which marks a non-meta argument, a mode indicator\n    can be given.  The effect is the same as specifying '*', and giving\n    the mode in a separate mode/1 declaration:\n\n    +\n\tThe argument is instantiated, i.e. it is not a variable.\n\n    ++\n\tThe argument is ground, i.e. contains no variables.\n\n    -\n\tThe argument is not instantiated, it must be a free variable without\n\tany constraints or aliases.\n\n    ?\n\tThe mode is not known or it is neither of the above.\n\n   If one of the declared predicates does not exist, a local undefined\n   predicate is created.\n\n   The declared meta-predicate information can be accessed by retrieving\n   the predicate's 'meta_predicate' and 'mode' properties with get_flag/3.\n\nModes and Determinism\n   meta_predicate(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- MetaSpecs is not ground\n     5 --- MetaSpecs is not a callable term, or a comma list of such\n     6 --- The callable term arguments are not meta-argument indicators\n\nExamples\n   \n:- meta_predicate p(:,*,*).\n\n:- meta_predicate q(0,+,-).\n\n:- meta_predicate\n\tmaplist(2,*,*),\n\tchecklist(1,*).\n\nSee Also\n   compile / 1, get_flag / 3, mode / 1, library(instrument), library(xref), library(coverage), library(lint)"},"parallel/1":{"prefix":"parallel","body":"parallel","description":"parallel +SpecList\n\n   Declares the procedure(s) specified by SpecList as parallel.\n\nArguments\n   SpecList    Comma-separated sequence of expressions of the form Atom/Integer.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   The parallel annotation specifies that the system is allowed to execute\n   the clauses of the annotated predicate in parallel (Or-parallelism),\n   instead of sequentially by backtracking.  This has the following\n   consequences:\n\n  * the predicate is a source of or-parallelism which will hopefully speed\n    up execution of the program on a parallel machine\n\n  * calls to this predicate may return alternative solutions in\n    unpredictable order\n\n  * side effects within the parallel execution may happen in unpredictable\n    order\n\n   The parallel annotation has simply no effect when the predicate (or a\n   particular call to it) is deterministic or when it is used with a\n   sequential ECLiPSe system.\n\n   A procedure can be declared parallel before it is actually defined.\n\nModes and Determinism\n   parallel(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but not to a sequence of    expressions of the form Atom/Integer.\n\nExamples\n   \n  [eclipse 1]: [user].\n   :- parallel p/1.\n   p(a).  p(b).  p(c).\n  user       compiled traceable 220 bytes in 0.02 seconds\n  yes.\n  [eclipse 2]: get_flag(p/1, parallel, Flag).\n  Flag = on\n  yes.\n  [eclipse 3]: p(X), use(X).\n  % The three clauses of p/1 as well as the resulting goals\n  % use(a), use(b) and use(c) may be executed in parallel!\n\nSee Also\n   compile / 1, get_flag / 3, set_flag / 3"},"mode/1":{"prefix":"mode","body":"mode","description":"mode +PredModes\n\n   Specifies the mode (calling pattern) for the given predicates\n\nArguments\n   PredModes    Callable term with mode-indicator arguments, or a comma-separated list of such\n\nType\n   Predicate Database and Compiler\n\nDescription\n   This declaration is normally used as a directive in compiled code,\n   and informs the compiler that the arguments of the specified predicate\n   will always have the corresponding form when the predicate is called.\n   The compiler takes this information into account when the predicate\n   is compiled, and generates more compact and/or faster code.\n   Specifying the mode of a predicate that has been already compiled\n   has no effect, unless it is recompiled.  If the specified predicate\n   does not exist, a local undefined predicate is created.\n\n   The possible argument modes are:\n\n    +\n\tThe argument is instantiated, i.e. it is not a variable.\n\n    ++\n\tThe argument is ground, i.e. contains no variables.\n\n    -\n\tThe argument is not instantiated, it must be a free variable without\n\tany constraints, especially it must not occur in any other argument\n\tand it cannot be a suspending variable.\n\n    ?\n\tThe mode is not known or it is neither of the above.\n\n   mode/1 is a prefix operator and accepts also comma-separated list of\n   mode specifications in the form\n\n   :- mode p(+), q(-), r(++, ?).\n\n   As the operator binds less than comma, the argument of mode/1 might\n   have to be parenthesised when it is followed by other goals.  Modes must\n   be declared in a predicate's definition module.  Modes are significant\n   only for the first 15 arguments, for higher arguments the mode is always\n   taken as ?.\n\n   NOTE: If the instantiation of a runtime predicate call violates its mode\n   declaration, no exception is raised and its behaviour is undefined.\n\n   The declared mode information can be accessed by retrieving the\n   predicate's 'mode' property with get_flag/3.\n\nModes and Determinism\n   mode(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- PredModes is not ground\n     5 --- PredModes is not a callable term, or a comma list, or its arguments are not atoms.\n     6 --- The callable term arguments are not mode indicators\n\nExamples\n   \nSuccess:\n    % code size:\n    % no mode declarations\n    [eclipse]: [append].\n    /home/eclipse/src/append.pl compiled 212 bytes in 0.03 seconds\n\n    % mode for one argument decreases the code size\n    [eclipse]: mode(append(++, ?, ?)), [append].\n    /home/eclipse/src/append.pl compiled 120 bytes in 0.00 seconds\n\n    % modes for other arguments further decreases the size\n    [eclipse]: mode(append(++, ++, -)), [append].\n    /home/eclipse/src/append.pl compiled 92 bytes in 0.00 seconds\n\n    % size of the trail stack\n    cygnus% cat p.pl\n    p(f(1), [output]) :- !.\n    p(f(2), [another_one]).\n\n    test :-\n    p(f(1), X),\n    statistics(trail_stack_used, T1),\n    writeln(T1).\n    :- test.\n    cygnus% eclipse\n    [eclipse]: [p].\n    16\n    /home/eclipse/p.pl    compiled 540 bytes in 0.02 seconds\n\n    % With modes the code is shorter and does less trailing\n    [eclipse]: mode(p(++, -)), [p].\n    12\n    /home/eclipse/p.pl    compiled 408 bytes in 0.02 seconds\n\n    % bad mode declaration:\n    [eclipse]: mode(p(+)), [user].\n     p(a).\n     user   compiled 40 bytes in 0.00 seconds\n\n    yes.\n    [eclipse]: p(X).    % call violates the mode declaration\n\n    no (more) solution.\nError:\n    mode p(X).    (Error 4).\n    mode p(+), get_flag(p/1, mode, X). (Error 5).\n    % equivalent to mode((p(+), get_flag(p/1, mode, X)))\n\nSee Also\n   compile / 1, get_flag / 3, set_flag / 3, meta_predicate / 1"},"set_flag/3":{"prefix":"set_flag","body":"set_flag(${1:PredSpec}, ${2:Flag}, ${3:Value})$4\n$0","description":"set_flag(++PredSpec, +Flag, +Value)\n\n   Sets the flag Flag of the procedure specified by PredSpec to the value\nValue.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer or a list of those.\n   Flag    Atom.\n   Value    Atom.\n\nType\n   Predicate Database and Compiler\n\nDescription\n   Used to set the value Value of the flag Flag of the procedure(s)\n   specified by PredSpec.  The value of a flag may be returned using\n   get_flag/3.\n\n   The settable flags, their values and their meanings are:\n\n   ---------------------------------------------------------------------\n   | Flags    Values     Description    |\n   |-------------------------------------------------------------------|\n   | deprecated     on, off    predicate is deprecated, warn on use    |\n   |    |\n   | leash    debugger behaviour for this procedure:  |\n   |    stop,    trace procedure's ports and stop      |\n   |    print,       trace procedure's ports and continue  |\n   |    notrace      hide procedure's ports    |\n   |    |\n   | skip    on, off    procedure will be traced,    |\n   |    but its children will not    |\n   |    |\n   | spy    on, off    procedure has a spypoint    |\n   |    |\n   | start_tracing  on, off    procedure starts the tracer    |\n   |    |\n   | priority       1..12      default waking priority    |\n   |    |\n   | run_priority   1..12      execution priority when woken    |\n   ---------------------------------------------------------------------\n\nModes and Determinism\n   set_flag(++, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- At least one of PredSpec, Flag or Value are not instantiated\n     5 --- PredSpec is not an expression of the form Atom/Integer.\n     5 --- Flag is not an atom.\n     5 --- Value is not an atom.\n     6 --- Flag is no flag.\n     6 --- Value is no value of the flag Flag.\n    30 --- Flag is a read only flag.\n    60 --- PredSpec is not defined.\n\nExamples\n   \nSuccess:\n    [eclipse]: [user].\n     pr([]).  % prints the elements of a list\n     pr([ S | T ]) :-\n    writeln(S),\n    pr(T).\n     user compiled 484 bytes in 0.00 seconds\n    yes.\n    [eclipse]: pr([tom, dick]).\n    tom\n    dick\n    yes.\n    [eclipse]: set_flag(pr/1, spy, on).\n    yes.\n    [eclipse]: trace.\n    Debugger switched on - creep mode\n    yes.\n    [eclipse]: pr([tom, dick]).\n     +(1) 0  CALL   pr([tom, dick]) (dbg)?- leap\n    tom\n     +(3) 1  CALL   pr([dick]) (dbg)?- leap\n    dick\n     +(5) 2  CALL   pr([]) (dbg)?- leap\n     +(5) 2  EXIT   pr([]) (dbg)?- leap\n     +(3) 1  EXIT   pr([dick]) (dbg)?- leap\n     +(1) 0  EXIT   pr([tom, dick]) (dbg)?- leap\n    yes.\n\nError:\n    set_flag(X, skip, on).    (Error 4).\n    set_flag(\"a\", spy, on).    (Error 5).\n    set_flag(is/2, spy, yes).    (Error 6).\n    set_flag(p/2, leash, on).    (Error 60).\n\nSee Also\n   debug / 0, get_flag / 3, deprecated / 2, nospy / 1, pred / 1, skipped / 1, spy / 1, trace / 0, traceable / 1, unskipped / 1, untraceable / 1"},"A/2":{"prefix":"Goal","body":"Goal","description":"Goal @ ContextModule\n\n   Goal is executed in the calling context of ContextModule.\n\nArguments\n   Goal    Callable term (atom or compound).\n   ContextModule       Atom.\n\nType\n   Control\n\nDescription\n   The calling context of a goal is normally the module where the goal is\n   called.  @/2 allows to specify this context module explicitly.  This is\n   needed when writing meta-predicates (i.e. predicates which have goals or\n   predicates as their arguments) or predicates which depend otherwise on\n   the module system's visibility rules.\n\n   @/2 changes only the context module, not the lookup module. I.e. the\n   way the definition of Goal is found is not affected at all. To specify\n   the lookup module, use :/2. The following table summarises:\n\n\tCall within module(m)    lookup module    caller module\n\n\t..., twice(X), ...    m    m\n\t..., lm : twice(X), ...    lm    m\n\t..., twice(X) @ cm, ...    m    cm\n\t..., lm : twice(X) @ cm, ...    lm    cm\n\t..., call(twice(X)) @ cm, ...   cm    cm\n\n   If Goal is not a tool-predicate, then Goal@ContextModule is completely\n   equivalent to Goal.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is neither an atom nor a compound term.\n    68 --- Goal is an undefined procedure in the caller module.\n\nExamples\n   \n    [eclipse 1]: [user].\n     :- tool(where/0, where/1).\n     where(Module) :-\n    printf(\"where/0 was called from module %w\\n\",\n    [Module]).\n    ^D\n    [eclipse 2]: where.\n    where/0 was called from module eclipse\n    yes.\n    [eclipse 3]: where @ m.\n    where/0 was called from module m\n    yes.\n    [eclipse 4]: call(where) @ m.\n    calling an undefined procedure where in module m\n    [eclipse 1]: [user].\n     :- tool(print_local_preds/0, print_local_preds/1).\n     print_local_preds(Module) :-\n    current_predicate(P) @ Module,\n    get_flag(P, visibility, local) @ Module,\n    writeln(P),\n    fail.\n    ^D\n    [eclipse 2]: print_local_preds.\n    print_local_preds / 0\n    print_local_preds / 1\n\nSee Also\n   : / 2, call / 1, tool / 2"},"expand_clause/2":{"prefix":"expand_clause","body":"expand_clause(${1:Term}, ${2:TransTerm})$3\n$0","description":"expand_clause(+Term, -TransTerm)\n\n   Apply clause transformation to Term\n\nArguments\n   Term    A clause term.\n   TransTerm    A variable or term.\n\nType\n   Predicate Database and Compiler\n\nDescription\n    Applies a clause-transformation (clause macro) to Term, if any is\n    visible in the caller module (see macro/3). If no transformation\n    is visible, TransTerm is identical to Term.\n    \n    Normally, clause expansion is performed implicitly by the compiler.\n    For certain meta-programming applications (e.g. for writing other\n    compilers) it can be performed explicitly using expand_clause/2.\n    Clause expansion is the second transformation which is applied during\n    the compilation process: macro expansion, then clause expansion, then\n    goal inlining expansion.\n    \n    Note that the result of clause transformation can be either a single\n    clause or a list of clauses. Transformed clauses should all be standard\n    clauses, i.e. either facts or rules with toplevel functor :-/2.\n\nModes and Determinism\n   expand_clause(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % A grammar rule is an example of a predefined clause transformation:\n    ?- expand_clause((p --> q, [tok]), C).\n\n    C = p(_263, _258) :- q(_263, _278), 'C'(_278, tok, _258)\n    yes.\n\nSee Also\n   macro / 3, expand_goal / 2, library(source_processor)"},"block/3":{"prefix":"block","body":"block(${1:Goal}, ${2:Catcher}, ${3:Recovery})$4\n$0","description":"block(?Goal, ?Catcher, ?Recovery)\n\n   Equivalent to call(Goal) if Goal succeeds or fails.\nIf Goal throws an exception that unifies with Catcher, Recovery is executed\n\nArguments\n   Goal    A callable term.\n   Catcher    Any term.\n   Recovery    A callable term.\n\nType\n   Control\n\nDescription\nThis is a deprecated alias for catch/3 - see there.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fail if Goal fails, or if Goal exits and Recovery fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable, or Goal exits and Recovery is resatisfiable\n\nSee Also\n   catch / 3, throw / 1, exit_block / 1"},"abort/0":{"prefix":"abort","body":"abort","description":"abort\n\n   The current computation is aborted and control is returned to the top\nlevel.\n\nArguments\n\nType\n   Control\n\nDescription\n   Used to abort the current computation and return control to the top\n   level.  This predicate is also executed when Ctrl-C is typed (unless the\n   interrupt handler for this event has been redefined).\n\n   abort/0 is implemented using throw(abort), which is caught by the top level\n   loop.  If there is an active catch/3 (or block/3) call whose tag matches\n   the atom abort, the control does not return to the top level loop but is\n   caught by this catch-block.  If there is neither a top level loop (eg the -e\n   option has been used) nor any block to catch the abort, then ECLiPSe will\n   either return to the host program (in case of an embedded ECLiPSe) or\n   the ECLiPSe process will exit (in case of a standalone ECLiPSe).\n\nModes and Determinism\n   abort is erroneous\n\nExamples\n   \n   [eclipse]: abort.\n   Aborting execution....\n   [eclipse]:\n\nSee Also\n   kill / 2, catch / 3, throw / 1"},"call/1":{"prefix":"call","body":"call(${1:Goal})$2\n$0","description":"call(+Goal)\n\n   Succeeds if Goal succeeds.\n\nArguments\n   Goal    Atom or compound term.\n\nType\n   Control\n\nDescription\n   Calls the goal Goal.  This predicate is used to call goals whose\n   functors are known only at the time they are called.\n\n   Note that:\n\n   call(Goal) is logically the same as Goal and !/0 does not cut through\n   call/1.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is not an atom or a compound term.\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       or(A -> B, C) :- call(A), !, call(B).\n       or(_ -> _, C) :- call(C).\n       user compiled 412 bytes in 0.02 seconds\n      [eclipse]: or(write(a)->fail, write(k)).\n      a\n      no.\n      [eclipse]: or(fail->write(here),true).\n      yes.\n\nFail:\n      [eclipse]: call(fail),write(here).\n      no.\nError:\n      call(G).    (Error 4).\n      call(\"write(a)\").    (Error 5).\n\nSee Also\n   subcall / 2, @ / 2, : / 2, call / (2 .. 255)"},"call/2-255":{"prefix":"call","body":"call(${1:GoalPrefix}, ${2:Arg}, ","description":"call(+GoalPrefix, ?Arg, ?...)\n\n   Call with any number of additional arguments\n\nArguments\n   GoalPrefix    A callable term\n   Arg    An additional argument for Goal\n   ...    Optional further additional arguments for Goal\n\nType\n   Control\n\nDescription\n    Call the goal formed by appending the additional argument Arg\n\t(and any further arguments given) to GoalPrefix.  For example,\n\tthe following calls are all equivalent and invoke p/2:\n\t\n\tcall(p, 1, 2)\n\tcall(p(1), 2)\n\tcall(p(1,2) )\n\t\n\tThe maximum arity for call/N is the one indicated by\n\tget_flag(max_predicate_arity,N), and is at least 255.\n\t\n\tThese predicates are sensitive to their calling context module\n\tin the same way as call/1.\n\t\n\tImplementation note: These predicates are materialised lazily the\n\tfirst time they are being invoked. They may therefore not show up\n\twith current_built_in/1, get_flag/3 or other similar access methods.\n    \n\nFail Conditions\n   Fails if the called goal fails\n\nResatisfiable\n   Resatisfiable if the called goal is resatisfiable\n\nExceptions\n     4 --- GoalPrefix is not instantiated.\n     5 --- GoalPrefix is not an atom or a compound term.\n    68 --- Constructed goal refers to an undefined predicate.\n\nExamples\n   \n    ?- call(p, 1, 2, 3).\n    calling an undefined procedure p(1, 2, 3) in module eclipse\n    Abort\n\n    ?- call(append(L, R), [1]).\n    L = []\n    R = [1]\n    Yes (0.00s cpu, solution 1, maybe more)\n    L = [1]\n    R = []\n    Yes (0.00s cpu, solution 2)\n\n    ?- call(+(3), 4, X).\n    X = 7\n    Yes (0.00s cpu)\n\n    % A typical use case\n    filter(_, [], []).\n    filter(Pred, [X|Xs], Ys) :-\n    ( call(Pred, X) ->\n    Ys = [X|Ys1],\n    filter(Pred, Xs, Ys1)\n    ;\n    filter(Pred, Xs, Ys)\n    ).\n\n    ?- filter(atom, [1, a, 2, b, c], As).\n    As = [a, b, c]\n    Yes (0.03s cpu)\n    ?- filter(integer, [1, a, 2, b, c], As).\n    As = [1, 2]\n    Yes (0.06s cpu)\n    ?- filter(<(2), [5, 1, 4, 2, 3], Is).\n    Is = [5, 4, 3]\n    Yes (0.00s cpu)\n\nSee Also\n   call / 1, @ / 2, : / 2"},"catch/3":{"prefix":"catch","body":"catch(${1:Goal}, ${2:Catcher}, ${3:Recovery})$4\n$0","description":"catch(+Goal, ?Catcher, +Recovery)\n\n   Equivalent to call(Goal) if Goal succeeds or fails.\nIf Goal throws an exception that unifies with Catcher, Recovery is executed\n\nArguments\n   Goal    A callable term.\n   Catcher    Any term.\n   Recovery    A callable term.\n\nType\n   Control\n\nDescription\n   First, Goal is called from the current module, and if this succeeds then\n   catch/3 succeeds.  If Goal fails, then so does the call of catch/3.  In\n   other words, unless exceptions are involved, catch(Goal, ..., ...)\n   operates like call(Goal), and Catcher and Recovery are ignored.\n\n   If, however, an exception is thrown during the execution of Goal \n   (either by an error condition in a built-in predicate, or by an invocation\n   of throw/1), and the exception term unifies with Catcher, then the\n   execution of Goal is undone, and Recovery is called instead.  In this\n   case, catch(Goal,Catcher,Recovery) is equivalent to call(Recovery).\n   Note that exceptions within Recovery are NOT caught by this catch!\n\n   If Goal terminates with an exception, and the exception term does NOT\n   unify with Catcher, then the exception is passed on, allowing an ancestor\n   catch/3 to catch it.  The innermost invocation of catch/3 whose Catcher\n   argument matches the exception will catch it.\n\n   NOTE: block/3 is a deprecated alias for catch/3, and behaves identically.\n   exit_block/1 is a deprecated alias for throw/1, and behaves identically.\n\nModes and Determinism\n   catch(+, +, +)\n   catch(+, -, +)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fail if Goal fails, or if Goal exits and Recovery fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable, or Goal exits and Recovery is resatisfiable\n\nExamples\n   \n      % success, failure and backtracking are not affected by the catch:\n      ?- catch(X is 3+4, T, writeln(recover(T))).\n      X = 7\n      T = T\n      Yes (0.00s cpu)\n\n      ?- catch(8 is 3+4, T, writeln(recover(T))).\n      No (0.00s cpu)\n\n      ?- catch(member(X,[1,2]), T, writeln(recover(T))).\n      X = 1\n      T = T\n      Yes (0.00s cpu, solution 1, maybe more) ? ;\n      X = 2\n      T = T\n      Yes (0.00s cpu, solution 2)\n\n      % A variable Catcher catches all throws\n      ?- catch(throw(hello), T, writeln(recover(T))).\n      recover(hello)\n      T = hello\n      Yes (0.00s cpu)\n\n      % An instantiated Catcher catches only matching throws\n      ?- catch(throw(hello), hello, writeln(recovered)).\n      recovered\n      Yes (0.00s cpu)\n\n      ?- catch(throw(hello), world, writeln(recovered)).\n      uncaught exception in throw(hello)\n      Abort\n\n      % A partially instantiated Catcher catches only matching throws\n      ?- catch(throw(hello(world)), hello(Who), writeln(recovered(Who))).\n      recovered(world)\n      Yes (0.00s cpu)\n\n      ?- catch(throw(hi(world)), hello(Who), writeln(recovered(Who))).\n      uncaught exception in throw(hi(world))\n      Yes (0.00s cpu)\n\n      % ECLiPSe's error handlers usually execute throw(abort)\n      % and therefore can be caught with a catch:\n      ?- catch(X is 1//0, T, writeln(recover(T))).\n      arithmetic exception in //(1, 0, X)\n      recover(abort)\n      X = X\n      T = abort\n      Yes (0.01s cpu)\n\n      % Executing a recovery action AND passing the exception on:\n      ?- catch(throw(hello), T, (writeln(caught(T)), throw(T))).\n      caught(hello)\n      uncaught exception in throw(hello)\n      Abort\n\nSee Also\n   throw / 1, abort / 0"},"fail/0":{"prefix":"fail","body":"fail","description":"fail\n\n   Does not succeed.  A synonym of false/0.\n\nArguments\n\nType\n   Control\n\nDescription\n   Does not succeed.\n\nModes and Determinism\n   fail is failure\n\nFail Conditions\n   Always fails\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       not1(Goal) :- call(Goal),!,fail.\n       not1(_).\n       user compiled 208 bytes in 0.02 seconds\n      [eclipse]: not1(true).\n      no.\n      [eclipse]: not1(fail).\n      yes.\n\nFail:\n     fail.\n\nSee Also\n   true / 0, false / 0"},"false/0":{"prefix":"false","body":"false","description":"false\n\n   Does not succeed (synonym of fail/0).\n\nArguments\n\nType\n   Control\n\nDescription\n   Does not succeed.\n\nModes and Determinism\n   false is failure\n\nFail Conditions\n   Always fails\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       not1(Goal) :- call(Goal), !, false.\n       not1(_).\n       user compiled 208 bytes in 0.02 seconds\n      [eclipse]: not1(true).\n      no.\n      [eclipse]: not1(fail).\n      yes.\n      [eclipse]: not1(false).\n      yes.\n\nFail:\n      false.\n\nSee Also\n   fail / 0"},"exit_block/1":{"prefix":"exit_block","body":"exit_block(${1:Ball})$2\n$0","description":"exit_block(+Ball)\n\n   Throw an exception described by Ball. Continue execution\nat the recovery procedure of a matching ancestestor catch/3 or block/3\n\nArguments\n   Ball    Any term, but no variable\n\nType\n   Control\n\nDescription\nThis is a deprecated alias for throw/1 - see there.\n\nModes and Determinism\n   exit_block(+) is erroneous\n\nExceptions\n     4 --- Ball is uninstantiated.\n   230 --- Ball does not unify with a Catcher of any uncompleted call of catch/3 or block/3.\n\nSee Also\n   throw / 1, catch / 3, block / 3"},"fork/2":{"prefix":"fork","body":"fork(${1:Max}, ${2:I})$3\n$0","description":"fork(+Max, -I)\n\n   Succeeds for all integers I between 1 and Max.  The solutions are generated\nin parallel.\n\nArguments\n   Max    Integer\n   I    Variable or Integer\n\nType\n   Control\n\nDescription\n   Generates in parallel the integers between 1 and a given maximum Max.\n   The order of solutions is unspecified.  For every value of Max, this\n   predicate behaves as if defined by\n\n   :- parallel fork/2.\n   fork(Max, Max).\n   ...\n   fork(Max, 2).\n   fork(Max, 1).\n\n   Operationally, the advantage of fork/2 compared to a recursive\n   definition like\n\n   :- parallel bfork/2.\n   bfork(Max, Max).\n   bfork(Max, I) :- Max>1, Max1 is Max-1, bfork(Max1, I).\n\n   is that fork/2 creates only a single wide choice point instead of Max\n   binary ones.  This improves efficiency, especially for parallel\n   execution.\n\nModes and Determinism\n   fork(+, -) is nondet\n\nFail Conditions\n   Fails if Max is less than 1\n\nExceptions\n     4 --- Max is not instantiated.\n     5 --- Max is not an integer.\n\nExamples\n   \n% peclipse -w 3\n[eclipse 1]: fork(5,X), get_flag(worker, W).\nX = 5\nW = 1     More? (;)\nX = 3\nW = 3     More? (;)\nX = 4\nW = 2     More? (;)\nX = 2\nW = 1     More? (;)\nX = 1\nW = 3     More? (;)\nno (more) solution.\n\nSee Also\n   between / 4, parallel / 1, repeat / 0, get_flag / 2"},"not/1":{"prefix":"not","body":"not","description":"not +Goal\n\n   Succeeds if Goal cannot be satisfied (uses negation as failure).\n\nArguments\n   Goal    Atom or compound term.\n\nType\n   Control\n\nDescription\n   Used to fail if Goal succeeds.  Uses the standard Prolog form of\n   negation as failure.\n\n   To check whether a call Goal succeeds without binding variables, the\n   call not not Goal can be used.  Note that !/0 does not cut through\n   not/1.\n\nModes and Determinism\n   not(+) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal succeeds\n\nExamples\n   \nSuccess:\n      not fail .\n      not 1 == 2 .\n      not X==1 .\n      not not X = 1.\n    % does not bind X\nFail:\n      not(X=1).\n      not(true).\n      not(3 == 3).\n\nSee Also\n   \\+ / 1, ~ / 1, -> / 2"},"phrase/2":{"prefix":"phrase","body":"phrase(${1:Grammar}, ${2:List})$3\n$0","description":"phrase(+Grammar, ?List)\n\n   Succeeds if List unifies with a list from the specified grammar Grammar.\n\nArguments\n   Grammar    Compound term or Atom.\n   List    List of grammar terminals (prolog terms).\n\nType\n   Control\n\nDescription\n   phrase/2 can be use as a recognizer or as a generator of grammars.  As a\n   recognizer, it succeeds or fails if term belongs or not to the specified\n   grammar Grammar.  As a generator, it generates on backtracking all the\n   elements of the grammar.\n\n   A grammar is specified by setting the flag macro_expansion to on and by\n   compiling clauses using the DCG operator -->.\n\nModes and Determinism\n   phrase(+, ++) is semidet\n   phrase(+, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   List does not belong to Grammar\n\nResatisfiable\n   Depends on the particular grammar\n\nExceptions\n     4 --- Grammar is not instantiated.\n     5 --- Grammar is a number or a string (i.e.  not a valid DCG    head).\n\nExamples\n   \n   [eclipse]: sh('cat gram.pl').\n   sentence --> noun_phrase, verb_phrase.\n   noun_phrase --> article, noun.\n   verb_phrase --> verb | verb, noun_phrase.\n   article --> [the].\n   noun --> [compiler].\n   noun --> [program].\n   verb --> [compiles].\n   yes.\n   [eclipse]: [gram].\n   /home/user/gram.pl    compiled 732 bytes in 0.37 seconds\n   yes.\n   [eclipse]: phrase(sentence,[the,compiler,compiles]).\n   yes.\n   [eclipse]: phrase(sentence,[the,compiler,compiles,the,program]).\n   yes.\n   [eclipse]: phrase(sentence, X).\n\n   X = [the, compiler, compiles]     More? (;)\n\n   X = [the, compiler, compiles, the, compiler]     More? (;)\n\n   X = [the, compiler, compiles, the, program]     More? (;)\n\n   X = [the, program, compiles]     More? (;)\n\n   X = [the, program, compiles, the, compiler]     More? (;)\n\n   X = [the, program, compiles, the, program]\n   yes.\n   [eclipse]:\n\nFail:\n   phrase(sentence, [not, a, sentence]).\n\nError:\n   phrase(X, [what, time, is, it]).    (Error 4).\n   phrase(\"sentence\", X).    (Error 5).\n   phrase(123, X).    (Error 5).\n\nSee Also\n   phrase / 3, current_macro / 4, macro / 3, erase_macro / 2"},"mutex_init/1":{"prefix":"mutex_init","body":"mutex_init(${1:MutexId})$2\n$0","description":"mutex_init(+MutexId)\n\n   Initialise the mutual exclusion lock MutexId\n\nArguments\n   MutexId    Atom.\n\nType\n   Control\n\nDescription\n   This built-in is used in parallel programs in connection with mutex/2\n   to implement mutual exclusion between parallel workers.\n    \n\nModes and Determinism\n   mutex_init(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- MutexId is not instantiated\n     5 --- MutexId is not an atom\n\nSee Also\n   mutex / 2"},"throw/1":{"prefix":"throw","body":"throw(${1:Ball})$2\n$0","description":"throw(+Ball)\n\n   Throw an exception described by Ball. Continue execution\nat the recovery procedure of a matching ancestestor catch/3\n\nArguments\n   Ball    Any term, but no variable\n\nType\n   Control\n\nDescription\n   This predicate neither succeeds nor fails, but raises (or \"throws\")\n   an exception identified by the term Ball.  Execution will then continue\n   with the Recovery goal of the innermost catch/3 ancestor that catches this\n   exception (i.e., whose second argument, the Catcher, unifies with Ball).\n\n   If the exception is not caught by any catch/3 in the user program, then\n   \n   in a development system with a toplevel, the exception will be caught\n       by the toplevel, reporting an 'uncaught exception' (230) error.\n   in a standalone ECLiPSe without toplevel (e.g. using the -e command\n       line option), the process will exit with exit code 2.\n   in an embeddded system, control will return to the host program\n       with a corresponding return code (PTHROW, EC_throw, etc).\n   \n\n   The term that is unified with the ancestor's Catcher is a copy of the \n   Ball, i.e. if it contains variables, these are not identical to the\n   original ones in Ball.\n\n   NOTE: block/3 is a deprecated alias for catch/3, and behaves identically.\n   exit_block/1 is a deprecated alias for throw/1, and behaves identically.\n\nModes and Determinism\n   throw(+) is erroneous\n\nExceptions\n     4 --- Ball is uninstantiated.\n   230 --- Ball does not unify with a Catcher of any uncompleted call of catch/3.\n\nExamples\n   \n      % A variable Catcher catches all throws\n      ?- catch(throw(hello), T, writeln(recover(T))).\n      recover(hello)\n      T = hello\n      Yes (0.00s cpu)\n\n      % An instantiated Catcher catches only matching throws\n      ?- catch(throw(hello), hello, writeln(recovered)).\n      recovered\n      Yes (0.00s cpu)\n\n      ?- catch(throw(hello), world, writeln(recovered)).\n      uncaught exception in throw(hello)\n      Abort\n\n      % A partially instantiated Catcher catches only matching throws\n      ?- catch(throw(hello(world)), hello(Who), writeln(recovered(Who))).\n      recovered(world)\n      Yes (0.00s cpu)\n\n      ?- catch(throw(hi(world)), hello(Who), writeln(recovered(Who))).\n      uncaught exception in throw(hi(world))\n      Yes (0.00s cpu)\n\n      % The caught term is a copy of the thrown term (fresh variables)\n      ?- T1=f(X), catch(throw(T1), T2, true), variant(T1, T2), T1\\==T2.\n      T1 = f(X_88)\n      T2 = f(X_510)\n      Yes (0.00s cpu)\n\nError:\n      throw(_).    (Error 4).\n      throw(never_caught).     (Error 230).\n\nSee Also\n   catch / 3"},"true/0":{"prefix":"true","body":"true","description":"true\n\n   Succeeds always.\n\nArguments\n\nType\n   Control\n\nDescription\n   Succeeds.  For example, can be used as a default, to join the `then'\n   path in ->/2 to the `if' path, or as a void event handler.\n\nModes and Determinism\n   true is det\n\nExamples\n   \nSuccess:\n      (F \\== \"d.error\" ->\n    writeln(error, \"Incorrect file \"),\n    writeln( error,F)\n      ;\n    true\n      ),\n      (L < 0 ->\n    writeln(error, \"Error in line number\")\n      ;\n    true\n      ).\n\nSee Also\n   fail / 0, false / 0"},"repeat/0":{"prefix":"repeat","body":"repeat","description":"repeat\n\n   Succeeds as often as tried.\n\nArguments\n\nType\n   Control\n\nDescription\n   Used to succeed as often as tried.\n\n   This predicate could be defined as\n\n   repeat.\n   repeat :- repeat.\n\n   repeat/0 succeeds when reached on backtracking.\n\n   !/0 may be added to exit from a clause containing repeat/0, as it\n   removes all choice points above it in the clause.\n\nModes and Determinism\n   repeat is multi\n\nExamples\n   \nSuccess:\n      [eclipse]: [p].\n      /home/user/p compiled 408 bytes in 0.03 seconds\n      yes.\n      [eclipse]: print_file(p).\n      print_file(File) :-\n    open(File, read, S),\n    repeat,\n    get(S,Char),\n    put(Char),\n    at_eof(S),\n    !,\n    close(S),\n    flush(output).\n      yes.\n\nSee Also\n   ! / 0"},"debug/0":{"prefix":"debug","body":"debug","description":"debug\n\n   Execute subsequent top-level queries with the debugger on.\n\nArguments\n\nType\n   Debugging\n\nDescription\n   If the debugger is already on, no effect.  If not, the debugger\n   will be switched on at the next top-level query.  The debugger will\n   stay on until it is switched off with notrace/0.\n\n   The debugger will stop at the first traceable port.\n\n   This is not actually a predicate but a toplevel-command.\n\nModes and Determinism\n   debug is det\n\nExamples\n   \n[eclipse 1]: [user].\np :- true, writeln(hello).\nuser       compiled traceable 68 bytes in 0.00 seconds\n\nYes (0.01s cpu)\n\n[eclipse 2]: spy writeln/1.\nspypoint added to sepia_kernel:writeln/1.\nDebugger switched on - leap mode\nYes (0.00s cpu)\n\n[eclipse 3]: trace.\nDebugger switched on - creep mode\n\n[eclipse 4]: p.\n  (1) 1 CALL  p   %> creep\nS+(2) 2 CALL  writeln(hello)   %> creep\nhello\nS+(2) 2 EXIT  writeln(hello)   %> creep\n  (1) 1 EXIT  p   %> creep\nYes (0.00s cpu)\n\n[eclipse 5]: debug.\nDebugger switched on - leap mode\n\n[eclipse 9]: p.\nS+(2) 2 CALL  writeln(hello)   %> creep\nhello\nS+(2) 2 EXIT  writeln(hello)   %> creep\n  (1) 1 EXIT  p   %> creep\nYes (0.00s cpu)\n\nSee Also\n   notrace / 0, trace / 0, trace / 1, debug / 1"},"once/1":{"prefix":"once","body":"once","description":"once +Goal\n\n   Succeeds if Goal succeeds, and removes all its alternatives --- equivalent\nto call((Goal, !))\n\nArguments\n   Goal    Goal.\n\nType\n   Control\n\nDescription\n   Used to find a single solution for Goal, alternative solutions are\n   ignored (cut).\n\n   Note that !/0 does not cut through once/1.\n\nModes and Determinism\n   once(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is neither an atom nor a compound term.\n\nExamples\n   \nSuccess:\n      [eclipse]: once member(X, [1,2,3]).\n      X = 1       % only first solution is bound.\n      yes.\n\nFail:\n      [eclipse]: once 1=2.\n      no.\n\nError:\n      once Goal.    (Error 4).\n      once \"ls\".    (Error 5).\n      once 1.0.    (Error 5).\n\nSee Also\n   call / 1, -> / 2"},"debug_reset/0":{"prefix":"debug_reset","body":"debug_reset","description":"debug_reset\n\n   Reset the debugger\n\nType\n   Debugging\n\nDescription\n\n    Reset the debugger. In particular, this includes:\n    \n\treset invocation numbers so they start from 0 again\n\treset all filter conditions\n\traise the debug-init event (250) at the next trace/1, debug/1\n\t    or any predicate that has the start_tracing flag set.\n    \n    Note that debug_reset/0 just sets some parameters, it does not\n    activate the debugger immediately. This only happens when a trace/1,\n    debug/1, or predicate with the start_tracing flag is executed.\n    \n    The debugger cannot be reset while it is active. The predicate will\n    fail in this case.\n\nModes and Determinism\n   debug_reset is semidet\n\nFail Conditions\n   Debugger is active and cannot be reset at this time\n\nExamples\n   \n[eclipse]: trace(true), trace(true), debug_reset, trace(true). \n  (1) 1 CALL  true   %> creep\n  (1) 1 EXIT  true   %> creep\n  (3) 1 CALL  true   %> creep\n  (3) 1 EXIT  true   %> creep\n  (1) 1 CALL  true   %> creep\n  (1) 1 EXIT  true   %> creep\n\nSee Also\n   trace / 1, debug / 1"},"phrase/3":{"prefix":"phrase","body":"phrase(${1:Grammar}, ${2:Tokens}, ${3:Remainder})$4\n$0","description":"phrase(+Grammar, ?Tokens, ?Remainder)\n\n   Succeeds if Tokens can be parsed as part of the grammar defined in Grammar\nand Remainder contains any remaining terms in Tokens.\n\nArguments\n   Grammar    Compound Term or Atom.\n   Tokens    List of Prolog terms.\n   Remainder    List of Prolog terms.\n\nType\n   Control\n\nDescription\n   phrase/3 is used to parse grammars (DCGs) defined using the grammar rule\n   operator -->.  The flag macro_expansion must be set on when compiling\n   grammar rules.\n\n   Giving a list of terms in Tokens, phrase/3 parses it according to the\n   grammar defined in Grammar.  As the terms in Tokens are parsed in order,\n   any remaining terms are returned in Remainder.  Further acceptable\n   solutions are returned on backtracking.\n\nModes and Determinism\n   phrase(+, -, -) is nondet\n   phrase(+, +, -) is nondet\n   phrase(+, +, +) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The initial terms in Tokens do not belong to Grammar\n\nResatisfiable\n   Depends on the grammar\n\nExceptions\n     4 --- Grammar is not instantiated.\n     5 --- Grammar is a number or a string.\n\nExamples\n   \n   [eclipse]: [user].\n    a --> [].\n    a --> [z],a.\n    user compiled 212 bytes in 0.03 seconds\n   yes.\n   [eclipse]: phrase(a,[z,z],[]).\n\n   yes.\n   [eclipse]: phrase(a,[z,z,z,y],[z,y]).\n\n   yes.\n   [eclipse]: phrase(a,[z,z,y],R).\n\n   R = [z, z, y]     More? (;)\n\n   R = [z, y]     More? (;)\n\n   R = [y]     More? (;)\n\n   no (more) solution.\n   [eclipse]: phrase(a,X,[y]).\n\n   X = [y]     More? (;)\n\n   X = [z, y]     More? (;)\n\n   X = [z, z, y]     More? (;)\n\n   X = [z, z, z, y]     More? (;)\n\n   X = [z, z, z, z, y]     More? (;)\n   yes.\n   [eclipse]:\n\nFail:\n   phrase(a, [z, z, y], []).\n\nError:\n   phrase(X, [what, time, is, it], [is, it],R).  (Error 4).\n   phrase(\"a\", X,R).    (Error 5).\n   phrase(456, X,R).    (Error 5).\n\nSee Also\n   phrase / 2, current_macro / 4, macro / 3, erase_macro / 2"},"debugging/0":{"prefix":"debugging","body":"debugging","description":"debugging\n\n   Prints summary information about the debugger state\n\nArguments\n\nType\n   Debugging\n\nDescription\n   Prints the information about the tracing mode:  whether it is off,\n   in creep or in leap mode.\n   It then lists all procedures with a spypoint set, and then all breakpoints.\n   The information is printed to the log_output stream.\n\nModes and Determinism\n   debugging is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n[eclipse 1]: debugging.\nDebugger is switched off\nyes.\n\n[eclipse 2]: trace.\nDebugger switched on - creep mode\n\n[eclipse 3]: trace.\nDebugger switched on - creep mode\n\n[eclipse 4]: spy writeln/1.\nspypoint added to writeln / 1.\nyes.\n\n[eclipse 6]: debugging.\nDebug mode is debug\nwriteln/1    is being spied\nyes.\n\nSee Also\n   spy / 1, trace / 0, debug / 0, notrace / 0"},"mutex/2":{"prefix":"mutex","body":"mutex(${1:MutexId}, ${2:Goal})$3\n$0","description":"mutex(+MutexId, +Goal)\n\n   Equivalent to once(Goal) but with mutual exclusion among parallel workers.\n\nArguments\n   MutexId    Atom.\n   Goal    Atom or compound term.\n\nType\n   Control\n\nDescription\n   This built-in can be used in parallel programs to implement mutual\n   exclusion between parallel workers.  A Goal that is called via mutex/2\n   can be sure that no parallel worker is executing at the same time any\n   goal that is protected by a mutex/2 with the same MutexId.\n\n   Note that in a side effect free program there is no need ever to worry\n   about mutual exclusion.  Only when side effects are involved (e.g.\n   read/1,2 and write/1,2, assert/1, setval/2, record/2 etc.)  it may be\n   necessary to acquire exclusive access to the common resource by using\n   mutex/2.\n\nModes and Determinism\n   mutex(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is not an atom or a compound term.\n\nExamples\n   \n    :- mutex_init(my_lock).\n\n    atomic_write_list(List) :-\n    % make sure the list is printed in one chunk\n    mutex(my_lock, write_list(List)).\n\n    write_list([]) :- nl.\n    write_list([X|Xs]) :- writeln(X), write_list(Xs).\n\n    [eclipse]: generate_lists_in_parallel(L),\n    atomic_write_list(L), fail.\n\nSee Also\n   mutex_init / 1, once / 1"},"debug/1":{"prefix":"debug","body":"debug(${1:Goal})$2\n$0","description":"debug(+Goal)\n\n   Execute the goal Goal with the debugger in leap mode.\n\nArguments\n   Goal    Atom or compound term.\n\nType\n   Debugging\n\nDescription\n   The goal Goal is called with the debugger in leap mode.\n   debug/1 succeeds or fails depending if Goal succeeds or fails.\n\n   This predicate is particularly useful for debugging large programs that\n   would take too much space or time to run completely with the debugger.\n   The debugger is only switched on in leap mode at the call port of Goal\n   and switched off when Goal exits (or fails, leaves,...).\n\n   If the debugger was already on before calling debug/1, it has no effect.\n\n   An alternative way of turning on the debugger selectively is to\n   set the start_tracing property of a particular predicate using\n   set_flag/3.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisifable if Goal is resatisfiable\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       p :- big_goal1, debug(buggy_goal), big_goal2.\n       big_goal1.\n       big_goal2.\n       buggy_goal.\n       user    compiled 208 bytes in 0.02 seconds\n      yes.\n      [eclipse]: set_flag(big_goal2/0, spy, on),\n    set_flag(buggy_goal/0, spy, on).\n      yes.\n      [eclipse]: p.\n      Start debugging - leap mode\n       +(1) 0  CALL   buggy_goal %> creep\n       +(1) 0  EXIT   buggy_goal %> creep\n      Stop debugging.\n      yes.\n\nSee Also\n   debug / 0, notrace / 0, trace / 0, trace / 1, set_flag / 3"},"get_leash/2":{"prefix":"get_leash","body":"get_leash(${1:Port}, ${2:Leash})$3\n$0","description":"get_leash(?Port, -Leash)\n\n   Currently not supported.\n\nArguments\n   Port    Atom or variable.\n   Leash    Atom or variable.\n\nType\n   Debugging\n\nDescription\n   Unifies Leash with the leashing mode of the port or ports specified by\n   Port.  Currently not supported.\n\nModes and Determinism\n   get_leash(+, -) is det\n   get_leash(-, -) is multi\n\nExceptions\n     5 --- Port is instantiated, but not to an atom.\n     5 --- Port is instantiated to an atom, but not to one of the valid    ports.\n     5 --- Leash is instantiated, but not to an atom.\n\nExamples\n   \n\nSee Also\n   set_leash / 2, get_flag / 3, set_flag / 3"},"kill_display_matrix/1":{"prefix":"kill_display_matrix","body":"kill_display_matrix(${1:Name})$2\n$0","description":"kill_display_matrix(+Name)\n\n      Destroys an existing display matrix. \n\nArguments\n   Name    An atomic term.\n\nType\n   Debugging\n\nDescription\n   Destroys an existing display matrix. The display matrix is removed\n   from being displayed. This command can only kill a display matrix within\n   the `logical scope' of the display matrix, i.e. within the part of the\n   search-tree rooted at the node where the display matrix was created.\n   The display matrix window may persist beyond the logical scope, and in\n   such cases the window can only be killed on the GUI side. Normally, \n   the matrix is removed on backtracking pass its point of creation, but\n   this may not occur due to cuts.\n\n   Name is mapped into a string internally, so a name that is a atom or\n   number is the same name as its equivalent string (i.e. 'matrix' and\n   \"matrix\" are the same name).  Note that display matrix names are local\n   to a module, so it should be killed in the module in which it was\n   created (perhaps with @/2 wrapper around the call).\n\nModes and Determinism\n   kill_display_matrix(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Name is not an atomic term.\n     6 --- Name is not an existing display matrix.\n\nExamples\n   \n   kill_display_matrix(queens).\n\nSee Also\n   make_display_matrix / 5, make_display_matrix / 2, @ / 2"},"nodebug/0":{"prefix":"nodebug","body":"nodebug","description":"nodebug\n\n   Switch the debugger off for subsequent top-level queries.\n\nArguments\n\nType\n   Debugging\n\nDescription\n   Used to switch tracing mode off (the default).  This disables printing\n   of any trace information. A synonym for notrace/0.\n\nModes and Determinism\n   nodebug is det\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       w(X) :- writeln(X).\n       user compiled 44 bytes in 0.00 seconds\n      yes.\n      [eclipse]: trace.\n      yes.\n      Debugger switched on - creep mode\n      [eclipse]: w(X = 2).\n    (1) 0  CALL   w(_g54 = 2) (dbg)?- creep     % type c\n      B (2) 1  CALL   writeln(_g54 = 2) (dbg)?- creep\n      _g54 = 2\n      B (2) 1  EXIT   writeln(_g54 = 2) (dbg)?- creep\n    (1) 0  EXIT   w(_g54 = 2) (dbg)?- creep\n      X = _g54\n      yes.\n      [eclipse]: nodebug.\n      Debugger switched off\n      yes.\n      [eclipse]: w(X = 2).\n      _g54 = 2\n      X = _g54\n      yes.\n\nSee Also\n   notrace / 0, trace / 0, trace / 1, debug / 0, debug / 1"},"notrace/0":{"prefix":"notrace","body":"notrace","description":"notrace\n\n   Switch the debugger off for subsequent top-level queries.\n\nArguments\n\nType\n   Debugging\n\nDescription\n   Used to switch tracing mode off (the default).  This disables printing\n   of any trace information.\n\nModes and Determinism\n   notrace is det\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       w(X) :- writeln(X).\n       user compiled 44 bytes in 0.00 seconds\n      yes.\n      [eclipse]: trace.\n      Debugger switched on - creep mode\n      yes.\n      [eclipse]: w(X = 2).\n    (1) 0  CALL   w(_g54 = 2) (dbg)?- creep      % type c\n      B (2) 1  CALL   writeln(_g54 = 2) (dbg)?- creep\n      _g54 = 2\n      B (2) 1  EXIT   writeln(_g54 = 2) (dbg)?- creep\n    (1) 0  EXIT   w(_g54 = 2) (dbg)?- creep\n      X = _g54\n      yes.\n      [eclipse]: notrace.\n      Debugger switched off\n      yes.\n      [eclipse]: w(X = 2).\n      _g54 = 2\n      X = _g54\n      yes.\n\nSee Also\n   nodebug / 0, trace / 0, trace / 1, debug / 0, debug / 1"},"make_display_matrix/5":{"prefix":"make_display_matrix","body":"make_display_matrix(${1:Terms}, ${2:Prio}, ${3:Type}, ${4:CondList}, ${5:Name})$6\n$0","description":"make_display_matrix(+Terms, +Prio, +Type, +CondList, +Name)\n\n      Creates a display matrix of terms that can be monitored with the \n   graphical ECLiPSe (the predicate will succeed silently in tty ECLiPSe).\n\nArguments\n   Terms    One or two dimensional array, or list or list/integer.\n   Prio    An integer.\n   Type    An atom.\n   CondList    An atom.\n   Name    An atomic term.\n\nType\n   Debugging\n\nDescription\n   Set up a one or two dimensional matrix of terms that can then be\n   monitored for changes in their values. The terms are either provided in\n   the form of an array (the nested structure type, compatible with dim/2),\n   or in the form +List/+Spec, where List is a list of the terms, and Spec\n   is an integer specifying the number of cells per row of the matrix, 0\n   means that the matrix is to have only one row (except if the members of\n   the list are matricies of the same size, in which case a two dimensional\n   matrix will be created).  If List is supplied without a Spec, this is\n   treated as Spec = 0.  Name specifies the name that is associated with\n   this display matrix, and cannot be used for another display matrix that\n   is active at the same time in the same module. The name is mapped into a\n   string internally, so a name that is a atom or number is the same name\n   as its equivalent string (i.e. 'matrix' and \"matrix\" are the same name).\n\n   The terms are monitored by placing a demon suspension on the variables\n   in each term. When a demon wakes, the new value of the term it is\n   associated with is sent to the display matrix (and possibly updated,\n   depending on the interactive settings on the matrix). When the new \n   value is backtracked, the old value is sent to the display matrix.\n   The other arguments in this predicate is used to control when the\n   demon wakes, and what sort of information is monitored. Prio is the\n   priority that the demon should be suspended at, Type is designed to\n   specify the attributes that is being monitored (currently all \n   attributes are monitored, and Type is a dummy argument), CondList is \n   the suspension list that the demon should be added to. Depending on\n   these arguments, the level of monitoring can be controlled. Note that\n   it is possible for the display matrix to show values that are out of\n   date because the change was not monitored. \n\n   The display matrix will be removed on backtracking. However, it will \n   not be removed if make_display_matrix has been cut. It is possible to\n   explicitly remove a matrix with kill_display_matrix/1.\n\n   Each cell of the display matrix represents one term. The value of the\n   term is displayed in the cell, and break-points can be set from a pop-up\n   menu so that execution suspends when an update occurs in a cell. The\n   term can also be inspected by the inspector. The actual current value of\n   the term will be examined, which may be different from the value shown\n   in the cell depending on how often the cell is updated. With breaks, the\n   changes due to forward execution (further constraining of a variable's\n   value) and backtracking are shown in different colours. Inspection is\n   not allowed on a term that has just been backtracked, because the actual\n   backtracking of the value have not yet occurred (the demon sends the old\n   value just before the actual backtracking). It can be examined at the\n   next break-point. The pop-up menu also shows the current displayed\n   value, and the previous displayed value for the cell.\n\nModes and Determinism\n   make_display_matrix(+, +, +, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n      No (but display matrix removed on backtracking).\t\t\n\nExceptions\n     5 --- Type errors in the various arguments.\n     6 --- Name has already been given to another display matrix that    is still active.\n\nExamples\n   \n   queens(N, List) :-\n       length(List, N),\n       List :: 1..N,\n       make_display_matrix(List/3, 1, any, constrained, queens),\n       % sets up a matrix with rows of 3 elements. This is the only\n       % extra goal that has to be added to enable monitoring\n       alldistinct(List),\n       constrain_queens(List),\n       % Label the variables\n       labeling(List).\n\nSee Also\n   make_display_matrix / 2, kill_display_matrix / 1, dim / 2"},"make_display_matrix/2":{"prefix":"make_display_matrix","body":"make_display_matrix(${1:Terms}, ${2:Name})$3\n$0","description":"make_display_matrix(+Terms, +Name)\n\n      Creates a display matrix of terms that can be monitored with the \n   graphical ECLiPSe (the predicate will succeed silently in tty ECLiPSe).\n\nArguments\n   Terms    One or two dimensional array, or List/integer.\n   Name    An atomic term.\n\nType\n   Debugging\n\nDescription\n   Set up a one or two dimensional matrix of terms that can then be\n   monitored for changes in their values. The terms are either provided in\n   the form of an array (the nested structure type, compatible with dim/2),\n   or in the form +List/+Spec, where List is a list of the terms, and Spec\n   is an integer specifying the number of cells per row of the matrix, 0\n   means that the matrix is to have only one row (except if the members of\n   the list are matricies of the same size, in which case a two dimensional\n   matrix will be created).  If List is supplied without a Spec, this is\n   treated as Spec = 0.  Name specifies the name that is associated with\n   this display matrix, and cannot be used for another display matrix that\n   is active at the same time in the same module. The name is mapped into a\n   string internally, so a name that is a atom or number is the same name\n   as its equivalent string (i.e. 'matrix' and \"matrix\" are the same name).\n\n   The terms are monitored by placing a demon suspension on the variables\n   in each term. When a demon wakes, the new value of the term it is\n   associated with is sent to the display matrix (and possibly updated,\n   depending on the interactive settings on the matrix). When the new \n   value is backtracked, the old value is sent to the display matrix.\n   This predicate sets default value for how the demon is suspended: it\n   is suspended with a priority of 1, and in the constrained suspension \n   list. This should enable it to monitor all changes unless the changes\n   were also effected by suspensions of priority 1.\n\n   The display matrix will be removed on backtracking. However, it will \n   not be removed if make_display_matrix has been cut. It is possible to\n   explicitly remove a matrix with kill_display_matrix/1.\n\n   Each cell of the display matrix represents one term. The value of the\n   term is displayed in the cell, and break-points can be set from a pop-up\n   menu so that execution suspends when an update occurs in a cell. The\n   term can also be inspected by the inspector. The actual current value of\n   the term will be examined, which may be different from the value shown\n   in the cell depending on how often the cell is updated. With breaks, the\n   changes due to forward execution (further constraining of a variable's\n   value) and backtracking are shown in different colours. Inspection is\n   not allowed on a term that has just been backtracked, because the actual\n   backtracking of the value have not yet occurred (the demon sends the old\n   value just before the actual backtracking). It can be examined at the\n   next break-point. The pop-up menu also shows the current displayed\n   value, and the previous displayed value for the cell.\n\nModes and Determinism\n   make_display_matrix(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n      No (but display matrix removed on backtracking).\t\t\n\nExceptions\n     5 --- Invalidly constructed Terms, or non-atomic Name.\n     6 --- Name has already been given to another display matrix that    is still active.\n\nExamples\n   \n   queens(N, List) :-\n       length(List, N),\n       List :: 1..N,\n       make_display_matrix(List/0, queens),\n       % sets up a matrix with all variables in 1 row. This is the only\n       % extra goal that has to be added to enable monitoring\n       alldistinct(List),\n       constrain_queens(List),\n       % Label the variables\n       labeling(List).\n\nSee Also\n   make_display_matrix / 5, kill_display_matrix / 1, dim / 2"},"nospy/1":{"prefix":"nospy","body":"nospy","description":"nospy ?Speclist\n\n   All spypoints or breakpoints are removed from all the procedures given by \nSpecList.  If SpecList is a variable, remove all spypoints.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer, Module:Atom/Integer, Module:Atom, Atom, File:Line or Variable.\n\nType\n   Debugging\n\nDescription\n   Removes spypoints or breakpoints from all procedures given by SpecList.\n\n   If SpecList is of the form Name or Module:Name, where Name is an atom, then \n   spypoints are removed from procedures from module Moudle (if given) with \n   name Name and of any arity.\n\n   If SpecList is of the form File:Line, where File is a file name and Line is\n   an integer, the the closest matching breakpoint to line Line in the file \n   File is removed. If Line is a variable, then all breakpoints in file File\n   are removed.\n  \n\n   If SpecList is a variable, all spypoints of visible procedures are\n   removed.\n\n   Note that spypoints can also be removed with set_flag(Proc, spy, off).\n\nModes and Determinism\n   nospy(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- SpecList is not in the correct form.\n    60 --- SpecList is an undefined procedure.\n\nExamples\n   \n\nSuccess:\n    [eclipse 1]: [user].\n     q.\n     p :- q, writeln(hi).\n     tty    compiled 132 bytes in 0.00 seconds\n\n    Yes (0.15s cpu)\n    [eclipse 2]: spy q.\n    spypoint added to q/0.\n    Debugger switched on - leap mode\n\n    Yes (0.00s cpu)\n    [eclipse 3]: p.\n\n     +(2) 2 CALL  q   %> leap\n     +(2) 2 EXIT  q   %> leap\n    hi\n\n    Yes (0.00s cpu)\n    [eclipse 4]: nospy q.\n    spypoint removed from q/0.\n\n    Yes (0.00s cpu)\n    [eclipse 5]: p.\n    hi\n\n    Yes (0.00s cpu)\n    [eclipse 6]: \n\nError:\n    nospy(\"l\").       (Error 5).\n\nSee Also\n   spy / 1, get_flag / 3, set_flag / 3"},"set_leash/2":{"prefix":"set_leash","body":"set_leash(${1:Ports}, ${2:Leash})$3\n$0","description":"set_leash(?Ports, +Leash)\n\n   Currently not supported.\n\nArguments\n   Ports    Atom, list of atoms, or variable.\n   Leash    Atom.\n\nType\n   Debugging\n\nDescription\n   Sets the port specified by Port to the leash mode Leash.\n   Currently not supported.\n\nModes and Determinism\n   set_leash(?, +) is det\n\nExceptions\n     4 --- Leash is not instantiated.\n     5 --- Ports is instantiated, but not to an atom or a list of    atoms.\n     5 --- Ports is instantiated to an atom or list of atoms, but the    atoms are not all valid ports.\n     5 --- Leash is instantiated, but not to an atom.\n     5 --- Ports is instantiated to an atom, but not to one of the    leashing modes.\n\nExamples\n   \n\nSee Also\n   get_leash / 2"},"spy/1":{"prefix":"spy","body":"spy","description":"spy +SpecList\n\n   Sets a spypoint for the procedure(s) in SpecList.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer, Module:Atom/Integer, Atom or File:Line\n\nType\n   Debugging\n\nDescription\n\n   This predicate sets spypoints on all the procedures given by SpecList,\n   or sets a breakpoint on a call in a specific source line. \n\n   For setting spypoints, the procedure(s) are all of the form name/arity,\n   or else of the form name, in which case all procedures with name name\n   and any arity have spy points set.\n\n   For setting a breakpoint, SpecList should be of the form File:Line, where\n   File is the name of a source file (atom/string) whose code is already\n   loaded into ECLiPSe, and Line is an integer that specifies a line number\n   in the file.  Breakpoints can only be set in procedures that have been\n   compiled in debug mode.  A breakpoint will be added to the subgoal call\n   that most closely matches the line number Line, i.e. the subgoal call\n   is either on, or close to, line Line in File.\n\n   If not already debugging, the trace mode is switched on and set to leap.\n\n   When tracing, a leap command to the debugger will cause execution to\n   continue until it reaches a spied predicate.  Setting a spy-point on a\n   non-existing procedure results in an error.\n\n   Note that spypoints can also be set using set_flag(Proc, spy, on).\n\nModes and Determinism\n   spy(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is not of the correct form\n     6 --- SpecList in the form File:Line did not correspond to a source file or breakpoint\n    60 --- SpecList contains an undefined procedure.\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       lower:-writeln(hi).\n       higher:-lower.\n       user    compiled 84 bytes in 0.00 seconds\n      yes.\n      [eclipse]: spy higher,writeln.\n      spypoint added to higher / 0.\n      spypoint added to writeln / 1.\n      spypoint added to writeln / 2.\n      yes.\n      [eclipse]: higher.\n       +(1) 0  CALL   higher (dbg)?- leap\n       B+(3) 2  CALL   writeln(hi) (dbg)?- leap\n       hi\n       B+(3) 2  EXIT   writeln(hi) (dbg)?- leap\n    +(1) 0  EXIT   higher (dbg)?- leap\n       yes.\nError:\n      spy(I).    (Error 4).\n      spy(\"l\").       (Error 5).\n      spy(foo).       (Error 60).\n\nSee Also\n   nospy / 1, get_flag / 3, set_flag / 3"},"skipped/1":{"prefix":"skipped","body":"skipped","description":"skipped +SpecList\n\n   Declares all the procedures given in SpecList as skipped.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer.\n\nType\n   Debugging\n\nDescription\n   Sets all the procedures given by SpecList in skipped mode.  Marking a\n   predicate as skipped will prevent any information about its subgoals\n   being displayed by the debugger.\n\n   The procedures are all of the form name/arity, or else of the form name,\n   in which case all procedures with name name are skipped.\n\n   Note that skipped/1 is superseded by the predicate call set_flag(Proc,\n   skip, on), which declares the procedure Proc as skipped.\n\nModes and Determinism\n   skipped(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but is not of the form atom or    Atom/Integer.\n    60 --- SpecList is not a defined procedure.\n\nExamples\n   \nSuccess:\n      [eclipse]: [user], skipped p/0.\n       q.   p :- q.\n       user compiled 60 bytes in 0.02 seconds\n      yes.\n      [eclipse]: trace.\n      Debugger switched on - creep mode\n      yes.\n      [eclipse]: p.\n      S (1) 0  CALL   p (dbg)?- creep\n      S (1) 0  EXIT   p (dbg)?- creep  % information on\n      yes.    % q not printed.\nError:\n      skipped Proc/1.    (Error 4).\n      skipped write(Term)/1.    (Error 5).\n      skipped do.    (Error 5).\n      skipped n/1.    (Error 60).\n\nSee Also\n   unskipped / 1, get_flag / 3, set_flag / 3"},"trace/0":{"prefix":"trace","body":"trace","description":"trace\n\n   Execute subsequent top-level queries with the debugger on.\n\nArguments\n\nType\n   Debugging\n\nDescription\n   If the debugger is already on, no effect.  If not, the debugger\n   will be switched on at the next top-level query.  The debugger will\n   stay on until it is switched off with notrace/0.\n\n   The debugger will stop at the first traceable port.\n\n   This is not actually a predicate but a toplevel-command.\n\nModes and Determinism\n   trace is det\n\nExamples\n   \n[eclipse 1]: [user].\np :- true, writeln(hello).\nuser       compiled traceable 68 bytes in 0.00 seconds\n\nyes.\n[eclipse 2]: trace.\nDebugger switched on - creep mode\n[eclipse 3]: p.\n  (1) 1 CALL  p   %> creep\nS (2) 2 CALL  writeln(hello)   %> creep\nhello\nS (2) 2 EXIT  writeln(hello)   %> creep\n  (1) 1 EXIT  p   %> creep\n\nyes.\n\nSee Also\n   debug / 0, debug / 1, notrace / 0, trace / 1"},"spy_var/1":{"prefix":"spy_var","body":"spy_var(${1:Var})$2\n$0","description":"spy_var(?Var)\n\n   Create a SPYTERM-port in the debugger and prepare for tracing\nmodifications to Var as MODIFY-ports.\n\nArguments\n   Var    A variable, possibly attributed.\n\nType\n   Debugging\n\nDescription\n    This predicate allows to trace modifications to the variable Var.\n\n    When the debugger is on, this predicate causes a SPYTERM-port to\n    be displayed.  In the subsequent execution, any variable\n    modification in Var will be shown as a MODIFY-port.  The SPYTERM\n    and MODIFY-port have the same unique invocation number, therefore\n    the invocation-skip command (i) can be used to follow the chain of\n    modifications.\n\n    This is equivalent to\n\n    spy_term(Var, Var->(constrained of suspend))\n\n    \n    This feature is implemented using high-priority (1) delayed goals\n    which create the MODIFY-ports.  These goals are visible to the\n    user as monitor_term/4 goals among the delayed goals.\n\nModes and Determinism\n   spy_var(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n[eclipse 1]: lib(fd).\nyes.\n\n[eclipse 1]: trace.\nDebugger switched on - creep mode\n\n[eclipse 3]: [X, Y] :: 1..9, spy_var(X), X #> Y, Y #> X.\n  (1) 1 CALL  [X, Y] :: 1..9   %> creep\n  (1) 1 EXIT  [X{[1..9]}, Y{[1..9]}] :: 1..9   %> creep\n  (3) 2 SPYTERM  X{[1..9]}   %> jump to invoc: [3]? \n  (3) 3 MODIFY  X{[2..9]}   %> jump to invoc: [3]? \n  (3) 4 MODIFY  X{[4..7]}   %> jump to invoc: [3]? \n\nno (more) solution.\n\nSee Also\n   suspend / 3, spy_term / 2, trace_point_port / 3, trace / 1"},"spy_term/2":{"prefix":"spy_term","body":"spy_term(${1:Term}, ${2:Cond})$3\n$0","description":"spy_term(?Term, ++Cond)\n\n   Create a SPYTERM-port in the debugger and prepare for tracing\nmodifications to Term as MODIFY-ports.\n\nArguments\n   Term    A variable or any term containing variables.\n   Cond    A trigger condition (as in suspend/3).\n\nType\n   Debugging\n\nDescription\n    This predicate allows to trace modifications to variables in Term.\n\n    When the debugger is on, this predicate causes a SPYTERM-port\n    to be displayed. In the subsequent execution, any variable\n    modification in Term which satisfies the trigger condition Cond\n    will be shown as a MODIFY-port. The SPYTERM and MODIFY-port have\n    the same unique invocation number, therefore the invocation-skip\n    command (i) can be used to follow the chain of modifications.\n\n    The  trigger conditions are specified in the same way as in the\n    suspend/3 built-in.\n    \n    This feature is implemented using high-priority (1) delayed goals\n    which create the MODIFY-ports.  These goals are visible to the\n    user as monitor_term/4 goals among the delayed goals.\n\n    CAUTION: Term is interpreted by the debugger as a goal. If Term\n    looks like a call of a visible predicate, this predicate's settings\n    (spy, traceable, etc) are taken into account for the SPYTERM and\n    MODIFY ports as well. In particular, don't use a list for Term,\n    since that looks like the compile-built-in ./2 which is untraceable.\n\nModes and Determinism\n   spy_term(?, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     6 --- Not a valid trigger condition.\n\nExamples\n   \n[eclipse 1]: lib(fd).\nyes.\n\n[eclipse 1]: trace.\nDebugger switched on - creep mode\n\n[eclipse 3]: [X, Y] :: 1..9,\n\t     spy_term(v(X,Y), v(X,Y)->any),\n\t     X #> Y, Y #> X.\n  (1) 1 CALL  [X, Y] :: 1..9   %> creep\n  (1) 1 EXIT  [X{[... .. ...]}, Y{[...]}] :: 1..9   %> creep\n  (3) 2 SPYTERM  v(X{[1..9]}, Y{[1..9]})   %> jump to invoc: [3]? \n  (3) 3 MODIFY  v(X{[2..9]}, Y{[1..8]})   %> jump to invoc: [3]? \n  (3) 3 MODIFY  v(X{[2..7]}, Y{[3..8]})   %> jump to invoc: [3]? \n  (3) 4 MODIFY  v(X{[4..7]}, Y{[3..6]})   %> jump to invoc: [3]? \n  (3) 4 MODIFY  v(X{[4, 5]}, Y{[5, 6]})   %> jump to invoc: [3]? \n\nno (more) solution.\n\nSee Also\n   suspend / 3, spy_var / 1, trace_point_port / 3, trace / 1"},"trace_exit_port/0":{"prefix":"trace_exit_port","body":"trace_exit_port","description":"trace_exit_port\n\n   Create an exit-port for the current procedure box.\n\nType\n   Debugging\n\nDescription\n\n    This predicate allows to generate a user-defined debugger port,\n    thus enhancing the debugger's basic box model with application-\n    specific checkpoints. In the box model, the execution is viewed as\n    consisting of nested boxes, which are being entered via CALL or\n    REDO ports, and left via EXIT, FAIL or LEAVE ports.\n\n    When the debugger is on, this predicate causes the current innermost\n    box to be exited. This should be a box created previously by the\n    trace_call_port/3 builtin, otherwise the debugger's box\n    nesting will get out of sync.\n\nModes and Determinism\n   trace_exit_port is det\n\nExamples\n   \n    search(Vars) :-\n\ttrace_call_port(search_enter, _Invoc, search(Vars)),  \n\tlabeling(Vars),\n\ttrace_exit_port.\n\n?- length(L, 3), L :: 1..4, search(L).\n  (1) 1 CALL  length(L, 3)   %> zap to port: [~ call] search_enter\n  (6) 2 SEARCH_ENTER  search([_501{[... .. ...]}, _514{[...]}, _527{...}])   %> skip\n  (6) 2 *EXIT  search([1, 1, 1])   %> skip\n\nSee Also\n   trace_call_port / 3, trace_point_port / 3, trace_parent_port / 1, spy_term / 2, spy_var / 1, trace / 1"},"trace/1":{"prefix":"trace","body":"trace(${1:Goal})$2\n$0","description":"trace(+Goal)\n\n   Execute the goal Goal with the debugger in creep mode.\n\nArguments\n   Goal    Atom or compound term.\n\nType\n   Debugging\n\nDescription\n   The goal Goal is called with the debugger in creep mode.\n   trace/1 succeeds or fails depending if Goal succeeds or fails.\n\n   This predicate is particularly useful for debugging large programs that\n   would take too much space or time to run completely with the debugger.\n   The debugger is only switched on in creep mode at the call port of Goal\n   and switched off when Goal exits (or fails, leaves,...).\n\n   If the debugger was already on before calling trace/1, it has\n   no effect.\n\n   An alternative way of turning on the debugger selectively is to\n   set the start_tracing property of a particular predicate using\n   set_flag/3.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisifable if Goal is resatisfiable\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       p :- big_goal1, trace(buggy_goal), big_goal2.\n       big_goal1.\n       big_goal2.\n       buggy_goal.\n       user    compiled 208 bytes in 0.02 seconds\n      yes.\n      [eclipse]: p.\n    % big_goal1/0 is executed without the debugger\n      Start debugging - creep mode\n    (1) 0  CALL   buggy_goal %> creep\n    (1) 0  EXIT   buggy_goal %> creep\n      Stop debugging.\n    % big_goal2/0 is executed without the debugger\n      yes.\n\nSee Also\n   notrace / 0, trace / 0, debug / 0, debug / 1, set_flag / 3"},"trace_point_port/3":{"prefix":"trace_point_port","body":"trace_point_port(${1:Port}, ${2:Invoc}, ${3:Term})$4\n$0","description":"trace_point_port(+Port, ?Invoc, ?Term)\n\n   Create a user-defined debugger port.\n\nArguments\n   Port    An atom.\n   Invoc    An integer or variable.\n   Term    Any term.\n\nType\n   Debugging\n\nDescription\n\n    This predicate allows to generate user-defined debugger ports,\n    thus enhancing the debugger's basic box model with application-\n    specific checkpoints.\n\n    When the debugger is on, this predicate causes a trace line to\n    be displayed with Port being the name of the debugger port,\n    invocation number Invoc and Term in the goal position.\n\n    If Invoc is left uninstantiated, it will be instantiated to a\n    unique invocation number by the system, if it is an integer, it\n    will be used. This way, several ports can be made to share the\n    same invocation number, which makes it possible to easily i-skip\n    from one to the other.\n\nModes and Determinism\n   trace_point_port(+, +, ?) is det\n   trace_point_port(+, -, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    :- pragma(nodebug).\n    bool(B) :-\n\ttrace_point_port(try_zero, Invoc, B=0),  \n\t(\n\t    B=0\n\t;\n\t    trace_point_port(try_one, Invoc, B=1),\n\t    B=1\n\t).\n    :- untraceable bool/1.\n\n[eclipse 9]: bool(B).\n  (3) 3 TRY_ZERO  B = 0   %> creep\n\nB = 0     More? (;) \n  (3) 3 TRY_ONE  B = 1   %> creep\n\nB = 1\nyes.\n\nSee Also\n   trace_call_port / 3, trace_parent_port / 1, trace_exit_port / 0, spy_term / 2, spy_var / 1, trace / 1"},"else/0":{"prefix":"else","body":"else","description":"else\n\n   Conditional compilation directive.\n\nType\n   Directives\n\nDescription\nSee if/1 for details.\n\nModes and Determinism\n   else is det\n\nSee Also\n   if / 1, elif / 1, endif / 0"},"trace_call_port/3":{"prefix":"trace_call_port","body":"trace_call_port(${1:Port}, ${2:Invoc}, ${3:Term})$4\n$0","description":"trace_call_port(+Port, ?Invoc, ?Term)\n\n   Create a user-defined debugger port (CALL-style).\n\nArguments\n   Port    An atom.\n   Invoc    An integer or variable.\n   Term    Any term.\n\nType\n   Debugging\n\nDescription\n\n    This predicate allows to generate a user-defined debugger port,\n    thus enhancing the debugger's basic box model with application-\n    specific checkpoints. In the box model, the execution is viewed as\n    consisting of nested boxes, which are being entered via CALL or\n    REDO ports, and left via EXIT, FAIL or LEAVE ports.\n\n    When the debugger is on, this predicate causes a new box to be entered,\n    i.e. a trace line to be displayed with Port being the name of the port,\n    invocation number Invoc and Term in the goal position.\n\n    It is important to use a corresponding trace_exit_port/0 call after\n    every call to trace_call_port/3, otherwise the debugger's box\n    nesting will get out of sync. Note however, that fail ports for\n    the new box will be generated automatically.\n\n    If Invoc is left uninstantiated, it will be instantiated to a\n    unique invocation number by the system.\n\nModes and Determinism\n   trace_call_port(+, +, ?) is det\n   trace_call_port(+, -, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    search(Vars) :-\n\ttrace_call_port(search_enter, _Invoc, search(Vars)),  \n\tlabeling(Vars),\n\ttrace_exit_port.\n\n?- length(L, 3), L :: 1..4, search(L).\n  (1) 1 CALL  length(L, 3)   %> zap to port: [~ call] search_enter\n  (6) 2 SEARCH_ENTER  search([_501{[... .. ...]}, _514{[...]}, _527{...}])   %> skip\n  (6) 2 *EXIT  search([1, 1, 1])   %> skip\n\nSee Also\n   trace_point_port / 3, trace_parent_port / 1, trace_exit_port / 0, spy_term / 2, spy_var / 1, trace / 1"},"endif/0":{"prefix":"endif","body":"endif","description":"endif\n\n   Conditional compilation directive.\n\nType\n   Directives\n\nDescription\nSee if/1 for details.\n\nModes and Determinism\n   endif is det\n\nSee Also\n   if / 1, elif / 1, else / 0"},"untraceable/1":{"prefix":"untraceable","body":"untraceable","description":"untraceable +SpecList\n\n   Declares the procedure(s) in SpecList to be untraceable.\n\nArguments\n   SpecList    Sequence of expressions of the form name/arity.\n\nType\n   Debugging\n\nDescription\n   Sets all the procedures given by SpecList untraceable.  Marking a\n   predicate as untraceable will prevent any information about it being\n   displayed.  The subgoals of this predicate will be shown in their normal\n   way.\n\n   Note that untraceable/1 is superseded by the predicate set_flag(Proc,\n   leash, notrace), which declares the procedure Proc to be untraceable.\n\nModes and Determinism\n   untraceable(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is not of the form Atom/Integer.\n    60 --- SpecList is an undefined procedure.\n\nSee Also\n   get_flag / 3, set_flag / 3, traceable / 1"},"elif/1":{"prefix":"elif","body":"elif(${1:Goal})$2\n$0","description":"elif(+Goal)\n\n   Conditional compilation directive.\n\nArguments\n   Goal    Goal to be tested\n\nType\n   Directives\n\nDescription\nSee if/1 for details.\n\nModes and Determinism\n   elif(+) is det\n\nSee Also\n   if / 1, else / 0, endif / 0"},"trace_parent_port/1":{"prefix":"trace_parent_port","body":"trace_parent_port(${1:Port})$2\n$0","description":"trace_parent_port(+Port)\n\n   Create a user-defined debugger port for the parent box.\n\nArguments\n   Port    An atom.\n\nType\n   Debugging\n\nDescription\n\n    This predicate allows to generate a user-defined debugger port,\n    thus enhancing the debugger's basic box model with application-\n    specific checkpoints. In the box model, the execution is viewed as\n    consisting of nested boxes, which are being entered via CALL or\n    REDO ports, and left via EXIT, FAIL or LEAVE ports.\n\n    When the debugger is on, this predicate causes a trace line to\n    be displayed for the current innermost box, with Port being the\n    name of the port, and all other information being the current\n    box's ones.\n\nModes and Determinism\n   trace_parent_port(+) is det\n\nExamples\n   \n    p :-\n\ttrace_parent_port(clause1),  \n\twriteln(hello),\n\tfail.\n    p :-\n\ttrace_parent_port(clause2),  \n\twriteln(world).\n\n?- p.\n  (1) 1 CALL  p   %> creep\n  (1) 1 CLAUSE1  p   %> creep\nS (2) 2 CALL  writeln(hello)   %> creep\nhello\nS (2) 2 EXIT  writeln(hello)   %> creep\n  (3) 2 CALL  fail   %> creep\n  (3) 2 FAIL  fail   %> creep\n  (1) 1 NEXT  p   %> creep\n  (1) 1 CLAUSE2  p   %> creep\nS (4) 2 CALL  writeln(world)   %> creep\nworld\nS (4) 2 EXIT  writeln(world)   %> creep\n  (1) 1 EXIT  p   %> creep\n\nYes (0.00s cpu)\n\nSee Also\n   trace_call_port / 3, trace_point_port / 3, trace_exit_port / 0, spy_term / 2, spy_var / 1, trace / 1"},"comment/2":{"prefix":"comment","body":"comment(${1:Type}, ${2:Information})$3\n$0","description":"comment(++Type, +Information)\n\n   Adding documentational information to ECLiPSe files.\n\nArguments\n   Type    Comment type\n   Information    Information for Type\n\nType\n   Directives\n\nDescription\nThe comment/2 predicate allows documentational information to be added to\nECLiPSe modules which can then be extracted and processed automatically by\nusing the document tools in the document library.  Please note that any\nreference to `comment' in the rest of this description means the comment\npredicate, not the normal ECLiPSe comment (% and /* ... */).\n\nOperationally, comment/2 always succeeds, so it is a no-op and is\nignored by ECLiPSe when executed. In order to be processed by the\ndocument tools, it should appear as a directive in the program, i.e. as\n\n:- comment(Type, Information).\n\nA comment directive provides information on various aspects of the module\nin which the comment occurs. The Type argument specifies what the aspect\nis, and Information gives the information associated with that aspect. Some\nrestrictions should be observed to the placement of comments to allow automatic\nprocessing to correctly process the comments. These are listed at the end.\n\nThe documentation generation tools and the tkeclipse library browser tool\nmake use of the comments to generate documentations for modules. They\nrecognise several comment types as specified by the Type argument and\nextract the information accordingly.\nThe comments can occur in any order inside the module, and none\nare compulsory; if they are missing, then the information they could have\nprovided is simply not used in the documentation generation. Most comment\ntype should only occur at most once per module unless marked *multiple* in\nthe following description. In the case of *multiple*, all occurrence of the\ncomments of the type are processed by the documentation tools. Otherwise,\nonly the first textual occurrence will be used.\n\nThe documentation tools recognise the following module-level comments:\n\ncomment(summary, String)\n   String is a short (one line) summary of the module.\n\ncomment(desc, Description)\n   Description is a longer Text (see below) describing the module in more\n   detail than summary.\n\ncomment(alias, String)    *once* per file\n   String is used to override the module name used by the document\n   processing for the comments in the file. This allows the user to\n   generate groupings of comments in the documentation other than the\n   module in which the comments resides.\n\ncomment(status, String)\n   String is a single word, describing the status of the library.\n   Classification used in ECLiPSe: prototype, evolving, stable, phase_out,\n   deprecated.\n\ncomment(author, String)\n   String is the name of author(s) of the module.\n\ncomment(copyright, String)\n   String is the copyright notice that the documentation library will\n   generate for the documentations it produce from the comments.\n\ncomment(date, String)\n   This is designed for version control.  String is a time-stamp\n   for the file.  With CVS version control software, the string can\n   initially be set to \"$Date$\", which will be expanded by\n   CVS into the actual date each time the file is checked in.\n\ncomment(include, FileNames)    *multiple*\n   FileNames is either one file name or a list of file names. The file\n   name is either a string or an atom. These are names of files in which\n   additional comments for the module are located. They are only processed\n   by the document library tools.\n\ncomment(index, ListOfStrings)\n   The strings are used by the documentation generation process to provide\n   pointers in the document index to the module: each string is added to\n   the index pointing at the module description. This is used to add extra\n   entries in the index in addition to the ones that are automatically\n   generated.\n\ncomment(categories, ListOfStrings)\n   A list of strings describing into which categories the library\n   belongs.  This is used to generate a classified index page.\n   While the category names can be freely chosen, it is recommended\n   to stick to the predefined ones: \"Algorithms\", \"Compatibility\",\n   \"Constraints\", \"Data Structures\", \"Development Tools\",\n   \"Interfacing\", \"Programming Utilities\", \"Techniques\",\n   \"Visualisation\".\n\nIn addition, it is possible to comment individual predicates and\nstructures, using comment directives of the form:\n\ncomment(Name/Arity, ListofProperties)    *once* for each Name/Arity\n   Name and Arity are the specification for a predicate in the module and\n   ListofProperties is a list of information for the predicate. The entries\n   are described below.\n   \n   Instead of a list of properties, the atom 'hidden' can be specified.\n   This will prevent an undocumented, exported predicate from showing up\n   in the generated library documentation.\n\ncomment(struct(Name), ListofProperties)    *once* for each structure\n   Name is the name of a structure and ListofProperties is a list\n   of information for the structure.  The entries are described below\n   (admissible properties are: summary, fields, desc, see_also,\n   eg, index).\n\nIn these comments, the ListOfProperties is a list of properties of the form:\n\n    PropertyName: PropertyInformation\n\nThe properties can occur in any order in the list.\nThe following ones are recognized by the document tools:\n\namode: FunctorTemplate *multiple*\n   FunctorTemplate is a structure corresponding to the functor of\n   the predicate with the arguments filled in with the modes admissible\n   for a call to the predicate.  The valid modes are those generally\n   recognised by ECLiPSe (++, +, -, ?), with the following meaning:\n   \n   \t++\tground (fully instantiated, not containing variables)\n   \t+\tinstantiated (not a variable)\n   \t-\tvariable\n   \t?\tany\n   \n   The amode field can also be used to specify the determinism of a\n   call with a specific mode. In this case, the format is\n   \n   amode:(FunctorTemplate is Determinism)\n   \n   where FunctorTemplate is as above, and Determinism is an atom specifying\n   the determinism behaviour of a call with the particular mode. Determinism\n   can be one of: erroneous, failure, det, semidet, multi, nondet.  Their\n   meaning is as defined for the Mercury programming language and can be\n   summarised as follows:\n   \n    |   Maximum number of solutions\n       Can fail?   |   0    1    > 1\n       ------------+------------------------------------------\n       no    |   erroneous       det    multi\n       yes    |   failure    semidet    nondet\n   \n   The amode property can occur multiple times, each giving a\n   different mode for the predicate.  The document tools\n   will generate the multiple modes description in the detail\n   description of the predicate, but will combine the modes by\n   generalising all the amodes to produce a general template\n   for the predicate in any summary description of the predicate.\n\nargs: ListofArgs\n   ListofArgs is a list of the argument descriptions describing the\n   argument. The length of the list should correspond to the arity of the\n   predicate. The argument description is of the form:\n    \n      ArgName: Description\n    \n   where both ArgName and Description are strings. If present, ArgName will\n   be used in the mode template.\n\ndesc: Description\n   Description is a Text (see below) giving a long description of the\n   predicate.\n\neg: Description\n    Description is a Text (see below) for examples of using the\n    predicate. This is used to generate the Examples section of the\n    predicate description.\n\nexceptions: ListofErrors\n   ListofErrors is a list of error description of the form:\n    \n      Int: Text\n    \n   where Int is a error code for an error that can occur with the predicate\n   and Text describes the error. This is used to generate the\n   `Exceptions' section of the predicate description.\n\nfail_if: Text\n   Text is a string describing the fail conditions for the predicate. It\n   is used to generate the `Fail Conditions' section of the predicate\n   description.\n\nfields: ListofFields\t*structures only*\n   ListofFields is a list of the field descriptions describing the\n   structure fields. A field description is of the form:\n    \n      FieldName: Description\n    \n   where FieldName is an atom or string and Description is a Text.\n\nindex: ListofStrings\n   Each string in ListofString will be added to the index generated by the\n   document tools, pointing at the predicate. This is used to add\n   additional index entries for the predicate in addition to the predicate\n   names that is generated automatically.\n\nresat: Resatisfiable\n   Resatisfiable is either yes or no, specifying if the predicate is\n   resatisfiable. This is used to generate the `Resatisfiable' section of\n   the predicate description.\n\nsee_also: ListofSpecs\n   ListofSpecs is a list of items, referring to other predicates\n   and libraries which are related to the commented predicate.  This\n   is used to generate the `See Also' section of the predicate description.\n   The specs can be of the form Name/Arity, LibName:Name/Arity,\n   library(LibName).  Name, Arity and LibName can be uninstantiated,\n   in which case links to every matching predicate or library will be\n   generated.  The form link(URL,Text) can be used to insert arbitrary\n   hyperlinks.\n\nsummary: String *compulsory*\n    String is a short (one line) summary of the predicate.\n\ntemplate: String or list of strings\n    This is normally not needed.  It is only useful to override\n    the most general default template that will otherwise be\n    automatically generated from the predicate name, the arguments and\n    and the amode information.\n\nkind: ListofKinds\n    ListofKinds is a list of 'kind' information about the commented\n    predicate. Unlike the other fields, the kind information is not intended\n    for the generated documentation for the predicate, but instead, it is \n    intended for producing meta-information about the predicate that can\n    then be processed by ECLiPSe programs. Each item in the ListofKinds\n    has the following form:\n    \n    Kind\n    \n    or\n    \n    Kind:Info\n    \n    where Kind is an atom specifying some classification of the predicate\n    (e.g. constraint). Info is a list of further information about the \n    predicate, and can be the following:\n    \n    root: Root\n    extra: Extra\n    \n    where Root is an atom, the name of the 'root' module for the predicate.\n    If it is not specified, the root module is taken to be the module in\n    which the predicate is defined.\n    Extra is a list of Kind-specific information about the predicate.\n\n    Each item in the ListofKinds will be processed by the document tools into \n    an ECLiPSe fact, and facts gathered from all the processed comment files \n    will be placed into a file after the processing. The fact is of the form:  \n    \n    kind(Kind, Name, Arity, Root, Module, Extra)\n    \n    where Name and Arity is the name and arity of the predicate, and Module is\n    the module the predicate is defined in.\n\nNote that only the 'summary' property is compulsory, and apart from\n'amode', each property should occur at most once.\n\nFor the longer descriptions in the comments, a `Text' is allowed. \nThis is either a normal ascii string or a string in a document markup\nlanguage.  In the latter case, the string must be enclosed in a\nwrapper.  Currently the following are supported:\n\nhtml(String)\n    String is in HTML format and can contain HTML tags.\n    Special characters must be written using HTML notation.\n    The string must be embeddable into an HTML document,\n    i.e. there should be no <html> .. </html> and\n    no headings.\nascii_fmt(String)\n    String is in ascii format. It will be rendered using a proportional\n    font and spacing and line breaks will be lost.\nascii(String)\n    String is in ascii format. It can consist of multiple lines\n    and will be rendered using a fixed width font with all spacing and\n    line breaks being preserved.\n    (To break lines without inserting a significant line break,\n    precede the line break with a '\\').\nString\n    The same as ascii_fmt(String), except in the 'eg' field\n    where it is interpreted as ascii(String).\n\nIn order to allow automatic processing, the following should be observed\nwith the placement of comments:\n\n   A comment should occur in a file.\n\n   A comment must occur as a directive.\n\n   A comment applies to a module, so it should occur textually inside\n     a module, i.e. after any module declarations. If the program does\n     not contain any module declarations, the file name (without suffix)\n     is assumed to be the module.\n\n   The file containing comments should only have a single module defined.\n\nNote that in addition to allowing automatic documentation generation, the\ncomment predicates can also be used to provide information on the module\nitself when the user reads the program. Thus it can also act as comments in\nthe same way as the traditional comments, but in a more structured way.\n\nModes and Determinism\n   comment(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n% comments for the document library\n:- comment(summary, \"Automatic document generation library\").\n\n:- comment(index, [\"Literate programming\",\n    \"automatic documentation generation\"]).\n\n% comment for comment/2\n:- comment(comment/2, [\n\n    summary: \"Adding documentational information to ECLiPSe files.\",\n\n    index: [\"Literate programming\"],\n\n    args: [\"Type\": \"Comment type\",\n       \"Information\": \"Information for Type\"],\n\n    amode: comment(+,+),\n\n    resat: no,\n\n    fail_if: \"None. Always succeed.\",\n\n    see_also:\n\t[icompile/1,icompile/2,eci_to_html/3,ecis_to_htmls/0,ecis_to_htmls/3],\n\n    desc: html(\"    The comment/2 predicate allows documentational information to be added to\n    .....\n    \"),\n\n    eg: \"\n    % comments for the document library\n    :- comment(summary, \\\"Automatic document generation library\\\").\n\n    ....the other examples you are seeing now\n    \"\n\n    ]).  % end of comment directive for comment/2\n\n% other examples\n:- comment(fcompile/2, [\n    summary: \"Generates an object file from the ECLiPSe source File in module Module.\",\n    args: [\"File\":\"Name of source file (Atom or string)\",\n    \"Module\":\"Name of module (Atom)\"],\n   amode: fcompile(+,+)\n    ]).\n\n:- comment(atom_string/2, [\n    summary: \"Conversion between an atom and a string.\",\n    args: [\"Atom\": \"Atom or variable\",\n       \"String\": \"String or variable\"],\n    amode:(atom_string(+,-) is det),\n    amode:(atom_string(-,+) is det),\n    desc: \"\\\n    If Atom is instantiated, converts it to a string String.\n    If String is instantiated, converts it to an atom Atom.\",\n\n    resat: no,\n\n    fail_if: \"\\\n    Fails if the string String does not unify with the string version of the\n    atom Atom.\",\n\n    exceptions: [5: \"Atom is instantiated, but not to an atom.\",\n\t5: \"String is instantiated, but not to a string.\",\n\t4: \"Neither Atom nor String are instantiated.\"]\n    ]).\n\nSee Also\n   document : icompile / 1, document : icompile / 2, document : eci_to_html / 3, document : ecis_to_htmls / 0, document : ecis_to_htmls / 3"},"unskipped/1":{"prefix":"unskipped","body":"unskipped","description":"unskipped +SpecList\n\n   Sets the procedures specified in SpecList to be unskipped or not skipped.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer.\n\nType\n   Debugging\n\nDescription\n   Undoes the effect of a call to skipped/1 on the specified procedure(s),\n   i.e.  its subgoals will now be traced.\n\n   The expressions in SpecList are all of the form name/arity.\n\n   Note that unskipped/1 is superseded by the predicate set_flag(Proc,\n   skip, off), which sets the procedure Proc to be unskipped.\n\nModes and Determinism\n   unskipped(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but not of the form atom or    Atom/Integer.\n    60 --- SpecList contains an undefined procedure.\n\nExamples\n   \nSuccess:\n      [eclipse]: [user], skipped p/0.\n       q.\n       p :- q.\n       user compiled 60 bytes in 0.00 seconds\n      yes.\n      [eclipse]: trace.\n      Debugger switched on - creep mode\n      yes.\n      [eclipse]: p.\n      S (1) 0  CALL   p (dbg)?- creep\n      S (1) 0  EXIT   p (dbg)?- creep\n      yes.\n      [eclipse]: unskipped p/0.\n      yes.\n      [eclipse]: p.\n    (1) 0  CALL   p (dbg)?- creep\n    (2) 1  CALL   q (dbg)?- creep\n    (2) 1  EXIT   q (dbg)?- creep\n    (1) 0  EXIT   p (dbg)?- creep\n      yes.\n\nError:\n      unskipped Proc/1.    (Error 4).\n      unskipped write(Term)/1.    (Error 5).\n      unskipped do.    (Error 5).\n      unskipped n/1.    (Error 60).\n\nSee Also\n   skipped / 1"},"include/1":{"prefix":"include","body":"include(${1:FileSpec})$2\n$0","description":"include(+FileSpec)\n\n   Include other files as part of the program source.\n\nArguments\n   FileSpec    File name(s) (atom/string or list of atoms/strings)\n\nType\n   Directives\n\nDescription\n\n     Include the contents of other file(s) as if the contents of those\n     file(s) had been inserted in place of the directive. If more than\n     one file is specified, they are included in the order in which they\n     appear in the list FileSpec. \n\n     Included files can contain clauses, directives and queries, but should\n     not contain module/1,3 directives (they would be interpreted as\n     occurring within the including file, and the included module would\n     not end at the end of the included file).  The correct way to use\n     another module is via the use_module/1 directive.\n\n     The square bracket notation [File] can be used as a synonym\n     for include(File) when used as a directive.\n\n     To include files that contain only comment/2 directives, it is\n     preferable to use comment(include, File) - the file will then only\n     be included (and needed) by the comment processor, not the compiler.\n\n     The rules for expanding the include file names are the same as\n     those used in compile/1,2 regarding suffixes and paths.\n\nModes and Determinism\n   include(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   . / 2, comment / 2, library(source_processor)"},"if/1":{"prefix":"if","body":"if(${1:Goal})$2\n$0","description":"if(+Goal)\n\n   Conditional compilation directive.\n\nArguments\n   Goal    Goal to be tested\n\nType\n   Directives\n\nDescription\n\n    The compiler and other source-processing tools recognise the conditional\n    compilation directives if/1, elif/1, else/0 and endif/0. The first two\n    take a goal as their argument, and parts of the program source can be\n    included or excluded depending of the satisfiability of that goal.\n\n    Note that these directives are the only ones that are not treated as\n    predicate separators and can be placed around individual clauses of\n    a predicate.\n    \n\nModes and Determinism\n   if(+) is det\n\nExamples\n   \n    :- if(get_flag(hostarch,\"i386_nt\")).\n\n\t...Windows-specific code...\n\n    :- elif( (get_flag(version_as_list,Version), Version @>= [6,0]) ).\n\n\t...code for version 6.0 and later...\n\n    :- else.\n\n\t...alternative code...\n\n    :- endif.\n    \n\nSee Also\n   elif / 1, else / 0, endif / 0, library(source_processor)"},"traceable/1":{"prefix":"traceable","body":"traceable","description":"traceable +SpecList\n\n   Sets the procedures in SpecList to be traceable.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer.\n\nType\n   Debugging\n\nDescription\n   Sets the leash mode of all the procedures given by SpecList to stop.\n\n   It is superseded by calling set_flag(Proc, leash, stop)\n\nModes and Determinism\n   traceable(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is not of the form Atom/Integer.\n    60 --- SpecList is an undefined procedure.\n\nSee Also\n   get_flag / 3, set_flag / 3, untraceable / 1"},"pragma/1":{"prefix":"pragma","body":"pragma(${1:Option})$2\n$0","description":"pragma(+Option)\n\n   Enable or disable compilation or other source processing options.\n\nArguments\n   Option    An atom.\n\nType\n   Directives\n\nDescription\n   The pragma/1 directive allows to control various compiler options, or\n   other source processing options.  A pragma can only be used as a\n   directive in source files or lists given to compile_term/1,2.\n   The effect of a pragma is local to a source file (unlike set_flag/2).\n   Settings are in effect until the next pragma that overrides it or until\n   the end of the file.\n\n    Option     Effect\n   ---------------------------------------------------------------\n    [no]debug    generate debuggable code\n    [no]expand       do goal expansion/inline compilation\n    opt_level(N)     set optimizer level (N>=0)\n    [no]skip    set the skipped flag for all compiled predicates\n    system    set the type of all compiled predicates to 'built_in'\n    [no]warnings     generate compiler warnings\n\n   The default for debug/nodebug depends on the global flag debug_compile\n   and the debug compiler option.\n   The default for expand/noexpand depends on the global flag goal_expansion\n   and the expand_goals compiler option.\n   The default for opt_level depends on the opt_level compiler option.\n   The default for skip is off. The default for warnings is on.\n   The global flags are set with set_flag/2 and tested with get_flag/2.\n\n   Pragmas which the compiler does not recognise are silently ignored by\n   the compiler, but are recorded and can be retrieved using current_pragma/1.\n   Such pragmas can be atoms or structures with arbitrary arguments.\n\nModes and Determinism\n   pragma(+) is det\n\nExceptions\n   148 --- An unknown Option was given.\n\nExamples\n   \n:- pragma(debug).\n:- pragma(expand).\ntwice(X, Y) :-      % this is compiled into debuggable\n    Y is 2*X.       % code with expanded arithmetic\n\nSee Also\n   compile / 1, env / 0, get_flag / 2, get_flag / 3, pred / 1, set_flag / 3, set_flag / 2, skipped / 1, unskipped / 1, current_pragma / 1"},"assertz/1":{"prefix":"assertz","body":"assertz(${1:Clause})$2\n$0","description":"assertz(+Clause)\n\n   Add specified clause at the end of the dynamic procedure to the database\n\nArguments\n   Clause    Atom or compound term\n\nType\n   Dynamic Predicates\n\nDescription\n   Adds the specified clause for a dynamic procedure to the database.]\n   The clause is added AFTER any existing clauses for the procedure.\n   This is an alias for assert/1.\n\n   The procedure must be declared to be dynamic using the dynamic/1\n   built-in.  If the procedure is undefined an exception is raised.\n   However, the default error handler for this exception simply declares\n   the procedure dynamic and asserts the clause.\n\n   The asserted clause is NOT removed from the database on backtracking\n   through the call to assertz/1.\n\n   assertz/1 satisfies the logical update semantics.  Asserting a clause to\n   a procedure will not, in any way, affect previous calls to it when\n   backtracking.\n\n   No clause transformation is performed on Clause. Use expand_clause/2 to\n   explicitly expand the clause before calling this predicate if clause\n   expansion is rquired.\n\nModes and Determinism\n   assertz(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Clause is a free variable.\n     4 --- The head of Clause is a free variable.\n     5 --- Clause is not a valid Prolog clause.\n    63 --- The procedure is not dynamic.\n    70 --- The procedure is undefined.  However, the default error handler for this exception simply declares the procedure dynamic and    asserts the clause, if the error was caused by an assert.\n\nExamples\n      Success:\n    ?- assertz(city(london)), assertz(city(munich)), assertz(city(paris)).\n    yes.\n    ?- listing.\n    city(london).\n    city(munich).\n    city(paris).\n    yes.\n\n    ?- assertz((likes(X,Y) :- man(X), woman(Y))).\n    yes.\n    ?- listing.\n    likes(_186, _187) :-\n    man(_186),\n    woman(_187).\n    yes.\n\n   Error:\n    assertz(X).    - gives error 4.\n    assertz(\"the man\").    - gives error 5.\n    assertz(1).    - gives error 5.\n    assertz((my_static(X):-write(X))). - gives error 63.\n    if my_static/1 is not\n    dynamic.\n   Logical semantics :\n\n   If the following clauses are in the database :\np :- assertz(p), fail.\np :- fail.\n\nq :- fail.\nq :- assertz(q), fail.\n\n   The queries p.  and q.  will both fail.\n\nSee Also\n   dynamic / 1, asserta / 1, assert / 1, retract / 1, compile_term / 1"},"asserta/1":{"prefix":"asserta","body":"asserta(${1:Clause})$2\n$0","description":"asserta(+Clause)\n\n   Add specified clause for a dynamic procedure to the database before any existing clauses\n\nArguments\n   Clause    Atom or compound term\n\nType\n   Dynamic Predicates\n\nDescription\n   Adds the specified clause for a dynamic procedure to the database.]\n   The clause is added BEFORE any existing clauses for the procedure.\n\n   The procedure must be declared to be dynamic using the dynamic/1\n   built-in.  If the procedure is undefined an exception is raised.\n   However, the default error handler for this exception simply declares\n   the procedure dynamic and asserts the clause.\n\n   The asserted clause is NOT removed from the database on backtracking\n   through the call to asserta/1.\n\n   asserta/1 satisfies the logical update semantics.  Asserting a clause to\n   a procedure will not, in any way, affect previous calls to it when\n   backtracking.\n\n   No clause transformation is performed on Clause. Use expand_clause/2 to\n   explicitly expand the clause before calling this predicate if clause\n   expansion is rquired.\n\nModes and Determinism\n   asserta(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Clause is a free variable.\n     4 --- The head of Clause is a free variable.\n     5 --- Clause is not a valid Prolog clause.\n    63 --- The procedure is not dynamic.\n    70 --- The procedure is undefined.  However, the default error handler for this exception simply declares the procedure dynamic and    asserts the clause, if the error was caused by an assert.\n\nExamples\n      Success:\n    ?- asserta(city(london)), asserta(city(munich)), asserta(city(paris)).\n    yes.\n    ?- listing.\n    city(paris).\n    city(munich).\n    city(london).\n    yes.\n\n    ?- asserta((likes(X,Y) :- man(X), woman(Y))).\n    yes.\n    ?- listing.\n    likes(_186, _187) :-\n    man(_186),\n    woman(_187).\n    yes.\n\n   Error:\n    asserta(X).    - gives error 4.\n    asserta(\"the man\").    - gives error 5.\n    asserta(1).    - gives error 5.\n    asserta((my_static(X):-write(X))). - gives error 63.\n    if my_static/1 is not\n    dynamic.\n   Logical semantics :\n\n   If the following clauses are in the database :\np :- asserta(p), fail.\np :- fail.\n\nq :- fail.\nq :- asserta(q), fail.\n\n   The queries p.  and q.  will both fail.\n\nSee Also\n   dynamic / 1, assert / 1, assertz / 1, retract / 1, compile_term / 1"},"assert/1":{"prefix":"assert","body":"assert(${1:Clause})$2\n$0","description":"assert(+Clause)\n\n   Add specified clause at the end of the dynamic procedure to the database\n\nArguments\n   Clause    Atom or compound term\n\nType\n   Dynamic Predicates\n\nDescription\n   Adds the specified clause for a dynamic procedure to the database.]\n   The clause is added AFTER any existing clauses for the procedure.\n   This is an alias for assertz/1.\n\n   The procedure must be declared to be dynamic using the dynamic/1\n   built-in.  If the procedure is undefined an exception is raised.\n   However, the default error handler for this exception simply declares\n   the procedure dynamic and asserts the clause.\n\n   The asserted clause is NOT removed from the database on backtracking\n   through the call to assert/1.\n\n   assert/1 satisfies the logical update semantics.  Asserting a clause to\n   a procedure will not, in any way, affect previous calls to it when\n   backtracking.\n\n   No clause transformation is performed on Clause. Use expand_clause/2 to\n   explicitly expand the clause before calling this predicate if clause\n   expansion is rquired.\n\nModes and Determinism\n   assert(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Clause is a free variable.\n     4 --- The head of Clause is a free variable.\n     5 --- Clause is not a valid Prolog clause.\n    63 --- The procedure is not dynamic.\n    70 --- The procedure is undefined.  However, the default error handler for this exception simply declares the procedure dynamic and    asserts the clause, if the error was caused by an assert.\n\nExamples\n      Success:\n    ?- assert(city(london)), assert(city(munich)), assert(city(paris)).\n    yes.\n    ?- listing.\n    city(london).\n    city(munich).\n    city(paris).\n    yes.\n\n    ?- assert((likes(X,Y) :- man(X), woman(Y))).\n    yes.\n    ?- listing.\n    likes(_186, _187) :-\n    man(_186),\n    woman(_187).\n    yes.\n\n   Error:\n    assert(X).    - gives error 4.\n    assert(\"the man\").    - gives error 5.\n    assert(1).    - gives error 5.\n    assert((my_static(X):-write(X))). - gives error 63.\n    if my_static/1 is not\n    dynamic.\n   Logical semantics :\n\n   If the following clauses are in the database :\np :- assert(p), fail.\np :- fail.\n\nq :- fail.\nq :- assert(q), fail.\n\n   The queries p.  and q.  will both fail.\n\nSee Also\n   dynamic / 1, asserta / 1, assertz / 1, retract / 1, compile_term / 1"},"listing/0":{"prefix":"listing","body":"listing","description":"listing\n\n   Outputs the definition of all dynamic predicates in the database.\n\nArguments\n\nType\n   Dynamic Predicates\n\nDescription\n   Outputs each of the dynamic predicates currently contained on the\n   database.  ie.  all predicates created using assert/1 or asserta/1 or\n   compiled as dynamic predicates.\n\n   The order in which the predicates are listed is undefined.\n\n   The individual clauses are output in indented format using\n   writeclause/2.\n\n   No static predicates are output.\n\nModes and Determinism\n   listing is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \nSuccess:\n    [eclipse]: [user].\n     :- dynamic x/0, y/1.\n     x :- true.\n     y(X) :- write(X).\n     user compiled 0 bytes in 0.07 seconds\n    yes.\n    [eclipse]: assert(man(adam)), assert(woman(eve)),\n    > assert((likes(X,Y):-man(X),woman(Y))).\n    X = _g102\n    Y = _g98\n    yes.\n    [eclipse]: listing.\n    x .\n    y(_g68):-\n    write(_g68) .\n    likes(_g68, _g70):-\n    man(_g68),\n    woman(_g70) .\n    woman(eve) .\n    man(adam) .\n    yes.\n\nSee Also\n   assert / 1, clause / 2, listing / 1, writeclause / 1"},"clause/1":{"prefix":"clause","body":"clause(${1:Clause})$2\n$0","description":"clause(+Clause)\n\n   Succeeds if Clause unifies with a clause of a dynamic procedure.\n\nArguments\n   Clause    Atom or compound term\n\nType\n   Dynamic Predicates\n\nDescription\n   Finds a dynamic clause whose head unifies with the head of Clause and\n   unifies the body of the clause with the body of Clause.  The head of\n   Clause must be sufficiently instantiated so that the predicate (head) of\n   the clause can be determined.  The functor of the head of Clause must be\n   that of a procedure previously declared as dynamic using dynamic/1.\n\n   This goal may be resatisfied if there are several clauses which match\n   the first argument.  In the first solution the argument will be unified\n   with the first such clause.  Subsequent solutions will unify the\n   argument to the other clauses in the same order in which they are listed\n   by listing/0, 1.\n\n   clause/1 satisfies the logical update semantics.  When clause/1 is first\n   called, it makes a virtual copy of the clauses that match and, on\n   backtracking, unifies its argument with them.  Any modifications made to\n   the procedure after clause/1 has started executing do not, in any way,\n   affect the solutions produced.  A subsequent call, however makes and\n   uses a new, virtual, copy of the modified database.\n\n   No clause transformation is performed on Clause. Use expand_clause/2 to\n   explicitly expand the clause before calling this predicate if clause\n   expansion is rquired.\n\nModes and Determinism\n   clause(+) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if no dynamic clause unifies with Clause\n\nExceptions\n     4 --- Clause is not instantiated\n     4 --- The head of Clause is a free variable.\n    63 --- Procedure is not dynamic\n    70 --- Procedure is undefined\n\nSee Also\n   clause / 2"},"dynamic/1":{"prefix":"dynamic","body":"dynamic","description":"dynamic ++SpecList\n\n   Declares the procedures specified by SpecList as dynamic.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer.\n\nType\n   Dynamic Predicates\n\nDescription\n   Declare the procedures specified by SpecList as dynamic procedures.\n   This has to be done before the procedure is defined.\n\n   To change a static procedure to a dynamic one it must first be\n   abolished.\n\n   If the procedure was already dynamic Error 64 is raised.  The default\n   error handler erases all existing clauses and succeeds.  This is useful\n   for recompiling files with dynamic declarations, but it can be redefined\n   if desired.\n\nModes and Determinism\n   dynamic(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but not to a sequence of    expressions of the form Atom/Integer.\n    64 --- SpecList is already dynamic.\n    65 --- SpecList is already defined.\n\nExamples\n   \nSuccess:\n     [eclipse]: pred(a/1).\n     no.\n     [eclipse]: dynamic a/1.\n     yes.\n     [eclipse]: pred(a/1).\n     in eclipse: dynamic prolog local debugged stopped traceable\n     yes.\n     [eclipse]: a(X).\n     no (more) solution.\nError:\n     dynamic X.    (Error 4).\n     dynamic a.    (Error 5).\n     dynamic a/1, a/1.    (Error 64). % succeeds\n     get_flag(p/0,type,user),\n     dynamic p/0.    (Error 65).\n\nSee Also\n   is_dynamic / 1"},"listing/1":{"prefix":"listing","body":"listing","description":"listing ++SpecList\n\n   Outputs the definition of all dynamic predicates indicated by SpecList.\n\nArguments\n   SpecList    Sequence of expressions of the form Atom/Integer or just    Atom.\n\nType\n   Dynamic Predicates\n\nDescription\n   Outputs the definition of all dynamic predicates defined by SpecList to\n   the standard output.  An expression in SpecList may be a single\n   predicate in the form name/arity in which case only the clauses for\n   name/arity are printed.  Alternatively the format name is accepted in\n   which case all the predicates of any arity associated with name are\n   output.\n\n   The individual clauses are output in indented format using\n   writeclause/2.\n\n   No static predicates are output.\n\nModes and Determinism\n   listing(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- An expression in SpecList is not instantiated.\n     5 --- An expression in SpecList is not of the form Atom/Integer or    Atom.\n    63 --- An expression in SpecList is not a dynamic procedure.\n\nExamples\n   \nSuccess:\n    [eclipse]: [user], assert(woman(eve)).\n     :- dynamic p/0.\n     p.\n     user compiled 0 bytes in 0.00 seconds\n    yes.\n    [eclipse]: listing p/0, woman/1.\n    p .\n    woman(eve) .\n    yes.\n\nError:\n    listing X.    (Error 4).\n    listing a/a.    (Error 5).\n    listing z/3.    (Error 63).\n\nSee Also\n   assert / 1, clause / 1, clause / 2, listing / 0, writeclause / 1"},"retractall/1":{"prefix":"retractall","body":"retractall(${1:Head})$2\n$0","description":"retractall(+Head)\n\n   Removes from the database all clauses whose heads match Head\n\nArguments\n   Head    Atom, variable or compound term.\n\nType\n   Dynamic Predicates\n\nDescription\n   Retracts from the database all clauses whose heads match the argument.\n   The argument must be sufficiently instantiated otherwise an error is\n   signalled.  retractall/1 never fails.  The clauses are not reasserted\n   when backtracking through the call of retractall/1.\n\n   The functor and the arity of Head must be that of a predicate declared\n   as dynamic (or implicitly declared as dynamic by asserting).\n\n   retractall/1 satisfies the logical update semantics.  Using it to\n   retract all the clauses of a predicate will not, in any way, affect\n   previous calls to the predicate, i.e. they will still see all the clauses\n   that existed at call time.\n\nModes and Determinism\n   retractall(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Head is not instantiated\n     5 --- Head is not a callable term\n    63 --- Procedure is not dynamic\n    70 --- Procedure is undefined\n\nExamples\n   \nSuccess:\n    [eclipse]: assert(city(munich)), assert(city(london)).\n    yes.\n    [eclipse]: retractall(city(_)).\n    yes.\n    [eclipse]: city(X).\n    no (more) solution.\n    [eclipse]: retractall(city(_)).\n    yes.\nError:\n    retractall(X).    (Error 4).\n    retractall(\"x\").    (Error 5).\n\n   % if h/0 is defined, but not as dynamic..\n    retractall(h).    (Error 63).\n\n    retractall(z/0).    (Error 70).\n\nSee Also\n   dynamic / 1, assert / 1, retract / 1"},"garbage_collect/0":{"prefix":"garbage_collect","body":"garbage_collect","description":"garbage_collect\n\n   Request an immediate garbage collection.\n\nArguments\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Causes an immediate garbage collection of the global and trail stack,\n   provided that the garbage collector is not switched off (cf.\n   set_flag/2).  In any case the predicate succeeds.\n\n   Note that the garbage collector is usually triggered automatically,\n   controlled by the user-definable flag gc_interval.  Therefore, the usage\n   of garbage_collect/0 should be restricted to situations where the\n   automatic triggering performs badly.  In this case it should be inserted\n   in a place where it is known for sure that a lot of structures and lists\n   have become useless, eg.  just before a tail-recursive call as shown in\n   the example.\n\nModes and Determinism\n   garbage_collect is det\n\nExamples\n   \ncycle(OldState) :-\n    transform(OldState, NewState), /* long computation     */\n    !,\n    garbage_collect,    /* OldState is obsolete */\n    cycle(NewState).\n\nSee Also\n   env / 0, set_flag / 2, get_flag / 2"},"env/0":{"prefix":"env","body":"env","description":"env\n\n   Prints information about the current ECLiPSe environment on the current\noutput.\n\nArguments\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Prints a list of the current global flag values on the toplevel output\n   stream.  These are the same values that get_flag/2 provides.\n\nModes and Determinism\n   env is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n[eclipse]: env.\n\nafter_event_timer:      real    ignore_eof:    off\nbounded:    false    last_errno:    0\nbreak_level:    0    macro_expansion:    on\nbreal_exceptions:       off    max_global_trail:       134217728\ncoroutine:    off    max_local_control:      134217728\ncwd_scope:    process    max_predicate_arity:    255\ndebug_compile:    on    object_suffix:    \"dll\"\ndebugging:    nodebug    output_mode:    \"QPm\"\neclipse_info_suffix:    \".eci\"    pid:    2856\neclipse_object_suffix:  \".eco\"    ppid:    0\nenable_interrupts:      on    prefer_rationals:       off\nfloat_precision:    double    print_depth:    20\ngc:    on    remote_protocol_version:1\ngc_interval:    4194304    toplevel_module:    eclipse\ngc_interval_dict:       960    unix_time:    1326075378\ngc_policy:    adaptive    version:    '6.1'\ngoal_expansion:    on    version_as_list:    [6, 1, 99]\nhostarch:    \"i386_linux\"\n\ncwd:    \"/homes/john/\" \ndefault_language:       eclipse_language\nextension:    development occur_check dfid\ntmp_dir:    \"/tmp\"\nhostid:    \"A#032167137134\"\nhostname:    \"foo.bar.com\"\ninstallation_directory: \"/usr/local/eclipse\" \nlibrary_path:    [\"/usr/local/eclipse/lib\",\n    \"/usr/local/eclipse/lib_public\"]\nloaded_library:    tracer_tty development_support toplevel\n    eclipse_language suspend\noutput_options:    [depth(20), attributes(pretty), quoted(true),\n    portrayed(true)]\nprolog_suffix:    [\"\", \".ecl\", \".pl\"]\nsyntax_option:    nl_in_quotes no_blanks\nvariable_names:    check_singletons\n\nSee Also\n   get_flag / 2, set_flag / 2"},"get_flag/2":{"prefix":"get_flag","body":"get_flag(${1:Flag}, ${2:Value})$3\n$0","description":"get_flag(?Flag, -Value)\n\n   Succeeds if the flag Flag has the value Value.\n\nArguments\n   Flag    Atom or Variable.\n   Value    Prolog term.\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Used to return or check the environment flag Flag with value Value.  The\n   environment flags which are read/write may be updated using set_flag/2.\n   The current values of the environment flags are returned by env/0.\n\n   The following list details the environment flags:\n\nafter_event_timer\n\n    Access mode :   read/write\n\n    Type :  Atomic constant real or virtual\n\n    Description : Specifies the timer used for event_after/2 and\n    event_after_every/2.\n\nbreak_level\n\n    Access mode :   read/write\n\n    Type :   Integer\n\n    Description :   Specifies current nesting level of recursive\n    top-level loops.\n\nbreal_exceptions\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   off\n\n    Description :   If on,  unifying or testing bounded reals\n    for identity raises an 'undecidable comparison of bounded reals'\n    exception in case the comparison is undecidable (i.e. the bounds\n    overlap).  If off, bounded reals compare equal when\n    their bounds are equal.  This flag does not affect arithmetic\n    comparisons.\n\ncoroutine\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   configuration dependent\n\n    Description :   Specifies whether built-in predicates delay or\n    raise instantiation faults.\n\ncwd\n\n    Access mode :   read/write\n\n    Type :   String\n\n    Description :   Specifies the name of the current working directory.\n    May also be set using cd/1 or read using getcwd/1.\n\ncwd_scope\n\n    Type :   Atomic constant process or separate\n\n    Description :   Specifies whether cd/1, getcwd/1, the cwd flag and\n    relative path names refer the process's current directory ('process'),\n    or to the ECLiPSe system's own idea of current directory ('separate').\n\tNote that the effective current directory may change when the cwd_mode\n\tis switched, as no synchronisation is done.\n\ndebug_compile\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   on\n\n    Description :   Specifies whether clauses are compiled for\n    debugging or not.  May be overwritten on a file by file\n    basis using pragma(debug) or pragma(nodebug).\n\ndebugging\n\n    Access mode : read-only\n\n    Type : Atomic constant nodebug, creep, or leap\n\n    Default :   nodebug\n\n    Description : Specifies whether debugging is disabled (nodebug) or\n    \tenabled.  trace/0 sets the creep mode, debug/0 sets the leap mode.\n\ndefault_language\n\n    Access mode : read/write\n\n    Type : Atom\n\n    Default :   eclipse_language\n\n    Description : Specifies the source language dialect for modules which\n    \tare created without an explicit language specification (module/1\n    directive or the create_module/1). Other possible settings are\n    for example 'iso' or 'sicstus'.\n\neclipse_info_suffix\n\n    Access mode : read\n\n    Type : String\n\n    Default : \".eci\"\n\n    Description : Specifies the ECLiPSe information file suffix used when a \n    file is generated by icompile/1. The suffix will be automatically\n    appended to the base file name when the information file is \n    generated. \n\neclipse_object_suffix\n\n    Access mode : read\n\n    Type : String\n\n    Default : \".eco\"\n\n    Description : Specifies the ECLiPSe object file suffix used when a file\n    is fcompiled. The suffix will be automatically appended to the \n    file's base name when the object file is generated. When loading a \n    file (e.g. use_module/1, lib/1), the system will try to find an\n    object file before a source file by appending the given suffix\n    before the source suffix(es).\n\nenable_interrupts\n\n    Access mode : read/write\n\n    Type : Atomic constant on or off\n\n    Default :   on\n\n    Description : If on, interrupts are recognised and processed as\n    they occur.  If off, interrupts are entered into a delay queue\n    and processed only when the flag is switched back to on.\n    Interrupts should be disabled only for short periods of time in\n    order to keep the system's interrupt response time short.\n\nextension\n\n    Access mode : read-only\n\n    Type : Atomic constant.\n\n    Default :   configuration dependent\n\n    Description : Specifies which extensions are available in the\n    system.  This flag may contain multiple values and will return\n    them on backtracking.\n\nfloat_precision\n\n    Access mode : read-only\n\n    Type : Atomic constant\n\n    Default :   double\n\n    Description : This flag is obsolete. Its value is always double.\n\ngc\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on, verbose or off\n\n    Default :   on\n\n    Description :   Specifies whether garbage collection is enabled\n    (on), disabled (off) or enabled and reports every collection on\n    log_output (verbose).\n\ngc_policy\n\n    Access mode :   read/write\n\n    Type :   Atomic constant adaptive or fixed.\n\n    Default :   adaptive\n\n    Description :   This option affects the triggering heuristics of\n    the garbage collector, together with the gc_interval setting.\n    The adaptive policy minimises garbage collection time,\n    while the fixed policy minimises space consumption.\n\ngc_interval\n\n    Access mode :   read/write\n\n    Type :   Integer\n\n    Default :   1/32 of global stack size, at least 64KB\n\n    Description :   Specify how often the collector is invoked.\n    Roughly, the argument specifies the minimum number of bytes a\n    program must have newly allocated before a garbage collection\n    is triggered.  If the garbage collector runs frequently while\n    reclaiming little space it may make sense to increase\n    gc_interval, thus reducing the number of garbage collections. \n    This is normally only necessary when the gc_policy is set to\n    fixed.  With gc_policy set to adaptive, the\n    collection intervals will be adjusted automatically.  See also\n    gc_policy setting.\n\ngc_interval_dict\n\n    Access mode :   read/write\n\n    Type :   Integer\n\n    Default :   960\n\n    Description :   Specify after how many new dictionary entries the\n    dictionary garbage collector is invoked.\n\ngoal_expansion\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   on\n\n    Description :   Specifies whether goal expansion (inling) is done by\n    the compiler or other source processing tools.  Can be disabled\n    for debugging purposes, but usually it is preferable to use a\n    compiler/source-processor option or a pragma for this purpose.\n\nhostarch\n\n    Access mode : read-only\n\n    Type : String\n\n    Description : String identifying the host processor and operating\n    system.  It is also the name of the machine-dependent\n    subdirectories in the ECLiPSe installation.\n\nhostid\n\n    Access mode : read-only\n\n    Type : String\n\n    Description : The unique identification of the host machine that\n    the system is running on.\n\nhostname\n\n    Access mode : read-only\n\n    Type : string\n\n    Description : The name of the current host machine.\n\nignore_eof\n\n    Access mode : read/write\n\n    Type :   Atomic constant on or off\n\n    Description : Controls whether ECLiPSe can be exited by typing an\n    end-of-file to the toplevel-prompt or whether this is ignored.\n    If ignored, ECLiPSe can be exited by calling halt/0.\n\ninstallation_directory\n\n    Access mode : read-only\n\n    Type : string\n\n    Description : The name of the toplevel directory of the running\n    ECLiPSe installation.  All ECLiPSe library, documentation and\n    other directories are below this one.\n\nlast_errno\n\n    Access mode : read-only\n\n    Type : Integer\n\n    Description : The error code that the most recent failed operating\n    system call returned. This should no longer be used because of\n    portability problems, use errno_id/1 instead.\n\nlibrary_path\n\n    Access mode : read/write\n\n    Type : List of strings\n\n    Default :   the contents of the user's ECLIPSELIBRARYPATH\n    environment variable, followed by the system library\n    directories\n\n    Description : Specifies the list of pathnames used by the system to\n    search for library files.  The library path is used by lib/1\n    for autoloading, and to expand library/1 structures in\n    pathnames.\n\nloaded_library\n\n    Access mode :   read/write\n\n    Type :   Atom\n\n    Description :   Returns the names of the currently loaded\n    libraries.  This flag may contain multiple values and will\n    return them on backtracking.\n\nmacro_expansion\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   on\n\n    Description :   Specifies whether macro expansion (including clause\n    \texpansion and goal expansion/inlining) is enabled or disabled.\n    Should be disabled only for very specific debugging purposes.\n    It is preferrable to disable macro expansion on a per-stream\n    basis (see set_stream_property/3) or via a source-processor option.\n\nmax_integer\n\n    Access mode : read-only\n\n    Type : Integer\n\n    Description :   If the range of integer is bounded (i.e. bignums not\n       supported), returns the maximum representable integer value. Fails \n       if the integer range is unbounded. \n\nmax_global_trail\n\n    Access mode : read-only\n\n    Type : Integer\n\n    Description : The maximum size in bytes to which the global/trail stack\n    can grow. See also statistics/2.\n\nmax_local_control\n\n    Access mode : read-only\n\n    Type : Integer\n\n    Description : The maximum size in bytes to which the global/trail stack\n    can grow. See also statistics/2.\n\nmax_predicate_arity\n\n    Access mode :   read-only\n\n    Type :   Integer\n\n    Default :   255\n\n    Description :   Returns the maximum number of arguments allowed for\n    an ECLiPSe predicate.\n\nobject_suffix\n\n    Access mode :   read-only\n\n    Type :   String\n\n    Description :   Returns the suffix of the external object files\n    that can be loaded using load/1.  It is usually \"so\" for\n    systems that support shared libraries and \"o\" for the others.\n\noccur_check\n\n    Access mode : read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   off\n\n    Description : If the flag is on, occur check is performed on\n    uncompiled unifications and the compiler generates code for\n    unifications that will perform the occur check when necessary.\n    Note that as ECLiPSe built-ins are compiled with this flag off,\n    so the occur check is never performed with built-ins.\n\noutput_mode\n\n    Access mode : read/write\n\n    Type : String\n\n    Default :   \"QPm\"\n\n    Description : The value is a control string that is recognised by\n    the %w format of printf/3.  This format is used to output\n    results on the toplevel loop and to print debugger trace lines.\n    See also the output_options flag.\n\noutput_options\n\n    Access mode : read/write\n\n    Type : List of structures\n\n    Default :   [depth(20), attributes(pretty), ...]\n\n    Description : The value is an output options list as understood by\n    \twrite_term/2,3.   This format is used to output results on the\n    toplevel loop and to print debugger trace lines.  This flag is\n    an alternative, more readable representation of the values of the\n    print_depth and output_mode flag.  It reflects the values of those\n    flags and will change their values whenever it is changed itself.\n\npid\n\n    Access mode :   read-only\n\n    Type :   Integer\n\n    Description :   Returns the process identifier of the current\n    ECLiPSe .\n\nppid\n\n    Access mode :   read-only\n\n    Type :   Integer\n\n    Description :   Returns the process identifier of the current\n    ECLiPSe 's parent process.\n\nprefer_rationals\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Default :   off\n\n    Description :   Specifies if the result of a /-division of two\n    integers gives a rational or a floating point result.  Similar\n    for the result of raising an integer to a negative integral\n    power.\n\nprint_depth\n\n    Access mode :   read/write\n\n    Type :   Integer\n\n    Default :   20\n\n    Description :   Specifies the print depth bound for printing\n    compound terms.  It is not taken into account by the output\n    predicates that produce machine-readable output (write_canonical,\n    writeq, etc), but other I/O built-ins obey this flag.\n    Identical to the depth(N) component of the output_options flag.\n\nprolog_suffix\n\n    Access mode :   read/write\n\n    Type :   List of strings\n\n    Default :   [\"\", \".ecl\", \".pl\"]\n\n    Description :   Specifies the Prolog source file suffix(es) used\n    when compiling files or loading libraries.  The system tries to\n    find the file by appending the given suffixes in the order\n    provided.\n\nremote_protocol_version\n\n    Access mode :   read only\n\n    Type :   Integer\n\n    Description :   Specifies the version of the protocol which this\n    \tEclipse uses to communicate with remotely attached peers.  See\n    Embedding and Interfacing Manual: The Remote Interface Protocol.\n\nsyntax_option\n\n    Access mode :   read/write\n\n    Type :   Atom\n\n    Description :   Returns the names of the currently enabled syntax\n    options.  This flag may contain multiple values and will return\n    them on backtracking.  A syntax option is reset using\n    set_flag(syntax_option, not(Flag)).  Most compatibility\n    packages affect these flags as well.  The following options are\n    available:\n\n    \n    atom_subscripts\n\t  allow atoms to be followed by subscripts, and parse as subscript/2.\n\t  Useful for parsing other languages, e.g. FlatZinc.\n\n    bar_is_no_atom\n\tdisallow the use of an unquoted vertical bar as atom or functor,\n\texcept when it occurs in infix-position.\n\n    bar_is_semicolon\n\ttranslate occurrences of unquoted infix vertical bars into terms\n\twith functor ;/2, e.g. (a|b) = (a;b).\n\n    based_bignums\n\t  Allow base notation even for integers longer than the\n\t  wordsize (i.e.  they are always positive).\n\n    blanks_after_sign\n\tignore blank space between a sign and a number (by default,\n\tthis space is significant and will lead to the sign being\n\ttaken as prefix operator rather than the number's sign).\n\tAlso allow signs of numbers to be quoted.\n\n    blanks_in_nil\n    has no effect (obsolete).\n\n    curly_args_as_list\n\t  Parse terms written as {a,b,c} as {}([a,b,c]) instead of\n\t  the default {}((a,b,c)).\n\n    doubled_quote_is_quote\n\t  parse a pair of quotes within a quoted item as one\n\t  occurrence of the quote within the item.  If this option is\n\t  off (the default), consecutive string-quoted and list-quoted\n\t  items are parsed as a single (concatenated) item, while\n\t  consecutive quoted atoms are parsed as consecutive atoms.\n \n    float_needs_point\n    \trequire floating point numbers to be written with a decimal point,\n\te.g. 1.0e-3 instead of 1e-3.\n\n    general_subscripts\n\t  allow atoms, parenthesized subterms and subscripted subterms\n\t  to be followed by subscripts, and parse as subscript/2.\n\t  Useful for parsing other languages, e.g. Zinc.\n\n    iso_base_prefix\n\t  allow binary, octal or hexadecimal numbers to be written\n\t  with 0b, 0o or 0x prefix respectively, and disallow the\n\t  base'number notation.\n\n    iso_escapes\n\t  ISO-Prolog compatible escape sequences within strings and atoms.\n\n    iso_restrictions\n\t  enable all ISO-Prolog syntax restrictions that are not controlled\n\t  by individual settings. This includes: disallowing operators as\n\t  operands of operators; disallowing an atom to be declared as both\n\t  an infix and a postfix operator; restrictions on changing operator\n\t  properties for comma, vertical bar, and the empty-bracket atoms.\n\n    limit_arg_precedence\n\t  do not allow terms with a precedence higher than 999 as\n\t  structure arguments, unless parenthesised.\n\n    nested_comments\n    allow bracketed comments to be nested.\n\n    nl_in_quotes\n    allow newlines to occur inside quotes (default).\n\n    no_array_subscripts\n\t  do not allow array subscript syntax for subscript/2.\n\n    no_attributes\n\tdisallow the Eclipse specific syntax for variable attributes\n\tin curly braces.\n\n    no_blanks\n\t  do not allow blanks between functor and opening parenthesis (default).\n\n    no_curly_arguments\n\tdisallow the Eclipse specific syntax for structures with\n\tnamed arguments in curly braces.\n\n    plus_is_no_sign\n\tdo not interpret a plus sign preceding a number as the\n\tnumber's sign (effectively ignoring it), but treat it as\n\ta possible prefix operator +/1.\n\n    read_floats_as_breals\n    \tread all floating point numbers as bounded reals rather than as\n\tfloats. The resulting breal is a small interval enclosing the\n\ttrue value of the number in decimal notation.\n\n    var_functor_is_apply\n\tallow variables as functors, and parse a term like X(A,B,C)\n\tas apply(X,[A,B,C]).\n\n     \n\ntmp_dir\n\n    Access mode : read/write\n\n    Type : String\n\n    Default : configuration dependent (see Description below)\n\n    Description : Specifies the temporary directory that ECLiPSe may use\n    for storing temporary data files. Value should be an\n    existing directory (in ECLiPSe's file name syntax) that the user\n    can write to (set_flag/2 will fail otherwise). It is also\n    recommended that the directory should reside on a local disk where\n    the I/O operations are as fast as possible.   By default, this\n    directory is taken from the environment variable ECLIPSETMP if it\n    exist. Otherwise, it is \"/tmp\" for Unix systems; \"//C/Temp\" for\n    Windows. If none of these exist, it is set to the current\n    working directory at start up.\n\ntoplevel_module\n\n    Access mode :   read/write\n\n    Type :   Atom\n\n    Default :   eclipse\n\n    Description :   The name of the current top-level module.  This is\n    the caller module for all queries entered in the top-level\n    loop.  By default, this is also shown in the top-level prompt.\n\nunix_time\n\n    Access mode :   read-only\n\n    Type :   Integer\n\n    Description :   Return the time as given by the UNIX time(3)\n    function, ie.  seconds since 00:00:00 GMT, Jan 1 1970.\n\nvariable_names\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on, off or check_singletons\n\n    Default :   check_singletons\n\n    Description :   Controls the ability to retain the source name of\n    variables.  This flag affects the reading process only, i.e.\n    when a variable is read (or compiled) with the flag set to on,\n    it will keep its name even when the flag is switched off later.\n    check_singletons is like on but additionally the compiler emits\n    warnings about source variables which occur only once in a\n    clause and whose name does not start with an underscore.  The\n    source variable names are being created during the term input\n    if this flag is not off, and then they are kept independently\n    of the value of this flag.\n\nversion\n\n    Access mode :   read-only\n\n    Type :   Atom\n\n    Description :   Returns the current version number of ECLiPSe .\n\nversion_as_list\n\n    Access mode :   read-only\n\n    Type :   List of integers\n\n    Description :   Returns a list of integers, starting with your ECLiPSe\n    \tsystem's major version number, and ending with its build number.\n\tNote that this list can be used for lexicographic comparison, e.g.\n\t[5,3,17] @>= [5,3] or [5,3,17] @>= [5,1,24].\n\nworker\n\n    Access mode :   read-only\n\n    Type :   Integer\n\n    Description :   In a parallel session it returns a positive number,\n    identifying the worker on which the flag inquiry was executed.\n    In a sequential session 0 is returned.\n\nworkers\n\n    Access mode :   read/write\n\n    Type :   A structure Host:N, where Host is an atom and N integer\n\n    Description :   In a parallel session it returns a positive number\n    for N, which is the number of active workers on a given host\n    Host.  If Host is a variable, it is bound to the host name\n    where this predicate is executed.\n\nworkerids\n\n    Access mode :   read-only\n\n    Type :   A structure Host:ActiveList+AsleepList, where Host is an\n    atom and ActiveList and AsleepList are integer lists\n\n    Description :   In a parallel session it returns the workerid lists\n    of of both active and asleep workers on a given host Host.  If\n    Host is a variable, it is bound to the host name where this\n    predicate is executed.\n\nwm_window\n\n    Access mode :   read/write\n\n    Type :   Atomic constant on or off\n\n    Description :   In a parallel session this flag tells if the window\n    interface for the worker manager is on or off.\n\nModes and Determinism\n   get_flag(-, -) is nondet\n   get_flag(+, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Flag is neither an atom nor variable.\n\nExamples\n   \nSuccess:\n   [eclipse]: get_flag(gc, X).\n   X = on\n\n   yes.\n   [eclipse]: get_flag(loaded_library, L).\n\n   L = lists     More? (;)\n\n   L = development_support     More? (;)\n   yes.\n\nError:\n   get_flag(1,X).    (Error 5)\n\nSee Also\n   set_flag / 2, env / 0, errno_id / 1"},"make/0":{"prefix":"make","body":"make","description":"make\n\n   Recompile all files that have been modified since their last compilation.\n\nArguments\n\nType\n   Development Environment and Global Settings\n\nDescription\n   This is a simple utility which uses file modification times to determine\n   if a file needs recompilation.  All compiled files in the system are\n   examined and recompiled if they have been modified since the previous\n   compilation.  make/0 can be defined as follows:\n\nmake :- current_compiled_file(File, Time, Module),\n    get_file_info(File, mtime) =\\= Time,\n    compile(File, Module),\n    fail.\nmake.\n\nModes and Determinism\n   make is det\n\nExamples\n   \n[eclipse 1]: [file1,file2].\nfile1.pl   compiled traceable 40 bytes in 0.00 seconds\nfile2.pl   compiled traceable 40 bytes in 0.00 seconds\n\nyes.\n[eclipse 2]: sh(\"touch file1.pl\").\n\nyes.\n[eclipse 3]: make.\nfile1.pl   compiled traceable 40 bytes in 0.00 seconds\n\nyes.\n\nSee Also\n   . / 2, compile / 1, compile / 2, current_compiled_file / 3, ensure_loaded / 1"},"is_dynamic/1":{"prefix":"is_dynamic","body":"is_dynamic(${1:PredSpec})$2\n$0","description":"is_dynamic(++PredSpec)\n\n   Succeeds if the procedure specified by PredSpec has been declared as\ndynamic.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer.\n\nType\n   Dynamic Predicates\n\nDescription\n   Used to test whether the procedure specified by PredSpec was declared as\n   dynamic.\n\nModes and Determinism\n   is_dynamic(++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the procedure specified by PredSpec has not been declared as\n   dynamic.\n\nExceptions\n     4 --- PredSpec is not instantiated.\n     5 --- PredSpec is instantiated, but not to an expression of the    form Atom/Integer.\n    60 --- PredSpec is an undefined procedure.\n\nExamples\n   \nSuccess:\n      [eclipse]: assert(p).\n      yes.\n      [eclipse]: is_dynamic(p/0).\n      yes.\n\nError:\n     is_dynamic(X).    (Error 4).\n     is_dynamic(a).    (Error 5).\n     is_dynamic(y/0).    (Error 60).\n\nSee Also\n   abolish / 1, dynamic / 1"},"help/1":{"prefix":"help","body":"help(${1:PredSpec})$2\n$0","description":"help(+PredSpec)\n\n   Prints help information on the specified predicate in PredSpec on the\ncurrent output.\n\nArguments\n   PredSpec    Predicate/Library specification in form Name/Arity or Module:Name/Arity, lib(Name), or an atom Name\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Prints help information about the specified predicates to the current\n   output.  The information displayed is a text version of the reference\n   manual.  If only Name is specified, the system looks for all predicates\n   that have this atom in their name.  If there are more than one predicate\n   matching, a short description for each one is printed, rather than the\n   whole page.  For instance, help var prints the short description of\n   get_var_info/3, nonvar/1, readvar/3, var/1 and variant/2, whereas help\n   dv prints the whole reference manual page for readvar/3.\n\n   Help information is available for both built-ins (those predicates\n   defined in eclipse_language) and library predicates. If a particular\n   predicate is available in more than one library, the user can specify\n   Module:Name/Arity for PredSpec where Module is the name of the library \n   to select a specific predicate description. If a predicate is available\n   both as a built-in and library predicate(s), then the built-in will be\n   printed in full, while short descriptions are given for the library\n   predicates.\n\n   In addition, if information on library is available, help\n   lib(LibraryName) can be used to obtain this information.\n\nModes and Determinism\n   help(+) is semidet\n\nFail Conditions\n   Fails if no help is available for PredSpec\n\nExamples\n   \nSuccess:\n      help(nl/0).    % Displays reference page on nl/0\n\n      help(write/X).      % Displays short description of\n  % write/1 and write/2\n\n      help(fd:(::)/2).    % Displays the reference page for fd's ::/2.\n\n      help((=:=)/2).      % Displays reference page for the built-in =:=/2,\n  % and short description of the other instances of =:=/2.\n\n      help(lib(eplex)).   % Displays the reference page for the library eplex.\n      help(X).    % Displays short description of\n  % all built-ins\n\nFail:\n      help(nobip/1).\n\nSee Also\n   current_built_in / 1"},"retract/1":{"prefix":"retract","body":"retract(${1:Clause})$2\n$0","description":"retract(+Clause)\n\n   Succeeds if a clause that unifies with Clause can be removed from the\ndatabase.\n\nArguments\n   Clause    Atom or compound term\n\nType\n   Dynamic Predicates\n\nDescription\n   Removes the first clause that matches the argument from the database.\n   On backtracking, successive clauses that match are removed.  The clauses\n   are not reasserted when backtracking occurs through retract/1.\n\n   The functor of the head of Clause must be that of a predicate declared\n   as dynamic, otherwise an error occurs.  If no clause matches, it fails.\n\n   retract/1 satisfies the logical update semantics.  When retract/1 is\n   first called, it makes a virtual copy of the clauses that match and, on\n   backtracking, unifies its argument with them and removes them from the\n   database.  Any modifications made to the procedure after retract/1 has\n   started executing do not, in any way, affect its behaviour.  A\n   subsequent call, however, makes and uses a new, virtual, copy of the\n   modified database.\n\n   No clause transformation is performed on Clause. Use expand_clause/2 to\n   explicitly expand the clause before calling this predicate if clause\n   expansion is rquired.\n\nModes and Determinism\n   retract(+) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if no dynamic clause unifies with Clause\n\nExceptions\n     4 --- Clause is not instantiated\n     4 --- The head of Clause is a free variable.\n     5 --- Clause or the head of Clause is not a callable term.\n    63 --- Procedure is not dynamic\n    70 --- Procedure is undefined\n\nExamples\n   \nSuccess:\n    [eclipse]: assert(city(munich)), assert(city(london)),\n    assert((p :- write(hi), write(there))).\n\n    yes.\n    [eclipse]: retract(city(X)).\n\n    X = munich     More? (;)\n    yes.\n    [eclipse]: retract(city(X) :- Body).\n\n    X = london\n    Body = true\n    yes.\n    [eclipse]: retract(p :- Body).\n\n    Body = write(hi) , write(there)\n    yes.\nFail:\n    assert(fact),retract(fact),retract(fact).\n\nError:\n    retract(X).    (Error 4).\n    retract(\"x\").    (Error 5).\n    retract(listing).    (Error 63).\n    retract(undef).    (Error 70).\n\nSee Also\n   assert / 1, dynamic / 1, listing / 1"},"pred/1":{"prefix":"pred","body":"pred(${1:PredSpec})$2\n$0","description":"pred(++PredSpec)\n\n   The flags of the predicate described by PredSpec are printed out on the\ncurrent output.\n\nArguments\n   PredSpec    Predicate name in the form Atom/Integer\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Used to print on the current output the flags of the visible predicate\n   described by PredSpec.  For the description of the flags see get_flag/3.\n\nModes and Determinism\n   pred(++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if PredSpec does not exist\n\nExceptions\n     4 --- PredSpec is not instantiated\n     5 --- PredSpec is not in the format Atom/Integer\n\nExamples\n   \n    ?- pred(pred/1).\n    mode    pred(?)\n    visibility    imported\n    definition_module   sepia_kernel\n    declared    on\n    defined    on\n    autoload    off\n    auxiliary    off\n    call_type    prolog\n    demon    off\n    deprecated    off\n    parallel    off\n    priority    2\n    run_priority    2\n    stability    static\n    tool    on\n    type    built_in\n    debugged    on\n    leash    notrace\n    skip    on\n    spy    off\n    start_tracing       off\n    port_calls    []\n    port_lines    []\n    break_lines    []\n    code_size    10\n    Yes (0.01s cpu)\n\n    ?- pred(nopred/1).\n    No (0.00s cpu)\n\nSee Also\n   get_flag / 3, set_flag / 3, current_built_in / 1"},"profile/1":{"prefix":"profile","body":"profile(${1:Goal})$2\n$0","description":"profile(+Goal)\n\n   Profile the goal and print the times spent in each predicate.\n\nArguments\n   Goal    Atom or a compound term.\n\nType\n   Development Environment and Global Settings\n\nDescription\n   This predicate invokes the profiler with default options.  Equivalent to:\n   \n       profile(Goal, []).\n   \n   See profile/2 for details.\n\nModes and Determinism\n   profile(+) is det\n\nExceptions\n     6 --- Flags contains an illegal flag.\n\nExamples\n   \n[eclipse 6]: profile(boyer).\nrewriting...\nproving...\ngoal succeeded\n\n    PROFILING STATISTICS\n    --------------------\n\nGoal:    boyer\nTotal user time:  10.65s\n\nPredicate    Module    %Time  Time\n-------------------------------------------------\nrewrite    /2  eclipse    52.3%  5.57s\ngarbage_collect   /0  sepia_kernel   23.1%  2.46s\nrewrite_args      /2  eclipse    16.6%  1.77s\nequal    /2  eclipse    4.7%  0.50s\n...\nplus    /3  eclipse    0.1%  0.01s\n\nSee Also\n   get_flag / 2, profile / 2"},"set_flag/2":{"prefix":"set_flag","body":"set_flag(${1:Flag}, ${2:Value})$3\n$0","description":"set_flag(+Flag, ++Value)\n\n   Succeeds if the flag Flag is successfully set to the value Value.\n\nArguments\n   Flag    Atom.\n   Value    Atomic or compound term.\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Used to set the environment flag Flag to the value Value.  The current\n   value of a flag may be returned using get_flag/2.  Refer to the\n   specification of get_flag/2 for details about each of the environment\n   flags.\n\nModes and Determinism\n   set_flag(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Flag and/or Value are not instantiated.\n     5 --- Flag is neither an atom nor a variable.\n     5 --- Value is not of the expected type.\n     6 --- Flag and/or Value are out of range.\n    30 --- Flag is a read-only flag.\n\nExamples\n   \nSuccess:\n   set_flag(gc,verbose).\n   set_flag(syntax_option, no_blanks).\n   set_flag(syntax_option, not nl_in_quotes).\n\n   % The following example will set a new library path\n\n   [eclipse]: get_flag(library_path,Path),\n      set_flag(library_path, [\"/home/myuser/mylibs\" | Path]).\n\n   Path = [\"/usr/local/ECLIPSE/lib\"]\n   yes.\n\nFail:\n   set_flag(statistics, some).\n\nError:\n   set_flag(X,a).    (Error  4)\n   set_flag(\"a\",x).    (Error  5)\n   set_flag(blah, a).    (Error  6)\n   set_flag(gc,fred).    (Error  6)\n   set_flag(version,1).    (Error 30)\n\nSee Also\n   get_flag / 2, env / 0, cd / 1, compile / 1, compile / 2, dynamic / 1, pragma / 1, lib / 1"},"statistics/0":{"prefix":"statistics","body":"statistics","description":"statistics\n\n   Prints information about resource usage and garbage collection.\n\nArguments\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Prints information about resource usage and garbage collection on the\n   log_output stream.  This information is also provided by\n   statistics/2.  Please refer to statistics/2 for a description of the\n   statistic items.  Times are displayed in seconds, memory sizes in bytes.\n\nModes and Determinism\n   statistics is det\n\nExamples\n   \n?- statistics.\ntimes:    [25.53, 30.64, 31548.76] seconds\nsession_time:    31548.765625 seconds\nevent_time:    31548.765625 seconds\nhr_time:    567247.01280051 seconds\nglobal_stack_used:       2632 bytes\nglobal_stack_allocated:  4259840 bytes\nglobal_stack_peak:       134152192 bytes\ntrail_stack_used:    200 bytes\ntrail_stack_allocated:   327680 bytes\ntrail_stack_peak:    4259840 bytes\ncontrol_stack_used:      600 bytes\ncontrol_stack_allocated: 65536 bytes\ncontrol_stack_peak:      65536 bytes\nlocal_stack_used:    364 bytes\nlocal_stack_allocated:   65536 bytes\nlocal_stack_peak:    65536 bytes\nshared_heap_allocated:   2985984 bytes\nshared_heap_used:    2900104 bytes\nprivate_heap_allocated:  139264 bytes\nprivate_heap_used:       132048 bytes\ngc_number:    46 \ngc_collected:    6509080.0 bytes\ngc_area:    46688728 bytes\ngc_ratio:    0.303074122993982 %\ngc_time:    14.046 seconds\ndictionary_entries:      6699 \ndict_hash_usage:    3847 / 8192 \ndict_hash_collisions:    1327 / 3847 \ndict_gc_number:    23 \ndict_gc_time:    0.0 seconds\n\nSee Also\n   statistics / 2"},"clause/2":{"prefix":"clause","body":"clause(${1:Head}, ${2:Body})$3\n$0","description":"clause(+Head, -Body)\n\n   Succeeds if Head :- Body  is an existing dynamic clause.\n\nArguments\n   Head    Atom or compound term.\n   Body    Atom, variable or compound term.\n\nType\n   Dynamic Predicates\n\nDescription\n   Identical to clause((Head :- Body)).\n\nModes and Determinism\n   clause(+, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if no dynamic clause head unifies with Head\n\nSee Also\n   clause / 1"},"trimcore/0":{"prefix":"trimcore","body":"trimcore","description":"trimcore\n\n   Frees currently unused memory.\n\nType\n   Development Environment and Global Settings\n\nDescription\n\n   Calling this predicate will free some currently deallocated memory, such\n   as memory occupied by retracted and abolished clauses. It also\n   returns deallocated stack space back to the operating system.\n\nModes and Determinism\n   trimcore is det"},"profile/2":{"prefix":"profile","body":"profile(${1:Goal}, ${2:Flags})$3\n$0","description":"profile(+Goal, ++Flags)\n\n   Profile the goal and print the times spent in each predicate.\n\nArguments\n   Goal    Atom or a compound term.\n   Flags    List of atoms.\n\nType\n   Development Environment and Global Settings\n\nDescription\n   This predicate invokes the profiler.  The profiler first executes Goal\n   in profiling mode, which means that during its execution interrupts are\n   generated at regular intervals and the profiler remembers the currently\n   executing predicate.  When the goal succeeds or fails, the profiler\n   prints so, and then it prints the statistics about the time spent in\n   every encountered predicate.  Goal can be any Prolog goal, it does not\n   have to be compiled in a special profiling mode and no Prolog flags have\n   to be set.  The time spent in simple predicates (i.e. those with call_type\n   external, written in C) is counted towards their parent predicate.\n\n   In cases where the predicate name is not available, e.g. local goals in\n   a locked module, the information is grouped under a blank predicate\n   name entry for the module.\n\n   Flags is a list of option flags:\n   \n   simple\n       obsolete\n   keep_file\n       do not remove temporary data file when finished\n   \n\n   A temporary file <tmp_dir>/eclipse.prof.<pid> is used to collect the\n   profiling information and is removed upon exit (unless keep_file option\n   is given).\n\nModes and Determinism\n   profile(+, ++) is det\n\nExceptions\n     6 --- Flags contains an illegal flag.\n\nExamples\n   \n[eclipse 6]: profile(boyer, []).\nrewriting...\nproving...\ngoal succeeded\n\n    PROFILING STATISTICS\n    --------------------\n\nGoal:    boyer\nTotal user time:  10.55s\n\nPredicate    Module    %Time  Time\n-------------------------------------------------\n=..    /2  sepia_kernel   31.1%  3.28s\ngarbage_collect   /0  sepia_kernel   23.5%  2.48s\nrewrite    /2  eclipse    21.6%  2.28s\nrewrite_args      /2  eclipse    17.2%  1.82s\nequal    /2  eclipse    4.1%  0.43s\nremainder    /3  eclipse    0.9%  0.10s\n...\nplus    /3  eclipse    0.1%  0.01s\n\nyes.\n\nSee Also\n   get_flag / 2, profile / 1"},"statistics/2":{"prefix":"statistics","body":"statistics(${1:Keyword}, ${2:Value})$3\n$0","description":"statistics(?Keyword, -Value)\n\n   Succeeds if the statistics item Keyword has value Value.\n\nArguments\n   Keyword    Atom or Variable.\n   Value    Prolog term.\n\nType\n   Development Environment and Global Settings\n\nDescription\n   Used to retrieve various statistical information about the running\n   ECLiPSe .  To print a list of all the current values, statistics/0 can\n   be used.\n\n   The following list details the statistic items:\n\ncontrol_stack_allocated\n\n    Unit :  bytes\n\n    Description : The amount of control stack currently allocated. The\n    control stack is allocated in chunks, up to a maximum controlled by\n    the -l command line option. The local and control stacks share the\n    same memory area specified by the -l option, which thus gives the\n    maximum combined allocated size of these two stacks.\n\ncontrol_stack_peak\n\n    Unit : bytes\n\n    Description :   The peak allocated size of the control stack during\n    this session. Chunks of memory can be allocated to, and\n    deallocated from, the control stack as it grows and shrinks.\n\ncontrol_stack_used\n\n    Unit :   bytes\n\n    Description :   The amount of control stack currently in use.  This\n    stack holds information needed for backtracking.  \n\ndictionary_entries\n\n    Unit :   count\n\n    Description :   The number of atoms and functors that are currently\n    known to the system.  This is equal to the number of solutions\n    that current_functor/1 would return.\n\ndict_hash_usage\n\n    Type :  pair of integers Used/Avail\n\n    Description :   Returns two numbers: the number of actually used slots\n\tin the dictionary hash table, versus the number of available slots.\n\ndict_hash_collisions\n\n    Type :  pair of integers Collisions/Entries\n\n    Description :   Returns two numbers: the number of dictionary entries \n\tthat collided with existing hash table entries, versus the total\n\tnumber of dictionary hash table entries.\n\ndict_gc_number\n\n    Unit :   count\n\n    Description :   The number of dictionary garbage collections performed\n    during this session. \n\ndict_gc_time\n\n    Unit :   seconds (float)\n\n    Description :   The total cputime spent by all dictionary garbage\n    collections performed during this session.\n\nevent_time\n\n    Unit :   seconds (float)\n\n    Description :   Returns the elapsed real time (session_time) or \n    the elapsed user time (cputime) since the start of a \n    (parallel) ECLiPSe session depending on the value of the \n    after_event_timer flag.  \n\ngc_area\n\n    Unit :   bytes\n\n    Description :   The average area processed by a garbage collection.\n    This number should be close to the value of gc_interval.  If it\n    is much higher, gc_interval should be increased.\n\ngc_collected\n\n    Unit :   bytes (float)\n\n    Description :   The total number of bytes collected in the global\n    stack during all the garbage collections in this session.  This\n\tvalue is a float, to avoid overflow.\n\ngc_number\n\n    Unit :   count\n\n    Description :   The number of global/trail stack garbage\n    collections performed during this session.\n\ngc_ratio\n\n    Unit :   percent (float)\n\n    Description :   The average percentage of garbage found and\n    collected in the garbage collections performed so far.  If this\n    number is low, gc_interval should be increased.\n\ngc_time\n\n    Unit :   seconds (float)\n\n    Description :   The total time spent for all garbage collections in\n    this session.\n\nprivate_heap_allocated\n\n    Unit :   bytes\n\n    Description :   The amount of memory assigned to the private heap.\n    This area will never shrink.\n\nprivate_heap_used\n\n    Unit :   bytes\n\n    Description :   The amount of memory currently used for private\n    data.\n\nglobal_stack_allocated\n\n    Unit :   bytes\n\n    Description :   The amount of global stack currently allocated. The\n    global stack is allocated in chunks, up to a maximum controlled\n    by the -g command line option. The global stack and trail share the\n    same memory area specified by the -g option, which thus gives the\n    maximum possible combined allocated size of these two stacks.\n\nglobal_stack_peak\n\n    Unit :   bytes\n\n    Description :   The peak allocated size of the global stack during\n    this session. Chunks of memory can be allocated to, and\n    deallocated from, the global stack as it grows and shrinks.\n\nglobal_stack_used\n\n    Unit :   bytes\n\n    Description :   The amount of global stack currently in use.  The\n    global stack holds lists and structures and is subject to\n    garbage collection.\n\nhr_time\n\n    Unit :   seconds (float)\n\n    Description :   Returns the value of a high-resolution timer in seconds.\n\tThe precise meaning of this value is operating system and hardware\n\tdependent, but the resolution should be better than the other time\n\tstatistics, usually in the microsecond range.  Only differences\n\tbetween two such times are meaningful, the absolute value does not\n\thave any specific meaning.  If operating system or hardware do not\n\tprovide such a timer, the value is the same as session_time.\n\nlocal_stack_allocated\n\n    Unit :   bytes\n\n    Description : The amount of local stack currently allocated. The local\n    stack is allocated in chunks, up to a maximum controlled by the -l\n    command line option. The local and control stacks share the same\n    memory area specified by the -l option, which thus gives the\n    maximum combined allocated size of these two stacks.\n\nlocal_stack_peak\n\n    Unit :   bytes\n\n    Description :   The peak allocated size of the local stack during\n    this session. Chunks of memory can be allocated to, and\n    deallocated from, the local stack as it grows and shrinks.\n\nlocal_stack_used\n\n    Unit :   bytes\n\n    Description :   The amount of local stack currently in use.  This\n    stack holds Prolog variables and return addresses.  \n\nglobal_stack\n\n    Unit :   List of bytes\n\n    Description : Returns a list of two numbers for the allocated global\n       stack: the number of bytes currently used, and the number of bytes\n       currently free. It is provided mainly for compatibility.\n\nlocal_stack\n\n    Unit :   List of bytes\n\n    Description : Returns a list of two numbers on the current usage of the\n       allocated local and control stacks. In the original WAM, these two\n       stacks are combined into a single stack. This is provided for\n       compatibility purposes only.\n\ntrail\n\n    Unit :   List of bytes\n\n    Description : Returns a list of two numbers for the allocated trail:\n    the number of bytes currently used, and the number of bytes\n    currently free. It is provided mainly for compatibility.\n\nruntime\n\n    Unit :   List of milliseconds (integers)\n\n    Description :   Returns a list of two times:  user cpu time since\n    the start of the ECLiPSe session, user cpu time since the last\n    call to statistics(runtime, _). As from ECLiPSe 4.2, these times\n\texclude the time spent in garbage collection. This item is provided\n    primarily for compatibility reasons.\n\nsession_time\n\n    Unit :   seconds (float)\n\n    Description :   Returns the real time elapsed since the start of a\n    (parallel) ECLiPSe session.  This is the only timer that can be\n    reliably used in a parallel execution, since it accesses a\n    central clock.  All other timers are local to the worker where\n    they are accessed.\n\nshared_heap_allocated\n\n    Unit :   bytes\n\n    Description :   The amount of memory assigned to the code heap, i.e.\n    the area used for storing compiled Prolog code, atoms, records,\n    non-logical variables, descriptors, buffers etc.  This area will\n    never shrink.\n\nshared_heap_used\n\n    Unit :   bytes\n\n    Description :   The amount of memory currently used for compiled\n    Prolog code, atoms, records, non-logical variables, descriptors,\n    buffers etc.\n\ntimes\n\n    Unit :   List of seconds (floats)\n\n    Description :   Returns a list of three times:  user cpu time,\n    system cpu time and real time elapsed since the start of the\n    ECLiPSe session.\n\ntrail_stack_allocated\n\n    Unit :   bytes\n\n    Description : The amount of trail stack currently allocated. The trail\n    is allocated in chunks, up to a maximum controlled by the -g\n    command line option. The global stack and trail share the same\n    memory area specified by the -g option, which thus gives the\n    maximum possible combined allocated size of these two stacks.\n\ntrail_stack_peak\n\n    Unit :   bytes\n\n    Description : The peak allocated size of the trail stack during\n    this session. Chunks of memory can be allocated to, and\n    deallocated from, the trail stack as it grows and shrinks.\n\ntrail_stack_used\n\n    Unit :   bytes\n\n    Description :   The amount of trail stack currently in use.  The\n    trail stack records information needed for backtracking and is\n    subject to garbage collection.\n\nNOTE: library(quintus) contains a compatibility version of statistics/2\nwhich accepts the following different keywords:  runtime, system_time,\nreal_time, walltime, memory, program, global_stack,  local_stack, trail,\nchoice, stacks, garbage_collection, stack_shifts, atoms,\natom_garbage_collection, core, heap.\n\nModes and Determinism\n   statistics(-, -) is multi\n   statistics(+, -) is det\n\nExceptions\n     5 --- Keyword is neither an atom nor variable.\n\nExamples\n   \nSuccess:\n   [eclipse]: statistics(times, [_,_,T]).\n   T = 2848.64\n   yes.\n   [eclipse]: statistics(global_stack_used, G).\n   G = 136\n   yes.\nFail:\n   statistics(times, [T]).\nError:\n   statistics(\"time\", T).    (Error 5)\n\nSee Also\n   set_flag / 2, env / 0, statistics / 0"},"cancel_after_event/2":{"prefix":"cancel_after_event","body":"cancel_after_event(${1:Event}, ${2:CancelledEvents})$3\n$0","description":"cancel_after_event(+Event, -CancelledEvents)\n\n   Cancel all pending instances of after event Event\n\nArguments\n   Event    Atom or Handle\n   CancelledEvents     Variable\n\nType\n   Event Handling\n\nDescription\n   All instances of the pending after event Event is \n   cancelled so that the event will not be triggered. A pending after event \n   is an event which is setup by either event_after/2, event_after/3 or \n   event_after_every/2, and which is waiting to be raised \n   (event_after_every/2 will always be pending as it is raised repeatedly).\n\n   CancelledEvents is the list of after events that have been cancelled. \n   Each element of CancelledEvents is of the form of an event specified\n   in Events of events_after / 1. As a result, CancelledEvents can be\n   reposted using events_after(CancelledEvents). If there was no event\n   to cancel, CancelledEvents will be bound to the empty list.\n\n   Note that the processing of an already raised, but as yet unprocessed\n   event will not be cancelled by this predicate (but you can use\n   event_disable/1 to achieve this).\n\nModes and Determinism\n   cancel_after_event(+, -) is det\n\nExceptions\n     5 --- Event is not an atom.\n\nExamples\n   \n    % setup an after event and cancel immediatedly\n    ?- event_create(writeln(hi), [], E),\n\tevent_after(E, 3.2),\n\tcancel_after_event(E, Cancelled).\n    E = 'EVENT'(16'ed980a58)\n    Cancelled = ['EVENT'(16'ed980a58) - 3.1999999999999886]\n    Yes (0.00s cpu)\n\n    % no after-event requested, nothing to cancel\n    ?- event_create(writeln(hi), [], E),\n\tcancel_after_event(E, Cancelled).\n    E = 'EVENT'(16'ed980a58)\n    Cancelled = []\n    Yes (0.00s cpu)\n\n    % setup an after event and cancel immediatedly\n    ?- event_create(writeln(hi), [], E1),\n\tevent_after_every(E1, 1),\n\tevent_create((cancel_after_event(E1, C1), writeln(cancelled(C1))), [], E2),\n\tevent_after(E2, 5),\n\trepeat, fail.\n    hi\n    hi\n    hi\n    hi\n    cancelled(['EVENT'(16'edbc0cc0) - every(1)])\n\nSee Also\n   event_after / 2, event_after / 3, event_disable / 1, event_after_every / 2, event / 1, set_event_handler / 2, current_after_events / 1, event_create / 3, event_retrieve / 3"},"current_error/1":{"prefix":"current_error","body":"current_error(${1:N})$2\n$0","description":"current_error(?N)\n\n   Succeeds if N unifies with a valid error number.\n\nArguments\n   N    Positive integer or variable.\n\nType\n   Event Handling\n\nDescription\n   Used to generate on backtracking all the current valid error numbers.  N\n   is a variable.\n\n   Also used to check that N is a valid error number.  N is an integer.\n\nModes and Determinism\n   current_error(+) is semidet\n   current_error(-) is multi\n\nFail Conditions\n   Fails if N is not a valid error number.\n\nExceptions\n     5 --- N is instantiated, but not to an integer.\n\nExamples\n   \nSuccess:\n      ?- current_error(N).\n      N = 1     More? (;)       % type `;'\n      N = 2     More? (;)\n      N = 4     More? (;)\n      N = 5     More? (;)       % carriage return typed\n      yes.\n\n      ?- [user].\n       list_error1(String, N, Message) :-\n    current_error(N),\n    error_id(N, Message),\n    substring(Message, String, _).\n       user compiled 208 bytes in 0.03 seconds\n\n      ?- list_error1(\"def\",N,M).\n      N = 21\n      M = \"undefined arithmetic expression\"     More? (;)\n      yes.\n\nFail:\n      current_error(3).\n\nError:\n      current_error(1.0).   (Error 5).\n\nSee Also\n   error_id / 2"},"current_after_events/1":{"prefix":"current_after_events","body":"current_after_events(${1:Events})$2\n$0","description":"current_after_events(-Events)\n\n      Check or find currently pending after events.\n\nArguments\n   Events    List of due / 2 structures or variable\n\nType\n   Event Handling\n\nDescription\n\n   If Events is a variable, then all the currently pending\n   events are returned as a list. The list elements are of the \n   form due(EventName - PostTime, DueTime) for an event raised with\n   event_after/2 and event_after/3 and of the form\n   due(EventName - every(Interval), NextDueTime) for an event raised \n   with event_after_every/2. An event will appear as many times as it\n   has been setup.   EventName is the name of the after event. PostTime is\n   the time at which the event was posted, and DueTime the time at which it \n   is to be raised. For a repeating after event, Interval is the period\n   between events, and NextDueTime is the next time at which it is to be raised.\n\n   Note that this predicate simply returns a snapshot of the current pending\n   after events. It is therefore possible that an after event returned in Events\n   has already been raised.\n\nModes and Determinism\n   current_after_events(-) is det\n\nExamples\n   \n   setup :-\n      set_event_handler(hi, hi/0),\n      event_after_every(hi, 3.2).\n\n   hi :-\n      current_after_events(Es),\n      writeln(hi),\n      writeln('Pending events'-Es).\n\n   % just spinning after the setup for events to be raised.\n   ?- setup, repeat, fail.  \n    hi\n    Pending events - [due(hi - every(3.2), 30.51)]\n    hi\n    Pending events - [due(hi - every(3.2), 33.72)]\n    hi\n    Pending events - [due(hi - every(3.2), 36.93)]\n    ...\n\nSee Also\n   event_after / 2, event_after / 3, event_after_every / 2, event / 1, set_event_handler / 2, event_create / 3, event_retrieve / 3"},"error/2":{"prefix":"error","body":"error(${1:EventId}, ${2:Culprit})$3\n$0","description":"error(+EventId, ?Culprit)\n\n   An error or event EventId is raised and the corresponding error handler is executed\n\nArguments\n   EventId    Atom, integer or structure with functor default/1.\n   Culprit    Prolog term.\n\nType\n   Event Handling\n\nDescription\n   The event or error EventId with Culprit as its culprit goal is raised.\n   EventId is either an integer error number, or an atomic event name.\n   The error handler which is associated with EventId is invoked,\n   with its first argument set to EventId, its second argument to Culprit,\n   and its third argument and fourth argument are the context module in\n   which error/2 is invoked. If the handler has less than four arguments,\n   the extra information is lost.\n\n   This simulates an occurrence of the error EventId inside a call\n   to Culprit.  The valid error numbers are those returned by\n   current_error/1.  Event names can be any atom as long as an event handler\n   has been defined for them.\n\n   If EventId is a structure with functor default/1, the structure's argument\n   is taken as the error number and the default handler is executed, even\n   if the error handler has been redefined using set_event_handler/2.\n   This is useful for writing user error handlers.\n\n   If the event handler succeeds, possibly binding some variables\n   inside Culprit, then error/2 succeeds as well. If the handler fails\n   or calls exit_block/1, then so does error/2.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the handler fails\n\nResatisfiable\n   Resatisfiable if the handler is resatisfiable\n\nExceptions\n     4 --- EventId is not instantiated.\n     5 --- EventId is not an error specification.\n     6 --- EventId is a number but not a valid error number.\n    32 --- No handler is associated to EventId\n\nExamples\n   \nSuccess:\n\n   % Writing a predicate with type checking\n    ?- [user].\n     is_positive(N) :-\n    number(N),\n    !,\n    N >= 0.\n     is_positive(N) :-\n    error(5, is_positive(N)).\n     user compiled 244 bytes in 0.02 seconds\n    yes.\n\n    ?- is_positive(a).\n    type error in is_positive(a)\n\n   % changing the behaviour of a built-in by redefining a handler\n    ?- //(1,0,X).       % change this behaviour\n    arithmetic exception in //(1, 0, X)\n\n    ?- [user].    % define the new handler\n     my_handler(_, //(_,_,Result)) :-\n    !,\n    Result = infinity.\n     my_handler(Err, Goal) :-\n    error(default(Err), Goal).\n     user compiled 212 bytes in 0.00 seconds\n    yes.\n\n    ?- set_event_handler(20, my_handler/2).\n    yes.\n\n    ?- //(1,0,X).      % check if it works\n    X = infinity\n    yes.\n\n    ?- sqrt(-1,X).   % other culprits: as before\n    arithmetic exception in sqrt(-1, _g36)\n\nError:\n      error(N,dummy(1)).    (Error 4).\n      error(5.0,dummy(1)).  (Error 5).\n      error(-2,dummy(1)).   (Error 6).\n\nSee Also\n   error / 3, event / 1, current_error / 1, error_id / 2, get_event_handler / 3, reset_event_handler / 1, reset_error_handlers / 0, set_event_handler / 2"},"current_interrupt/2":{"prefix":"current_interrupt","body":"current_interrupt(${1:N}, ${2:IntID})$3\n$0","description":"current_interrupt(?N, ?IntID)\n\n   Succeeds if N unifies with the number and IntID unifies with the mnemonic\nname of a valid interrupt.\n\nArguments\n   N    Positive integer or variable.\n   IntID    Atom or variable.\n\nType\n   Event Handling\n\nDescription\n   This predicate unifies N with the signal number and IntID with the\n   mnemonic name of an existing interrupt type.  This predicate can be used\n   to find the signal number related to a mnemonic interrupt name and vice\n   versa, or to return all valid interrupts on backtracking.\n\nModes and Determinism\n   current_interrupt(-, -) is multi\n   current_interrupt(+, -) is semidet\n   current_interrupt(-, +) is semidet\n\nFail Conditions\n   N or IntID do not unify with the interrupt number resp.  the mnemonic name of a valid interrupt\n\nExceptions\n     5 --- N is instantiated, but not to an integer.\n     5 --- IntID is instantiated, but not to an atom.\n\nExamples\n   \nSuccess:\n      current_interrupt(2, X)    (gives X = int)\n      current_interrupt(X, kill)      (gives X = 9)\n      current_interrupt(N, Int)\nFail:\n      current_interrupt(43, Int)\n      current_interrupt(N, noint)\nError:\n      current_interrupt(1.0, Int).    (Error 5).\n      current_interrupt(N, \"int\").    (Error 5).\n\nSee Also\n   current_error / 1, kill / 2"},"event/1":{"prefix":"event","body":"event(${1:EventId})$2\n$0","description":"event(+EventId)\n\n   The event EventId is raised and the corresponding error handler is\nexecuted.\n\nArguments\n   EventId    Atom or event Handle, or a list of atoms and/or event handles.\n\nType\n   Event Handling\n\nDescription\n   The event EventId is raised and the corresponding error handler is\n   executed.\n\n   Other ways to raise events are by\n\n   - one of the builtins error/2 or error/3.\n   - posting an event from external code using ec_post_event().\n   - an interrupt whose handler has been specified as event/1.\n\n   The latter two have the effect of dynamically inserting an event/1\n   goal into the current execution at the next synchronous point,\n   which is usually just before the next predicate call.\n\nFail Conditions\n   Fails if the handler fails\n\nResatisfiable\n   Resatisfiable if the handler is resatisfiable\n\nExceptions\n     4 --- EventId is not ground\n     5 --- EventId is instantiated, but neither an atom nor an event handle, or a list of them\n    32 --- No handler is associated to an atomic EventId\n\nExamples\n   \n    ?- event(hello).\n    warning: no handler for event in hello\n    yes.\n\n    ?- set_event_handler(hello, writeln/1).    \n    yes.\n\n    ?- event(hello).\n    hello\n    yes.\n\n    ?- event([hello,hello]).\n    hello\n    hello\n    Yes (0.00s cpu)\n\nSee Also\n   event_create / 3, is_event / 1, error / 2, error / 3, reset_event_handler / 1, set_event_handler / 2, set_interrupt_handler / 2"},"event_after/2":{"prefix":"event_after","body":"event_after(${1:Event}, ${2:Time})$3\n$0","description":"event_after(+Event, +Time)\n\n      Set up an event Event which is triggered after Time seconds have\n   elapsed.\n\nArguments\n   Event    Atom or Handle\n   Time    Positive number\n\nType\n   Event Handling\n\nDescription\n   The event Event is raised after Time seconds of elapsed time from when\n   the predicate is executed. Every call to event_after/2 will cause exactly\n   one corresponding event, if the same event is requested several times, it\n   will be raised several times. The event mechanism is safe with respect to\n   backtracking: once an after-event has been requested, it will be raised,\n   even when execution fails across the point where it was requested.\n\n   Time can be a real number, but the actual granularity of how fine\n   the elapsed time is measured is operating system dependent, and the\n   triggering condition is actually that at least Time seconds have\n   elapsed.\n\n   In addition, the processing of an event may not happen immediately\n   upon the raising the event, as events are processed synchronously:\n   An event can only be handled at a point where an ECLiPSe goal can\n   be executed. This can delay the handling of an event when ECLiPSe is\n   performing some uninterruptible task, e.g. waiting for I/O, or executing\n   external code.\n\n   The use of after-events requires some thought because after-events can\n   be raised at unpredictable (even though well-defined) points during\n   program execution. As long as the handlers succeed, this poses no\n   particular problem, because execution is allowed to continue after the\n   handler succeeds. By design, the possibilities of an event handler to\n   interact with the interrupted execution are limited (the handler can\n   access global data structures, use a symbolic trigger, etc).\n\n   More problematic are applications where the handler is allowed to\n   abort using exit_block/1.  Due to the timed execution, the exact\n   program point where the abort happens is unpredictable.  It must be\n   made sure that the abort is safely caught in all cases, and that\n   nonlogical data is not left in an inconsistent state.  In such cases,\n   it is possible to use events_defer/0 and events_nodefer/0 to protect\n   critical code sequences from being interrupted by event handling.\n   Note that it never makes sense to let after-event handlers fail.\n\n   Another problem that may occur with timed events is that a new\n   event may be raised while another one is still being handled.  To\n   stop event handlers from being interrupted by others, it is possible\n   to give events the defer-property.  This means that event handling\n   is automatically deferred on entering the event's handler, thus\n   preventing other events from interrupting the handler.  Such handlers\n   must always explicitly invoke events_nodefer/0 before exiting in order\n   to reenable event handling.\n\n   The timer used by measuring elapsed time is specified by the environment\n   flag after_event_timer: virtual means that elapsed user cpu time is\n   used, real means elapsed real time. The default is real. On\n   systems that cannot support CPU time measurement, such as Microsoft\n   Windows, one may not set the timer to virtual: an error is raised\n   if this is attempted.  The time relevant for event handling can be\n   obtained by calling statistics(event_time, Now).\n\nModes and Determinism\n   event_after(+, +) is det\n\nExceptions\n     5 --- Event is neither an atom nor a handle or Time is not a positive number.\n\nExamples\n   \n   ?- event_create(writeln(hi), [], E),\n      event_after(E, 3.2),\n      event_create(abort, [], E1),\n      event_after(E1, 5),\n      repeat, fail.\n   hi\t\t\t\t% after 3.2 seconds\n   Aborting execution ...\t% after 5 seconds\n   Abort\n\nSee Also\n   event_after / 3, event_after_every / 2, cancel_after_event / 2, events_after / 1, event / 1, set_event_handler / 2, current_after_events / 1, event_create / 3, event_retrieve / 3, get_flag / 2, statistics / 2"},"event_after_every/2":{"prefix":"event_after_every","body":"event_after_every(${1:Event}, ${2:Time})$3\n$0","description":"event_after_every(+Event, +Time)\n\n      Set up an event Event which is triggered after every Time seconds have\n   elapsed.\n\nArguments\n   Event    Atom or Handle\n   Time    Positive number\n\nType\n   Event Handling\n\nDescription\n   The event Event is raised after every Time seconds of elapsed time from when\n   the predicate is executed.  The difference from event_after/2 and event_after/3\n   is that event_after_every/2 raises the event Event at regular Time intervals \n   once it is initiated, whereas event_after/2 and event_after/3 \n   raise the event once (per event_after/2 and event_after/3) only.  The time\n   for the next event starts counting from the moment the previous event is\n   raised. This means that the time between the raising of two events will\n   never fall below the Time interval, even if there is a delay in raising\n   one of the events.  The event mechanism is safe with respect to\n   backtracking: once an after-event has been requested, it will be raised,\n   even when execution fails across the point where it was requested.\n   The only way to stop further after-every-events being raised is to cancel\n   them using cancel_after_event/2.\n\n   Time can be a real number, but the actual granularity of how fine\n   the elapsed time is measured is operating system dependent, and the\n   triggering condition is actually that at least Time seconds have\n   elapsed.\n\n   In addition, the processing of an event may not happen immediately\n   upon the raising the event, as events are processed synchronously:\n   An event can only be handled at a point where an ECLiPSe goal can\n   be executed. This can delay the handling of an event when ECLiPSe is\n   performing some uninterruptible task, e.g. waiting for I/O, or executing\n   external code.\n\n   The use of after-events requires some thought because after-events can\n   be raised at unpredictable (even though well-defined) points during\n   program execution. As long as the handlers succeed, this poses no\n   particular problem, because execution is allowed to continue after the\n   handler succeeds. By design, the possibilities of an event handler to\n   interact with the interrupted execution are limited (the handler can\n   access global data structures, use a symbolic trigger, etc).\n\n   More problematic are applications where the handler is allowed to\n   abort using exit_block/1.  Due to the timed execution, the exact\n   program point where the abort happens is unpredictable.  It must be\n   made sure that the abort is safely caught in all cases, and that\n   nonlogical data is not left in an inconsistent state.  In such cases,\n   it is possible to use events_defer/0 and events_nodefer/0 to protect\n   critical code sequences from being interrupted by event handling.\n   Note that it never makes sense to let after-event handlers fail.\n\n   Another problem that may occur with timed events is that a new\n   event may be raised while another one is still being handled.  To\n   stop event handlers from being interrupted by others, it is possible\n   to give events the defer-property.  This means that event handling\n   is automatically deferred on entering the event's handler, thus\n   preventing other events from interrupting the handler.  Such handlers\n   must always explicitly invoke events_nodefer/0 before exiting in order\n   to reenable event handling.\n\n   The timer used by measuring elapsed time is specified by the environment\n   flag after_event_timer: virtual means that elapsed user cpu time is\n   used, real means elapsed real time. The default is real. On\n   systems that cannot support CPU time measurement, such as Microsoft\n   Windows, one may not set the timer to virtual: an error is raised\n   if this is attempted.  The time relevant for event handling can be\n   obtained by calling statistics(event_time, Now).\n\nModes and Determinism\n   event_after_every(+, +) is det\n\nExceptions\n     5 --- Event is neither an atom nor a handle or Time is not a positive number.\n\nExamples\n   \n    ?- event_create((statistics(event_time,T),writeln(now(T))), [], E),\n\tevent_after_every(E, 1),\n\trepeat,fail.\n    now(4.61)\t% after 1 second\n    now(5.62)\t% after 2 seconds\n    now(6.63)\n    now(7.64)\n    now(8.65)\n    ...\n\nSee Also\n   event_after / 2, event_after / 3, events_after / 1, cancel_after_event / 2, event / 1, set_event_handler / 2, current_after_events / 1, event_create / 3, event_retrieve / 3, get_flag / 2"},"event_create/3":{"prefix":"event_create","body":"event_create(${1:Goal}, ${2:Options}, ${3:EventHandle})$4\n$0","description":"event_create(+Goal, ++Options, -EventHandle)\n\n   Create an ECLiPSe event from an arbitrary goal.\n\nArguments\n   Goal    An arbitrary goal\n   Options    A list of atoms.\n   EventHandle    A free variable\n\nType\n   Event Handling\n\nDescription\n\tThis creates an event from the goal provided, which can be raised \n\twith the standard event handling predicates (e.g. event / 1, event_after / 2\n\tand event_after_every / 2) using the associated handle.\n    \n\tThe event creation requires non-logical copying of the goal.\n\tAs a result, if the goal contains variables, they lose their identity \n\tand are replaced with fresh ones.\n    \n\tThe intended use of such events are for localised event handling\n\tor when it is necessary to pass ground parameters to the event goal,\n\ti.e. when the use of a global event handler is unnecessary or does not suffice.\n    \n\tIt should be noted that the event handle is the only way to uniquely\n\tidentify a given event.  E.g. if an event has been scheduled as an\n\tafter-event (using event_after/3 or events_after/2), it can only be\n\tcancelled by invoking cancel_after_event/2 with the correct handle.\n    \n    The following options are recognised:\n\t\n\tdefers\n\t    Give the event the defers-property.  This means that event\n\t    handling is automatically deferred on entering the event's handler,\n\t    thus preventing other events from interrupting the handler.\n\t    Such handlers must always explicitly invoke events_nodefer/0\n\t    before exiting in order to reenable event handling.\n\t\n    \n\nModes and Determinism\n   event_create(+, ++, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Goal is not instantiated\n     5 --- Goal is not a valid goal\n     5 --- EventHandle is not a free variable\n     5 --- Options is not a list of atoms\n     6 --- Some element of Options is not a valid option\n\nExamples\n       % Create and raise a single event\n    ?-  event_create(writeln('Goodbye cruel world!'), [], Event),\n    \twriteln('Hello world!'),\n\tevent(Event).\n    Hello world!\n    Goodbye cruel world!\n    Event = 'EVENT'(16'503f0238)\n    Yes (0.00s cpu)\n\n    % Raise events via a timer\n    ?-  event_create(writeln('e1'), [], E1Event),\n\tevent_create(writeln('e2'), [], E2Event),\n    \tevents_after([E1Event-every(0.2), E2Event-0.5]),\n    \trepeat, fail.\n    e1\n    e1\n    e2\n    e1\n    e1\n    ^C\n    interruption: type a, b, c, e, or h for help : ? e1\n    abort\n    Aborting execution ...\n\n    % By default, event handlers are allowed to interrupt each other,\n    % which can make it seem that they are handled in reverse order:\n    ?-  event_create(writeln('e1'), [], E1Event),\n\tevent_create(writeln('e2'), [], E2Event),\n\tevent([E1Event,E2Event]).\t% raise both events together\n    e2\n    e1\n    E1Event = 'EVENT'(16'ed9b0010)\n    E2Event = 'EVENT'(16'ed770b20)\n    Yes (0.00s cpu)\n\n    % By default, event handlers are allowed to interrupt each other,\n    % which can make it seem that they are handled in reverse order:\n    ?-  event_create((writeln('e1'),events_nodefer), [defers], E1Event),\n\tevent_create((writeln('e2'),events_nodefer), [defers], E2Event),\n\tevent([E1Event,E2Event]).\t% raise both events together\n    e1\n    e2\n    E1Event = 'EVENT'(16'ed9b0010)\n    E2Event = 'EVENT'(16'ed770b20)\n    Yes (0.00s cpu)\n    \n\nSee Also\n   event_retrieve / 3, event / 1, event_after / 2, event_after / 3, event_after_every / 2, set_event_handler / 2, current_after_events / 1, cancel_after_event / 2, is_event / 1, events_nodefer / 0"},"events_defer/0":{"prefix":"events_defer","body":"events_defer","description":"events_defer\n\n   Defer event handling\n\nType\n   Event Handling\n\nDescription\n    \tDefer event handling until a subsequent call to events_nodefer/0.\n\tThe purpose of this feature is to\n\t\n\t    sequence event handlers so they don't interrupt each other\n\t    protect accesses to global data structures from being interrupted\n\t\tor preempted by events.\n\t\n\tEvents whose handling will be deferred are:\n\t\n\t    events raised by the builtin event/1\n\t    events posted from external code using ec_post_event()\n\t    events raised by interrupts whose handler is event/1\n\t\n\tEvents that are raised while event handling is deferred will be\n\tqueued and handled later.\n    \n\tEvent handling is also automatically deferred when entering the\n\tevent handlers of events that have the defer-property set (see\n\tevent_create/3 and set_event_handler/2).\n    \n    \tThe predicate fails (and has no further effect) if event handling\n\tis already deferred. This feature should be used to make sure that\n\tevent handling is not accidentally reenabled in a nested situation.\n\tE.g.\n\t\n\t    ...,\n\t    ( events_defer ->\n\t    <manipulate protected data>\n\t\tevents_nodefer\n\t    ;\n\t\t% events already deferred\n\t    <manipulate protected data>\n\t    ),\n\t    ...\n\t\n\n    \n\tCAUTION: events_defer/0 is a low-level primitive that must be\n\tused with great care. Part of ECLiPSe's functionality (e.g. timeout,\n\tbranch-and-bound) relies on event handling and will not work\n\tproperly while event handling is deferred. Deferring and undeferring\n\tevents are nonlogical operations which are not undone on backtracking.\n\tThe programmer must therefore make sure that every time event handling\n\tis deferred, it is eventually reenabled by a call to events_nodefer/0,\n\teven in case of failure or abort in the deferred code sequence.\n    \n    \n\nModes and Determinism\n   events_defer is semidet\n\nFail Conditions\n   Fails iff event handling is already deferred\n\nExamples\n       ?- event_create(writeln(hello), [], E),\n\t    event(E),\n\t    writeln(deferring),\n\t    events_defer,\n\t    event(E),\n\t    writeln(nodeferring),\n\t    events_nodefer.\n    hello\n    deferring\n    nodeferring\n    hello\n    \n\nSee Also\n   event_create / 3, event / 1, events_nodefer / 0, set_event_handler / 2"},"event_after/3":{"prefix":"event_after","body":"event_after(${1:Event}, ${2:Time}, ${3:DueTime})$4\n$0","description":"event_after(+Event, +Time, -DueTime)\n\n   Set up an event Event which is triggered at DueTime, after Time seconds have elapsed\n\nArguments\n   Event    Atom or Handle\n   Time    Positive number\n   DueTime    Variable, will be bound to a float\n\nType\n   Event Handling\n\nDescription\n   The event Event is raised after Time seconds of elapsed time from when\n   the predicate is executed.  This is identical to event_after/2, except\n   that DueTime gets bound to the time at which the event will be raised.\n   This time can be compared to the the current event_time as returned by\n   statistics/2.\n\n   For more details, see event_after/2.\n\nModes and Determinism\n   event_after(+, +, -) is det\n\nExceptions\n     5 --- Event is neither an atom nor a handle or Time is not a positive number.\n\nExamples\n   \n    % With the following the handler definition\n    report_due(DueTime) :-\n\t Remaining is DueTime - statistics(event_time),\n\t printf(\"Event is due in %w seconds%n\", [Remaining]).\n\n    ?- event_create(abort, [], E1),\n\tevent_after(E1, 5, Due),\n\tevent_create(report_due(Due), [], E2),\n\tevent_after_every(E2, 1),\n\trepeat, fail.\n    Event is due in 3.98999999999999 seconds\n    Event is due in 2.98 seconds\n    Event is due in 1.97 seconds\n    Event is due in 0.959999999999994 seconds\n    Aborting execution ...\n    Abort\n\nSee Also\n   event_after / 2, event_after_every / 2, cancel_after_event / 2, events_after / 1, event / 1, set_event_handler / 2, current_after_events / 1, event_create / 3, event_retrieve / 3, get_flag / 2, statistics / 2"},"event_retrieve/3":{"prefix":"event_retrieve","body":"event_retrieve(${1:EventHandle}, ${2:Goal}, ${3:Module})$4\n$0","description":"event_retrieve(+EventHandle, -Goal, -Module)\n\n   Given the handle with which an event is associated, retrieve the event goal and module\n\nArguments\n   EventHandle    An event handle\n   Goal    A free variable or goal to unify\n   Module    A free variable or module name\n\nType\n   Event Handling\n\nDescription\n\tThe goal associated with an event handle, created using event_create/3,\n\tis retrieved using this predicate. It also returns the context module\n\tin which the event was created (and where the goal should be called).\n    \n\tLike event creation, retrieval of the goal produces a copy of the\n\tgoal. As a result, if the goal contains variables, they lose their\n\tidentity and are replaced with fresh ones.\n    \n    If the event was disabled, the goal 'true' is retrieved instead of the\n\toriginal goal.\n    \n\nModes and Determinism\n   event_retrieve(+, -, -) is det\n\nExceptions\n     4 --- EventHandle is un-instantiated\n     5 --- EventHandle is not a handle\n\nExamples\n       ?- event_create(writeln('Hello world!'), [], Event),\n    \tevent_retrieve(Event, EventGoal, Module).\n\n    Event = 'EVENT'(16'50421bd0)\n    EventGoal = writeln('Hello world!')\n    Module = eclipse\n    Yes (0.00s cpu)\n    \n\nSee Also\n   event_create / 3, event / 1, event_after / 2, event_after / 3, event_after_every / 2, set_event_handler / 2, current_after_events / 1, cancel_after_event / 2, is_event / 1, event_disable / 1, event_enable / 1"},"error_id/2":{"prefix":"error_id","body":"error_id(${1:N}, ${2:Message})$3\n$0","description":"error_id(+N, -Message)\n\n   Succeeds if Message unifies with the error message string defined for error\nnumber N.\n\nArguments\n   N    Positive integer.\n   Message    String or variable.\n\nType\n   Event Handling\n\nDescription\n   This predicate unifies Message with the message string defined for error\n   number N.\n\nModes and Determinism\n   error_id(+, -) is det\n\nExceptions\n     4 --- N is not instantiated.\n     5 --- N is instantiated, but not to an integer.\n     5 --- Message is instantiated, but not to a string.\n\nExamples\n   \nSuccess:\n      error_id(80,M).\n    (gives M=\"not a module\").\n      error_id(70,M).\n    (gives M=\"accessing an undefined dynamic procedure\").\n      error_id(60,M).\n    (gives M=\"accessing an undefined procedure\").\n      error_id(90,M).\n    (gives M=\"declaration not at module beginning\").\n\n      ?- [user].\n       warning_handler(X, Where) :-\n    write('(warning) '),\n    error_id(X, Message),\n    write(Message),\n    write(' in '),\n    write(Where).\n       user compiled 332 bytes in 0.05 seconds\n\n      ?- warning_handler(60,dummy).\n      (warning) accessing an undefined procedure in dummy\n      yes.\n\n      ?- [user].\n       fail_warning(N, Where) :-\n    write(\"Warning: Failure due to \"),\n    error_id(N, Errmsg),\n    write(Errmsg),\n    write(\":\"-Where),\n    fail.\n       user compiled 328 bytes in 0.00 seconds\n      yes.\n\n      ?- set_event_handler(68, fail_warning/2).\n      yes.\n\n      ?- p.\n      Warning: Failure due to calling an undefined procedure: - p\n      no.\nFail:\n      error_id(60,\"procedure not defined\").\nError:\n      error_id(N,\"not a module\").    (Error 4).\n      error_id(1.0,M).    (Error 5).\n      error_id(1,atom).    (Error 5).\n\nSee Also"},"events_after/1":{"prefix":"events_after","body":"events_after(${1:Events})$2\n$0","description":"events_after(++Events)\n\n      Set up a series of after events Events. \n\nArguments\n   Events    A list of the form Event-Time or Event-every(Time)\n\nType\n   Event Handling\n\nDescription\n   Events is a list of after events where each element of the list\n   specifies one after event. Each element is either in the form of\n   EventName-Time or EventName-every(Time) where the first form is\n   equivalent to event_after(EventName, Time) and the second to\n   event_after_every(EventName, Time). The difference between using\n   a single events_after/1 and multiple calls to event_after/2, \n   event_after/3 and event_after_every/2 to set up a series of after \n   events is that with events_after/1, all the events are set up as a \n   unit, and it is guaranteed that the relative orderings between the \n   events are preserved, and that no after events will be raised until\n   all the specified events have been set up.\n\n   The main use of events_after/1 is for restart event that have been\n   cancelled previously with cancel_after_event/2.\n\n   See event_after/2, event_after/3 or event_after_every/2 for more details\n   on after events.\n\nModes and Determinism\n   events_after(++) is det\n\nExceptions\n     4 --- Events is not instantiated.\n     5 --- Events is not a list of after events of the form Event-Time or Event-every(Time), where Event is an atom or a handle and Time is a positive (non-breal) number.\n\nExamples\n   \n    % set event handlers to write the event name\n    ?- set_event_handler(e1, writeln/1),\n    \tset_event_handler(e2, writeln/1).\n    Yes (0.00s cpu)\n\n    ?- events_after([e1-every(0.2), e2-0.5]),\n    \trepeat,fail.\n    e1\n    e1\n    e2\n    e1\n    e1\n    e1\n    ^C\n    interruption: type a, b, c, e, or h for help : ? a\n    abort\n    Aborting execution ...\n    Abort\n\n    % cancel further e1 events\n    ?- cancel_after_event(e1, Cancelled).\n    Cancelled = [e1 - every(0.2)]\n    Yes (0.00s cpu)\n\n    % e2 was already raised, nothing to cancel\n    ?- cancel_after_event(e2, Cancelled).\n    Cancelled = []\n    Yes (0.00s cpu)\n\n    % restart the cancelled events\n    ?- events_after([e1 - every(0.2)]),\n\t    repeat, fail.\n    e1\n    e1\n    e1\n    e1\n    ...\n\nSee Also\n   event_after / 2, event_after / 3, event_after_every / 2, cancel_after_event / 2, events_after / 1, event / 1, set_event_handler / 2, current_after_events / 1, event_create / 3, event_retrieve / 3, get_flag / 2"},"events_nodefer/0":{"prefix":"events_nodefer","body":"events_nodefer","description":"events_nodefer\n\n   Allow event handling\n\nType\n   Event Handling\n\nDescription\n    \tReenable event handling after it was previously deferred by\n    \n\t    entering the handler for an event with the defer-property\n\t\t(see event_create/3 and set_event_handler/2).\n\t    a call to events_defer/0\n    \n\tThe purpose of this feature is to\n\t\n\t    sequence event handlers so they don't interrupt each other\n\t    protect accesses to global data structures from being interrupted\n\t\tor preempted by events.\n\t\n\tEvents whose handling will be deferred are:\n\t\n\t   events raised by the builtin event/1\n\t   events posted from external code using ec_post_event()\n\t   events raised by interrupts whose handler is event/1\n\t\n\tEvents that are raised while event handling is deferred will be\n\tqueued and handled later. A handler for an event with the defer-\n\tproperty must always call events_nodefer/0 before exiting, e.g.\n\t\n\tdeferring_event_handler :-\n\t\twriteln(\"This event handler\"),\n\t\twriteln(\"will not be interrupted\"),\n\t\twriteln(\"by other events!\"),\n\t\tevents_nodefer.\n\t\n    \n\tCAUTION: events_nodefer/0 is a low-level primitive that must be\n\tused with great care. Part of ECLiPSe's functionality (e.g. timeout,\n\tbranch-and-bound) relies on event handling and will not work\n\tproperly while event handling is deferred. Deferring and undeferring\n\tevents are nonlogical operations which are not undone on backtracking.\n\tThe programmer must therefore make sure that every time event handling\n\tis deferred, it is eventually reenabled by a call to events_nodefer/0,\n\teven in case of failure or abort in the deferred code sequence.\n    \n    \n\nModes and Determinism\n   events_nodefer is det\n\nExamples\n       % Without deferring, event handlers interrupt each other, which\n    % makes it seem as if events were handled in reverse order:\n\n    simple_handler(E) :-\n    \twriteln(simple_handling(E)).\n\n    ?- set_event_handler(e1, simple_handler/1),\n       set_event_handler(e2, simple_handler/1),\n       set_event_handler(e3, simple_handler/1).\n    Yes (0.00s cpu)\n\n    ?-  event([e1,e2,e3]).\n    simple_handling(e3)\n    simple_handling(e2)\n    simple_handling(e1)\n    Yes (0.00s cpu)\n\n    % With deferring, event handlers are sequenced, i.e. every\n    % handler is allowed to finish before the next one executes:\n\n    deferred_handler(E) :-\n    \twriteln(defered_handling(E)),\n\tevents_nodefer.\n\n    ?- set_event_handler(e1, defers(deferred_handler/1)),\n       set_event_handler(e2, defers(deferred_handler/1)),\n       set_event_handler(e3, defers(deferred_handler/1)).\n    Yes (0.00s cpu)\n\n    ?- event([e1,e2,e3]).\n    defered_handling(e1)\n    defered_handling(e2)\n    defered_handling(e3)\n    Yes (0.00s cpu)\n    \n\nSee Also\n   event_create / 3, event / 1, events_defer / 0, set_event_handler / 2"},"event_enable/1":{"prefix":"event_enable","body":"event_enable(${1:EventHandle})$2\n$0","description":"event_enable(+EventHandle)\n\n   Enable the given event\n\nArguments\n   EventHandle    An event handle\n\nType\n   Event Handling\n\nDescription\n\tThe given event is (re-)enabled.  Since events are enabled by default,\n\tthis only makes sense if the event had been previously disabled.\n    \n\tA disabled events behaves as if its handler was the goal 'true':\n\t\n\tRetrieving the goal using event_retrieve/3 returns 'true'\n\tWhen the event is raised (e.g. posted via event/1), nothing happens\n\tIf the event gets disabled after it was raised, but before its handler\n\t    execution has started, handler execution will be suppressed.\n\t\n    \n\tNote that disabling and enabling events are nonlogical operations\n\twhich are not undone on backtracking.\n    \n    \n\nModes and Determinism\n   event_enable(+) is det\n\nExceptions\n     4 --- EventHandle is un-instantiated\n     5 --- EventHandle is not a handle\n\nExamples\n       ?- event_create(writeln(hello), [], E),\n       event_disable(E), writeln(disabled),\n       event(E),\t% does nothing\n       event_enable(E), writeln(enabled),\n       event(E).\n    disabled\n    enabled\n    hello\n    \n\nSee Also\n   event_create / 3, event / 1, event_disable / 1, event_retrieve / 3"},"get_event_handler/3":{"prefix":"get_event_handler","body":"get_event_handler(${1:Event}, ${2:Predspec}, ${3:Module})$4\n$0","description":"get_event_handler(+Event, -Predspec, -Module)\n\n   Returns the event handler for event/error Event and its home module Module.\n\nArguments\n   Event    atom or integer.\n   Predspec    term which unifies with atom/integer.\n   Module    atom or variable.\n\nType\n   Event Handling\n\nDescription\n   Given the event name/error number Event, Predspec is unified with the specification\n   (i.e.  a term of the form name/arity) of the current handler for \n   event; Module is unified with its home module.\n\n   The events which exist are user defined; the errors which exist are\n   implementation defined. \n\nModes and Determinism\n   get_event_handler(+, -, -) is semidet\n\nFail Conditions\n   Fails if Event is not an event\n\nExceptions\n     4 --- Event is not instantiated.\n     5 --- Event is not an atom nor integer.\n     5 --- PredSpec is neither a variable nor of the form Atom/Integer.\n\nSee Also\n   set_event_handler / 2, event / 1"},"get_interrupt_handler/3":{"prefix":"get_interrupt_handler","body":"get_interrupt_handler(${1:IntId}, ${2:PredSpec}, ${3:Module})$4\n$0","description":"get_interrupt_handler(+IntId, -PredSpec, -Module)\n\n   Succeeds if PredSpec unifies with the specification of the current handler\nfor interrupt IntId and Module unifies with its home module.\n\nArguments\n   IntId    Integer or atom.\n   PredSpec    Term which unifies with atom/integer.\n   Module    Atom or variable.\n\nType\n   Event Handling\n\nDescription\n   Provided IntId is a valid interrupt identifier, unifies PredSpec with\n   the specification (i.e.  a term of the form name/arity) of the current\n   handler for interrupt IntId, and Module with the module in which it is\n   defined.\n\n   The interrupts which exist are machine dependent.  The interrupts which\n   can be caught or trapped are implementation defined.\n\nModes and Determinism\n   get_interrupt_handler(+, -, -) is semidet\n\nFail Conditions\n   Fails if no handler has been set for the interrupt IntId\n\nExceptions\n     4 --- IntId is not instantiated.\n     5 --- IntId is not an atom or integer.\n     5 --- PredSpec does not unify with atom/integer.\n     6 --- IntId is not a valid interrupt name or number.\n\nExamples\n   \nSuccess:\n      ?- get_interrupt_handler(18,M,N).\n      M = pause/0\n      N = sepia_kernel\n      yes.\n\n      ?- set_interrupt_handler(18,true/0), kill(0, 18),\n      > get_interrupt_handler(18,true/0,sepia_kernel).\n      yes.\nFail:\n      get_interrupt_handler(16, true/0, sepia_kernel).\nError:\n      get_interrupt_handler(N,true/0,sepia_kernel).   (Error 4).\n      get_interrupt_handler(5.0,true/0,sepia_kernel). (Error 5).\n      get_interrupt_handler(-1,X,sepia_kernel).       (Error 6).\n\nSee Also\n   current_interrupt / 2, set_interrupt_handler / 2, kill / 2"},"reset_error_handlers/0":{"prefix":"reset_error_handlers","body":"reset_error_handlers","description":"reset_error_handlers\n\n   All error handlers are reset, cancelling any redefinition.\n\nArguments\n\nType\n   Event Handling\n\nDescription\n   All error handlers are reset, cancelling any redefinition.\n\n   The errors which exist are implementation defined.\n\nModes and Determinism\n   reset_error_handlers is det\n\nExamples\n   \nSuccess:\n      ?- string_list(S,L).\n      instantiation fault in string_list(_g50, _g52)\n\n      ?- atom_length(\"atom\",L).\n      type error in atom_length(\"atom\", _g52).\n\n      ?- set_event_handler(4,fail/0), string_list(S,L).\n      no (more) solution.\n\n      ?- set_event_handler(5,abort/0),atom_length(\"atom\",L).\n      Aborting execution....\n\n      ?- reset_error_handlers, string_list(S,L).\n      instantiation fault in string_list(_g62, _g64)\n\n      ?- atom_length(\"atom\",L).\n      type error in atom_length(\"atom\", _g52).\n\nSee Also\n   reset_event_handler / 1"},"set_event_handler/2":{"prefix":"set_event_handler","body":"set_event_handler(${1:EventId}, ${2:PredSpec})$3\n$0","description":"set_event_handler(+EventId, ++PredSpec)\n\n   Set an event handler PredSpec for the event EventId.\n\nArguments\n   EventId    Atom or Integer.\n   PredSpec    Term of the form Atom/Integer, or defers(Atom/Integer).\n\nType\n   Event Handling\n\nDescription\n   Assigns the procedure specified by PredSpec as the event handler\n   for the event specified by EventId.  The event name can be either\n   an arbitrary atom or a valid error number (as returned by\n   current_error/1).\n\n   An event handler which is used as an error handler can have 4\n   optional arguments:\n   \n       the 1st argument is the event number/identifier itself\n       the 2nd argument is the culprit (a structure corresponding to\n\t   the call which caused it)\n       the 3rd argument is the context module (or the lookup module\n       \t   if the context module is unknown)\n       the 4th argument is the lookup module for the call\n   \n   The error handler is free to use less than 4 arguments.\n   \n\n   Handlers for events raised by event/1 or posted to the system from\n   the outside usually have no arguments or just the event name.\n\n   Events can be raised by\n\n   - one of the builtins event/1, error/2 or error/3.\n   - posting an event from external code using ec_post_event().\n   - an interrupt whose handler has been specified as event/1.\n\n   The latter two have the effect of dynamically inserting an event/1\n   goal into the current execution at the next synchronous point,\n   which is usually just before the next predicate call.\n\n   If the handler is specified as defers(Name/Arity), then the event has\n   the defer-property. This means that event handling is automatically\n   deferred on entering the event's handler, thus preventing other events\n   from interrupting the handler. Such handlers must always explicitly invoke\n   events_nodefer/0 before exiting in order to reenable event handling.\n\nModes and Determinism\n   set_event_handler(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either EventId or PredSpec is not instantiated.\n     5 --- EventId is neither atom nor integer.\n     5 --- PredSpec is not of the form Atom/Integer or defers(Atom/Integer).\n     6 --- EventId is integer, but not a valid error number.\n     6 --- PredSpec specifies an illegal handler arity.\n\nExamples\n   \nSuccess:\n    ?- event(hello).\n    warning: no handler for event in hello\n    yes.\n\n    ?- set_event_handler(hello, writeln/1).    \n    yes.\n\n    ?- event(hello).\n    hello\n    yes.\n\nSee Also\n   current_error / 1, get_event_handler / 3, error / 2, error / 3, event / 1, reset_event_handler / 1, events_nodefer / 0"},"reset_event_handler/1":{"prefix":"reset_event_handler","body":"reset_event_handler(${1:EventId})$2\n$0","description":"reset_event_handler(+EventId)\n\n   Resets the handler for the event EventId to its default value\n\nArguments\n   EventId    Atom or Integer.\n\nType\n   Event Handling\n\nDescription\n   If EventId is an error number, the error handler is reset to\n   its default value, cancelling any previous redefinition.\n\n   If EventId is an atom, any previously installed handler is uninstalled,\n   and future occurrences of the event will cause an error (32).\n\nModes and Determinism\n   reset_event_handler(+) is det\n\nExceptions\n     4 --- EventId is not instantiated.\n     5 --- EventId is neither atom nor integer.\n     6 --- EventId is integer, but not a valid error number.\n\nExamples\n   \nSuccess:\n    ?- event(hello).\n    warning: no handler for event in hello\n    yes.\n\n    ?- set_event_handler(hello, writeln/1).    \n    yes.\n\n    ?- event(hello).\n    hello\n\n    ?- reset_event_handler(hello).\n    yes.\n\n    ?- event(hello).\n    warning: no handler for event in hello\n    yes.\n\nSee Also\n   current_error / 1, get_event_handler / 3, error / 2, error / 3, event / 1, set_event_handler / 2"},"call_c/2":{"prefix":"call_c","body":"call_c(${1:Function}, ${2:Code})$3\n$0","description":"call_c(+Function, ?Code)\n\n   Invoke the C function Function and unify its return code with Code.\n\nArguments\n   Function    Atom or structure\n   Code    Variable, integer or structure\n\nType\n   External Interface\n\nDescription\n   This predicate allows to call C functions directly from Prolog.  The\n   arguments of Function are translated as follows:\n\n  * integers and floats are passed directly\n\n  * strings and atoms are passed as C strings\n\n  * terms Name/Arity are interpreted as arrays and a pointer to the first\n    array's element is passed\n\n  * structures in the form ar(M, N, K) are interpreted as array elements\n    and a pointer to this array element is passed.\n\n   C numbers and strings are thus mapped directly on Prolog constants, C\n   structures are mapped on Prolog arrays.  If Code is a variable or an\n   integer, it will be unified with the (integer) return code of the\n   function.  If the function return value is of another type, it must be\n   specified in the Code as follows:\n\n  * integer(Code) denotes an integer\n\n  * float(Code) denotes a (double precision) floating point number\n\n  * string(Code) denotes a string\n\n   After Function finishes, Code is unified with its return code.  If\n   Function is a system function and the return code is -1, the flag\n   last_errno contains the errno value set by the command.  Function can\n   have at most 10 arguments (floating-point arguments count as two).  Note\n   that only functions linked with the current session can be called.\n   Other functions can be dynamically linked using the load/1 predicate.\n   The first time a function is called it takes longer because the system\n   has to find the function in the symbol table of the binary.  Its address\n   is remembered and thus next calls are faster.\n\nModes and Determinism\n   call_c(+, ?) is det\n\nExceptions\n     4 --- Function is not instantiated.\n     5 --- Function is neither an atom nor a structure.\n     5 --- An argument of Function has a type which cannot be    translated.\n    20 --- Arithmetic exception in the function or when converting a    single-precision float to a double.\n    31 --- Arity of Function exceeds 10.\n    41 --- The array argument of Function does not exist.\n   211 --- The specified C function does not exist.\n\nExamples\n   \nSuccess:\n    [eclipse 16]: make_array(time(4), integer).\n\n    yes.\n    [eclipse 17]: call_c(gettimeofday(time/1, time(2)), X).\n\n    X = 0\n    yes.\n    [eclipse 18]: getval(time(0), Sec1Jan70), getval(time(2), MinWest),\n    getval(time(3), DstTime).\n\n    Sec1Jan70 = 733148538\n    MinWest = -60\n    DstTime = 4\n    yes.\n    [eclipse 19]: call_c(ctime(time(0)), string(Date)).\n\n    Date = \"Fri Mar 26 13:22:18 1993\\n\"\n    yes.\n    [eclipse 20]: call_c(sinh(1.5), float(X)).\n    External function does not exist in call_c(sinh(1.5), float(X))\n    [eclipse 21]: load(\"-u _sinh -lm\"), call_c(sinh(1.5), float(X)).\n\n    X = 2.12927938\n    yes.\n\nError:\n      call_c(nofunc, X).    (Error 211).\n      call_c(getrusage(noarray/1, 0)      (Error 41).\n\nSee Also\n   exec / 2, system / 1"},"event_disable/1":{"prefix":"event_disable","body":"event_disable(${1:EventHandle})$2\n$0","description":"event_disable(+EventHandle)\n\n   Disable the given event\n\nArguments\n   EventHandle    An event handle\n\nType\n   Event Handling\n\nDescription\n\tThe given event is disabled.  A disabled events behaves as if its\n\thandler was the goal 'true':\n\t\n\tRetrieving the goal using event_retrieve/3 returns 'true'\n\tWhen the event is raised (e.g. posted via event/1), nothing happens\n\tIf the event gets disabled after it was raised, but before its handler\n\t    execution has started, handler execution will be suppressed.\n\t\n    \n\tNote that disabling and enabling events are nonlogical operations\n\twhich are not undone on backtracking.\n    \n    \n\nModes and Determinism\n   event_disable(+) is det\n\nExceptions\n     4 --- EventHandle is un-instantiated\n     5 --- EventHandle is not a handle\n\nExamples\n       ?- event_create(writeln(hello), [], E),\n       event_disable(E), writeln(disabled),\n       event(E),\t% does nothing\n       event_enable(E), writeln(enabled),\n       event(E).\n    disabled\n    enabled\n    hello\n    \n\nSee Also\n   event_create / 3, event / 1, event_enable / 1, event_retrieve / 3"},"externals_desc":{"prefix":"lib","body":"lib(${1:externals})$2\n$0","description":"lib(externals)\n\nFor more information, see the Embedding and Interfacing Manual"},"external/2":{"prefix":"external","body":"external(${1:PredSpec}, ${2:CName})$3\n$0","description":"external(++PredSpec, +CName)\n\n   Defines PredSpec to be a deterministic external predicate linked to the C\nfunction whose system name is CName.\n\nArguments\n   PredSpec    Of the form Atom/Integer (predicate name/arity).\n   CName    Atom or string.\n\nType\n   External Interface\n\nDescription\n   Declares PredSpec to be a deterministic external predicate (in the\n   caller module) linked to the ``C'' function whose system name is CName.\n\n   If the visibility of PredSpec is not declared, it is set to local.\n\n   If necessary, an underscore is prepended to CName to get its form as\n   used by the C compiler.\n\n   If a call to PredSpec has already been compiled as a Prolog call or a\n   non-deterministic external call, error 62 is raised (``inconsistent\n   procedure redefinition'').  This can be prevented by defining the\n   external before compiling any call to it or by using the declaration\n   predicate external/1.\n\nModes and Determinism\n   external(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either PredSpec or CName is not instantiated.\n     5 --- PredSpec is not of the form Atom/Integer.\n     5 --- CName is not an atom or a string.\n    62 --- A call to PredSpec has already been compiled as a Prolog    call or a non-deterministic external call.\n   211 --- External function does not exist.\n\nExamples\n   \nAssume we have the C++ file eg_cc_external.cc:\n\n    #include \"eclipseclass.h\"\n    extern \"C\" int\n    p_sumlist()\n    {\n\tint res;\n\tlong x, sum = 0;\n\tEC_word list(EC_arg(1));\n\tEC_word car,cdr;\n\n\tfor ( ; list.is_list(car,cdr) == EC_succeed; list = cdr)\n\t{\n\t    res = car.is_long(&x);\n\t    if (res != EC_succeed) return res;\n\t    sum += x;\n\t}\n\tres = list.is_nil();\n\tif (res != EC_succeed) return res;\n\treturn unify(EC_arg(2), EC_word(sum));\n    }\n\nCompile that into a dynamic library, e.g. using g++ on a Linux machine:\n\n    g++ -I/usr/local/eclipse/include/i386_linux -shared \\\n    \t-o eg_cc_external.so eg_cc_external.cc\n\nLoad the .so file dynamically into Eclipse and declare the external:\n\n      ?- load('eg_cc_external.so').\n      yes.\n\n      ?- external(sumlist/2, p_sumlist).\n      yes.\n\n      ?- sumlist([1,2,3,4,5],S).\n      S = 15\n      yes.\n\nErrors:\n      external(PredSpec, \"p_member\"). (Error 4).\n      external(p/0, S).    (Error 4).\n      external('p/0', p_p0).    (Error 5).\n      external(p/0, 123).    (Error 5).\n      external(prmsg/1, nosuchfunc).  (Error 211).\n\n      ?- [user].\n       p :- a.\n       user   compiled 32 bytes in 0.00 seconds\n      yes.\n      ?- external(a/0, c_a).   (Error 62).\n\nSee Also\n   external / 1, load / 1"},"set_interrupt_handler/2":{"prefix":"set_interrupt_handler","body":"set_interrupt_handler(${1:IntId}, ${2:PredSpec})$3\n$0","description":"set_interrupt_handler(+IntId, ++PredSpec)\n\n   Sets an interrupt handler PredSpec for the interrupt IntId\n\nArguments\n   IntId    Integer or atom.\n   PredSpec    Term of the form Atom/Integer.\n\nType\n   Event Handling\n\nDescription\n\n   Assigns the procedure specified by PredSpec as the interrupt handler for\n   the interrupt whose name or number is given by IntId.\n\n   See the ECLiPSe User Manual for details on the operation of\n   interrupt handlers.\n\n   The interrupt handlers of the following interrupts cannot be modified,\n   since they cannot be caught by ECLiPSe .\n\n    No. Code     Description  Example\n    9   SIGKILL  kill    kill process from keyboard\n    17  SIGSTOP  stop    cannot be caught, blocked, ignored\n\n   The interrupts which can be caught or trapped are implementation\n   defined.\n\n   The following interrupt handlers have a special meaning and can be\n   used even with the embedded library version of Eclipse:\n\n    Handler     Meaning\n    -------     -------\n    true/0      ignore the interrupt (SIG_IGN).\n    default/0   take the default operating system action when the\n    interrupt occurs (SIG_DFL).\n    event/1     handle the signal by posting a (synchronous) event. The\n    symbolic name of the interrupt will be used as the event name.\n    throw/1     invoke exit_block/1 with the interrupt's symbolic name.\n    abort/0     invoke exit_block(abort)\n    halt/0      halt Eclipse and terminate the process\n    internal/0  the signal is used by Eclipse to implement internal\n    functionality (e.g. profiler)\n\n    All other handler specifications cause the specified predicate to\n    be called in a nested invocation of the Eclipse engine. This is\n    not supported on some hardware/OS platforms, e.g. Windows.\n\nModes and Determinism\n   set_interrupt_handler(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either IntId or PredSpec is not instantiated.\n     5 --- IntId is not an atom or integer.\n     5 --- PredSpec is neither a variable nor of the form Atom/Integer.\n     6 --- IntId is not a valid interrupt name or number.\n     6 --- PredSpec is of the form Atom/Integer, but the integer is greater than 3.\n    60 --- PredSpec is of the form Atom/Integer, but no such predicate has been defined.\n   170 --- The interrupt cannot be caught.\n\nExamples\n   \nSuccess:\n    ?- get_interrupt_handler(alrm,M,N).\n    M = event / 1\n    N = sepia_kernel\n    yes.\n\n    ?- set_interrupt_handler(alrm,true/0), interrupt(alrm).\n    yes.\n\n    ?- kill(0, alrm).\n    yes.\n\n    ?- get_interrupt_handler(alrm,M,N).\n    M = true / 0\n    N = sepia_kernel\n    yes.\n\n    ?- [user].\n     a :- write(log_output, \"interrupt 16\"), fail.\n     user compiled 136 bytes in 0.00 seconds\n\n    ?- set_interrupt_handler(16,a/0).\n    yes.\n\n    ?- kill(0, 16).\n    interrupt 16\n    yes.\n\nError:\n    set_interrupt_handler(N,true/0).    (Error 4).\n    set_interrupt_handler(15,P).    (Error 4).\n    set_interrupt_handler(15.0,true/0). (Error 5).\n    set_interrupt_handler(1000,X).      (Error 6).\n    set_interrupt_handler(-1,X).    (Error 6).\n    set_interrupt_handler(6,a/4).       (Error 6).  % arity > 3.\n    set_interrupt_handler(6,t/2).       (Error 60). % no t/2.\n    set_interrupt_handler(9,true/0).    (Error 170).\n    set_interrupt_handler(17,true/0).   (Error 170).\n\nSee Also\n   event / 1, set_event_handler / 2, current_interrupt / 2, get_interrupt_handler / 3"},"load/1":{"prefix":"load","body":"load(${1:File})$2\n$0","description":"load(++File)\n\n   The object code or loadable library File is loaded into the running system.\n\nArguments\n   File    Atom or a string.\n\nType\n   External Interface\n\nDescription\n   Used to load the object code file File into the ECLiPSe system.\n   The object code would normally contain functions that implement\n   ECLiPSe predicates via the external language interface.\n   Such code can currently be written in C or C++.\n   See the Embedding and Interfacing Manual for more detail.\n\n   On modern UNIX systems shared objects are used and loading is done using\n   dlopen().  The argument of load/1 must be a shared object (.so file).\n\n   On Windows systems dynamic libraries are used. The argument of\n   load/1 must be a .dll file.\n\n   For old BSD systems, File specifies one or more object files, libraries\n   and/or options in the form accepted by the UNIX linker ld(1).  The\n   argument is passed literally to the loader; the command executed is\n\n   bin/ld -N -A <binary> -T <addr> -o /tmp/eclipse.<pid>.N <File> -lc 1>&2\n   2>&2\n\n   where <pid> is the process ID of the ECLiPSe process and N is an integer\n   that starts as zero and that is incremented after each dynamic loading.\n\n   To write portable programs, it is possible to query the value of the\n   flag object_suffix. It gives the correct file extensions for the loadable\n   objects on the current platform (e.g. \"o\", \"so\", \"dll\").\n\nModes and Determinism\n   load(++) is det\n\nExceptions\n     4 --- File is not instantiated.\n     5 --- File is instantiated, but not to an atom or a string.\n   177 --- A shared library object (or one of its dependencies) could not be found\n\nExamples\n   \nSuccess:\n\n   % See the msg.c example source in external/2.\n    % eclipse\n\n   % load the .o file dynamically into the system\n    [eclipse]: load('msg.so').\n    yes.\n    [eclipse]: get_flag(prmsg/1,visibility,Vis).\n    accessing an undefined procedure\n\n   % link the object file with a predicate definition.\n    [eclipse]: external(prmsg/1,\"p_prmsg\").\n    yes.\n\n   % check on existence and flags of prmsg/1.\n    [eclipse]: get_flag(prmsg/1,type,V),\n    get_flag(prmsg/1,tool,T),\n    get_flag(prmsg/1,visibility,Vis).\n    V = user\n    T = off\n    Vis = local     More? (;)\n    yes.\n\nError:\n    [eclipse]: load('msg.c').\n    system interface error: Unknown system error\n    % not loading an object file.\n\n    [eclipse]: load('msg.o').\n    system interface error: No such file or directory\n    % no compilation of msg.c to give msg.o\n\n    load(F).    (Error 4).\n    load(msg(o)).    (Error 5).\n\nSee Also\n   call_c / 2, external / 1, external / 2, get_flag / 2"},"peer/1":{"prefix":"peer","body":"peer(${1:Peer})$2\n$0","description":"peer(?Peer)\n\n   Checks or enumerates peer names\n\nArguments\n   Peer    Peer name (atom or variable).\n\nType\n   External Interface\n\nDescription\n   \n   If Peer is a variable, this predicate enumerates the current peers\n   (remote and embedded). If Peer is an atom, it checks if that is the name\n   of a current peer.\n   \n\nModes and Determinism\n   peer(-) is nondet\n   peer(+) is semidet\n\nFail Conditions\n   Peer is not a current peer.\n\nExceptions\n     5 --- Peer is neither an atom or a variable.\n\nSee Also\n   peer_get_property / 3"},"external/1":{"prefix":"external","body":"external(${1:PredSpec})$2\n$0","description":"external(++PredSpec)\n\n   Declares PredSpec to be a deterministic external predicate.\n\nArguments\n   PredSpec    Of the form Atom/Integer (predicate name/arity).\n\nType\n   External Interface\n\nDescription\n   Declares the (may be not yet visible) predicate PredSpec to be a\n   deterministic external predicate.\n\n   This declaration is needed to compile calls to an external predicate\n   before it is actually defined with external/2.\n\nModes and Determinism\n   external(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- PredSpec is not instantiated.\n     5 --- PredSpec is not of the form Atom/Integer.\n    62 --- A call to PredSpec has already been compiled as a Prolog    call or a non-deterministic external call.\n\nExamples\n   \nSuccess:\n\n   % compiling a call to an external before its definition (see description\n   % of external/2 for detail on creating external predicates).\n      [eclipse]: [user].\n       :- import prmsg/1 from msg_lib.\n       :- external(prmsg/1). % declare its call_type\n       hello :- prmsg(\"hello\").\n       user      compiled 216 bytes in 0.03 seconds\n\n   % definition of sines/2 will not raise an inconsistent type definition\n   % thanks to the proper declaration above.\n      [eclipse]: sh(\"cat msg_lib.pl\").\n      :- module(msg_lib).\n      :- load('msg.o', \"-lm\"). % see example in external/2\n      :- external(prmsg/1, p_prmsg).\n      :- export prmsg/1.\n\n      yes\n      [eclipse]: [msg_lib].\n       msg_lib.pl      compiled 0 bytes in 0.18 seconds\n      yes.\n      [eclipse]: hello.\n      message: hello\n      yes.\n\nError:\n      external(PredSpec).    (Error 4).\n      external(\"p/0\").    (Error 5).\n\n      [eclipse]: [user].\n       p :- a.\n       user   compiled 32 bytes in 0.00 seconds\n      yes.\n      [eclipse]: external(a/0).    (Error 62).\n\nSee Also\n   external / 2, load / 1"},"peer_deregister_multitask/1":{"prefix":"peer_deregister_multitask","body":"peer_deregister_multitask(${1:Peer})$2\n$0","description":"peer_deregister_multitask(+Peer)\n\n   Deregisters and removes the peer Peer from peer multitasking.\n\nArguments\n   Peer    Existing multitasking peer name (atom)\n\nType\n   External Interface\n\nDescription\n\n   This predicate is intended for use only in implementing peer \n   multitasking for an external language interface.\n\n   Deregisters the existing multitasking peer Peer as a multitask peer.\n   The  multitasking control peer queue for Peer, created when the peer was\n   registered  for multitasking, is closed. Peer will no longer be involved \n   in future multitasking phases.\n\n   Note that while information associated with the multitasking for Peer is\n   removed from the ECLiPSe side, any information on the external side is\n   not touched. It is the responsibility of the external language interface\n   to remove any multitasking information on the external side, before or\n   after using this predicate.\n\nModes and Determinism\n   peer_deregister_multitask(+) is semidet\n\nFail Conditions\n   Peer is a peer, but not registered for multitasking.\n\nExceptions\n     6 --- Peer is not an existing peer name\n\nSee Also\n   peer_register_multitask / 2, peer_do_multitask / 1, peer_multitask_terminate / 0, peer_multitask_confirm / 0"},"peer_multitask_terminate/0":{"prefix":"peer_multitask_terminate","body":"peer_multitask_terminate","description":"peer_multitask_terminate\n\n   Terminate a peer multitasking phase.\n\nType\n   External Interface\n\nDescription\n\n   This predicate is intended for use only in implementing peer \n   multitasking for an external language interface.\n\n   A multitasking phase is terminated by this predicate. That is, when this\n   predicate is executed, then the end of the multitasking phase is\n   initiated. ECLiPSe will then inform all the multitasking peers that\n   the current multitasking phase is over. It is intended that this\n   predicate be executed via an ERPC by a peer when it wants to initiate\n   the end of a multitasking phase.\n   \n\nModes and Determinism\n   peer_multitask_terminate is det\n\nSee Also\n   peer_multitask_confirm / 0"},"peer_multitask_confirm/0":{"prefix":"peer_multitask_confirm","body":"peer_multitask_confirm","description":"peer_multitask_confirm\n\n   Confirm a peer multitasking phase.\n\nType\n   External Interface\n\nDescription\n\n   This predicate is intended for use only in implementing peer \n   multitasking for an external language interface.\n\n   A multitasking phase is confirmed by this predicate. That is, when a\n   multitasking phase is initiated by a call to peer_do_multitask/1, this\n   predicate should be executed for the multitasking phase to continue. If\n   this predicate is not executed, the multitasking phase will be\n   terminated. It is intended that this predicate is executed via an ERPC\n   by a peer when the multitasking phase is initiated, if that peer is\n   interested in the phase. A multitasking phase will be ended when\n   peer_multitask_terminate/0 is called.\n   \n\nModes and Determinism\n   peer_multitask_confirm is det\n\nSee Also\n   peer_do_multitask / 1, peer_multitask_terminate / 0"},"peer_do_multitask/1":{"prefix":"peer_do_multitask","body":"peer_do_multitask(${1:Type})$2\n$0","description":"peer_do_multitask(+Type)\n\n   Perform a multitasking phase.\n\nArguments\n   Type    User defined term (term)\n\nType\n   External Interface\n\nDescription\n\n   This predicate is intended for use only in implementing peer \n   multitasking for an external language interface.\n\n   Multitasking is done within this predicate. That is, a multitasking \n   phase is initiated when the predicate is called, and when the multitasking \n   phase is finished, the predicate returns. If the abort exception is\n   raised during the multitasking phase, the multitasking phase is properly\n   terminated before the abort continues. \n\n   Type is a user defined term that is passed to all the multitasking \n   peers when the multitasking phase is initiated. This allows the \n   programming of different types of multitasking situations. Type must be \n   representable as an EXDR term.\n\n   This is the only way to initiate multitasking, so if the user wishes to\n   to initiate multitasking from a peer, they should call this goal \n   via an ERPC.\n\n   During a multitasking phase, multitasking peers are each given a\n   time-slice in round-robin fashion. They are allowed to perform ERPC\n   during the time-slice. (More precisely: they are allow to execute\n   peer-side code that contains ERPCs).\n\n   To participate in peer multitasking, a peer should first be registered\n   using peer_register_multitask/2. A peer can then initiate multitasking\n   by calling peer_do_multitask/1 while the peer has control. The\n   multitasking phase is started, and all registered peer will be informed\n   during their time-slice that a multitasking phase has started. If the\n   peer is interested in this particularly multitasking phase (as specified\n   in Type), they should execute peer_multitask_confirm/0. The multitasking\n   phase can be terminated by any peer by calling\n   peer_multitask_terminate/0.\n   \n\nModes and Determinism\n   peer_do_multitask(+) is det\n\nExceptions\n   peer_multitask_empty --- No peer is currently registered for multitasking.\n\nSee Also\n   peer_register_multitask / 2, peer_multitask_terminate / 0, peer_multitask_confirm / 0"},"peer_get_property/3":{"prefix":"peer_get_property","body":"peer_get_property(${1:Peer}, ${2:Property}, ${3:Value})$4\n$0","description":"peer_get_property(+Peer, ?Property, -Value)\n\n   Returns the properties of the peer Peer.\n\nArguments\n   Peer    Peer name (atom).\n   Property    Property name (atom or variable).\n   Value    Value of property Property for Peer.\n\nType\n   External Interface\n\nDescription\n   \n   If Property is a variable, this predicate will enumerate on backtracking\n   all the properties of peer Peer. If Property is instantiated to a valid\n   property name, the value of the property for Peer is unified with Value.\n\n   \n   Property is one of the following:\n\n   type       peer type (remote or embed)\n   language   peer language (e.g. \"tcl\" or \"java\")\n   connect    connection information. Either:\n    remote(LocalHost,PeerHost,TimeOut) or\n    embed(Host,Host,block)\n   queues     current peer queues (list of stream ids)\n\n   'connect' returns the information on the connection for the peer. This\n   information is mainly relevant only for remote peers, but is provided\n   for the embedded peer for compatibility. The arguments for the remote \n   and embedded cases are equivalent, and are:\n\n       LocalHost   Original local Host specification at peer creation\n       PeerHost    Host for the Peer\n       TimeOut     Time-out interval for creating new peer queues\n\n   For remote peers, LocalHost specifies how the local hostname will be\n   specified when setting up a connection between the peer and ECLiPSe.  It\n   is the same as how the hostname was specified initially when the peer\n   was set up: it can be either a variable, the actual hostname, or the\n   special name 'localhost'. The specification may place restrictions on how\n   the peer side client connection is specified. In particular, 'localhost'\n   would restrict the peer to be on the same host as ECLiPSe.  PeerHost is\n   either the hostname of the machine the peer is running on, or \n   'localhost'. TimeOut is the time-out interval (in seconds) for accepting\n   peer queues, or the atom 'block' if there is no time-limit.\n\n   The LocalHost and PeerHost are identical for the embedded peer, and is\n   the hostname Host of the machine. There are no time-outs, so TimeOut\n   argument is the the atom 'block'. \n   \n   \n\nModes and Determinism\n   peer_get_property(+, +, -) is semidet\n   peer_get_property(+, -, -) is nondet\n\nFail Conditions\n   Peer is not a current peer; Property is not a valid property.\n\nExceptions\n     5 --- Peer or Property not of the right type.\n\nSee Also\n   peer / 1"},"peer_queue_create/5":{"prefix":"peer_queue_create","body":"peer_queue_create(${1:Queue}, ${2:Peer}, ${3:QueueType}, ${4:Direction}, ${5:Event})$6\n$0","description":"peer_queue_create(+Queue, +Peer, +QueueType, +Direction, +Event)\n\n   Create a new peer queue Queue for Peer from ECLiPSe side.\n\nArguments\n   Queue    Name of peer queue (atom)\n   Peer    Peer name (atom)\n   QueueType    Queue type (sync or async)\n   Direction    Queue direction (fromec, toec or bidirect)\n   Event    Event for peer queue (atom or event handle)\n\nType\n   External Interface\n\nDescription\n\n   Creates a new peer queue Queue for peer Peer from ECLiPSe\n   side. The nature of queue created is specified by the other arguments\n   (see the Embedding and interfacing manual for more details on peer queues):\n\nQueueType\n      Type of the queue: either synchronous (sync) or asynchronous (async).\n\nDirection\n      Direction of the synchronous queue: either from ECLiPSe to remote\n      (fromec) or to ECLiPSe from remote (toec). This argument is ignored\n      for asynchronous queues, which are bidirectional.\n\nEvent\n      Name or handle of event that will be raised on the ECLiPSe side when\n      data arrives. Applicable only for data sent from remote side to ECLiPSe. \n      If Event is the empty atom '', then no event will be associated with\n      the peer queue. \n\n      This predicate will cause the queue to be created (if permitted by\n      the remote side) on both the ECLiPSe and remote sides. Alternatively,\n      the queue can be created from the remote side. Note in either case,\n      the creation is done only on one side, and the created queue appears\n      on the other side without an explicit creation there. Note also that\n      if the queue is created on the ECLiPSe side, there is no way to name\n      the handler on the remote side for data arriving on the remote side.\n\n      In the case of a remote peer, the queue is connected by a socket\n      connection between the two sides. The server socket is created on the\n      ECLiPSe side, and it will wait at most TimeOut seconds for the remote\n      side to make the connection. TimeOut is the time specified in\n      remote_connect_accept/6 when the remote peer was created. In\n      addition, when the client socket connection is accepted, ECLiPSe\n      checks to ensure that the client's host is the same as the one that\n      formed the attachment. If not, then the connection is from someone\n      else, and ECLiPSe will reject and close the queue connection.\n      \n\nModes and Determinism\n   peer_queue_create(+, +, +, +, +) is semidet\n\nFail Conditions\n   Peer is not a current peer.\n\nExceptions\n     5 --- QueueName, Peer or Event not of the correct type.\n     6 --- QueueType or Direction not of permitted values.\n\nSee Also\n   peer_queue_close / 1, peer_queue_get_property / 3, remote_connect_accept / 6, event_create / 3"},"peer_queue_close/1":{"prefix":"peer_queue_close","body":"peer_queue_close(${1:Queue})$2\n$0","description":"peer_queue_close(+Queue)\n\n   Closes the peer queue Queue from ECLiPSe side.\n\nArguments\n   Queue    Peer queue (atom or integer)\n\nType\n   External Interface\n\nDescription\n\n   Close the peer queue Queue from ECLiPSe side. When this predicate\n   returns, the peer queue would be closed on both the ECLiPSe and remote\n   sides, and book-keeping information on both sides updated to exclude the\n   queue. As with creating a peer queue, closing a peer queue is performed\n   explicitly from one side only. \n\n   The user should not close a peer queue with close/1. This will only\n   close the ECLiPSe end of the queue, and would not remove the\n   book-keeping information. Note that peer_queue_close/1 will still remove\n   the book-keeping information if some of the underlying streams\n   associated with the peer queue are already unexpectedly closed.\n   \n\nModes and Determinism\n   peer_queue_close(+) is semidet\n\nFail Conditions\n   Queue is not a current peer queue.\n\nExceptions\n     5 --- Queue is not an atom or integer.\n\nSee Also\n   peer_queue_create / 5, peer_queue_get_property / 3"},"peer_queue_get_property/3":{"prefix":"peer_queue_get_property","body":"peer_queue_get_property(${1:Queue}, ${2:Property}, ${3:Value})$4\n$0","description":"peer_queue_get_property(+Queue, ?Property, -Value)\n\n   Get or enumerate properties of a peer queue Queue.\n\nArguments\n   Queue    Peer queue (atom or integer).\n   Property    Queue property name (atom or variable).\n   Value    Value of property Property.\n\nType\n   External Interface\n\nDescription\n\n   Get or enumerate properties of a peer queue Queue. If Property is a\n   variable, the properties of the queue will be enumerated on\n   backtracking. Otherwise, if Property is a property name, the value for\n   that property for Queue is unified with Value. The properties are:\n\n     type       type of queue:\n    sync(SId):  synchronous queue \n    SId is Socket Id for remote peers, \n    Stream Id for the embedded peer\n\t\t  async:      asynchronous queue\n     direction  direction of queue:\n    fromec:   from ECLiPSe to remote \n    toec:     to ECLiPSe from remote\n    bidirect: bidirectional\n     peer_type  type of the peer that Queue belongs to:\n    embed  : for embedded peer\n    remote : for remote peer\n     peer_name  name of the peer that Queue belongs to.\n\n   \n\nModes and Determinism\n   peer_queue_get_property(+, +, -) is semidet\n   peer_queue_get_property(+, -, -) is nondet\n\nFail Conditions\n   Queue is not a current peer queue.\n\nSee Also\n   peer_queue_create / 5, peer_queue_close / 1"},"peer_register_multitask/2":{"prefix":"peer_register_multitask","body":"peer_register_multitask(${1:Peer}, ${2:MsgQ})$3\n$0","description":"peer_register_multitask(+Peer, -MsgQ)\n\n   Registers the peer Peer for peer multitasking.\n\nArguments\n   Peer    Existing peer name (atom)\n   MsgQ    From ECLiPSe Multitasking message queue (variable)\n\nType\n   External Interface\n\nDescription\n\n   This predicate is intended for use only in implementing peer \n   multitasking for an external language interface.\n\n   Registers the existing peer Peer as a multitask peer. A peer \n   queue MsgQ for Peer is created to control the multitasking.\n   Only peers which are registered as a multitasking peer participate in \n   the multitasking phase.\n\nModes and Determinism\n   peer_register_multitask(+, -) is semidet\n\nFail Conditions\n   Peer is already registered for multitasking.\n\nExceptions\n     6 --- Peer is not an existing peer name\n\nSee Also\n   peer_do_multitask / 1, peer_multitask_terminate / 0, peer_multitask_confirm / 0, peer_deregister_multitask / 1"},"remote_connect/3":{"prefix":"remote_connect","body":"remote_connect(${1:Address}, ${2:Peer}, ${3:InitGoal})$4\n$0","description":"remote_connect(?Address, ?Peer, ?InitGoal)\n\n   Initiate a remote interface connection\n\nArguments\n   Address    Address for remote connection (Host/Port or variable)\n   Peer    Remote Peer name (atom or variable)\n   InitGoal    Initialisation Goal (goal or variable)\n\nType\n   External Interface\n\nDescription\n\n    \n       Initiate a remote interface connection and sets up a remote peer\n       Peer. ECLiPSe will listen for a remote connection from another\n       process at the Address. Address can be either a variable, or\n       HostName/Port, where either HostName or Port can be variables. The\n       host name and port number are printed on log_output so that the\n       other process can use them. The other process must be able to form a\n       remote interface connection with ECLiPSe.  When the predicate\n       returns, the remote process will have attached to the ECLiPSe\n       session.  This predicate will block until the remote connection\n       is established, and the remote side hands over control.\n\n       \n       Once the Address is printed by the predicate, this information can\n       then be used on the remote side to establish the remote connection,\n       according to the remote interface connection protocol described in\n       the Embedding and Interfacing manual. Once the connection is\n       established, the optional user initialisation is performed on the\n       ECLiPSe side before any further interactions. This is specified by\n       InitGoal: If InitGoal is not a variable, it gives the goal that will\n       be executed for the initialisation. If InitGoal is a variable, then\n       no user initialisation is done before the two sides can\n       interact. Initially, the remote side has control after the\n       connection, so the predicate will return only when the remote side\n       hands over control. Note that the predicate will not fail even if\n       InitGoal fails or aborts.\n\n       \n       If Host and Port are initially not variables, they must be valid for\n       forming a socket connection.\n\n       \n       This predicate is implemented by remote_connect_setup/3 and\n       remote_connect_accept/6. These two predicates can be used to\n       implement the remote connection, allowing for more flexibility.\n\nModes and Determinism\n   remote_connect(?, -, ?) is det\n   remote_connect(?, +, ?) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Peer is an existing peer name.\n\nExceptions\n     5 --- Host, Port or Peer not of correct type\n   141 --- The remote protocols of the remote and ECLiPSe sides are incompatible.\n   170 --- Port is not a valid port number\n\nExamples\n   \n\n% with the following definition for disconnect/0\ndisconnect :- writeln(bye).\n\n% the following will cause `bye' to be printed when the remote connection\n% is disconnected\n\nremote_connect(_Address, Peer, set_event_handler(Control, disconnect/0)).\n\nSee Also\n   remote_disconnect / 1, remote_yield / 1, remote_connect_setup / 3, remote_connect_accept / 6"},"remote_connect_accept/6":{"prefix":"remote_connect_accept","body":"remote_connect_accept(${1:Peer}, ${2:Socket}, ${3:TimeOut}, ${4:InitGoal}, ${5:PassTerm}, ${6:InitRes})$7\n$0","description":"remote_connect_accept(+Peer, +Socket, +TimeOut, ?InitGoal, +PassTerm, -InitRes)\n\n   Second half of initiating a remote interface connection.\n\nArguments\n   Peer    Remote peer name (atom)\n   Socket    Server socket stream number (integer)\n   TimeOut    Time out interval (atomic)\n   InitGoal    Initialisation Goal (goal or variable)\n   PassTerm    `PassTerm' for authenticating connection (term)\n   InitRes    Result of executing the InitGoal (variable)\n\nType\n   External Interface\n\nDescription\n\n    \n    This predicate completes the remote interface connection started by\n    remote_connect_setup/3, which must be called before. The Peer and\n    Socket arguments should be the same as those in the call to\n    remote_connect_setup/3. \n\n    \n    This predicate will accept the remote socket stream connections\n    according to the remote interface protocol described in the embedding\n    and interfacing manual. Peer is the name of the new remote peer.\n    TimeOut is used to specify the amount of time, in seconds, that the\n    predicate will wait for the remote connection. If TimeOut is the atom\n    block, then it will wait indefinitely for the connection from the\n    remote process. The predicate will fail if the interval specified in\n    TimeOut has elapsed while waiting for any of the connections with the\n    remote side (including any subsequent peer queue connections).\n    PassTerm is used for a simple authentication of the remote process:\n    once the control connection is established, but before the rest of the\n    creation of the ec_rpc link, the remote process must send a ECLiPSe\n    term that matches (the comparison is performed using ==/2) PassTerm. If\n    the terms fail to match, then the connection is closed and an out of\n    range exception raised. The term is specified in EXDR format on the\n    remote side. With the Tcl remote interface, the command to establish\n    the connection sends a default PassTerm that is the empty string. This\n    can be overridden by the programmer with a more complicated term.\n    After establishing the connection, InitGoal will be executed to perform\n    any user-defined initialisation on the ECLiPSe side, before any further\n    interactions between the two sides. The result of executing the goal is\n    passed back in InitRes; InitRes is set to fail and throw respectively\n    if the goal fails or throws an exception.\n\n    \n    The socket server Socket will be closed upon successful completion of\n    the connection. It will also be closed if the predicate times out.\n\n    \n    Once the connection is established, the optional user initialisation is\n    performed on the ECLiPSe side before any further interactions. This is\n    specified by InitGoal: If InitGoal is not a variable, it gives the\n    goal that will be executed for the initialisation. If\n    InitGoal is a variable, then no user initialisation is done before the\n    two sides can interact. The result of executing the goal is returned in\n    InitRes: the goal with its bindings if it was successful, the atom fail\n    if the goal failed, and the atom throw if an exception occurred. \n    InitRes should be uninstantiated initially; otherwise, InitGoal will\n    not be executed. \n\n    \n    After the optional initialisation, the remote interface is\n    established. Initially, the remote side has control, and the predicate\n    will block, and returns when the remote side hands over control.\n \n\nModes and Determinism\n   remote_connect_accept(+, +, +, ?, +, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n    TimeOut second has elapsed without a connection request;\n     Peer is not a remote peer name which is waiting to complete a remote connection.\n\nExceptions\n     1 --- PassTerm fails to match the term sent by the remote side.\n     6 --- Handshaking timed-out after 100 seconds.\n   141 --- The remote protocols of the remote and ECLiPSe sides are incompatible.\n   193 --- Socket is not a valid server socket.\n\nSee Also\n   remote_connect_setup / 3, remote_disconnect / 1, remote_yield / 1, remote_connect / 3"},"remote_connect_setup/3":{"prefix":"remote_connect_setup","body":"remote_connect_setup(${1:Address}, ${2:Peer}, ${3:Socket})$4\n$0","description":"remote_connect_setup(?Address, ?Peer, -Socket)\n\n   First half of initiating a remote interface connection.\n\nArguments\n   Address    Address for remote connection (Host/Port or variable)\n   Peer    Remote Peer name (atom or variable)\n   Socket    Server socket stream number (variable)\n\nType\n   External Interface\n\nDescription\n    \n    Set up the initial stage for a remote interface connection. This\n    predicate type checks the arguments and creates a socket server at\n    address Host/Port. This socket server will accept the socket stream\n    connections from the remote process that is to be attached. The socket\n    server stream is returned in Socket. Peer should be the name of the new\n    remote Peer; if it is a variable, the predicate will assign a new name\n    to the Peer. If Peer is an atom, the predicate will fail if Peer is an\n    existing peer name (including names which has been created using\n    remote_connect_setup/3, but not yet attached by remote_connect_accept/6).\n    \n    When the predicate returns, the remote process can make its socket\n    connections at Host/Port. The connecting request will suspend until\n    they are accepted on the ECLiPSe side by calling\n    remote_connect_accept/6. \n    \n    This predicate should always be followed by a call to\n    remote_connect_accept/6, which completes the remote connection. The\n    predicates are separated to allow the user to start the connecting\n    request on the remote process. This can be done for example via exec/3.\n    \n    If Host and Port are not initially variables, they must be valid for\n    forming a socket connection. If Host is `localhost', then the remote\n    connection would be restricted to the same host as the ECLiPSe process.\n    \n    The predicates remote_connect_setup/3 and remote_connect_accept/6 are\n    used to implement remote_connect/3. \n\nModes and Determinism\n   remote_connect_setup(?, -, -) is det\n   remote_connect_setup(?, +, -) is semidet\n\nFail Conditions\n   Peer is an existing peer name.\n\nExceptions\n     5 --- Arguments are not of the correct type\n\nSee Also\n   remote_connect_accept / 6, remote_disconnect / 1, remote_yield / 1, remote_connect / 3, exec / 3"},"remote_yield/1":{"prefix":"remote_yield","body":"remote_yield(${1:Peer})$2\n$0","description":"remote_yield(+Peer)\n\n   Explicitly yield to the remote peer Peer\n\nArguments\n   Peer    Remote peer (atom)\n\nType\n   External Interface\n\nDescription\n\n    \n   If Peer is a valid current remote peer, this predicate will cause the control to be\n   transfer to that peer, i.e. the ECLiPSe will yield to the remote\n   side. This predicate returns when ECLiPSe side resumes control.\n   If the remote side initiates disconnection while it has control,\n   remote_yield/1 will abort after the disconnection.\n\nModes and Determinism\n   remote_yield(+) is semidet\n\nFail Conditions\n   Peer is not a valid current remote peer.\n\nExceptions\n   peer_abort_disconnected --- Peer has disconnected.\n   peer_abort_error --- Some internal error has occured (this should be reported as an ECLiPSe bug to the ECLiPSe team).\n\nSee Also\n   remote_connect / 3, remote_disconnect / 1"},"remote_disconnect/1":{"prefix":"remote_disconnect","body":"remote_disconnect(${1:Peer})$2\n$0","description":"remote_disconnect(+Peer)\n\n   Disconnect the remote peer Peer\n\nArguments\n   Peer    Remote Peer (atom)\n\nType\n   External Interface\n\nDescription\n\n     \n    If Peer is the name for a current remote peer, this predicate will\n    initiate a disconnection. Otherwise, the predicate succeeds without\n    performing any action.\n\nModes and Determinism\n   remote_disconnect(+) is det\n\nSee Also\n   remote_connect / 3, remote_yield / 1"},"xset/3":{"prefix":"xset","body":"xset(${1:Handle}, ${2:Index}, ${3:Value})$4\n$0","description":"xset(+Handle, +Index, +Value)\n\n   Set the Index-th field of an external data structure (referenced by Handle) to Value.\n\nArguments\n   Handle    An external data handle.\n   Index    An integer.\n   Value    A term.\n\nType\n   External Interface\n\nDescription\n   ECLiPSe can manipulate external data structures via handles.\n   An external data handle can only be created by external code.\n   It consists of a pointer to the external data and a descriptor\n   for this data (a method table). ECLiPSe can then perform certain\n   operations on the data using this method table.\n\n   The xset/3 predicate invokes one of the methods, the set-method. \n   The intended meaning is that a field of the external data structure\n   (indicated by Index) is set to the given Value.  This setting\n   qualifies as a side-effect (similar to writing to a file) and is\n   not undone on backtracking.  The details of how the index is\n   interpreted and which values are allowed depend on the set-method\n   supplied by external code.\n\nModes and Determinism\n   xset(+, +, +) is semidet\n\nFail Conditions\n   Fails if the set-method specifies failure for certain arguments\n\nExceptions\n     4 --- Handle or Index is uninstantiated.\n     5 --- Handle is not a handle, or Index is not an integer.\n   141 --- The set-method is not implemented for this handle.\n   other --- The set-method can raise any exception\n\nExamples\n   \n    /* C code with embedded ECLiPSe call, passing data via C ararys */\n    #include \"eclipse.h\"\n\n    #define N 5\n    double data_in[N] = {1.1,2.2,3.3,4.4,5.5};\n    double data_out[N];\n\n    main()\n    {\n    pword   call;\n    int     i;\n    \n    ec_init();\n    ec_post_string(\"[my_code]\");\n    ec_post_goal(\n    ec_term(ec_did(\"process\", 3),\n    ec_long(N),\n    ec_handle(&ec_xt_double_arr, (t_ext_ptr) data_in),\n    ec_handle(&ec_xt_double_arr, (t_ext_ptr) data_out)\n    )\n    );\n    if (ec_resume() == PSUCCEED)\n    {\n    for (i=0; i<N; i++)\n    printf(\"%f,\", data_out[i]);\n    }\n    ec_cleanup();\n    }\n\n    /* ECLiPSe code in file my_code.pl */\n\n    process(0, _, _) :- !.\n    process(N, In, Out) :-\n    N1 is N-1,\n    xget(In, N1, X),\n    Y is sqrt(X),\n    xset(Out, N1, Y),\n    process(N1, In, Out).\n\n    /* Sample run */\n\n    % main\n    1.048809,1.483240,1.816590,2.097618,2.345208,\n\nSee Also\n   xget / 3, subscript / 3"},"xget/3":{"prefix":"xget","body":"xget(${1:Handle}, ${2:Index}, ${3:Value})$4\n$0","description":"xget(+Handle, +Index, -Value)\n\n   Get the Index-th field of an external data structure (referenced by Handle).\n\nArguments\n   Handle    An external data handle.\n   Index    An integer.\n   Value    A variable.\n\nType\n   External Interface\n\nDescription\n   ECLiPSe can manipulate external data structures via handles.\n   An external data handle can only be created by external code.\n   It consists of a pointer to the external data and a descriptor\n   for this data (a method table). ECLiPSe can then perform certain\n   operations on the data using this method table.\n\n   The xget/3 predicate invokes one of the methods, the get-method.\n   The intended meaning is that it gets a field of the external data\n   structure (indicated by Index) and unifies it with Value.\n   The details of how the index is interpreted and how the field's\n   value is converted to an ECLiPSe term is dependent on the\n   get-method supplied by external code.\n\nModes and Determinism\n   xget(+, +, -) is det\n\nExceptions\n     4 --- Handle or Index is uninstantiated.\n     5 --- Handle is not a handle, or Index is not an integer.\n     6 --- Index is out of range (if check implemented by method).\n   141 --- The get-method is not implemented for this handle.\n\nExamples\n   \n    /* C code with embedded ECLiPSe call, passing data via C ararys */\n    #include \"eclipse.h\"\n\n    #define N 5\n    double data_in[N] = {1.1,2.2,3.3,4.4,5.5};\n    double data_out[N];\n\n    main()\n    {\n    pword   call;\n    int     i;\n    \n    ec_init();\n    ec_post_string(\"[my_code]\");\n    ec_post_goal(\n    ec_term(ec_did(\"process\", 3),\n    ec_long(N),\n    ec_handle(&ec_xt_double_arr, (t_ext_ptr) data_in),\n    ec_handle(&ec_xt_double_arr, (t_ext_ptr) data_out)\n    )\n    );\n    if (ec_resume() == PSUCCEED)\n    {\n    for (i=0; i<N; i++)\n    printf(\"%f,\", data_out[i]);\n    }\n    ec_cleanup();\n    }\n\n    /* ECLiPSe code in file my_code.pl */\n\n    process(0, _, _) :- !.\n    process(N, In, Out) :-\n    N1 is N-1,\n    xget(In, N1, X),\n    Y is sqrt(X),\n    xset(Out, N1, Y),\n    process(N1, In, Out).\n\n    /* Sample run */\n\n    % main\n    1.048809,1.483240,1.816590,2.097618,2.345208,\n\nSee Also\n   xset / 3, setarg / 3"},"get/2":{"prefix":"get","body":"get(${1:Stream}, ${2:Code})$3\n$0","description":"get(+Stream, -Code)\n\n   Reads the next character from the input stream Stream\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Code    Variable or integer.\n\nType\n   Character I/O\n\nDescription\n   Takes the next character from the input stream Stream, and unifies its\n   integer character code with Code.  The range of possible values depends\n   on the stream's text encoding, or is 0 to 255 for binary streams.\n\n   Character codes for the non-printable characters (i.e. control characters)\n   are treated like normal characters.\n\n   On end-of-file, -1 is returned (via the default handler for event 190).\n\nModes and Determinism\n   get(+, -) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Code is instantiated, but not to an integer.\n   190 --- End of file has been reached.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      ?- get(input, X).\n       a\n      X = 97\n      yes.\n\n      ?- get(input, 0'a), get(input,97).\n       aa\n      yes.\nFail:\n      ?- get(input,98).\n       a\n      no.\nError:\n      get(Stream,98).    (Error 4).\n      get(input, '98').    (Error 5).\n      get(10,A).    (Error 192).\n      get(atom,A).    (Error 193).\n\nSee Also\n   get / 1, put / 1, put / 2"},"nl/0":{"prefix":"nl","body":"nl","description":"nl\n\n   A newline is printed on the output stream.\n\nArguments\n\nType\n   Character I/O\n\nDescription\n    Used to print a newline sequence on the current output stream.\n    The exact character sequence emitted depends on the setting of\n    the stream's end_of_line flag (lf or crlf).\n    In addition, if the stream's flush flag is set to\n    end_of_line, the stream is also flushed.\n\nModes and Determinism\n   nl is det\n\nSee Also\n   nl / 1, writeln / 1"},"yield/2":{"prefix":"yield","body":"yield(${1:ToC}, ${2:FromC})$3\n$0","description":"yield(+ToC, -FromC)\n\n   Yield control to the C/C++ main program that has invoked ECLiPSe.\nThe arguments are used for passing data in and out.\n\nArguments\n   ToC    A term.\n   FromC    A variable.\n\nType\n   External Interface\n\nDescription\n   When ECLiPSe is used as an embedded component within an application\n   written in C/C++, the ECLiPSe execution is conceptually a thread.\n   Therefore, a yield-resume control flow model is used.\n   On the C/C++ side, the ec_resume()/EC_resume() functions pass\n   control to the ECLiPSe thread, while on the ECLiPSe side, the\n   yield/2 predicate is used to pass control back.\n   Data can be passed both ways: the ToC argument of yield/2 is passed\n   to C/C++ via the second argument of ec_resume()/EC_resume() when it\n   returns. Similarly a ec_resume()/EC_resume() first argument is\n   passed to ECLiPSe as the FromC argument of yield/2.\n\n   This mechanism is supposed to be used such that an ECLiPSe server\n   loop is set up, and the host program resumes ECLiPSe repeatedly\n   to have a request served.\n\n   Note that, by default, ECLiPSe is set up as a server which calls\n   posted goals. This is such a general mechanism that it is often\n   not necessary to write a special-purpose server loop.\n\nModes and Determinism\n   yield(+, -) is det\n\nExamples\n   \n    % ECLiPSe server code\n    start_server :-\n    eclipse_server(dummy).\n\n    eclipse_server(PrevResult) :-\n    yield(PrevResult, Request),\n    process_request(Request, NewResult),\n    eclipse_server(NewResult).\n\n    // C++ client code\n    ec_init();\n    post_goal(\"start_server\");\n    if (EC_resume() == EC_yield)\n    {\n    for(;;)\n    {\n\t    // create a request\n    ...\n    if (EC_resume(request, result) != EC_yield);\n    break;\n    ...\n    // use the result\n    }\n    }\n\nSee Also\n   xget / 3, xset / 3"},"get/1":{"prefix":"get","body":"get(${1:Code})$2\n$0","description":"get(-Code)\n\n   Reads the next character or byte from the current input stream\n\nArguments\n   Code    Variable or integer.\n\nType\n   Character I/O\n\nDescription\n   Takes the next character from the current input stream, and unifies its\n   integer character code with Code.  The range of possible values depends\n   on the stream's text encoding, or is 0 to 255 for binary streams.\n\n   Character codes for the non-printable characters (i.e. control characters)\n   are treated like normal characters.\n\n   On end-of-file, -1 is returned (via the default handler for event 190).\n\nModes and Determinism\n   get(-) is det\n\nExceptions\n     5 --- Code is instantiated, but not to an integer.\n   190 --- End of file has been reached.\n\nExamples\n      Equivalent to get(input, Code).  (see get/2 for details).\n\nSee Also\n   get / 2, put / 1, put / 2"},"get_char/1":{"prefix":"get_char","body":"get_char(${1:Char})$2\n$0","description":"get_char(-Char)\n\n   Reads the next character from the current input\n\nArguments\n   Char    Single character string or variable.\n\nType\n   Character I/O\n\nDescription\n   Takes a single-character string from the current input and unifies it\n   with Char.\n\n   Note that this predicate returns a string, while the corresponding predicate\n   iso:get_char/1 returns an atom!\n\nModes and Determinism\n   get_char(-) is det\n\nExceptions\n     5 --- Char is instantiated, but not to a string.\n\nExamples\n      Equivalent to get_char(input, Char).  (see get_char/2 for details).\n\nSee Also\n   get_char / 2, iso : get_char / 1, put_char / 1, put_char / 2"},"nl/1":{"prefix":"nl","body":"nl(${1:Stream})$2\n$0","description":"nl(+Stream)\n\n   A newline is printed on the output stream Stream.\n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Character I/O\n\nDescription\n    Used to print a newline sequence on the output stream Stream.\n    The exact character sequence emitted depends on the setting of\n    the stream's end_of_line flag (lf or crlf).\n    In addition, if the stream's flush flag is set to\n    end_of_line, the stream is also flushed.\n\nModes and Determinism\n   nl(+) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither an atom nor a number.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n   Success:\n      open(file1,update,s), nl(s), close(s).\n      nl(output).\nError:\n      nl(Stream).    (Error 4).\n      nl(7.0).    (Error 5).\n      open(file1,read,s),nl(s). (Error 192). % read mode\n      nl(29).    (Error 192). % stream not open\n      nl(-1).    (Error 193). % out of range\n      nl(30).    (Error 193). % out of range\n      nl(atom).    (Error 193). % no such stream\n\nSee Also\n   nl / 0, writeln / 2, flush / 1, open / 4, set_stream_property / 3, get_stream_info / 3"},"put/2":{"prefix":"put","body":"put(${1:Stream}, ${2:Code})$3\n$0","description":"put(+Stream, +Code)\n\n   The character represented by the integer code Code is put onto the\nbuffered output stream Stream.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Code    Integer.\n\nType\n   Character I/O\n\nDescription\n   Writes the character (or byte, in case of binary stream) represented by\n   the integer Code onto the output stream Stream.  The acceptable\n   value range depends on the stream's character encoding, or is 0 to 255\n   for binary streams.\n\n   Note that the output from put/2 is usually buffered, and is only output\n   to the stream when the output is flushed (e.g.  using flush/1).\n\n   Character codes for the non-printable characters (i.e. control characters)\n   are also acceptable.\n\nModes and Determinism\n   put(+, +) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     4 --- Code is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Code is instantiated, but not to an integer.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      ?- put(output, 0'a).\n      a\n      yes.\n\n      ?- sh('cat file1').\n      a\n      yes.\n      ?- open(file1,read,s1),\n    open(file2,write,s2),repeat,\n    ( at_eof(s1) ->\n    !,\n    flush(s2),\n    close(s1),close(s2)\n    ;\n    get(s1,Char),\n    put(s2,Char),\n    fail\n    ).\n      Char = _g72\n      yes.\n      ?- sh('cat file2').\n      a\n      yes.\n\nError:\n      put(output,A).    (Error 4).\n      put(Stream,98).    (Error 4).\n      put(output, '98').    (Error 5).\n      put(output, 98.0).    (Error 5).\n      put(\"string\" A).    (Error 5).\n      put(11,97).    (Error 192). % stream not open\n      put(atom,97).    (Error 193).\n\nSee Also\n   get / 1, get / 2, put / 1, nl / 1"},"read_string/3":{"prefix":"read_string","body":"read_string(${1:Delimiters}, ${2:Length}, ${3:String})$4\n$0","description":"read_string(+Delimiters, ?Length, -String)\n\n   Reads a string from the input stream up to a delimiter or up to a specified length\n\nArguments\n   Delimiters    String or atom.\n   Length    Integer or variable.\n   String    String or variable.\n\nType\n   Character I/O\n\nDescription\n   A string of characters is read from the input up to one character which\n   occurs in the delimiter string Delimiters.  This character is also\n   consumed, but does not appear in the string which is unified with\n   String.\n   \n   Two symbolic Delimiters can be specified:\n\n    end_of_line   a newline or carriage-return/newline sequence\n    end_of_file   the end of the file/input\n\n   End of file always acts like a delimiter.\n\n   If Length is a variable, it is unified with the length of the string\n   String.  If Length is an integer, the number of characters read from\n   the input is limited by the Length.\n\nModes and Determinism\n   read_string(+, +, -) is semidet\n   read_string(+, -, -) is semidet\n\nFail Conditions\n   There is nothing to read, i.e. the stream is at end_of_file\n\nExceptions\n     4 --- Delimiters is not instantiated.\n     5 --- Delimiters is not a string or atom.\n     5 --- Length is not an atom or an integer.\n     5 --- String is not an atom or a string.\n     6 --- Delimiters is an atom but not a valid symbolic delimiter.\n   190 --- End of file was encountered before reading any character.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n      Equivalent to read_string(input, Delimiters, Length, String).  (see\n   read_string/4 for details).\n\nSee Also\n   read_string / 4, read_token / 2, read_token / 3, open / 3"},"put/1":{"prefix":"put","body":"put(${1:Code})$2\n$0","description":"put(+Code)\n\n   The character represented by the integer Code is put onto the\nbuffered current output\n\nArguments\n   Code    Integer.\n\nType\n   Character I/O\n\nDescription\n   Writes the character (or byte, in case of binary stream) represented by\n   the integer Code onto the buffered current output stream.  The acceptable\n   value range depends on the stream's character encoding, or is 0 to 255\n   for binary streams.\n\n   Note that the output from put/1 is usually buffered, and is only output\n   to the screen when the output is flushed e.g. when returning to the\n   ECLiPSe prompt or explicitly using flush(output).\n\n   Character codes for the non-printable characters (i.e. control characters)\n   are also acceptable.\n\nModes and Determinism\n   put(+) is det\n\nExceptions\n     4 --- Code is not instantiated.\n     5 --- Code is instantiated, but not to an integer.\n\nExamples\n      Equivalent to put(output, Code).  (see put/2 for details).\n\nSee Also\n   get / 1, get / 2, put / 2, nl / 0"},"get_char/2":{"prefix":"get_char","body":"get_char(${1:Stream}, ${2:Char})$3\n$0","description":"get_char(+Stream, -Char)\n\n   Reads the next character from the input stream Stream\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Char    Single character string or variable.\n\nType\n   Character I/O\n\nDescription\n   Takes a single character string from the input stream Stream.  and\n   unifies it with Char.\n\n   Note that this predicate returns a string, while the corresponding predicate\n   iso:get_char/2 returns an atom!\n\nModes and Determinism\n   get_char(+, -) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Char is instantiated, but not to a single character string.\n   190 --- End of file has been reached.\n   192 --- Stream is not open for reading.\n   193 --- Stream is not a valid stream number.\n\nExamples\n   \n   Success:\n      ?- get_char(input,Char).\n       a\n      Char = \"a\"\n      yes.\n\n      ?- get_char(input, \"b\").\n       b\n      yes.\n\n      ?- sh('cat file1').\n      p\n      yes.\n      ?- open(file1, update,s),\n    get_char(s,X).\n      X = \"p\"\n      yes.\nFail:\n      ?- get_char(input, \"b\").\n       a\n      no.\n\nError:\n      get_char(Stream, \"b\").    (Error 4).\n      get_char(input, 'b').    (Error 5).\n      get_char(input, 98.0).    (Error 5).\n      get_char(\"string\", Char).    (Error 5).\n      get_char(null,Char).    (Error 190).\n      get_char(9,Char).    (Error 192).\n      get_char(atom,Char).    (Error 193).\n\nSee Also\n   get / 1, get / 2, get_char / 1, iso : get_char / 2, put / 1, put / 2, put_char / 1, put_char / 2"},"put_char/1":{"prefix":"put_char","body":"put_char(${1:Char})$2\n$0","description":"put_char(+Char)\n\n   Puts the single character text Char onto the buffered current output.\n\nArguments\n   Char    Single character string or atom.\n\nType\n   Character I/O\n\nDescription\n   Puts the single-character string or atom Char onto the current output.\n\nModes and Determinism\n   put_char(+) is det\n\nExceptions\n     4 --- Char is not instantiated.\n     5 --- Char is instantiated, but not to a single character string or atom.\n\nExamples\n      Equivalent to put_char(output, Char).  (see put_char/2 for details).\n\nSee Also\n   get_char / 1, get_char / 2, put_char / 2, nl / 0"},"put_char/2":{"prefix":"put_char","body":"put_char(${1:Stream}, ${2:Char})$3\n$0","description":"put_char(+Stream, +Char)\n\n   Puts the single character text Char onto the buffered output stream Stream.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Char    Single character string or atom.\n\nType\n   Character I/O\n\nDescription\n   Puts the single-character string or atom Char onto the output stream Stream.\n\nModes and Determinism\n   put_char(+, +) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     4 --- Char is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Char is instantiated, but not to a single character string or atom.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n  ?- put_char(output, \"a\").\n  a\n  yes.\n\n  ?- put_char(output, '7').\n  7\n  yes.\n\n  ?- put_char(output, a).\n  a\n  yes.\n\nError:\n  put_char(Stream,A).      (Error 4).\n  put_char(output,ab).     (Error 5).\n  put_char(output,98).     (Error 5).\n  put_char(11, \"a\").    (Error 192).\n  put_char(atom, \"a\").      (Error 193).\n\nSee Also\n   get_char / 1, get_char / 2, put_char / 1, nl / 1"},"read_token/2":{"prefix":"read_token","body":"read_token(${1:Token}, ${2:Class})$3\n$0","description":"read_token(-Token, -Class)\n\n   Succeeds if the next token from the current input stream is successfully\nread and unified with Token and its token class with Class.\n\nArguments\n   Token    Variable or constant.\n   Class    Variable or atom.\n\nType\n   Character I/O\n\nDescription\n   This predicate is an interface to the ECLiPSe tokenizer.  It can be used\n   to read terms which are not ended by a fullstop or even to build whole\n   new parsers.  The next token from the input stream is read and unified\n   with Token.  The token class of this token is unified with Class.\n\n   read_token(Token, Class) is equivalent to read_token(input, Token,\n   Class).  See read_token/3 for details.\n\nModes and Determinism\n   read_token(-, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Class does not unify with an atom.\n   190 --- End of file was encountered before reading any character.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n      See read_token/3 for examples.\n\nSee Also\n   get_chtab / 2, set_chtab / 2, read_token / 3"},"read_string/4":{"prefix":"read_string","body":"read_string(${1:Stream}, ${2:Delimiters}, ${3:Length}, ${4:String})$5\n$0","description":"read_string(+Stream, +Delimiters, ?Length, -String)\n\n   Reads a string from the stream Stream up to a delimiter or up to a\nspecified length.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Delimiters    String or atom.\n   Length    Integer or variable.\n   String    String or variable.\n\nType\n   Character I/O\n\nDescription\n   A string of characters is read from the input stream Stream up to one\n   character which occurs in the delimiter string Delimiters.  This\n   character is also consumed, but does not appear in the string which is\n   unified with String.\n\n   Two symbolic Delimiters can be specified:\n\n    end_of_line   a newline or carriage-return/newline sequence\n    end_of_file   the end of the file/input\n\n   End of file always acts like a delimiter.\n\n   If Length is a variable, it is unified with the length of the string\n   String.  If Length is an integer, the number of characters read from\n   the input stream Stream is limited by Length.\n\nModes and Determinism\n   read_string(+, +, +, -) is semidet\n   read_string(+, +, -, -) is semidet\n\nFail Conditions\n   There is nothing to read, i.e. the stream is at end_of_file\n\nExceptions\n     4 --- Delimiters is not instantiated.\n     5 --- Delimiters is not a string or atom.\n     5 --- Length is a non-integer number.\n     5 --- String is not a variable or a string.\n     6 --- Delimiters is an atom but not a valid symbolic delimiter.\n    24 --- Length is not a variable or number.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \nSuccess:\n      ?- read_string(input, \"123\", Length, String).\n       abcdef2ghi\n      Length = 6\n      String = \"abcdef\"\n      yes.\n\n      ?- read_string(input, \" \\t\", Length, String).\n       one two\n      Length = 3\n      String = \"one\"\n      yes.\n\n      ?- read_string(input, end_of_line, Length, String).\n      abcdefghi\n      Length = 9\n      String = \"abcdefghi\"\n      yes.\n\n      ?- read_string(input, end_of_line, 6, String).\n      abcdefghi\n      String = \"abcdef\"\n      yes.\n\n      ?- open(file1, read, s).\n      yes.\n      ?- system('cat file1').\n      abcd\n      yes.\n      ?- read_string(s, \"\", Length, String).\n      Length = 5\n      String = \"abcd\\n\"    % Read up to end of file\n      yes.\n\n% Code example: read lines from a file and return\n% a list of strings, each string containing a line\n\n    get_lines(File, Lines) :-\n    open(File, read, S),\n    get_lines(S, Lines),\n    close(S).\n\n    get_lines(S, Lines) :-\n    ( read_string(S, end_of_line, _, Line) ->\n    Lines = [Line|Ls],\n    get_lines(S, Ls)\n    ;\n    Lines = []\n    ).\n\nFail:\n      ?- open(string(\"\"),read,s), read_string(s,\"\",L,String).\n\n      no (more) solution.    % EOF - Error 190 - handler fails\n\nError:\n    read_string(Stream, \"\", Length, String).       (Error 4).\n    read_string(stream, Dels, Length, String).     (Error 4).\n    read_string(\"stream\", \"\", Length, String).     (Error 5).\n    read_string(stream, 12, Length, String).       (Error 5).\n    read_string(stream, \"\", \"abc\", String).    (Error 5).\n    read_string(stream, \"\", Length, 12).    (Error 5).\n    read_string(stream, stop, Length, String).     (Error 6).\n    read_string(output, \"\", Length, String).       (Error 192).\n    read_string(atom, \"\", Length, String).    (Error 193).\n\nSee Also\n   read_string / 3, read_token / 2, read_token / 3, open / 3"},"read_token/3":{"prefix":"read_token","body":"read_token(${1:Stream}, ${2:Token}, ${3:Class})$4\n$0","description":"read_token(+Stream, -Token, -Class)\n\n   Succeeds if the next token from the input stream Stream is successfully\nread and unified with Token and its token class with Class.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Token    Variable or constant.\n   Class    Variable or atom.\n\nType\n   Character I/O\n\nDescription\n   This predicate is an interface to the ECLiPSe tokenizer.  It can be used\n   to read terms which are not ended by a fullstop or even to build whole\n   new parsers.  The next token from the input stream Stream is read and\n   unified with Token.  The token class of this token is unified with\n   Class.\n\n   The possible token classes with examples:\n\n   ---------------------------------------\n   | Input Example  Token    Class    |\n   |------------------------------------  |\n   | X    \"X\"      var    |\n   | _    \"_\"      anonymous    |\n   | abc    'abc'    atom    |\n   | 'a-b'    'a-b'    quoted_atom  |\n   | 123    123      integer      |\n   | 1.2    1.2      float    |\n   | 1_3    1_3      rational     |\n   | 0.9__1.1       0.9__1.1 breal    |\n   | \"abc\"    \"abc\"    string       |\n   | |    \"|\"      solo    |\n   | )    \")\"      solo    |\n   | (    \"(\"      solo    |\n   | <SPACE>(       \"(\"      open_par     |\n   | ,    ','      comma    |\n   | .<NL>    '.'      fullstop     |\n   | 1e789<NL>      \"1e789\"  error    |\n   ---------------------------------------|\n\n   Note that round, square and curly brackets are solo tokens whose\n   value is returned as a string.  Opening brackets preceded by space\n   are treated specially as open_par tokens.  Comma and fullstop have\n   their own token class.  All syntax errors are reported as class\n   error, with the input string up to the error as Token.  The default\n   error handler for the event 190 (reading EOF) returns end_of_file\n   in both Class and Token.\n\n   Note about signed numbers: the tokenizer returns a sign followed by a\n   number as two separate tokens.  For instance, the input \"-5\" is read\n   as two tokens, the atom '-' and the integer 5.  In the case of bounded\n   reals, this leads to \"-1.1__-0.9\" being returned as the atom '-' and\n   the bounded real 1.1__-0.9.  This is a non-canonical breal, since the\n   upper bound is lower than the lower bound.  read_token/2,3 is the only\n   predicate that can produce such objects, and it is the programmer's\n   responsibility to construct a valid breal using breal_bounds/3 and\n   breal_from_bounds/3, taking the sign into account.  Note that all\n   other arithmetic operations are undefined on non-canonical breals.\n\nModes and Determinism\n   read_token(+, -, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n     5 --- Class does not unify with an atom.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \nSuccess:\n      ?- read_token(input,T,C).\n    []\n      T = []\n      C = atom\n      ?- read_token(input,T,C).\n    [\n      T = \"[\"\n      C = solo\n      ?- read_token(input, \"k\",C).\n    \"k\"\n      C = string\n      ?- read_token(input,T,C).\n    X\n      T = \"X\"\n      C = var\n      ?- read_token(input,T,C).\n    1.6e-5.\n      T = 1.6e-05\n      C = float\n\nFail:\n      ?- read_token(input, \"[\", C).\n    &\n      no.\n\nError:\n      ?- read_token(input, T, C).\n    ^D\n      T = end_of_file\n      C = end_of_file\n      yes. (Error 190, default handler)\n\n      read_token(S, a(b,c), C).    (Error 4).\n      read_token(\"string\", a(b,c), C).  (Error 5).\n      read_token(9, X + 2, C).    (Error 192). % stream not open\n      read_token(atom, X + 2, C).       (Error 193).\n\nSee Also\n   get_chtab / 2, set_chtab / 2, read_token / 2"},"tyi/1":{"prefix":"tyi","body":"tyi(${1:Code})$2\n$0","description":"tyi(-Code)\n\n   Succeeds if the code of the next character read in raw mode from the\ncurrent input is successfully unified with Code.\n\nArguments\n   Code    Variable or integer.\n\nType\n   Character I/O\n\nDescription\n   Takes the next character from the current input and unifies its integer\n   character code (in the range 0 to 255) with Code.  The input is in raw mode\n   so that no newline character must be typed.\n\n   Character codes for the non-printable characters (i.e.  control characters)\n   are also acceptable.\n\nModes and Determinism\n   tyi(-) is det\n\nExceptions\n     5 --- Code is instantiated, but not to an integer.\n   190 --- End of file was encountered before reading any character.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n      Equivalent to tyi(input, Code).  (see tyi/2 for details).\n\nSee Also\n   tyi / 2, tyo / 1, tyo / 2"},"tyi/2":{"prefix":"tyi","body":"tyi(${1:Stream}, ${2:Code})$3\n$0","description":"tyi(+Stream, -Code)\n\n   Succeeds if the code of the next character read in raw mode from the\ninput stream Stream is successfully unified with Code.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Code    Variable or integer.\n\nType\n   Character I/O\n\nDescription\n   Takes the next character from the unbuffered input stream Stream and\n   unifies its integer character code (in the range 0 to 255) with Code.  The\n   input is in raw mode so that no newline character must be typed, and the\n   character is not echoed on the screen.\n\n   Character codes for the non-printable characters (i.e.  control characters)\n   are also acceptable.\n\nNote\n   tyi/2 reads from the stream in raw mode.  If it is combined with the\n   buffered predicates, it might happen that some characters typed ahead\n   may be lost if the input device is a terminal.\n\nModes and Determinism\n   tyi(+, -) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Code is instantiated, but not to an integer.\n   190 --- End of file has been reached.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \nSuccess:\n      ?- tyi(input,Code).\n      Code = 97    % press 'a'\n      yes.\n\n      ?- tyi(input,97).\n    % press 'a'\n      yes.\n\n      ?- tyi(input,Code).\n      Code = 4    % press ^D\n      yes.\n\nFail:\n      ?- tyi(input, 0'b).\n    % press 'a'\n      no.\n\nError:\n      tyi(Stream,98).    (Error 4).\n      tyi(input, '98').    (Error 5).\n      tyi(input, 98.0).    (Error 5).\n      tyi(\"string\", A).    (Error 5).\n\n      ?- open(file1,update,s), write(s,p),\n    seek(s,0), tyi(s,Code),\n      tyi(s,Code).    (Error 190).\n      tyi(9,A).    (Error 192).\n      tyi(atom,A).    (Error 193).\n\nSee Also\n   tyi / 1, tyo / 1, tyo / 2"},"tyo/1":{"prefix":"tyo","body":"tyo(${1:Code})$2\n$0","description":"tyo(+Code)\n\n   The character represented by the integer Code is put onto the\ncurrent output in raw mode.\n\nArguments\n   Code    Integer.\n\nType\n   Character I/O\n\nDescription\n   Puts the character represented by the integer character code Code (in the\n   range 0 to 255) onto the current output in raw mode.\n\n   If the output device is a terminal, the tyo/1 output goes directly to\n   the screen, whereas the output from put/1 is buffered first, and is only\n   output to the screen when the current output is flushed (e.g.\n   explicitly using flush(1).).\n\n   Character codes for the non-printable characters (i.e.  control characters)\n   are also acceptable.\n\nModes and Determinism\n   tyo(+) is det\n\nExceptions\n     4 --- Code is not instantiated.\n     5 --- Code is instantiated, but not to an integer.\n\nExamples\n      Equivalent to tyo(output, Code).  (see tyo/2 for details).\n\nSee Also\n   tyi / 1, tyi / 2, tyo / 2"},"accept/3":{"prefix":"accept","body":"accept(${1:Stream}, ${2:From}, ${3:NewStream})$4\n$0","description":"accept(+Stream, -From, ?NewStream)\n\n   Accepts a connection for a stream socket and creates a new socket which can\nbe used for I/O.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   From    A term unifiable with a structure atom/integer.\n   NewStream    Atom, structure or variable.\n\nType\n   Stream I/O\n\nDescription\n   accept/3 is a direct link to the accept(2) socket system call.\n   Stream must be a socket stream created with socket/3 or new_socket_server/3\n   of the type stream, listening for connections.  accept/3 blocks until\n   there is a connection request from another process, and then it creates\n   a new socket stream NewStream with the same properties as Stream, which\n   can be then used for communication with the connecting process.  The\n   Stream socket remains open and listening for further connections.\n\n   In the internet domain, From is unified with the address of the\n   connecting process in the form HostName/Port.  In the unix domain, From\n   is unified with an empty atom ''.\n\n   When instantiated, NewStream must be a symbolic stream name, i.e.  an\n   atom.  The stream can also be specified as sigio(NewStream).  In this\n   case the socket is created and in addition it is instructed to send the\n   signal io each time new data appears in it.\n\n   Stream sockets are connected using the standard sequence, i.e.\n   socket/3, bind/2, listen/2 and accept/3 on the server and socket/3 and\n   connect/2 on the client.  After the sockets are connected, both\n   processes can use them for reading and writing.\n\nModes and Determinism\n   accept(+, -, -) is det\n   accept(+, -, +) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a sigio/1    structure.\n     5 --- From is instantiated but not to an atom or a structure.\n   170 --- It was not possible to execute the system call.\n\nExamples\n   \nSuccess:\n      socket(internet, stream, s), bind(s, Addr), listen(s, 1),\n      accept(s, From, news).\n\nError:\n      accept(s, From, 6)    (Error 5).\n      socket(internet, datagram, s), bind(s, Addr), listen(s, 2),\n      accept(s, From, news)    (Error 170).\n\nSee Also\n   socket / 3, bind / 2, listen / 2, connect / 2"},"unget/1":{"prefix":"unget","body":"unget(${1:Stream})$2\n$0","description":"unget(+Stream)\n\n   Back up one character on Stream\n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Character I/O\n\nDescription\n    Go back one character on the given Stream. This can be used to\n    implement lookaheads.\n    \n    The number of characters that can be reliably ungotten is 4, and the\n    result is only defined if these characters have been read previously.\n    \n    The result of the operation is undefined if\n    \n    trying to unget more than 4 characters\n    trying to unget more characters than had been read previously\n    trying to unget after a seek operation\n    \n    In these cases, unget/1 will succeed, but subsequent read operations\n    will return undefined results.\n\nModes and Determinism\n   unget(+) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n   192 --- Stream not in read mode.\n\nExamples\n   \n% look ahead one character in Stream:\n\n    peek(Stream, X) :-\n    get(Stream, X),\n    unget(Stream).\n\nSee Also\n   get / 2, get_char / 2"},"tyo/2":{"prefix":"tyo","body":"tyo(${1:Stream}, ${2:Code})$3\n$0","description":"tyo(+Stream, +Code)\n\n   The character represented by the integer Code is put onto the output\nstream Stream in raw mode.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Code    Integer.\n\nType\n   Character I/O\n\nDescription\n   Puts the character represented by the integer character code Code (in the\n   range 0 to 255) onto the output stream Stream in raw mode.\n\n   If the stream is a terminal, the tyo/2 output goes directly to the\n   stream, whereas the output from put/2 is buffered first, and is only\n   output to the stream when the output is flushed (e.g.  explicitly using\n   flush/1).\n\n   If the stream is not a terminal, tyo/2 behaves like put/2.\n\n   Character codes for the non-printable characters (i.e.  control characters)\n   are also acceptable.\n\nModes and Determinism\n   tyo(+, +) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     4 --- Code is not instantiated.\n     5 --- Stream is neither a stream handle nor an atom.\n     5 --- Code is instantiated, but not to an integer.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n   Success:\n      ?- set_stream(screen,output),\n    tyo(screen,91),tyo(screen,97),\n    tyo(screen,93).\n      [a]\n      yes.\n\n      ?- put(screen, 0'a), tyo(screen, 0'b),\n    put(screen, 0'c), tyo(screen, 0'd).\n      bdac\n      yes.\n\n      ?- write(screen,i), tyo(screen, 0'h).\n      hi\n      yes.\n\nError:\n      tyo(Stream,A).    (Error 4).\n      tyo(output,a).    (Error 5).\n      tyo(98.0,output).    (Error 5).\n      tyo(\"string\", A).    (Error 5).\n      tyo(11,97).    (Error 192).\n      tyo(atom,97).    (Error 193).\n\nSee Also\n   tyi / 1, tyi / 2, tyo / 1"},"bind/2":{"prefix":"bind","body":"bind(${1:Stream}, ${2:Address})$3\n$0","description":"bind(+Stream, ?Address)\n\n   Associates an address with a given socket stream. \n\nArguments\n   Stream    Stream handle or alias (atom)\n   Address    Atom, structure or variable.\n\nType\n   Stream I/O\n\nDescription\n\n   bind/2 is a direct link to the bind(2) socket system call.\n   Stream must be a socket stream created with socket/3.\n   If the socket was created in the unix domain, Address must be an atom\n   which identifies the file associated with the socket.  This file name\n   can then be used by other processes to connect with this socket using\n   the predicate connect/2.\n\n   If the socket is in the internet domain, the address is in the form\n   HostName/Port, where any of Address or HostName or Port may be\n   uninstantiated.  When the port is already in use, the predicate raises\n   an error and so it is always safest to call bind/2 with Address\n   uninstantiated (this corresponds to the INADDR_ANY value for the system\n   call), and upon success it will be instantiated to the hostname and\n   selected port number.\n\n   Stream sockets are connected using the standard sequence, i.e.\n   socket/3, bind/2, listen/2 and accept/3 on the server and socket/3 and\n   connect/2 on the client.  After the sockets are connected, both\n   processes can use them for reading and writing.\n\n   Datagram sockets require a connect/2 call from the process that wants to\n   write on the socket and bind/2 from the one that reads from it.\n\nModes and Determinism\n   bind(+, +) is det\n   bind(+, -) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n     5 --- Address is instantiated but not to the form accepted by the    socket domain.\n   170 --- It was not possible to bind the socket.\n\nExamples\n   \nSuccess:\n\nError:\n      bind(s, Host/p)    (Error 5).\n      bind(s, '/usr/bin')    (Error 170).\n\nSee Also\n   socket / 3, listen / 2, accept / 3, connect / 2, new_socket_server / 3, current_stream / 1, get_stream_info / 3"},"at/2":{"prefix":"at","body":"at(${1:Stream}, ${2:Pointer})$3\n$0","description":"at(+Stream, -Pointer)\n\n   Succeeds if Position is the position of the stream Stream.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Pointer    Integer or variable.\n\nType\n   Stream I/O\n\nDescription\n   Unifies Position with the position of the given Stream, which is\n   defined as follows:\n\n   For file streams, Position is the position in the file (the offset in\n   bytes from the beginning of the file) where the next read/write operation\n   will occur.\n\n   For tty read streams, Position is the number of bytes already read from\n   the tty. For tty write streams, Position is the number of bytes already\n   written to the tty.\n\n   For pipe read streams, Position is the number of bytes already read from\n   the pipe. For pipe write streams, Position is the number of bytes already\n   written to the pipe.\n\n   For socket streams, Position is the number of bytes already read from\n   the socket.\n\n   For string streams, Position is the position in the string (the offset in\n   bytes from the beginning of the string) where the next read/write operation\n   will occur.\n\n   For queue read streams, Position is always 0. For queue write and queue\n   update streams, Position is the number of unread bytes in the queue.\n\n   For the null stream, Position is always 0.\n\n   Stream can be a symbolic stream name or a stream handle.\n\nModes and Determinism\n   at(+, -) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Pointer is instantiated to a non-integer.\n     5 --- Stream is instantiated to neither to an atom nor a stream handle.\n   192 --- Stream is an illegal stream mode.\n\nExamples\n   \nSuccess:\n      ?- open(file1,write,S), at(S, P1),\n    write(S, 1234567890), at(S, P2), close(S).\n      P1 = 0\n      P2 = 10\n\n      ?- open(file1,update,S), at(S, P1), read(S, T),\n    at(S, P2), close(S).\n      P1 = 0\n      T = 1234567890\n      P2 = 10\n\nError:\n      at(Stream, 4).      (Error 4).\n      at(\"3\", Position).   (Error 5).\n      at(7, 4.3).    (Error 5).\n\nSee Also\n   at_eof / 1, seek / 2"},"at_eof/1":{"prefix":"at_eof","body":"at_eof(${1:Stream})$2\n$0","description":"at_eof(+Stream)\n\n   Succeeds if the stream Stream is positioned at end of file. \n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n   Used to test if the input stream Stream is positioned at end of file.\n\n   For file streams and string streams, this means that either the next read\n   operation will return an end-of-file condition, or end-of-file was already\n   read and the next read operation would result in a past-end-of-file error.\n\n   For tty streams, it means only that there is currently no further input\n   available, and a subsequent read operation will prompt for more.\n\n   For queue streams, it means only that the queue is currently empty.\n   The queue will recover from the end-of-file condition when new data\n   is written into it from the write end.\n\n   For pipe and socket streams, this condition means that the next read\n   operation will either block or return an end-of-file condition.\n   To check whether there is any data to read, use stream_select/3.\n\n   The null stream is always at end-of-file.\n\n   Stream can be a symbolic stream name or a stream handle.\n\nModes and Determinism\n   at_eof(+) is semidet\n\nFail Conditions\n   Fails if Stream is a file with its pointer not at end of file.\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n   192 --- Stream is an illegal stream mode.\n\nExamples\n   \nSuccess:\n      at_eof(null).\n\n      ?- open(file1,update,S), at_eof(S),\n    write(S,hello), at(S,5), at_eof(S), close(S).\n      yes.\n\nFail:\n\n      ?- open(file1,write,S),write(S,hello), close(S),\n    open(file1,read,S), at_eof(S), close(S).\n      no.\n\nError:\n      at_eof(X).    (Error 4).\n      at_eof(\"s\").    (Error 5).\n      at_eof(not_a_stream).       (Error 192).\n\nSee Also\n   at / 2, seek / 2, stream_truncate / 1"},"close/1":{"prefix":"close","body":"close(${1:Stream})$2\n$0","description":"close(+Stream)\n\n   Closes the stream specified by Stream.  \n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n\n   Used to explicitly close a stream.  Stream can be a symbolic stream name\n   or a stream handle.\n\n   When Stream is a stream handle, the stream is closed, but any symbolic\n   stream aliases associated with it still refer to this (now closed) stream,\n   until they are either closed as well, or redirected to other streams.\n\n   When Stream is a symbolic stream name, the stream gets closed (unless it\n   was already closed using a different alias or handle), and the alias gets\n   detached and no longer refers to a stream.\n\n   If a stream has several aliases, every alias should be closed explicitly.\n   If a stream has handles and aliases, then only the aliases need to be\n   closed.  If a stream has only handles, it is enough to close it using\n   one of the handles.\n\n   If a stream has only handles, it is actually not absolutely necessary\n   to close it at all: it will be closed automatically when the handles\n   become inaccessible, e.g. due to failure or garbage collection of the\n   handles.  In particular, it is NOT necessary to take precautions for\n   closing a stream in case of failure or abort across the stream opening.\n\n   The predefined stream aliases and the standard streams always remain\n   open.  Trying to close them has the following effect:\n   \n   Current streams (input, output, warning_output, log_output, error):\n       the stream is closed (unless it was directed to a standard stream),\n       and the alias is reset to the corresponding user_XXX alias\n   Default streams (user_input, user_output, user_error):\n       the stream is closed (unless it was directed to a standard stream),\n       and the alias is reset to the corresponding stdXXX alias\n   Standard streams (stdin, stdout, stderr, null):\n       no effect\n   \n\nModes and Determinism\n   close(+) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to a stream handle or an atom.\n    40 --- Stream is a handle that was already closed.\n   170 --- Operating system could not close the stream.\n   193 --- Stream is an illegal stream specification.\n   196 --- Trying to close a system stream (handled by default).\n\nExamples\n   \n      % Open and close using a handle\n      ?- open(file1,write,S), write(S,hello), close(S).\n      Yes (0.00s cpu)\n\n      % Open and close using an alias name\n      ?- open(file1,write,a), write(a,hello), close(a).\n      Yes (0.00s cpu)\n\n      % WRONG: Closing the stream via handle, but not closing the alias:\n      % (alias refers to a closed stream)\n      ?- open(file1,write,S), set_stream(a,S), write(a,hello),\n    close(S), write(a, world).\n      illegal stream mode in write(a, world)\n      Abort\n\n      % OK: Closing the stream via its alias only:\n      ?- open(file1,write,S), set_stream(a,S), write(a,hello),\n    close(a), write(a, world).\n      illegal stream specification in write(a, world)\n      Abort\n\n      % OK: handle-only stream gets auto-closed on abort\n      ?- open(file1, read, S), abort.\n      Abort\n\n      % OK: handle-only stream gets auto-closed on failure\n      ?- open(file1, read, S), fail.\n      No (0.00s cpu)\n\n      % OK: handle-only stream gets auto-closed on abort (and file deleted)\n      ?- open(file2, write, S, [delete_file(when_lost)]), abort.\n      Abort\n\n      % OK: handle-only stream gets auto-closed on failure (and file deleted)\n      ?- open(file2, write, S, [delete_file(when_lost)]), fail.\n      No (0.00s cpu)\n\nError:\n      close(Stream).    (Error 4).\n      close(\"4\").    (Error 5).\n      close(S),close(S).     (Error 40).\n      close(10).    (Error 193).\n      close(nostream).       (Error 193).\n      close(output).    (Error 196).\n\nSee Also\n   close / 2, open / 3, open / 4, set_stream / 2"},"close/2":{"prefix":"close","body":"close(${1:Stream}, ${2:Options})$3\n$0","description":"close(+Stream, +Options)\n\n   Closes the stream specified by Stream.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Options    List of option terms\n\nType\n   Stream I/O\n\nDescription\n\n\t    The only supported option is force(true).  This will suppress\n\t    any errors that would have been raised during closing otherwise,\n\t    in particular errors from the operating system, or the stream\n\t    being already closed.  It is intended for error handling\n\t    routines that want to do their best to free resources.\n\t\n\t    close(Stream,[]) is equivalent to close(Stream).\n\t    See close/1 for more details.  \n\t\n\nModes and Determinism\n   close(+, +) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     4 --- Options is not sufficiently instantiated.\n     5 --- Stream is instantiated, but not to a stream handle or an atom.\n   196 --- Trying to close a system stream (handled by default).\n\nExamples\n   \n\t:- local finalization(\n\t\tclose(logstream, [force(true)])\n\t    ).\n\t\n\nSee Also\n   close / 1, open / 3, open / 4"},"connect/2":{"prefix":"connect","body":"connect(${1:Stream}, ${2:Address})$3\n$0","description":"connect(+Stream, +Address)\n\n   Connects a socket with the given address.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Address    Atom, integer or structure.\n\nType\n   Stream I/O\n\nDescription\n\n   connect/2 is a direct link to the connect(2) socket system call.\n   Stream must be a socket stream created with socket/3.\n   If the socket was created in the unix domain, Address must be an atom\n   which identifies the file associated with the socket.  If Address is 0\n   and socket type is datagram, the socket is disconnected.\n\n   If the socket is in the internet domain, the address is in the form\n   HostName/Port, where the atom HostName denotes the host to be connected\n   on the given integer port Port.  If Address is 0/0 and socket type is\n   datagram, the socket is disconnected.\n\n   Every socket communication in ECLiPSe requires at least one of every two\n   communicating processes to call connect/2, because system calls to\n   perform direct datagram addressing are not available.  The socket\n   connection can be queried with get_stream_info(s, connection, C).\n\n   Stream sockets are connected using the standard sequence, i.e.\n   socket/3, bind/2, listen/2 and accept/3 on the server and socket/3 and\n   connect/2 on the client.  After the sockets are connected, both\n   processes can use them for reading and writing.\n\n   Datagram sockets require a connect/2 call from the process that wants to\n   write on the socket and bind/2 from the one that reads from it.\n\n   If a system interface error (170) is raised while calling connect/2, the\n   socket will be automatically closed. This is to get around a problem\n   where the connect(2) system call can leave the socket in an incorrect\n   state on some operating systems. \n\nModes and Determinism\n   connect(+, +) is det\n\nExceptions\n     4 --- Stream or Address is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n     5 --- Address is instantiated but not to the form accepted by the    socket domain.\n     6 --- Address is a nonzero integer.\n   170 --- It was not possible to connect the socket.\n\nSee Also\n   socket / 3, listen / 2, accept / 3, connect / 2, current_stream / 1, get_stream_info / 3"},"current_stream/1":{"prefix":"current_stream","body":"current_stream(${1:Stream})$2\n$0","description":"current_stream(?Stream)\n\n   Succeeds if Stream is a currently open stream. \n\nArguments\n   Stream    Variable, stream handle, or atom.\n\nType\n   Stream I/O\n\nDescription\n\n   Used to test whether a given identifier or handle denotes an open stream,\n   or enumerates all currently open streams on backtracking.\n\n   When called with a variable argument, only stream handles are returned,\n   not any symbolic aliases.\n\nModes and Determinism\n   current_stream(+) is semidet\n   current_stream(-) is nondet\n\nFail Conditions\n   Fails if Stream is instantiated but does not denote an open stream.\n\nExceptions\n     5 --- Stream is instantiated, but not to an atom or stream handle.\n\nExamples\n   \nSuccess:\n    ?- current_stream(S), writeln(S), fail.\n    $&(stream(0))\n    $&(stream(1))\n    $&(stream(2))\n    $&(stream(3))\n    $&(stream(4))\n    $&(stream(5))\n    $&(stream(6))\n    $&(stream(8))\n    No (0.00s cpu)\n\n    ?- current_stream(output).\n    Yes (0.00s cpu)\n\n    ?- current_stream(junk).\n    No (0.00s cpu)\n\nSee Also\n   open / 3, open / 4, get_stream_info / 3, get_stream / 2"},"get_stream/2":{"prefix":"get_stream","body":"get_stream(${1:StreamId}, ${2:Stream})$3\n$0","description":"get_stream(+StreamId, ?Stream)\n\n   Succeeds if Stream is the stream to which the stream StreamId is assigned. \n\nArguments\n   StreamId    Stream alias (atom), or handle\n   Stream    Variable, stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n\n   StreamId is an existing symbolic stream alias or a stream handle.\n   If Stream is a variable, it will get bound to a stream handle corresponding\n   to StreamId.  If Stream is a symbolic stream alias or a handle, then\n   the predicate succeeds iff StreamId and Stream denote the same stream.\n\n   The predefined symbolic system stream names are:\n\n   input, output, error, warning_output, log_output,\n   stdin, stdout, stderr, null\n\nModes and Determinism\n   get_stream(+, -) is det\n   get_stream(+, +) is semidet\n\nFail Conditions\n   Fails if Stream is not a stream with the stream identifier StreamId\n\nExceptions\n     4 --- One or both of StreamId and Stream is not instantiated.\n     5 --- Stream is neither an atom, a stream handle nor a variable.\n     5 --- StreamId is neither an atom nor a stream handle.\n   193 --- StreamId is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      ?- get_stream(input,S).\n      S = $&(stream(0))\n      Yes (0.00s cpu)\n\n      ?- set_stream(a,input), get_stream(input,a), get_stream(a,input).\n      Yes (0.00s cpu)\n\nFail:\n      set_stream(b,input), get_stream(b,output).\n\nError:\n      get_stream(Id, S).      (Error 4).\n      get_stream(1.0,S).      (Error 5).\n      get_stream(3, S).       (Error 5).\n      get_stream(blah,S).     (Error 193). % does not exist\n\nSee Also\n   set_stream / 2"},"listen/2":{"prefix":"listen","body":"listen(${1:Stream}, ${2:Queue})$3\n$0","description":"listen(+Stream, +Queue)\n\n   Specifies how many connections are accepted for a socket and makes\nconnections available.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Queue    An integer.\n\nType\n   Stream I/O\n\nDescription\n\n   listen/2 is a direct link to the listen(2) socket system call.\n   Stream must be a socket stream created with socket/3\n   of the type stream.  Queue specifies the length of the connection queue,\n   i.e.  how many connections are allowed for this socket.  After the call\n   to listen/2, other processes can call connect/2 to connect with this\n   socket, but the I/O is possible only after the server process creates\n   the new socket using accept/3.\n\n   Stream sockets are connected using the standard sequence, i.e.\n   socket/3, bind/2, listen/2 and accept/3 on the server and socket/3 and\n   connect/2 on the client.  After the sockets are connected, both\n   processes can use them for reading and writing.\n\nModes and Determinism\n   listen(+, +) is det\n\nExceptions\n     4 --- Stream or Queue is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n     5 --- Queue is instantiated but not to an integer.\n   170 --- It was not possible to execute the system call.\n\nExamples\n   \nSuccess:\n      socket(internet, stream, s), bind(s, Addr), listen(s, 1).\n\nError:\n      listen(s, N)    (Error 4).\n      listen(s, 1.0)    (Error 5).\n      listen(null, 2)    (Error 170).\n\nSee Also\n   socket / 3, bind / 2, accept / 3, connect / 2, new_socket_server / 3"},"get_stream_info/3":{"prefix":"get_stream_info","body":"get_stream_info(${1:Stream}, ${2:Attr}, ${3:Value})$4\n$0","description":"get_stream_info(+Stream, ?Attr, -Value)\n\n   Succeeds if the attribute Attr of the open stream Stream has the value\nValue.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Attr    Atom or variable.\n   Value    Variable, atom, string, integer or handle.\n\nType\n   Stream I/O\n\nDescription\n   Used to retrieve information associated to an open stream.  The\n   available attributes and their meanings are:\n\n    Attr    Value    Description\n\n    aliases    integer       current number of symbolic names\n\n    compress    on, off       a hint for output operations (e.g.\n    write_exdr/2) to use a more compact\n    output format (output streams only).\n    Default: on (file,pipe,socket) or off.\n\n    connection      atom    identification of the connected\n    socket - file name for unix sockets,\n    host name for internet ones\n\n    delete_file     off,    delete an opened file automatically when:\n    when_lost,    - its stream handle becomes inaccessible\n    when_closed   - the stream is closed in any way\n\n    device    file, null,   the device behind the stream\n    pipe, queue,\n    socket, tty,\n    string\n\n    encoding    octet,    character encoding used by this stream\n    iso_latin_1,\n    ...\n\n    end_of_line     lf, crlf      which end-of-line sequence to write\n    (output streams only)\n\n    end_of_stream   at,not,past   indicates whether the stream is currently\n    positioned at (or past) the end-of-file\n\n    eof_action      eof_code,     how to react to end-of-file\n    error,    (input streams only)\n    reset\n\n    event    atom or       event on writing to empty stream\n    event handle  (see open/4)\n\n    fd    integer       the associated OS file descriptor\n\n    flush    flush,    explicit or implicit flushing\n    end_of_line   (output streams only)\n\n    handle    stream handle a garbage-collectable handle to the stream\n    (see also get_stream/2)\n\n    input    true, false   this is an input stream (ISO)\n\n    last_written    integer       character code of last written character\n    (output streams only)\n\n    line    integer       current line number\n    (input streams only)\n\n    mode    read, write,  the stream's direction\n    update\n\n    name    atom or       associated filename, or contents\n    string    (in case of a string or queue), or\n    pseudo file name (user, error, null)\n\n    macro_expansion on, off       expand term macros (input streams only)\n\n    offset    integer       current position in the\n    stream, as given by at/2\n\n    output    true, false   this is an input stream (ISO)\n\n    output_options  list    default output options for all term\n    output on this stream. The list\n    format is as in write_term/2,3.\n\n    physical_stream integer       associated stream number\n    (DEPRECATED: if this number is retrieved,\n    the system will no longer be able to close\n    the stream automatically when unused)\n\n    port    integer       port number associated with an\n    internet socket\n\n    prompt    string    prompt string (input streams only)\n\n    prompt_stream   handle    output stream for the prompt\n    (input streams only)\n\n    reposition      true, false   the stream can be repositioned (seek/2)\n\n    sigio    on    SIGIO signals enabled (UNIX only)\n\n    system_use      on, off       a system stream is currently\n    redirected to this stream\n\n    usable    on, off       if the stream can currently be used:\n    flushing or reading the empty stream\n    may not be properly handled if `off'.\n\n    yield    on, off       yield on end-of-file (see open/4)\n\nModes and Determinism\n   get_stream_info(+, -, -) is multi\n   get_stream_info(+, +, -) is semidet\n\nFail Conditions\n   Fails if the requested attribute is not available for this stream\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is neither an atom nor a handle.\n     5 --- Attr is instantiated, but not to an atom.\n     5 --- Value is instantiated, but not to an atom, string, integer or handle.\n     6 --- Attr is an atom, but not a valid attribute name.\n   193 --- Stream does not denote an open stream.\n\nExamples\n   \nSuccess:\n    ?- get_stream_info(input,X,Y), writeln(X is Y), fail.\n    name is user\n    aliases is 2\n    system_use is on\n    line is 1\n    offset is 0\n    prompt is\n    prompt_stream is $&(stream(1))\n    fd is 0\n    reprompt_only is off\n    device is tty\n    mode is read\n    usable is on\n    macro_expansion is on\n    handle is $&(stream(0))\n    No (0.00s cpu)\n\n    ?- get_stream_info(toplevel_input, prompt, P).\n    P = \"\\t\"\n    Yes (0.00s cpu)\n\nFail:\n    get_stream_info(output, prompt, P).\n    get_stream_info(output, system_use, off).\n\nError:\n    get_stream_info(X, Y, Z).    (Error 4)\n    get_stream_info(file(f), Y, Z).    (Error 5)\n    get_stream_info(output, 7, X).    (Error 5)\n    get_stream_info(output, offset, 8.5).    (Error 5)\n    get_stream_info(output, length, Z).    (Error 6)\n    get_stream_info(nostream, Y, Z).    (Error 193)\n\nSee Also\n   set_stream_property / 3, open / 3, open / 4, current_stream / 1, get_stream_info / 3, get_stream / 2, at / 2, write_term / 2, write_term / 3"},"new_socket_server/3":{"prefix":"new_socket_server","body":"new_socket_server(${1:Socket}, ${2:Address}, ${3:Queue})$4\n$0","description":"new_socket_server(?Socket, ?Address, +Queue)\n\n   Opens a new IP socket server stream with a maximum of Queue connections.\n\nArguments\n   Socket    Socket server name (atom or variable)\n   Address    Address for socket connection (Host/Port or variable)\n   Queue    Number of connections allowed (integer)\n\nType\n   Stream I/O\n\nDescription\n    Opens a new IP stream socket server Socket at host Host and port number\n   Port. It is allowed a maximum of Queue connection requests.\n   This predicate combines the calls to socket/3, bind/2, listen/2 as follows:\n   \n       new_socket_server(Soc, Address, N) :-\n    socket(internet, stream, Soc), \n    bind(Soc, Address),\n    listen(Soc, N).\n   \n\n   After creation of the socket server, accept/2 can be called to\n   accept client socket stream connections.  Socket is closed if\n   either the bind/2 or listen/2 calls throws an exception and thus a\n   server socket cannot be made.\n\nModes and Determinism\n   new_socket_server(-, ?, +) is det\n   new_socket_server(+, ?, +) is det\n\nExamples\n   \n\n% Set up a socket server and accept a socket connection. The following will\n% print the Port number used for the server, and waits for a client connection\n[eclipse 26]: new_socket_server(Server, localhost/Port, 1), writeln(Port), accept(Server, _, Socket).\n27694\n....\n\n% On a different ECLiPSe process running on the same machine (as localhost\n% is used for the host name)\n\nsocket(internet, stream, Client), connect(Client, localhost/27694).\n\nClient = 9\nYes (0.00s cpu)\n[eclipse 3]: \n...\n\n% On the original ECLiPSe process, the accept/3 call will now return\n[eclipse 26]: new_socket_server(Server, localhost/Port, 1), writeln(Port), accept(Server, _, Socket).\n27694\n\nPort = 27694\nServer = 9\nSocket = 11\nYes (0.00s cpu)\n% The Server can now be closed while the socket stream remains connected\n[eclipse 27]: close(9).\n\nSee Also\n   accept / 3, socket / 3, bind / 2, listen / 2"},"open/3":{"prefix":"open","body":"open(${1:SourceSink}, ${2:Mode}, ${3:Stream})$4\n$0","description":"open(++SourceSink, +Mode, ?Stream)\n\n   Opens the I/O source or sink SourceSink in mode Mode and associates it\nwith the stream identifier Stream.  \n\nArguments\n   SourceSink    Atom, string or structure.\n   Mode    One of the atoms read, write, update, append.\n   Stream    Atom or variable.\n\nType\n   Stream I/O\n\nDescription\n   This predicate opens an ECLiPSe I/O stream.\n\n   The most common use is for opening files. In this case, SourceSink\n   is a file name (atom or string).\n\n   Mode is one of the following\n\n    read    open for reading\n    write    open for writing\n    update       open for reading and writing\n    append       open for writing at the end\n\n   A file must already exist if it is to be opened in read mode.  A file\n   opened in append mode is opened in write mode at the end of the file.\n   If an existing file is opened in write mode, it is truncated to zero\n   size, i.e. its previous content is lost.\n\n   If Stream is a variable, it will be instantiated to a system-generated\n   stream handle.  This handle can subsequently be used to identify the\n   stream.  If Stream is an atom, then this atom will be used as a symbolic\n   alias name for the stream (like with the alias(Name) option of open/4,\n   or set_stream/2).  The use of handles should be preferred.\n\n   If SourceSink is of the form string(InitialString), then a so-called\n   string stream is opened.  A string stream is basically an in-memory\n   file and its initial contents is the string InitialString.\n   A string stream can be used like any other stream, i.e. it is possible\n   to read, write and seek like on a true file.\n   The current contents of a string stream can at any time be retrieved\n   as a whole using get_stream_info(Stream, name, Contents).\n\n   If SourceSink is of the form queue(InitialString), then a queue\n   stream is opened. It behaves like a string that can be written at the\n   end and read from the beginning.  Seeking is not allowed on queues.\n   The current contents of a queue can at any time be retrieved as a\n   whole using get_stream_info(Stream, name, Contents). Queues are\n   considered to be at end-of-file while they are empty. \n   Queues can be configured to raise an event every time something\n   is written to the previously empty queue (see open/4).\n\n   If SourceSink is of the form fd(Integer), then the stream in opened\n   onto an existing operating system file descriptor.\n\nLifetime of Streams\n   A stream lives until it is closed.  Streams that are only referenced by\n   handle are closed automatically, either on failure across the open/3,4\n   predicate, or after all copies of their handle become unused and garbage\n   collected.  This means that no extra precautions have to be taken to\n   ensure that streams are closed on failure or when aborting.\n   Handle-streams can optionally be closed explicitly if their lifetime\n   is statically known in the program.  Streams that have aliases cannot\n   be closed automatically: all aliases must be closed explicitly.\n\n   NOTE: Stream handles are not normal Prolog terms!  They can not be\n   assembled, decomposed, or occur in Prolog text.\n\nModes and Determinism\n   open(++, +, -) is det\n   open(++, +, +) is det\n\nExceptions\n     4 --- File or Mode is not instantiated.\n     5 --- File is not an atom, string or structure.\n     5 --- Mode is not an atom.\n     5 --- Stream is not an atom or a variable.\n   170 --- The operating system cannot open the file.\n   192 --- Mode is an atom, but is not a valid mode.\n\nExamples\n   \n    ?- open(file1, write, S), write(S, foo), close(S).\n    S = $&(stream(closed))\n    yes.\n\n    ?- open(file1, update, S), read(S,X), write(S,bar), close(S).\n    X = foo\n    S = $&(stream(closed))\n    yes.\n\n    ?- open(file1, append, S), write(S, baz), close(S).\n    S = $&(stream(closed))\n    yes.\n\n    ?- open(file1, read, mystr), read(mystr,X), close(mystr).\n    X = foobarbaz\n    yes.\n\n    ?- open(string(\"foo\"), update, S),\n    read(S,X), write(S,bar),\n    get_stream_info(S, name, Contents), close(S).\n    X = foo\n    Contents = \"foobar\"\n    yes.\n\n    ?- open(queue(\"\"), update, S),\n    write(S, hello), read(S, X), close(S).\n    X = hello\n    yes.\n\n    ?- event_create(writeln(my_event_handler), Event),\n    open(queue(\"\"), write, S, [event(Event)]),\n    write(S, hello).\n    my_event_handler\n    S = $&(stream(7))\n    yes.\n\nError:\n       open(Var,update,s).      (Error 4).\n       open(file1,Mode,s).      (Error 4).\n       open(2,update,s).    (Error 5).\n       open(file1,\"str\",s).     (Error 5).\n       open(file1,update,9).    (Error 5).\n       open(nonex,read,s).      (Error 170). % no such file\n       open(file1,atom,s).      (Error 192). % no such mode\n\nSee Also\n   open / 4, existing_file / 4, close / 1, set_stream / 2, at / 2, at_eof / 1, current_stream / 1, get_stream_info / 3, seek / 2, stream_select / 3, stream_truncate / 1"},"flush/1":{"prefix":"flush","body":"flush(${1:Stream})$2\n$0","description":"flush(+Stream)\n\n   Flushes the output stream Stream.  \n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n\n   Used to flush any data contained in the Stream buffer of an output stream.\n   Flushing means that the data is transferred from a memory buffer to the\n   operation system's I/O system.\n\n   Buffers are normally only flushed when they get full, or when the stream\n   is closed.  Explicit flushing in between reduces performance, but sometimes\n   it is desirable to make sure that data is actually written at certain points.\n\n   Note that streams can be also be configured to flush automatically at\n   every newline, using the flush(end_of_line) option.\n\n   Stream can be a symbolic stream name (atom) or a stream handle.\n\nModes and Determinism\n   flush(+) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated neither to a stream handle nor an atom.\n   192 --- Stream is not an output stream.\n\nExamples\n   \nSuccess:\n      flush(output).\n      flush(null).\n\nError:\n      flush(Stream).    (Error 4).\n      flush(\"Stream\").    (Error 5).\n      flush(12).    (Error 192). % no such stream\n      flush(debug_input).       (Error 192). % input stream\n\nSee Also\n   set_stream_property / 3, open / 3, open / 4, close / 1, tyo / 2"},"seek/2":{"prefix":"seek","body":"seek(${1:Stream}, ${2:Offset})$3\n$0","description":"seek(+Stream, +Offset)\n\n   The pointer in stream Stream is offset Offset from the start of the file\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Offset    Integer or the atom end_of_file.\n\nType\n   Stream I/O\n\nDescription\n   Moves the file pointer to offset Offset from the start of the file\n   opened.  It is an error if Stream is not a stream or if Offset is not an\n   integer or the atom 'end_of_file'.\n\n   seek/2 seeks to the end of the file when Offset is instantiated to\n   end_of_file.\n\n   Only file and string streams are seekable.\n   seek/2 has no effect on the null stream, it always succeeds.\n\nModes and Determinism\n   seek(+, +) is det\n\nExceptions\n     4 --- Either Stream or Offset is uninstantiated.\n     5 --- Offset is instantiated, but not to an integer or the atom end_of_file.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n     6 --- Offset is a negative integer or greater than the file length.\n   192 --- Stream is not seekable.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      seek(0, null). % does not modify, only succeeds\n\n      ?- open(file1,update,S), write(S,hello),\n    seek(S,3), read(S,T), close(S).\n      T = lo\n      yes.\n\nError:\n      seek( Offset,7).      (Error 4).\n      seek(\"7\", 2).    (Error 5).\n      seek(7, -1).    (Error 6).\n      seek( 0,input).       (Error 192).\n      seek(-1, 0).    (Error 193). % does not exist\n\nSee Also\n   at / 2, at_eof / 1, set_stream_property / 3"},"socket/3":{"prefix":"socket","body":"socket(${1:Domain}, ${2:Type}, ${3:Stream})$4\n$0","description":"socket(+Domain, +Type, ?Stream)\n\n   Creates a socket of a given type and domain and associates a stream with\nit.  \n\nArguments\n   Domain    Atom\n   Type    Atom\n   Stream    Atom, structure or variable.\n\nType\n   Stream I/O\n\nDescription\n\n   socket/3 is a direct link to the socket(2) socket system call.\n   Domain is either unix or internet, type is stream or\n   datagram.  It creates a socket of the given type in the given domain and\n   creates a stream associated with it.  After the connection is\n   established using bind/2, connect/2, listen/2 and/or accept/3, the\n   stream can be used for input and output to communicate with other\n   processes.\n\n   The unix domain can be used for communication between processes on the\n   same machine, whereas the internet domain can connect any two machines.\n   The stream type supports point-to-point reliable communication, whereas\n   the datagram communication is a network-type communication with clear\n   message boundaries, which, however, are not visible in ECLiPSe .\n\n   Note that in order to read data using read/1,2, it must have been\n   written in Prolog term format (i.e.  ended with a period and a blank\n   space character).  The output to sockets is buffered, so that data might\n   be actually written only after a call to flush(Stream).\n\n   When instantiated, Stream must be the symbolic stream name (atom).  The\n   stream can also be specified as sigio(Stream).  In this case the socket\n   is created and in addition it is instructed to send the signal io each\n   time new data appears in it.\n\nModes and Determinism\n   socket(+, +, -) is det\n   socket(+, +, +) is det\n\nExceptions\n     5 --- Stream is instantiated, but not to an atom or a sigio    structure.\n     5 --- Domain or Type are instantiated but not to atoms.\n     6 --- Domain or Type are atoms, but different from the accepted    ones.\n   170 --- It was not possible to create the socket.\n\nExamples\n   \nSuccess:\n      socket(unix, stream, s).\n      socket(internet, datagram, socket).\n\nError:\n      socket(unix, stream, 1)       (Error 5).\n      socket(telnet, datagram, X)   (Error 6).\n\nSee Also\n   bind / 2, listen / 2, accept / 3, connect / 2, new_socket_server / 3, exec / 2"},"set_stream_property/3":{"prefix":"set_stream_property","body":"set_stream_property(${1:Stream}, ${2:Prop}, ${3:Value})$4\n$0","description":"set_stream_property(+Stream, +Prop, +Value)\n\n   Sets the property Prop of the stream Stream to the value Value.  \n\nArguments\n   Stream    Stream handle or alias (atom)\n   Prop    Atom.\n   Value    atom, string, handle or integer.\n\nType\n   Stream I/O\n\nDescription\n   Used to set various stream properties:\n\n    Prop    Value    Description\n\n    compress    on, off       a hint for output operations (e.g.\n    write_exdr/2) to use a more compact\n    output format (output streams only).\n    Default: on (file,pipe,socket) or off.\n\n    delete_file     off,    delete an opened file automatically when:\n    when_lost,    - its stream handle becomes inaccessible\n    when_closed   - the stream is closed in any way\n\n    encoding    octet,    character encoding used by this stream\n    iso_latin_1,\n    ...\n\n    end_of_line     lf, crlf      which end-of-line sequence to write\n\n    eof_action      eof_code,     how to react to end-of-file\n    error,    (input streams only)\n    reset\n\n    event    atom or       event on writing to empty stream\n    event handle  (see open/4)\n\n    flush    flush,    explicit or implicit flushing\n    end_of_line\n\n    macro_expansion on, off       expand term macros (input streams only)\n\n    offset    integer       current position in the\n    stream, same as seek/2\n\n    output_options  list    default output options for all term\n    output on this stream. The list\n    format is as in write_term/2,3.\n\n    prompt    string    prompt string (input streams only)\n\n    prompt_stream   handle    output stream for the prompt\n    or atom       (input streams only)\n\n    sigio    on, off       enable/disable SIGIO signals on\n    this stream (UNIX only)\n\n    yield    on, off       yield on end-of-file (see open/4)\n\nModes and Determinism\n   set_stream_property(+, +, +) is det\n\nExceptions\n     4 --- Stream, Prop or Value is not instantiated.\n     5 --- Stream is neither an atom nor a stream handle.\n     5 --- Prop is instantiated, but not to an atom.\n     5 --- Value is of the wrong type for the given property.\n     6 --- Prop is an atom, but not a settable property.\n     6 --- Value is not recognised for the given property.\n   193 --- Stream does not denote an open stream.\n\nExamples\n   \nSuccess:\n    set_stream_property(input, prompt, \"hello: \").\n    set_stream_property(Stream, flush, end_of_line).\n    set_stream_property(Stream, end_of_line, crlf).\n\nSee Also\n   open / 3, open / 4, current_stream / 1, seek / 2, get_stream_info / 3, write_term / 2, write_term / 3"},"display/1":{"prefix":"display","body":"display(${1:Term})$2\n$0","description":"display(?Term)\n\n   Term is displayed on the current output --- without considering operator\ndefinitions.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to display an expression in standard parenthesised prefix notation,\n   onto the current output. This is mainly useful for debugging,\n   in order to see how a term has been parsed.\n\n   display(Term) is equivalent to write_term(Term, [operators(false),\n   dotlists(true)]).\n\nModes and Determinism\n   display(?) is det\n\nExamples\n      Equivalent to display(output, Term).  (see display/2).\n\nSee Also\n   display / 2, write / 1, write / 2, writeq / 1, writeq / 2"},"set_stream/2":{"prefix":"set_stream","body":"set_stream(${1:Alias}, ${2:Stream})$3\n$0","description":"set_stream(+Alias, +Stream)\n\n   The symbolic stream name Alias is associated with the stream Stream.  \n\nArguments\n   Alias    Atom.\n   Stream    Stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n   This predicate is used to create new symbolic names (aliases) for streams,\n   or to redirect existing symbolic stream names to other streams.\n\n   If Alias is a new user-defined stream name, then that new name is\n   associated with the stream denoted by the Stream.  Stream can be given\n   in the form of a stream handle or an already existing alias name.\n\n   If Alias is an already existing stream name (including one of the\n   symbolic system stream names like input, output, error, warning_output,\n   log_output), then that stream is redirected to Stream.  Note that the\n   setting of the 'input' and 'output' aliases determines the streams used\n   by the I/O predicates that have no stream argument.\n\n   Any previous association of the name Alias is forgotten.  Other alias\n   names for the same physical stream are not affected by redirection.\n\n   When a user-defined symbolic stream is closed, the associated physical\n   stream is closed and the association forgotten.\n   Note that it is not enough to close the stream only via a handle, because\n   the association of symbolic an physical stream remains (even though the\n   physical stream is closed) until the stream alias is closed as well.\n   A system-defined stream alias however will be automatically redirected\n   back to its default when the associated physical stream is closed.\n\n   An anonymous stream handle associated with a symbolic stream name can be\n   obtained using get_stream/2 or get_stream_info/3.\n\n   An alternative way of creating a stream alias is to specify it during\n   stream creation, i.e. as the Stream-argument to open/3, socket/3, etc.,\n   or by using an alias(Alias) option in open/4.\n\n   The standard stream aliases stdin, stdout, stderr and null cannot be\n   redirected.\n\nModes and Determinism\n   set_stream(+, +) is det\n\nExceptions\n     4 --- Either Alias or Stream is uninstantiated.\n     5 --- Either Alias is not an atom or Stream is not a stream handle or symbolic stream name.\n   193 --- Stream is an illegal stream specification.\n   196 --- Stream is fixed system stream.\n\nExamples\n   \n    % suppress standard output temporarily:\n    ?- set_stream(output, null).\n    Yes (0.00s cpu)\n    ?- writeln(hello).\n    Yes (0.00s cpu)\n\n    % set standard output back to default:\n    ?- set_stream(output, stdout).\n    Yes (0.00s cpu)\n    ?- writeln(hello).\n    hello\n    Yes (0.00s cpu)\n\n    % alias the names s and output:\n    ?- open(file1,update,s), set_stream(output,s),\n    writeln(output,hi), flush(output).\n    yes.\n    ?- seek(s,0), read(s,X).\n    X = hi\n    yes.\n\nError:\n    set_stream(a, S).    (Error 4).\n    set_stream(1.0, S).      (Error 5).\n    set_stream(a, nonex).    (Error 193).\n\nSee Also\n   open / 4, get_stream / 2"},"open/4":{"prefix":"open","body":"open(${1:SourceSink}, ${2:Mode}, ${3:Stream}, ${4:Options})$5\n$0","description":"open(++SourceSink, +Mode, ?Stream, ++Options)\n\n   Opens the I/O source or sink SourceSink in mode Mode and associates it\nwith the stream identifier Stream.\n\nArguments\n   SourceSink    Atom, string or structure.\n   Mode    One of the atoms read, write, update, append.\n   Stream    Atom or variable.\n   Options    List.\n\nType\n   Stream I/O\n\nDescription\n   This predicate opens an ECLiPSe I/O stream.\n\n   The most common use is for opening files. In this case, SourceSink\n   is a file name (atom or string).\n\n   Mode is one of the following\n\n    read    open for reading\n    write    open for writing\n    update       open for reading and writing\n    append       open for writing at the end\n\n   A file must already exist if it is to be opened in read mode.  A file\n   opened in append mode is opened in write mode at the end of the file.\n   If an existing file is opened in write mode, it is truncated to zero\n   size, i.e. its previous content is lost.\n\n   If Stream is a variable, it will be instantiated to a system-generated\n   stream handle.  This handle can subsequently be used to identify the\n   stream.  If Stream is an atom, then this atom will be used as a symbolic\n   alias name for the stream (like with the alias(Name) option, or\n   set_stream/2).  The use of handles should be preferred.\n\n   If SourceSink is of the form string(InitialString), then a so-called\n   string stream is opened.  A string stream is basically an in-memory\n   file and its initial contents is the string InitialString.\n   A string stream can be used like any other stream, i.e. it is possible\n   to read, write and seek like on a true file.\n   The current contents of a string stream can at any time be retrieved\n   as a whole using get_stream_info(Stream, name, Contents).\n\n   If SourceSink is of the form queue(InitialString), then a queue\n   stream is opened. It behaves like a string that can be written at the\n   end and read from the beginning.  Seeking is not allowed on queues.\n   The current contents of a queue can at any time be retrieved as a\n   whole using get_stream_info(Stream, name, Contents). Queues are\n   considered to be at end-of-file while they are empty. \n   Queues can be configured to raise an event every time something\n   is written to the previously empty queue (see open/4).\n\n   If SourceSink is of the form fd(Integer), then the stream in opened\n   onto an existing operating system file descriptor.\n\n   Options is a list of zero or more of the following stream options:\n\nalias(Name)\n    Make the stream known under an alternative name.  Name is an atom,\n    and must not already be a stream alias. See also set_stream/2.\n\ncompress(OnOff)\n    a hint for output operations (e.g. write_exdr/2) to use a more\n    compact output format (output streams only). OnOff is one of the\n    atoms on or off. The default is on (for files, pipes and sockets)\n    or off (for queues and string streams).\n\ndelete_file(When)\n    This option applies to file streams only: the value 'when_closed'\n    causes the associated file to be deleted as soon as the stream is closed\n    (whether implicitly or explicitly).  The value 'when_lost' causes\n    the associated file to be deleted only when the stream is implicitly\n    closed, either because of failure across the opening, or because\n    its handles were garbage collected.  The default is 'off'.\n\nencoding(Code)\n    The character encoding used on the stream.  In version 6.1, the\n    only allowed values are: octet, ascii, and iso_latin_1 (the default).\n\nend_of_line(CrLf)\n    This option affects only write-streams and determines which\n    end-of-line character sequence is written by predicates like nl/1,\n    writeln/1 and printf/3.  Possible values are the atoms lf and\n    crlf.  The default for string and queue streams is lf, for other\n    streams it is operating-system dependent.\n\neof_action(Action)\n    Controls how end-of-file is handled on this stream.  Possible values\n    are: 'eof_code' (return an code appropriate to the input predicate used\n    - this is the default), 'error' (raise an error), 'reset' (like eof_code,\n    but allow further read attempts on the stream).\n\nevent(Name)\n    This option configures a read-queue stream or a socket stream to raise\n    the given event whenever data arrives on the previously empty stream.\n    This option is intended for queue streams in embedded applications\n    of ECLiPSe, or for socket streams in remote connection setups.  The\n    event handler should consume all data that is available on the stream.\n    Name must be an atom or an event handle.\n\nflush(Where)\n    This option affects only write-streams and allows to configure a\n    stream to automatically flush after every line written.  Where is\n    one of the atoms end_of_line (flush automatically after every\n    line) or flush (require explicit flushing).  The default setting\n    is flush, except for tty streams where the default is end_of_line.\n\nmacro_expansion(OnOff)\n    Input streams only. Specifies whether term-macros (see macro/3) will\n    be expanded when reading from this stream using read/2, read_term/3 etc.\n    OnOff is one of the atoms on or off, the default is on.\n\noutput_options(OptionList)\n    Write-streams only. Specifies the default output options that will be\n    used when printing terms onto this stream, e.g. using write/2.\n    The format of OptionList is the same as the one accepted by the\n    write_term/2,3 predicates.\n    Note that certain output predicates can override these default\n    settings, e.g. writeq/2, write_term/3, printf/3, etc.\n\nreposition(Bool)\n    The option reposition(true) verifies that the stream can be repositioned,\n    i.e. that seek/2 can be used on it.  Otherwise an error is raised.\n    The option reposition(false) has no effect.\n\nyield(OnOff)\n    This option is intended for queue streams in embedded applications\n    of ECLiPSe.  It configures the stream to yield control to the host\n    program whenever a read-queue reaches end-of-file or a write-queue\n    gets flushed.  See the Embedding Manual for more details.  OnOff\n    is one of the atoms on or off.\n\nLifetime of Streams\n   A stream lives until it is closed.  Streams that are only referenced by\n   handle are closed automatically, either on failure across the open/3,4\n   predicate, or after all copies of their handle become unused and garbage\n   collected.  This means that no extra precautions have to be taken to\n   ensure that streams are closed on failure or when aborting.\n   Handle-streams can optionally be closed explicitly if their lifetime\n   is statically known in the program.  Streams that have aliases cannot\n   be closed automatically: all aliases must be closed explicitly.\n\n   NOTE: Stream handles are not normal Prolog terms!  They can not be\n   assembled, decomposed, or occur in Prolog text.\n\nModes and Determinism\n   open(++, +, -, ++) is det\n   open(++, +, +, ++) is det\n\nExceptions\n     4 --- File or Mode is not instantiated.\n     5 --- File is not an atom, string or structure.\n     5 --- Mode is not an atom.\n     5 --- Stream is not an atom or a variable.\n   170 --- The operating system cannot open the file.\n   192 --- Mode is an atom, but is not a valid mode.\n\nExamples\n   \n    See open/3.\n\nSee Also\n   open / 3, existing_file / 4, close / 1, close / 2, set_stream_property / 3, at / 2, at_eof / 1, current_stream / 1, get_stream_info / 3, seek / 2, set_stream / 2, stream_select / 3, stream_truncate / 1, flush / 1, write_term / 2, write_term / 3"},"expand_macros/2":{"prefix":"expand_macros","body":"expand_macros(${1:Term}, ${2:TransTerm})$3\n$0","description":"expand_macros(?Term, -TransTerm)\n\n   Apply macro transformations to Term\n\nArguments\n   Term    A term.\n   TransTerm    A variable.\n\nType\n   Term I/O\n\nDescription\n    Applies macro-transformations to Term, if any are visible in the\n    caller module. If no transformation is visible, TransTerm is identical\n    to Term.\n    \n    Normally, macro expansion is performed implicitly by the parser, i.e.\n    when using either the compiler or term-input builtins like read/1,2,\n    read_term/2,3 or readvar/2,3.\n    \n    For certain meta-programming applications, where one needs to work with\n    the original unexpanded form of the input, this is undesirable.\n    In such cases, macro-expansion can be switched off during reading\n    and later performed explicitly using expand_macros/2.\n    \n    For reading input without macro expansion, set the stream-flag\n    macro_expansion to off before reading (see set_stream_property/3\n    or open/4), or use the facilities of the library(source_processor).\n\nModes and Determinism\n   expand_macros(?, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % Given the program:\n\n    t(water, wine).\n    :- local macro(water, t/2, []).\n\n    % Implicit macro expansion by read/1:\n    ?- open(string(\"water\"),read,S),\n    read(S,X),\n    close(S).\n    X = wine\n    yes.\n\n    % Implicit macro expansion switched off:\n    ?- open(string(\"water\"),read,S,[macro_expansion(off)]),\n    read(S,X),\n    close(S).\n    X = water\n    yes.\n\n    % Explicit macro expansion:\n    ?- open(string(\"water\"),read,S,[macro_expansion(off)]),\n    read(S,X),\n    expand_macros(X,Y),\n    close(S).\n    X = water\n    Y = wine\n    yes.\n\n    % All occurrences are expanded:\n    ?- open(string(\"[water,beer,fizzy(water)]\"),read,S,[macro_expansion(off)]),\n    read(S,X),\n    expand_macros(X,Y),\n    close(S).\n    X = [water, beer, fizzy(water)]\n    Y = [wine, beer, fizzy(wine)]\n    yes.\n\nSee Also\n   macro / 3, expand_clause / 2, expand_goal / 2, open / 4, set_stream_property / 3, library(source_processor), portray / 3, portray_term / 3"},"stream_truncate/1":{"prefix":"stream_truncate","body":"stream_truncate(${1:Stream})$2\n$0","description":"stream_truncate(+Stream)\n\n   Truncate Stream at the current position\n\nArguments\n   Stream    Stream handle or alias (atom)\n\nType\n   Stream I/O\n\nDescription\n    Used to truncate a stream, i.e. to remove all contents beyond the\n    current (write) position.  As a consequence, immediately after this\n    operation the stream is at end of file.\n    \n    This operation only makes sense on file-streams and string streams\n    which are open for writing (or updating). On all other types of streams,\n    the predicate silently succeeds.\n    \n    Files will be physically truncated, i.e. their size is trimmed and extra\n    disk space returned to the operating system. String streams will free\n    any unnecessary buffer memory.\n    \n    Note: When opening an existing file for writing (not updating), the\n    file is automatically truncated to size zero (see open/3,4).\n\nModes and Determinism\n   stream_truncate(+) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is instantiated, but not to an atom or a stream handle.\n   192 --- Stream is not open in write mode.\n\nExamples\n   \n    ?- open(string(\"hellothere\"), update, s).\n    Yes (0.00s cpu)\n\n    ?- seek(s, 5).\n    Yes (0.00s cpu)\n\n    ?- at_eof(s).\n    No (0.00s cpu)\n\n    ?- stream_truncate(s).\n    Yes (0.00s cpu)\n\n    ?- at_eof(s).\n    Yes (0.00s cpu)\n\n    ?- seek(s,0).\n    Yes (0.00s cpu)\n\n    ?- read_string(s, end_of_file, _, S).\n    S = \"hello\"\n    Yes (0.00s cpu)\n\nSee Also\n   at_eof / 1, seek / 2, open / 3, open / 4"},"stream_select/3":{"prefix":"stream_select","body":"stream_select(${1:StreamList}, ${2:Timeout}, ${3:ReadyStreams})$4\n$0","description":"stream_select(++StreamList, +Timeout, -ReadyStreams)\n\n   Returns streams from StreamList which are ready for I/O, blocking at most\nTimeout seconds.  \n\nArguments\n   StreamList    A list of atoms (stream aliases) or stream handles.\n   Timeout    A number or an atom.\n   ReadyStreams    A term unifiable with a list of atoms or stream handles.\n\nType\n   Stream I/O\n\nDescription\n   stream_select/3 is modelled after (and partially implemented using) the\n   select() Unix system call.  StreamList is a list of streams where\n   input or output is expected to occur.  If I/O is available on some\n   streams from the StreamList, ReadyStreams is unified with a list of\n   those. The same symbolic stream names are used in both lists.\n\n   If Timeout is a number, it must be non-negative and less than\n   100000000. stream_select/3 then waits for at most Timeout seconds for I/O\n   on these streams and if none is available, it unifies ReadyStreams\n   with nil.  If Timeout is zero, stream_select/3 does not wait but it\n   immediately returns the list of streams where I/O is available.  If\n   Timeout is the atom 'block', stream_select/3 waits until I/O is possible\n   on one of the streams in StreamList.\n\n   The streams in StreamList can be sockets, queues, string streams or\n   the null stream.  On Unix systems, pipes, files and ttys are also\n   allowed.  On Windows, ttys (the console) is also allowed, but only\n   when timeout is 0.\n\nNotes:\n\n   Sockets are only considered ready when input (rather than output) is\n   possible.\n\n   The null stream is never ready.\n\n   Unlike the select() system call, stream_select/3 does not test any\n   exceptional pending conditions on sockets.\n\nModes and Determinism\n   stream_select(++, +, -) is det\n\nExceptions\n     4 --- StreamList is not instantiated or it contains uninstantiated    variables.\n     4 --- Timeout is not instantiated.\n     5 --- StreamList is not a list of stream handles and atoms.\n     5 --- Timeout instantiated, but not to a number or an atom.\n     5 --- ReadyStreams is instantiated, but not to a list or nil\n     6 --- Timeout is a negative number or an atom different from block.\n   141 --- Not implemented for this stream class on this system.\n   170 --- The system call was interrupted by a signal.\n   192 --- A stream in StreamList is not an input stream or a pipe,    or it is a string stream or null.\n   193 --- A stream in StreamList is not open or does not exist.\n\nExamples\n   \n     ?- socket(internet, datagram, s), bind(s, _/40000),\n    socket(internet, datagram, r), bind(r, _/40001),\n    stream_select([s, r], block, Streams).\n\n     <blocks until data arrives>\n\n     ?- open(queue(\"\"), update, q).\n     yes.\n\n     ?- stream_select([q],0,L).\n     L = []\n     yes.\n\n     ?- write(q,hello).\n     yes.\n\n     ?- stream_select([q],0,L).\n     L = [q]\n     yes.\n\nSee Also\n   open / 3, open / 4, socket / 3, get_stream_info / 3"},"display/2":{"prefix":"display","body":"display(${1:Stream}, ${2:Term})$3\n$0","description":"display(+Stream, ?Term)\n\n   Term is displayed on the output stream Stream --- without considering\noperator definitions.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to display an expression in standard parenthesised prefix notation,\n   onto the output stream Stream.\n\n   display(S, Term) is equivalent to write_term(S, Term, [operators(false),\n   dotlists(true)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the stream, by writing again or by using flush/1.\n\nModes and Determinism\n   display(+, ?) is det\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      display(output, 3.0).    % displays 3.0\n      set_stream(a,output), display(a,hi). % displays hi\n\n      ?- open(file1,update,S), display(S, X+2), close(S).\n      X = _72\n      S = 6\n      yes.\n      ?- sh('cat file1').\n      +(_98, 2)\n      yes.\nError:\n      display(S, a(b,c)).    (Error 4).\n      display(\"string\", a(b,c)). (Error 5).\n      display(9, X=2).    (Error 192). % stream not open\n      display(atom, X=2).    (Error 193).\n\nSee Also\n   display / 1, write / 1, write / 2"},"portray_term/3":{"prefix":"portray_term","body":"portray_term(${1:Term}, ${2:TransTerm}, ${3:As})$4\n$0","description":"portray_term(?Term, -TransTerm, +As)\n\n   Apply portray (write) transformations to Term\n\nArguments\n   Term    A term.\n   TransTerm    A variable.\n   As    One of the atoms 'term', 'goal' or 'clause'\n\nType\n   Term I/O\n\nDescription\n    Applies portray-transformations to Term, if any are visible in the\n    caller module. If no transformation is visible, TransTerm is identical\n    to Term.\n    \n    This predicate is intended mainly for testing purposes, because\n    portray-transformations are normally performed implicitly by the\n    term output predicates write/1,2, writeln/1,2, print/1,2,\n    display/1,2, printf/2,3 or write_term/2,3.  \n\nModes and Determinism\n   portray_term(?, -, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % Given the program:\n\n    :- local portray(s/1, tr_s/2, []).\n    tr_s(0, 0).\n    tr_s(s(S), N) :- tr_s(S, N1), N is N1+1.\n\n    % Implicit portray transformation by write/1:\n    ?- S = s(s(s(0))), write(S).\n    3\n    yes.\n\n    % Explicit portray transformation\n    % Note: no transformation done by writeq/1\n    ?- S = s(s(s(0))), writeq(S), portray_term(S, P, term), writeq(P).\n    s(s(s(0)))\n    3\n    yes.\n\nSee Also\n   portray / 3, expand_clause / 2, expand_goal / 2, expand_macros / 2"},"print/1":{"prefix":"print","body":"print(${1:Term})$2\n$0","description":"print(?Term)\n\n   The term Term is written on the output stream according to the current\noperator declarations, using the predicate portray/2 or portray/1 if it\nexists.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to print the term Term on the current output according to the\n   current operator declarations, i.e.  the same as write/1, however the\n   user has the possibility to influence the way the term is printed.  If\n   the predicate portray/2 is visible in the module where print/1 was\n   called from, it is used by print/1 in the following way:\n\n  * If Term is a variable, it is printed using write/1.\n\n  * If Term is a nonvariable or an attributed variable, then portray(output,\n    Term) is called.  If it succeeds, so does print/1.  Otherwise, if Term is\n    atomic, it is written using write/1 and the predicate succeeds.  If\n    Term is a compound term, its main functor is printed using write/1 and\n    print/1 is called recursively on its arguments.\n\n   If portray/2 is not visible but portray/1 is, it is called instead of\n   portray/2.\n\n   Note that when this predicate is used to print a list, only the elements\n   of the list, i.e.  the heads, are passed to the recursive calls of\n   print/2, but not the list tails.  Thus e.g.  a list [1,2,3] will be\n   passed once to portray/2 as a whole and then the elements 1, 2, 3, but\n   not [2,3], [3] and [].\n\n   portray/1, 2 is used by the system when printing the answer bindings\n   in the top-level loop, and by the debugger to print trace lines.\n\n   print(Term) is equivalent to write_term(Term, [portrayed(true),\n   numbervars(true)]).\n\n   As usual, the output is buffered, so it may need to be flushed (e.g.\n   explicitly using flush/1).\n\nNote\n   The output of print/1 is not necessarily in a form acceptable to\n   read/1,2.\n\nModes and Determinism\n   print(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \nSuccess:\n    ?- [user].\n     portray(S, a) :- write(S, b).\n     user   compiled 100 bytes in 0.02 seconds\n    yes.\n    ?- print([a, b, c, d]).\n    [b, b, c, d]\n    yes.\n\n    ?- [user].\n     portray(S, '$VAR'(X)) :- write(S, 'X_'), write(S, X).\n     user   compiled 180 bytes in 0.00 seconds\n    yes.\n    ?- lib(numbervars).\n    yes.\n    ?- F=f(_,_,_,_), numbervars(F, 0, _), write(F).\n    f(A, B, C, D)    % default printing of '$VAR'/1\n    F = f(X_0, X_1, X_2, X_3)    % toplevel uses portray\n    yes.\n\nSee Also\n   display / 1, display / 2, print / 2, write / 1, write / 2, writeq / 1, writeq / 2"},"print/2":{"prefix":"print","body":"print(${1:Stream}, ${2:Term})$3\n$0","description":"print(+Stream, ?Term)\n\n   The term Term is written on the output stream Stream according to the\ncurrent operator declarations, using the predicate portray/2 or portray/1\nif it exists.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to print the term Term on the output stream Stream according to the\n   current operator declarations, i.e.  the same as write/2, however the\n   user has the possibility to influence the way the term is printed.  If\n   the predicate portray/2 is visible in the module where print/2 was\n   called from, it is used by print/2 in the following way:\n\n  * If Term is a variable, it is printed using write/2.\n\n  * If Term is a nonvariable or an attributed variable, then portray(Stream,\n    Term) is called.  If it succeeds, so does print/2.  Otherwise, if Term is\n    atomic, it is written using write/2 and the predicate succeeds.  If\n    Term is a compound term, its main functor is printed using write/2 and\n    print/2 is called recursively on its arguments.\n\n   Note that when this predicate is used to print a list, only the elements\n   of the list, i.e.  the heads, are passed to the recursive calls of\n   print/2, but not the list tails.  Thus e.g.  a list [1,2,3] will be\n   passed once to portray/2 as a whole and then the elements 1, 2, 3, but\n   not [2,3], [3] and [].\n\n   If portray/2 is not visible but portray/1 is, it is called instead of\n   portray/2, with the 'output' stream temporarily redirected to Stream.\n   Because of this side effect, defining portray/2 is preferrable.\n\n   portray/1, 2 is used by the system when printing the answer bindings\n   in the top-level loop, and by the debugger to print trace lines.\n\n   print(S, Term) is equivalent to write_term(S, Term, [portrayed(true),\n   numbervars(true)]).\n\n   As usual, the output is buffered, so it may need to be flushed (e.g.\n   explicitly using flush/1).\n\nNote\n   The output of print/2 is not necessarily in a form acceptable to\n   read/1,2 and there is no 'printq' predicate.\n\nModes and Determinism\n   print(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output steam.\n   193 --- Stream is not a stream specification.\n\nExamples\n   \nSuccess:\n    ?- [user].\n     portray(S, a) :- write(S, b).\n\n     p(a).\n     user   compiled 148 bytes in 0.00 seconds\n\n    yes.\n    ?- write(write(a)), nl, print(output, print(a)).\n    write(a)\n    print(b)\n    yes.\n    ?- trace.\n\n    yes.\n    Debugger switched on - creep mode\n    ?- p(a).\n      (1) 0  CALL   p(a) (dbg)?- output: write    ('o' typed)\n      (1) 0  CALL   p(a) (dbg)?- output: display\n      (1) 0  CALL   p(a) (dbg)?- output: print/writeq\n      (1) 0  CALL   p(b) (dbg)?- creep\n      (1) 0  EXIT   p(b) (dbg)?- creep\n\n    yes.\n\nError:\n     print(S, a(b,c)).    (Error 4).\n     print(\"str\", a(b,c)).     (Error 5).\n     print(input, X).    (Error 192).\n     print(nostr, X + 2).      (Error 193).\n\nSee Also\n   display / 1, display / 2, print / 1, write / 1, write / 2, writeq / 1, writeq / 2"},"printf/2":{"prefix":"printf","body":"printf(${1:Format}, ${2:ArgList})$3\n$0","description":"printf(+Format, ?ArgList)\n\n   The arguments in the argument list ArgList are interpreted according to the\nFormat string and the result is printed to the output stream\n\nArguments\n   Format    String or Atom.\n   ArgList    List or any Term.\n\nType\n   Term I/O\n\nDescription\n\n   Format is an atom or a string which can contain embedded format control\n   sequences.  ArgList is a list of arguments that will be interpreted,\n   and possibly printed, under control of these format options.\n   Any part of Format that is not a control sequence is written to the\n   output stream.\n\n   For details of the formatting options, see printf/3.\n\nModes and Determinism\n   printf(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Format is not an atom or a string.\n     5 --- ArgList contains argument whose type does not correspond to    the control sequence.\n     7 --- Format is not correct, it contains too many asterisks or a    control character is missing or there is a redundant character before    the control character.\n     8 --- ArgList has not enough or too many arguments.\n\nExamples\n      Equivalent to printf(output, Format, ArgList).  (see printf/3 for\n   details).\n\nSee Also\n   printf / 3, display / 1, display / 2, print / 1, print / 2, sprintf / 3, write / 1, write / 2, writeq / 1, writeq / 2"},"read/1":{"prefix":"read","body":"read(${1:Term})$2\n$0","description":"read(-Term)\n\n   Succeeds if the next term from the input stream is successfully read and\nunified with Term.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to read the next term from the input stream and unify it with Term.\n   The term must be in Prolog term format i.e.  terminated by fullstop (a\n   period and a blank space character), neither of which are retained by\n   Prolog.\n\n   End of file acts like fullstop.  If only end of file is read, the event\n   190 is raised and the default handler unifies Term with the atom\n   end_of_file.\n\n   The default action for syntax errors is to print a warning and fail.\n\nModes and Determinism\n   read(-) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n   190 --- End of file was encountered before reading any character.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n      Equivalent to read(input, Term).  (see read/2 for details).\n\nSee Also\n   read / 2"},"printf/3":{"prefix":"printf","body":"printf(${1:Stream}, ${2:Format}, ${3:ArgList})$4\n$0","description":"printf(+Stream, +Format, ?ArgList)\n\n   The arguments in the argument list ArgList are interpreted according to the\nFormat string and the result is printed on the output Stream\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Format    String or Atom.\n   ArgList    List or any Term.\n\nType\n   Term I/O\n\nDescription\n\n   Format is an atom or a string which can contain embedded format control\n   sequences.  ArgList is a list of arguments that will be interpreted,\n   and possibly printed, under control of these format options.\n   Any part of Format that is not a control sequence is written to the\n   output stream Stream unchanged.  As far as the functionality overlaps,\n   the behaviour is similar to the 'C' function printf().\n\n   Format control sequences take one of the following forms:\n\n       %[-+ 0][minwidth][.precision]{d|u|o|x|X}\n       %[-+ 0][minwidth][.precision]{f|g|e|E}\n       %[-+ 0][minwidth.]radix{r|R}\n       %[-][minwidth][.precision]{s|a|A}\n       %[depth][modifiers]{w|W}\n       %[count]{c|i|n|t}\n       %{b|k|p|q|%}\n\n   Each control sequence starts with a percent character, followed by a\n   number of optional flags/parameters, and ends in one of the conversion\n   control characters (described below in detail).\n\n   The meaning of the flags and parameters are:\n\n    -\n    Left-justify the output (if the field width is greater than the\n\tlength of the printed representation).  Default is right-justified.\n    \n    +\n    Print a plus sign in front of non-negative numbers.  By default,\n\tonly negative numbers are printed with a sign.\n    \n    (space)\n    Print a blank space in front of non-negative numbers.  If a plus\n\tsign is specified as well, the space is ignored.\n    \n    0\n\tIf the width of a right-justified field is greater than the length\n\tof the printed representation, fill the space with leading zeros\n\tinstead of spaces.\n    \n    minwidth\n\tAn optional minimum field width, which causes the printed\n\trepresentation to be padded (left or right) in case it is shorter\n\tthan the specified minimum.  The width is given either as an\n\tunsigned decimal integer, or as a '*' character, in which case\n\tthe number is taken from the next element of ArgList.\n    \n    precision\n\tAn optional precision, determining the number of places after\n\tthe decimal point (for floating point arguments), the minimum\n\tnumber of digits (for integer arguments), or the maximum number\n\tof characters (for atom/string arguments).  The precision is given\n\teither as an unsigned decimal integer, or as a '*' character, in\n\twhich case the number is taken from the next element of ArgList.\n    \n    radix\n\tA number between 2 and 36, giving the number base in which the\n\targument is to be printed.  For instance, 2 for binary, 16 for\n\thexadecimal, 8 for octal, or 36 to use all the digits 0-9a-z.\n\tThe radix is given either as a decimal integer, or as a '*'\n\tcharacter, in which case it is taken from the next element\n\tof ArgList.\n    \n    count, depth\n\tAn optional count (determining how many times an option will be\n\trepeated), or depth (determining the maximum nesting depth for\n\tprinting terms).  It is given either as an unsigned decimal\n\tinteger, or as a '*' character, in which case the number is\n\ttaken from the next element of ArgList.\n    \n\n   The meaning of the conversion control characters is:\n\n  a\n    The argument has to be an atom (or string) and is printed without\n    any quoting.  Optionally, field width, justification, and maximum\n    length can be specified.  Identical to the s format.\n\n  A\n    The argument has to be an atom (or string), is converted to upper\n    case, and then printed without quoting.  Optionally, field width,\n    justification, and maximum length can be specified.\n\n  b\n    The stream's output buffer is flushed, buffered data is written\n    to the device attached to the stream.\n\n  c\n    The argument has to be an integer character code and is printed\n    as a character.  Optionally, a repeat count can be specified.\n\n  d\n    The argument has to be an integer and is printed in signed decimal\n    notation.  Optionally, details regarding field width, number of\n    digits, padding and sign representation can be specified.\n    See r for non-decimal notation.\n\n  e\n    The argument has to be a floating-point number and is printed according\n    to the substring A in exponential notation.('e' is used for\n    exponentiation)\n\n  E\n    The argument has to be a floating-point number and is printed according\n    to the substring A in exponential notation.  ('E' is used for\n    exponentiation)\n\n  f\n    The argument has to be a floating-point number and is printed according\n    to the substring A in non-exponential form.\n\n  g\n    The argument has to be a floating-point number and is printed according\n    to the substring A in exponential or non-exponential form, whichever\n    gives the best precision in minimum space.('e' is used for\n    exponentiation)\n\n  i\n    The next argument of ArgList is ignored.  An optional repeat count\n    can be specified.\n\n  k\n    The argument is passed to display/1.  It is a synonym for %O.w.\n\n  n\n    A newline sequences is printed.  An optional repeat count can be given.\n    Which newline characters are printed depends on the setting of the\n    stream's end_of_line property. If the stream's flush-property is set\n    to end_of_line, the stream is also flushed.\n\n  o\n    The argument has to be an integer and its least significant 32 bits\n    are printed in unsigned octal notation.  Optionally, details regarding\n    field width, number of digits, padding and sign representation can be\n    specified. DEPRECATED, see r.\n\n  r\n    The argument has to be an integer and is printed in signed notation\n    in the given base (radix) between 2 and 36.  The digits are\n    represented as the characters 0-9a-z.  Optionally, details regarding\n    field width, padding and sign representation can be specified.\n\n  R\n    The argument has to be an integer and is printed in signed notation\n    in the given base (radix) between 2 and 36.  The digits are\n    represented as the characters 0-9A-Z.  Optionally, details regarding\n    field width, padding and sign representation can be specified.\n\n  p\n    The argument is passed to print/1.  It is a synonym for %Pw.\n\n  q\n    The argument is passed to writeq/1.  It is a synonym for %QDvw.\n\n  s\n    The argument has to be an string or atom and is printed without\n    any quoting.  Optionally, field width, justification, and maximum\n    length can be specified.\n\n  t\n    A tab character is printed.  An optional repeat count can be given.\n\n  u\n    The argument has to be an integer and its least significant 32 bits\n    are printed in unsigned decimal notation.  Optionally, details\n    regarding field width, number of digits, padding and sign representation\n    specified. DEPRECATED.\n\n  w\n   The argument is by default passed to write/1.\n   However, the %w format recognises a number of modifier characters,\n   placed between the percent sign and w.  They give the user full\n   control over the various possibilities of printing Prolog terms.\n   A number immediately after the percent sign determines the depth\n   to which the term is printed, if an asterisk is used instead, the\n   depth is taken from the next argument in ArgList. The default depth\n   is determined by the setting of the (stream-specific or global)\n   print_depth flag.\n   After the optional depth, the following modifiers are recognized:\n\n      O\n    omit operator declarations.  All terms are written in the canonical\n    notation without operators.\n\n      Q\n    quote atoms and strings if necessary.\n\n      .\n    write lists in the dot functor notation rather than using the\n    square bracket notation, e.g. .(1, .(2, [])) rather than [1, 2].\n\n      G\n    print the term as a goal, i.e.  goal write transformations will\n    be taken into account.\n\n      P\n    call the user-defined predicate portray/1, 2 in the way print/1, 2\n    does.\n\n      D\n    disregard the depth restriction of the print-depth flag and print\n    the whole term.\n\n      U\n    call portray/1, 2 even on variables.  This is to be used in\n    conjunction with the P option.  Note that attributed variables\n    are always portrayed.\n\n      V\n    print the full variable name, if available, either in the form\n    Name_Number, e.g. Alpha_132, or Name#Number, if the variable had\n    been given a name via lib(var_name). This is necessary to \n    distinguish different variables with the same name.\n\n      v\n    print only the short variable form, i.e. even when available, the\n    variable name is not printed.  This is useful if a term should be\n    written and read back in several times.  If neither V nor v is\n    specified, variables are printed only with their name, if it is\n    available.  Variable without names are always printed in the v form.\n\n      _\n    print every variable as a simple underscore. Any information about\n    multiple occurrences of a variable is lost with this format. It is\n    mainly useful to produce output that can be compared easily with\n    the output of a different Eclipse session.\n\n      I\n    any term of the form '$VAR'(N), where N is a non-negative integer,\n    is printed as a variable name consisting of a capital letter\n    followed by a number. The capital letter is the ((N mod 26)+1)st\n    letter of the alphabet, and the integer is N//26.\n    If N is an atom, this atom gets printed instead of the term.\n\n      K\n    don't print blank space (around operators, after commas, etc.)\n    unless necessary.\n\n      M\n    print the full contents of all variable attributes.  This is\n    necessary if the term is to be written out and read back in.\n\n      m\n    variable attributes are printed using the corresponding print\n    handlers.  If neither M nor m is specified, attributed variables\n    are printed as variables, without any attribute.\n\n      N\n    print newline (NL) characters as newlines rather than as an\n    escape sequence, even when they occur in quoted atoms or strings.\n    This only makes sense together with the Q modifier.\n\n      T\n    do not apply any write transformations.\n\n      C\n    print the term as a clause, i.e.  clause macros will be taken into\n    account.\n\n      F\n\tprint a fullstop after the term, separated from the term by an\n\textra space, if necessary.\n\n      L\n\tprint a newline after the term (or as part of the fullstop\n\tsequence, if used together with the F option).\n\n  W\n    Like %w, but the stream's default output options are taken into\n    account, unless overridden by the format options specified here.\n    Note in particular that a default setting may be cancelled by\n    prefixing the format character with a minus sign. E.g. if the stream\n    defaults specify that quotes should be printed (quoted(true)), this\n    can be overridden by a %-QW format string.\n\n  x\n    The argument has to be an integer and its least significant 32 bits\n    are printed in unsigned hexadecimal notation (using letters abcdef).\n    Optionally, details regarding field width, number of digits, padding\n    and sign representation can be specified.  DEPRECATED, see r.\n\n  X\n    The argument has to be an integer and its least significant 32 bits\n    are printed in unsigned hexadecimal notation (using letters ABCDEF).\n    Optionally, details regarding field width, number of digits, padding\n    and sign representation can be specified.  DEPRECATED, see R.\n\n  %\n    One % is printed.\n\n   For backward compatibility, if ArgList contains only one argument,\n   it need not be in a list.\n\nModes and Determinism\n   printf(+, +, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n     5 --- Format is not an atom or a string.\n     5 --- ArgList contains argument whose type does not correspond to    the control sequence.\n     7 --- Format is not correct, it contains too many asterisks or a    control character is missing or there is a redundant character before    the control character.\n     8 --- ArgList has not enough or too many arguments.\n   192 --- Stream is not an output stream.\n   193 --- Stream is not a stream specification.\n\nExamples\n   \nSuccess:\n?- printf(output, \"abc %s ghi %+*.*E...\",\n    [\"def\", 2, 3, 12.34]).\nabc def ghi +1.234E+01...\nyes.\n?- printf(output, \"abc %12c %*n\", [77, 3]).\nabc MMMMMMMMMMMM\n\nyes.\n?- printf(output, \"abc %i def %a%2t%%\", [123, ghi]).\nabc  def ghi    %\nyes.\n?- printf(output, \"%w\", ['A'+'B']).\nA + B\nyes.\n?- printf(output, \"%q\", ['A'+'B']).\n'A' + 'B'\nyes.\n?- printf(output, \"%k\", ['A'+'B']).\n+(A, B)\nyes.\n\nError:\n      printf(S, \"%s\", [\"eclipse\"]).    (Error 4).\n      printf(output, F, eclipse).    (Error 4).\n      printf(\"output\", \"%s\", [\"eclipse\"]).   (Error 5).\n      printf(output, \"%a\", 1).    (Error 5).\n      printf(output, \"%*.*.*s\", [2, 3, 4,  \"eclipse\"]).\n    (Error 7).\n      printf(output, \"%d %d %d\", [1, 9]).    (Error 8).\n      printf(9, \"%s\", [\"eclipse\"]).\n    (Error 192). % stream not open\n      printf(atom, \"%s\", [\"eclipse\"]).       (Error 193).\n      printf(s, comment%s, eclipse).\n    '%' starts a comment\n\nSee Also\n   display / 1, display / 2, print / 1, print / 2, printf / 2, sprintf / 3, write / 1, write / 2, write_term / 2, write_term / 3, writeq / 1, writeq / 2"},"read/2":{"prefix":"read","body":"read(${1:Stream}, ${2:Term})$3\n$0","description":"read(+Stream, -Term)\n\n   Succeeds if the next term from the input stream Stream is successfully read\nand unified with Term.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term or variable.\n\nType\n   Term I/O\n\nDescription\n   Used to read the next term from the input stream Stream and unify it\n   with Term.  If there is more than one Prolog term in the file, the term\n   must be in Prolog term format i.e.  terminated by fullstop (a period and\n   a blank space character), neither of which are retained by Prolog.\n\n   Otherwise, end of file acts like fullstop.  If only end of file is read,\n   the event 190 is raised and the default handler unifies Term with the\n   atom end_of_file.\n\n   The default action for syntax errors is to print a warning and fail.\n\nModes and Determinism\n   read(+, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \nSuccess:\n      ?- read(0,Term).\n       atom.\n      Term = atom\n      yes.\n\n      ?- open(file1,write,s),write(s, 'f(1,2,3).\\ng(1,2'),\n    write(s, ',3). h(1,2,3).\\ni.\\nj(1, 2\\n,3).').\n      yes.\n      ?- system('cat file1').\n      f(1,2,3).\n      g(1,2,3). h(1,2,3).\n      i.\n      j(1, 2\n      ,3).\n      yes.\n      ?- open(file1,read,s), read(s,A), read(s,B),\n    read(s,C), read(s,D), read(s,E), read(s,F).\n      A = f(1, 2, 3)\n      B = g(1, 2, 3)\n      C = h(1, 2, 3)\n      D = i\n      E = j(1, 2, 3)\n      F = end_of_file\n      yes.\nFail:\n      ?- read(0,a).\n       b.\n      no.\n\n      ?- read(0,X).\n       f(1,2)m.\n    ^ (here?)\n      syntax error: postfix/infix operator expected\n      no (more) solution.\nError:\n      read(a(b,c),S).    (Error 4).\n      read(\"string\", a(b,c)).       (Error 5).\n      read(9, X=2).    (Error 192). % stream not open\n      read(atom, X=2).    (Error 193).\n\nSee Also\n   read / 1, readvar / 3, read_token / 2, read_token / 3"},"read_annotated/3":{"prefix":"read_annotated","body":"read_annotated(${1:Stream}, ${2:Term}, ${3:AnnTerm})$4\n$0","description":"read_annotated(+Stream, -Term, -AnnTerm)\n\n   Read term with type and source position information\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Variable or term\n   AnnTerm    Variable or term\n\nType\n   Term I/O\n\nDescription\n    Reads the next input term (up to the end of file, or up to a fullstop)\n    from from the input stream Stream, and returns this term as Term, and\n    a descriptor AnnTerm.  AnnTerm is structurally similar to Term and\n    contains all information about the term, plus additional type information,\n    variable names, and source position annotations for all subterms.\n\n    The structure of the descriptive terms is as follows:\n    \n    :- export struct(annotated_term(\n    term,    % var, atomic or compound\n    type,    % term type (see below)\n    file,    % source file name (atom)\n    line,    % source line (integer)\n    from, to    % source position (integers)\n    ...\n    )).\n    \n\n    The type-field describes the type of the parsed term and is one of\n    the following:\n\n    integer\n    float\n    rational\n    breal\n    atom\n    string\n    compound    term is compound (with annotated subterms)\n    anonymous    term is a variable (was anonymous (_) in source)\n    var(NameAtom)       term is a variable (with the given source name)\n    var    term is a variable (introduced by macro expansion)\n    end_of_file    end of file was read (term is end_of_file)\n\n    These type names correspond to the ones used in type_of/2, except that\n    they convey additional information about variables and end_of_file..\n\n    In the case of atomic terms and variables, the term-field simply\n    contains the plain parsed term. For compound terms, the term-field\n    contains a structure whose functor is the functor of the plain term,\n    but whose arguments are annotated versions of the plain term arguments.\n\n    E.g. the source term\n\n    3\n\n    is parsed as\n\n    annotated_term(3, integer, ...)\n\n    The source term\n\n    foo(bar, X, _, 3)\n\n    is parsed as\n\n    annotated_term(foo(\n    annotated_term(bar, atom, ...),\n    annotated_term(X, var('X'), ...),\n    annotated_term(_, anonymous, ...),\n    annotated_term(3, integer, ...)),\n    compound, ...)\n\n    The source term\n\n    [1,2]\n\n    is parsed as\n\n    annotated_term(.(\n    annotated_term(1, integer, ...),\n    annotated_term(.(\n    annotated_term(2, integer, ...),\n    annotated_term([], atom, ...)),\n    compound, ...)),\n    compound, ...)\n\nThe file/line/from/to-fields of an annotated term describe the\n\"source position\" of the term.  The fields contain:\n\nfile\n    The canonical file name of the source file (an atom), or the\n    empty atom '' if the source is not a file or not known.\n\nline\n    The line number in the source stream (positive integer).\n\nfrom, to\n    The exact term position as integer offsets in the source stream,\n    starting at from and ending at to-1.\n\nThe source position of a whole (sub)term is defined as the source position\nof the unique token (sometimes token pair) which represents that (sub)term.\nThe representing token (pair) is defined as follows:\n\natoms, strings and unsigned numbers are represented by their\n    corresponding IDENTIFIER, NUMBER or STRING token.\n\nsigned numbers are represented by two consecutive tokens (sign+number)\n\ncompound terms in canonical notation are represented by two consecutive\n    tokens (functor and opening parenthesis)\n\ncompound terms in operator syntax are represented by the operator's\n    IDENTIFIER token\n\nlists:\n\n  a proper list [a,b] has subterms\n    \n    [a,b]   represented by the [ token,\n    [b]     represented by the , token,\n    []      represented by the ] token,\n    a       represented by itself,\n    b       represented by itself.\n    \n  a general list [a,b|T] has subterms\n    \n    [a,b|T] represented by the [ token,\n    [b|T]   represented by the , token,\n    T       represented by itself,\n    a       represented by itself,\n    b       represented by itself.\n    \n  Note that the | and ] tokens do not represent any term.\n\nspecial notations:\n\n  {X}\n\n    '{}'(X) represented by the { token,\n    X       represented by itself\n\n  X[Args]\n\n    subscript(X, [...]) represented by the [ token,\n    X,Args  represented by themselves\n\n  X{Args}\n\n    'with attributes'(X,[Args]) represented by { token,\n    X,Args  represented by themselves\n\n  a{Args}\n\n    with(a,[Args])  represented by the { token\n    a,Args  represented by themselves\n\n  X(Args)\n\n    apply(X,[Args]) represented by the ( token\n    X,Args  represented by themselves\n\n    Terms that were read from source may be subject to macro expansion\n    (see macro/3, expand_macros/2).  In that case, term components\n    that were introduced by the expansion may not have an exactly\n    corresponding item in the source (but will usually inherit a\n    meaningful, though not necessarily unique, source position). \n    Moreover, variables that were newly introduced by the expansion\n    have a type-field of 'var' without name information.  Also,\n    'anonymous' variables may have more than one occurrence after expansion.\n\n    If only end of file is read, the event 190 is raised. The default\n    handler unifies Term with an annotated term of the form\n    annotated_term{term:end_of_file,type:end_of_file}, and the source\n    location is the last position in the file.\n\n    The default action for syntax errors is to print a warning and fail.\n\nModes and Determinism\n   read_annotated(+, -, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \n?- read_annotated(input,T,AT).\n 33.\n\nT = 33\nAT = annotated_term(33, integer, user, 1, 0, 2)\nYes (0.00s cpu)\n\n?- read_annotated(input,T,AT).\n foo(bar).\n\nT = foo(bar)\nAT = annotated_term(foo(\n    annotated_term(bar, atom, user, 2, 8, 11)\n    ), compound, user, 2, 4, 8)\nYes (0.00s cpu)\n\n?- read_annotated(input,X).\n a + 3.\n\nT = a + 3\nAT = annotated_term(\n    annotated_term(a, atom, user, 3, 14, 15)\n    +   annotated_term(3, integer, user, 3, 18, 19),\n    compound, user, 3, 16, 17)\nYes (0.00s cpu)\n\n?- read_annotated(input,X).\n [a,b].\n\nT = [a, b]\nAT = annotated_term([\n    annotated_term(a, atom, user, 4, 22, 23)|\n    annotated_term([\n    annotated_term(b, atom, user, 4, 24, 25)|\n    annotated_term([], atom, user, 4, 25, 26)\n    ], compound, user, 4, 23, 24)\n    ], compound, user, 4, 21, 22)\nYes (0.00s cpu)\n\nSee Also\n   read_annotated / 2, read / 1, readvar / 3, read_token / 2, read_token / 3, expand_macros / 2, macro / 3, type_of / 2"},"read_annotated/2":{"prefix":"read_annotated","body":"read_annotated(${1:Stream}, ${2:AnnTerm})$3\n$0","description":"read_annotated(+Stream, -AnnTerm)\n\n   Read term with type and source position information\n\nArguments\n   Stream    Stream handle or alias (atom)\n   AnnTerm    Variable or term\n\nType\n   Term I/O\n\nDescription\n    This is defined as\n\n    read_annoated(Stream, AnnTerm) :-\n    read_annotated(Stream _Term, AnnTerm).\n\n    \n\nModes and Determinism\n   read_annotated(+, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nSee Also\n   read_annotated / 3"},"read_exdr/2":{"prefix":"read_exdr","body":"read_exdr(${1:Stream}, ${2:Term})$3\n$0","description":"read_exdr(+Stream, -Term)\n\n   A term in EXDR-format is read from the input stream Stream and\nconverted to the corresponding ECLiPSe term Term.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    A variable.\n\nType\n   Term I/O\n\nDescription\n    The predicates write_exdr/2 and read_exdr/2 can be used for letting\n    ECLiPSe programs exchange data with the host language in an embedded\n    environment (e.g.  Java, Tcl).  More generally, they allow exchanging\n    data with agents written in programming languages that define a\n    mapping from EXDR format to the language's data structures.\n\n    EXDR defines the abstract data types Integer, Long, Double, String,\n    List, Nil, Struct and Anonymous Variable. Their mapping to ECLiPSe\n    data types is as follows:\n\n    EXDR type       ECLiPSe type    e.g.\n    ----------------------------------------------\n    Integer    integer    123\n    Long    integer    10000000000\n    Double    float    12.3\n    String    string    \"abc\"\n    List    ./2    [a,b,c]\n    Nil    []/0    []\n    Struct    compound or atom    foo(bar,3)\n    Anon.Variable   var    _\n\n    Not all ECLiPSe terms have an EXDR representation, e.g. integers longer\n    than 64 bits, rationals, suspensions or attributed variables.\n\n    More information about EXDR format, including the specification of the\n    serialised encoding, can be found in the Embedding and Interfacing Manual.\n\nModes and Determinism\n   read_exdr(+, -) is semidet\n\nFail Conditions\n   Fails when reaching end of file\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n     7 --- EXDR term corrupted.\n   190 --- End of file (default handler fails)\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   264 --- Not EXDR format.\n   265 --- Unknown EXDR format version.\n\nExamples\n   \nSuccess:\n    ?- open(queue(\"\"),update,q),\n    write_exdr(q, foo(12.3,123,[\"hello\",_])),\n    read_exdr(q, Term),\n    close(q).\n\n    Term = foo(12.3, 123, [\"hello\", _131])\n    yes.\n\nError:\n    read_exdr(S, a(b,c)).    (Error 4).\n    read_exdr(output, X).    (Error 192).\n    read_exdr(atom, X).      (Error 193).\n\nSee Also\n   write_exdr / 2, read / 1, read / 2"},"readvar/3":{"prefix":"readvar","body":"readvar(${1:Stream}, ${2:Term}, ${3:VarList})$4\n$0","description":"readvar(+Stream, -Term, -VarList)\n\n   Succeeds if the next Prolog term from the input stream Stream is\nsuccessfully read and unified with Term, and any variables in Term are\ncollected in the list VarList, together with their names.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n   VarList    A Variable.\n\nType\n   Term I/O\n\nDescription\n   Used to read the next term from the input stream Stream, unify it with\n   Term and store any variables in Term to the list VarList.  This is a\n   list of pairs in the format [VarName|Var].\n\n   VarName is the literal input variable name expressed as an atom; Var is\n   the variable.  The first element of the pair Varname is the atom\n   corresponding to the variable name, and the second element Var is the\n   corresponding variable.\n\n   If there is more than one Prolog term in the file, the term must be in\n   Prolog term format i.e.  terminated by a period and a blank space\n   character, neither of which are retained by Prolog.\n\nModes and Determinism\n   readvar(+, -, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle, Varlist is not a    variable.\n   190 --- End of file was encountered before reading any character.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n   198 --- Trying to read even after the error 190 was raised.\n\nExamples\n   \nSuccess:\n      ?- readvar(input,Term,VarList).\n       atom.\n      Term = atom\n      VarList = []\n      yes.\n\n      ?- readvar(input,T,L).\n       X.\n      T = _50\n      L = [['X'|_50]]\n      yes.\n\n      ?- system('cat file1').\n      f(X,Y).\n      g(1,X).\n      yes.\n      ?- open(file1,update,r), readvar(r,T1,V1),\n    readvar(r, T2,V2).\n      T1 = f(_120, _122)\n      V1 = [['X'|_120], ['Y'|_122]]\n      T2 = g(1, _146)    % the clauses are separate,\n      V2 = [['X'|_146]]    % so the X's are different.\n      yes.\n\nFail:\n      ?- readvar(input, X + 2,V).\n       X + 1.\n      no.\n\nError:\n      readvar(S,a(b,c),V).    (Error 4).\n      readvar(\"string\",a(b,c),V,).  (Error 5).\n      readvar(output,X + 2,V).      (Error 192).\n      readvar(atom,X + 2,V).    (Error 193).\n\nSee Also\n   read / 1, read / 2"},"read_term/2":{"prefix":"read_term","body":"read_term(${1:Term}, ${2:Options})$3\n$0","description":"read_term(-Term, +Options)\n\n   Read a whole term in ECLiPSe syntax from the current input stream, according to Options\n\nArguments\n   Term    An term, usually a variable\n   Options    List of option terms\n\nType\n   Term I/O\n\nDescription\n\n    This is a generalisation of the predicates read/1 and readvar/3.\n\n    read_term(Term, Options) is equivalent to\n    read_term(output, Term, Options).\n    For details see read_term/3.\n\n    \n\nModes and Determinism\n   read_term(-, +) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     5 --- Options is not a list of compound terms.\n     6 --- Options list contains a unrecognised option.\n\nExamples\n   \n    Equivalent to read_term(output, Term, Options).\n    See read_term/3 for examples.\n\nSee Also\n   read_term / 3, read / 1, read / 2, readvar / 3, library(numbervars)"},"write/1":{"prefix":"write","body":"write(${1:Term})$2\n$0","description":"write(?Term)\n\n   The term Term is written on output stream according to the current operator\ndeclarations.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term on the current output according to the\n   current operator declarations.  Lists and compound terms are only\n   printed up to the nesting depth specified by the (stream-specific\n   or global) print_depth setting (cf. set_stream_property/3, set_flag/2).\n\n   write(Term) is equivalent to write_term(Term, [numbervars(true)]).\n\nNote\n   The output of write/1 is not necessarily in a form acceptable to\n   read/1/2.\n\nModes and Determinism\n   write(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n      Equivalent to write(output, Term).  (see write/2 for details).\n\nSee Also\n   display / 1, display / 2, get_flag / 2, set_flag / 2, write / 2, writeln / 1, writeq / 1, writeq / 2"},"read_term/3":{"prefix":"read_term","body":"read_term(${1:Stream}, ${2:Term}, ${3:Options})$4\n$0","description":"read_term(+Stream, -Term, ++Options)\n\n   Read a whole term in ECLiPSe syntax from the input stream Stream, according to Options\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    An term, usually a variable\n   Options    List of option terms\n\nType\n   Term I/O\n\nDescription\n\n    This is a generalisation of the predicates read/2 and readvar/3.\n    Options is a (possibly empty) list of the following options:\n\n    variables(Vars)\n    returns a duplicate-free list of all the variables in the term\n    that has been read (including anonymous variables).\n    \n\n    variable_names(VarsNames)\n    returns a duplicate-free list of structures of the form\n    Name=Var, where Var is a named (non-anonymous) variable which\n    occurs in the term that has been read, and Name is an atom,\n    representing the source name.  \n\n    singletons(VarsNames)\n    returns a list of structures of the form Name=Var, where Var\n    is a named (non-anonymous) variable which occurs only once in\n    the term that has been read, and Name is an atom, representing\n    the source name.  \n\nModes and Determinism\n   read_term(+, -, ++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if a syntax error was detected and no term could be read\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n     5 --- Options is not a list of compound terms.\n     6 --- Options list contains a unrecognised option.\n   192 --- Stream is not an input stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n    ?- read_term(T, []).\n    foo(X,_,bar(X,Y,_Z)).\n\n    T = foo(X, _255, bar(X, Y, _Z))\n\n    ?- read_term(T, [variable_names(VN)]).\n    foo(X,_,bar(X,Y,_Z)).\n\n    T = foo(X, _260, bar(X, Y, _Z))\n    VN = ['X' = X, 'Y' = Y, '_Z' = _Z]\n\n    ?- read_term(T, [variables(V),variable_names(VN),singletons(S)]).\n    foo(X,_,bar(X,Y,_Z)).\n\n    T = foo(X, _278, bar(X, Y, _Z))\n    V = [X, _278, Y, _Z]\n    VN = ['X' = X, 'Y' = Y, '_Z' = _Z]\n    S = ['_Z' = _Z, 'Y' = Y]\n\nSee Also\n   read_term / 2, readvar / 3, read / 1, read / 2, set_stream_property / 3"},"write/2":{"prefix":"write","body":"write(${1:Stream}, ${2:Term})$3\n$0","description":"write(+Stream, ?Term)\n\n   The term Term is written on the output stream Stream according to the\ncurrent operator declarations.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term on the output stream Stream according to the\n   current operator declarations.  Lists and compound terms are only\n   printed up to the nesting depth specified by the (stream-specific or\n   global) print_depth setting (cf. set_stream_property/3, set_flag/2).\n\n   write(Term) is equivalent to write_term(Term, [numbervars(true)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   (e.g.  explicitly using flush/1).\n\nNote\n   The output of write/1 is not necessarily in a form acceptable to\n   read/1,2.\n\nModes and Determinism\n   write(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output steam.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      ?- open(file1,update,s), write(s, X + 2), close(s).\n      X = _72\n      yes.\n      ?- sh('cat file1').\n      _72 + 2\n      yes.\n\nError:\n      write(S, a(b,c)).    (Error 4).\n      write(\"string\", a(b,c)).   (Error 5).\n      write(9, X + 2).    (Error 192). % stream not open\n      write(atom, X + 2).    (Error 193).\n\nSee Also\n   display / 1, display / 2, get_flag / 2, set_flag / 2, write / 1, writeln / 2, writeq / 1, writeq / 2"},"sprintf/3":{"prefix":"sprintf","body":"sprintf(${1:String}, ${2:Format}, ${3:ArgList})$4\n$0","description":"sprintf(-String, +Format, ?ArgList)\n\n   The arguments in the argument list ArgList are interpreted according to the\nFormat string and the formatted result is unified with String.\n\nArguments\n   String    Variable or String.\n   Format    String or Atom.\n   ArgList    List or any Term.\n\nType\n   Term I/O\n\nDescription\n    This predicate works exactly like printf/2,3 except that the formatted\n    result is delivered in the form of a string.  See printf/3 for details.\n\n    Note that for simple cases it is usually more efficient to use\n    primitives like concat_string/2, join_string/3 or number_string/2.\n\nModes and Determinism\n   sprintf(-, +, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- String is instantiated to something other than a string.\n     5 --- Format is not an atom or a string.\n     5 --- ArgList contains argument whose type does not correspond to the control sequence.\n     7 --- Format is not correct, it contains too many asterisks or a control character is missing or there is a redundant character before the control character.\n     8 --- ArgList has not enough or too many arguments.\n\nExamples\n   \nSuccess:\n?- sprintf(String, \"abc %s ghi %+*.*E...\", [\"def\", 2, 3, 12.34]).\nString = \"abc def ghi +1.234E+01...\"\nyes.\n\n?- sprintf(String, \"abc %12c %*n\", [77, 3]).\nString = \"abc MMMMMMMMMMMM \\n\\n\\n\"\nyes.\n\n?- sprintf(\"x9\", \"x%d\", [3]).\nno.\n\nSee Also\n   concat_string / 2, join_string / 3, number_string / 2, printf / 2, printf / 3"},"writeclause/1":{"prefix":"writeclause","body":"writeclause(${1:Clause})$2\n$0","description":"writeclause(?Clause)\n\n   The clause Clause is pretty printed on the current output .\n\nArguments\n   Clause    A Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to pretty print the clause Clause on the current output according\n   to the current operator declarations.\n\n   When reading Prolog clauses from one file, and then writing to the\n   current output, the latter part can be done using writeclause/1.  This\n   is because the clauses are terminated by a period and a newline, which\n   are not retained by Prolog.  writeclause/1 replaces these, and flushes\n   the output.\n\n   writeclause/1,2 knows about the special meaning of ,/2, ;/2, ->/2, fg,\n   -->/2 and :-/2 and prints the clause with the appropriate indentation of\n   subgoals and some (redundant) parentheses to show the clause structure.\n   Everything else is written as with writeq/1,2, so output of writeclause/1,2\n   is readable for read/1,2.\n\nModes and Determinism\n   writeclause(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    Equivalent to writeclause(output, Term).  (see writeclause/2 for details).\n\nSee Also\n   writeq / 1, writeclause / 2"},"write_canonical/1":{"prefix":"write_canonical","body":"write_canonical(${1:Term})$2\n$0","description":"write_canonical(?Term)\n\n   The term Term is written on the stream output in a form that ignores\noperator declarations and can be read in.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term in a form that can be read back independent\n   of the current operator declarations.  Atoms and strings are quoted,\n   operator declarations are ignored, lists are printed as ./2 structures,\n   the (stream-specific or global) print_depth flag is not taken into account,\n   variable attributes are printed, and variables are printed with unique\n   identifiers.\n\n   write_canonical(Term) is equivalent to printf(\"%DMOQv.w\", Term)\n   or write_term(Term, [attributes(full),operators(false),quoted(true),\n    dotlists(true),variables(raw),depth(full),transform(false)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the output stream, by writing again or by using\n   flush/1.\n\nModes and Determinism\n   write_canonical(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n   Equivalent to write_canonical(output, Term).\n   (see write_canonical/2 for details).\n\nSee Also\n   write / 1, write / 2, writeq / 1, writeq / 2, write_canonical / 2"},"write_canonical/2":{"prefix":"write_canonical","body":"write_canonical(${1:Stream}, ${2:Term})$3\n$0","description":"write_canonical(+Stream, ?Term)\n\n   The term Term is written on the output stream Stream in a form that ignores\noperator declarations and can be read in.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term in a form that can be read back independent\n   of the current operator declarations.  Atoms and strings are quoted,\n   operator declarations are ignored, lists are printed as ./2 structures,\n   the (stream-specific or global) print_depth flag is not taken into account,\n   variable attributes are printed, and variables are printed with unique\n   identifiers.\n\n   write_canonical(S,Term) is equivalent to printf(S,\"%DMOQv.w\", Term)\n   or write_term(S,Term, [attributes(full),operators(false),quoted(true),\n    dotlists(true),variables(raw),depth(full),transform(false)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the stream, by writing again or by using flush/1.\n\nModes and Determinism\n   write_canonical(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n   Success:\n    ?- write_canonical(output, 'A'+[a,B]).\n    +('A', .(a, .(_216, [])))\n    B = B\n    yes.\n\nError:\n    write_canonical(S, a(b,c)).    (Error 4).\n    write_canonical(\"string\", a(b,c)). (Error 5).\n    write_canonical(input, X + 2).     (Error 192).\n    write_canonical(atom, X + 2).      (Error 193).\n\nSee Also\n   write / 1, write / 2, writeq / 1, writeq / 2, write_canonical / 1"},"writeclause/2":{"prefix":"writeclause","body":"writeclause(${1:Stream}, ${2:Clause})$3\n$0","description":"writeclause(+Stream, ?Clause)\n\n   The clause Clause is pretty printed on the output stream Stream .\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Clause    A Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to pretty print the clause Clause on the output stream Stream\n   according to the current operator declarations.\n\n   When reading Prolog clauses from one file, and then writing to another,\n   the latter part can be done using writeclause/2.  This is because the\n   clauses are terminated by a period and a newline, which are not retained\n   by prolog.  writeclause/2 replaces these, and flushes the output.\n\n   writeclause/1,2 knows about the special meaning of ,/2, ;/2, ->/2, fg\n   -->/2 and :-/2 and prints the clause with the appropriate indentation of\n   subgoals and some (redundant) parantheses to show the clause structure.\n   Everything else is written as with writeq/1,2, so output of writeclause/1,2\n   is readable for read/1,2.\n\nModes and Determinism\n   writeclause(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n      ?- writeclause(output, f(1,2,3)), writeclause(output, h(2,3)).\n      f(1, 2, 3) .\n      h(2, 3) .\n      yes.\n\n      ?- writeclause(output, X + 2).\n      _56 + 2.\n      yes.\n\n      ?- writeclause(output, a(k):-write(k)).\n      a(k) :-\n    write(k) .\n      yes.\n\n      ?- writeclause(output, (a:-write(k),date(K))).\n      a :-\n    write(k),\n    date(_68) .\n      yes.\n\n      ?- open(file1,update,s), writeclause(s, X + 2), close(s).\n      X = _72\n      yes.\n      ?- sh('cat file1').\n      _72 + 2.\n      yes.\n\n      ?- set_stream(a,output), writeclause(a, (:- dynamic f/1)).\n      :- dynamic f / 1 .\n      yes.\n\n      ?- writeclause(output, (head:-a1,a2;a3,a4->a5;a6)).\n      head :-\n    (\n    a1,\n    a2\n    ;\n    (\n    a3,\n    a4\n    ->\n    a5\n    ;\n    a6\n    )\n    ).\n      yes.\n\nError:\n      writeclause(S, a(b,c)).    (Error 4).\n      writeclause(\"string\" a(b,c)).   (Error 5).\n\nSee Also\n   writeq / 2, writeclause / 1"},"writeln/1":{"prefix":"writeln","body":"writeln(${1:Term})$2\n$0","description":"writeln(?Term)\n\n   The term Term is written on the current output according to the current\noperator declarations.  Equivalent to write(Term),nl.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term (followed by a newline) on the current\n   output according to the current operator declarations.\n\nModes and Determinism\n   writeln(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n      Equivalent to writeln(output, Term).  (see writeln/2 for details).\n\nSee Also\n   writeln / 2, write / 1, nl / 0"},"writeln/2":{"prefix":"writeln","body":"writeln(${1:Stream}, ${2:Term})$3\n$0","description":"writeln(+Stream, ?Term)\n\n   The term Term is written on the output stream Stream according to the\ncurrent operator declarations.  Equivalent to write(Stream,Term),\nnl(Stream).\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n   Used to write the term Term (followed by a newline) on the output stream\n   Stream according to the current operator declarations.\n\nModes and Determinism\n   writeln(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n   Success:\n      ?- open(file1,update,s), writeln(s, X + 2),\n    writeln(s, Y + 3), close(s).\n      X = _90\n      Y = _78\n      yes.\n      ?- sh('cat file1').\n      _90 + 2\n      _78 + 3\n      yes.\n\nError:\n      writeln(S, a(b,c)).    (Error 4).\n      writeln(\"string\", a(b,c)). (Error 5).\n      writeln(9, X + 2).    (Error 192).\n      writeln(atom, X + 2).      (Error 193).\n\nSee Also\n   writeln / 1, write / 1, write / 2"},"write_exdr/2":{"prefix":"write_exdr","body":"write_exdr(${1:Stream}, ${2:Term})$3\n$0","description":"write_exdr(+Stream, ?Term)\n\n   The term Term is written onto the output stream Stream in EXDR-format\n(a format for communication with agents in other programming languages).\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n    The predicates write_exdr/2 and read_exdr/2 can be used for letting\n    ECLiPSe programs exchange data with the host language in an embedded\n    environment (e.g.  Java, Tcl).  More generally, they allow exchanging\n    data with agents written in programming languages that define a\n    mapping from EXDR format to the language's data structures.\n\n    EXDR defines the abstract data types Integer, Long, Double, String,\n    List, Nil, Struct and Anonymous Variable. Their mapping to ECLiPSe\n    data types is as follows:\n\n    EXDR type       ECLiPSe type    e.g.\n    ----------------------------------------------\n    Integer    integer    123\n    Long    integer    10000000000\n    Double    float    12.3\n    String    string    \"abc\"\n    List    ./2    [a,b,c]\n    Nil    []/0    []\n    Struct    compound or atom    foo(bar,3)\n    Anon.Variable   var    _\n\n    The type of the generated EXDR-term is the type resulting from the\n    \"natural\" mapping of the Eclipse terms.  Atoms are written as\n    structures of arity 0 (not as strings).\n\n    Not all ECLiPSe terms have an EXDR representation, e.g. integers longer\n    than 64 bits, rationals, suspensions or improper lists.  The predicate\n    fails in this case, nevertheless writing a complete but simplified term\n    to the stream.  All information about variable sharing and variable\n    attributes in the ECLiPSe term is silently lost (no failure).\n\n    Note that as with all output predicates, the output may be buffered,\n    so it may be necessary to flush either by closing the stream or by\n    using flush/1.\n\n    If the output Stream has the compress-flag set, write_exdr/2 will use a\n    more compact variant of EXDR encoding, at the expense of encoding speed.\n\n    More information about EXDR format, including the specification of the\n    serialised encoding, can be found in the Embedding and Interfacing Manual.\n\nModes and Determinism\n   write_exdr(+, ?) is semidet\n\nFail Conditions\n   Fails if the Term cannot be represented in EXDR format\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \nSuccess:\n    ?- open(queue(\"\"),update,q),\n    write_exdr(q, foo(12.3,123,[\"hello\",_])),\n    read_exdr(q, Term),\n    close(q).\n\n    Term = foo(12.3, 123, [\"hello\", _131])\n    yes.\n\nFailure:\n    write_exdr(q, 617236126172).\n    write_exdr(q, 3_4).\n\nError:\n    write_exdr(S, a(b,c)).    (Error 4).\n    write_exdr(input, X + 2).     (Error 192).\n    write_exdr(atom, X + 2).      (Error 193).\n\nSee Also\n   read_exdr / 2, flush / 1, set_stream_property / 3, open / 4"},"writeq/1":{"prefix":"writeq","body":"writeq(${1:Term})$2\n$0","description":"writeq(?Term)\n\n   The term Term is written on the current output in a form that can be read\nin.\n\nArguments\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n\n   Used to write the term Term on the current output according to the\n   current operator declarations.  Atoms and strings are quoted,\n   operator expressions parenthesised (whenever necessary) and the\n   (stream-specific or global) print_depth flag is not taken into\n   account.  The output of writeq/1 can be read back, provided that\n   the same operator declarations are in effect at write and read\n   time.\n\n   writeq(Term) is equivalent to printf(\"%DIMQvw\", Term)\n   or write_term(Term, [attributes(full),quoted(true),numbervars(true),\n   variables(raw),depth(full),transform(false)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the stream, by writing again or by using flush/1.\n\n   Note also that although it is possible to print suspensions and external\n   handles, these are printed in their printed representation as Prolog\n   terms with functors such as 'BAG' (for bag objects). They will be read\n   back in as such Prolog terms, rather than as their original type. \n\nModes and Determinism\n   writeq(?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n      Equivalent to writeq(output, Term).  (see writeq/2 for details).\n\nSee Also\n   printf / 2, write / 1, write / 2, writeq / 2"},"writeq/2":{"prefix":"writeq","body":"writeq(${1:Stream}, ${2:Term})$3\n$0","description":"writeq(+Stream, ?Term)\n\n   The term Term is written on the output stream Stream in a form that can be\nread in.\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    Prolog term.\n\nType\n   Term I/O\n\nDescription\n\n   Used to write the term Term on the output stream Stream according\n   to the current operator declarations.  Atoms and strings are\n   quoted, operator expressions parenthesised (whenever necessary) and\n   the (stream-specific or global) print_depth flag is not taken into\n   account.  The output of writeq/2 can be read back, provided that\n   the same operator declarations are in effect at write and read\n   time.\n\n   writeq(Term) is equivalent to printf(\"%DIMQvw\", Term)\n   or write_term(Term, [attributes(full),quoted(true),numbervars(true),\n   variables(raw),depth(full),transform(false)]).\n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the stream, by writing again or by using flush/1.\n\n   Note also that although it is possible to print suspensions and external\n   handles, these are printed in their printed representation as Prolog\n   terms with functors such as 'BAG' (for bag objects). They will be read\n   back in as such Prolog terms, rather than as their original type. \n\nModes and Determinism\n   writeq(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n   Success:\n      ?- writeq(output, \"string\"),nl(output),\n    writeq(output, head:-body).\n      \"string\"\n      head :- body\n      yes.\n\n      ?- writeq(*(^(1,2),+(3,4))).\n      1 ^ 2 * (3 + 4)\n      yes.\nError:\n      writeq(S, a(b,c)).    (Error 4).\n      writeq(\"string\", a(b,c)). (Error 5).\n      writeq(9, X + 2).    (Error 192).\n      writeq(atom, X + 2).      (Error 193).\n\nSee Also\n   write / 1, write / 2, writeq / 1"},"write_term/3":{"prefix":"write_term","body":"write_term(${1:Stream}, ${2:Term}, ${3:Options})$4\n$0","description":"write_term(+Stream, ?Term, ++Options)\n\n   The term Term is written to the output stream Stream in a format specified by Options\n\nArguments\n   Stream    Stream handle or alias (atom)\n   Term    An arbitrary term\n   Options    List of option terms\n\nType\n   Term I/O\n\nDescription\n\n    This is a generalisation of the predicates write/2, writeq/2, print/2,\n    display/2, write_canonical/2. It is used to write an arbitrary term\n    Term onto the current output stream according to the given options.\n    Options is a (possibly empty) list of the following options:\n\n    as(term) -- default\n    do not assume any particular meaning of the printed term.\n    \n\n    as(clause)\n    print the term as a clause, i.e. clause macros will be taken into\n    account.\n    \n\n    as(goal)\n    print the term as a goal, i.e. goal write transformations will\n    be taken into account.\n    \n\n    attributes(none) -- default\n    do not print any variable attributes, i.e. print attributed\n    variables like plain variables.\n    \n\n    attributes(pretty)\n    variable attributes are printed using the corresponding print\n    handlers. See meta_attribute/2.\n    \n\n    attributes(full)\n    print the full contents of all variable attributes.  This is\n    necessary if the term is to be written out and read back in.\n    \n\n    compact(false) -- default\n    print extra blank space (around operators, after commas, etc.)\n    for better readability.\n    \n\n    compact(true)\n    don't print blank space unless necessary.\n    \n\n    depth(0) -- default\n    print the term only up to a maximum nesting depth determined\n    by the (stream-specific or global) flag 'print_depth'. See\n    get_stream_info/3 and get_flag/2.\n    \n\n    depth(MaxDepth)\n    print the term only up to a maximum nesting depth of MaxDepth.\n    MaxDepth is a positive integer.\n    \n\n    depth(full)\n    do not observe any depth limit and print the whole term. Note that\n    this will cause looping when the term is cyclic.\n    \n\n    dotlists(false) -- default\n    write lists in the common square bracket notation, e.g. [1, 2].\n    \n\n    dotlists(true)\n    write lists in the dot functor notation rather than using the\n    square bracket notation, e.g. .(1, .(2, [])) rather than [1, 2].\n    \n\n    newlines(false) -- default\n    print newline (NL) characters as escape sequence, when they\n    occur in quoted atoms or strings.\n    \n\n    newlines(true)\n    print newline (NL) characters as newlines rather than as an\n    escape sequence, even when they occur in quoted atoms or strings.\n    This only makes sense together with the quoted(true) option.\n    \n\n    nl(false) -- default\n\tdo no add a newline.\n    \n\n    nl(true)\n    print a newline sequence (as with nl/1) after the term.  If this is\n\tused together with the fullstop(true) option, this newline serves\n\tas the blank space after the fullstop.\n    \n\n    fullstop(false) -- default\n\tdo no add a fullstop.\n    \n\n    fullstop(true)\n\tterminate the term with a fullstop (a dot followed by blank space),\n\tso it can be read back.  The blank space after the dot is a newline\n\tif the nl(true) option is present, otherwise a space character.\n\tIf necessary, an extra space will be inserted before the fullstop,\n\tin order to separate it from the end of the term.\n    \n\n    numbervars(false) -- default\n    do not treat '$VAR'/1 terms specially.\n    ISO-Prolog compatible.\n    \n\n    numbervars(true)\n    any term of the form '$VAR'(N), where N is a non-negative integer,\n    is printed as a variable name consisting of a capital letter\n    followed by a number. The capital letter is the ((N mod 26)+1)st\n    letter of the alphabet, and the integer is N//26.\n    If N is an atom, this atom gets printed instead of the term.\n    ISO-Prolog compatible.\n    \n\n    operators(true) -- default\n    obey operator declarations. All infix, prefix and postfix operators\n    are printed in infix, prefix or postfix form, respectively.\n    \n\n    operators(false)\n    ignore operator declarations.  All terms are written in the canonical\n    notation, with a functor followed by the arguments in parentheses.\n    \n\n    portrayed(false) -- default\n    do not use portray/1,2.\n    \n\n    portrayed(true)\n    call the user-defined predicate portray/1,2 in the way print/1,2\n    does.\n    \n\n    precedence(Prec)\n\tPrec is an integer between 0 and 1200 (default 1200), representing\n\tcontext operator precedence.  Can be used to force correct\n\tparenthesizing when partial terms are written as arguments of\n\toperators.  The written term will be enclosed in parentheses if\n\tits precedence is higher than Prec.\n    \n\n    quoted(false) -- default\n    do not print quotes around strings or atoms.\n    ISO-Prolog compatible.\n    \n\n    quoted(true)\n    quote atoms and strings if necessary.\n    ISO-Prolog compatible.\n    \n\n    transform(true) -- default\n    apply portray (write) transformations before printing.\n    \n\n    transform(false)\n    do not apply any portray (write) transformations.\n    \n\n    variables(default) -- default\n    print variables using their source name, if available.\n    Otherwise print a system-generated name, which consists of\n    an underscore and a number, e.g. _123.\n    Note that this format cannot be reliably read back, because\n    different variables may have the same source name.\n    \n\n    variables(raw)\n    print all variables using a system-generated name, which\n    consists of an underscore and a number, e.g. _123.\n    This format is suitable when the term needs to be read back\n    later.  It makes sure that multiple occurrences of the same\n    variable have the same name, and different variables have\n    different names.\n    \n\n    variables(full)\n    print variables using their source name, if available, followed\n    by a unique number, e.g. Alpha_132. Variables without source\n    name are printed in the raw format. Since variables with\n    identical source names are named apart, this format is suitable\n    when the term needs to be read back later.\n    \n\n    variables(anonymous)\n    print every variable as a simple underscore. Any information about\n    multiple occurrences of a variable is lost with this format. It is\n    mainly useful to produce output that can be compared easily with\n    the output of a different Eclipse session.\n    \n\n    When an option is omitted altogether, then the corresponding option\n    settings for the output stream will come into effect (see\n    set_stream_property/3, get_stream_info/3, open/4).\n\n    The following additional options are supported for compatibility\n    with other Prolog systems:\n\n    ignore_ops(true)\n    the same as [operators(false),dotlists(true),transform(false)].\n    ISO-Prolog compatibility.\n    \n\n    ignore_ops(false)\n    the same as [operators(true),dotlists(false),transform(true)].\n    ISO-Prolog compatibility.\n    \n\n    max_depth(0)\n    the same as depth(full).\n    SICStus-Prolog compatibility.\n    \n\n    max_depth(N)\n    the same as depth(N).\n    SICStus-Prolog compatibility.\n    \n\n    priority(Prec)\n    the same as precedence(Prec).\n    SICStus/SWI-Prolog compatibility.\n    \n\n    The correspondence between write_term/2,3 and the other output predicates\n    is as follows:\n\n    write(T)\n    write_term(T, [numbervars(true)])\n    \n\n    writeln(T)\n    write_term(T, [numbervars(true),nl(true)])\n    \n\n    writeq(T)\n    write_term(T, [variables(raw),attributes(full),transform(false),\n    numbervars(true),quoted(true),depth(full)])\n    \n\n    write_canonical(T)\n    write_term(T, [variables(raw),attributes(full),transform(false),\n    quoted(true),depth(full),dotlist(true),operators(false)])\n    \n\n    print(T)\n    write_term(T, [portrayed(true),numbervars(true)])\n    \n\n    display(T)\n    write_term(T, [dotlist(true),operators(false)])\n    \n\n   Note that as usual, the output is buffered, so it may need to be flushed\n   either by closing the stream, by writing again or by using flush/1.\n\nModes and Determinism\n   write_term(+, ?, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Stream is not instantiated.\n     5 --- Stream is not an atom or a stream handle.\n     5 --- Options is not a list of compound terms.\n     6 --- Options list contains a unrecognised option.\n   192 --- Stream is not an output stream.\n   193 --- Stream is an illegal stream specification.\n\nExamples\n   \n    ?- write_term(*(^(1,2),+(3,4)), []).\n    1 ^ 2 * (3 + 4)\n\n    ?- write_term(*(^(1,2),+(3,4)), [operators(false)]).\n    *(^(1, 2), +(3, 4))\n\n    ?- write_term(['a-b',\"cd\"], []). \n    [a-b, cd]\n\n    ?- write_term(['a-b',\"cd\"], [quoted(true)]).\n    ['a-b', \"cd\"]\n\n    ?- write_term(['a-b',\"cd\"], [quoted(true),dotlists(true)]).\n    .('a-b', .(\"cd\", []))\n\n    ?- write_term(hello, [fullstop(true)]).\n\thello.\n\n    ?- write_term(***, [fullstop(true)]).\n\t*** .\n\n    ?- write('X = '), write_term(a=b, [precedence(699)]).\n\tX = (a = b)\n\nSee Also\n   write_term / 2, display / 2, print / 2, printf / 3, write / 2, writeln / 2, writeq / 2, write_canonical / 2, get_stream_info / 3, get_flag / 2"},"create_module/3":{"prefix":"create_module","body":"create_module(${1:Module}, ${2:Exports}, ${3:Imports})$4\n$0","description":"create_module(+Module, ++Exports, ++Imports)\n\n   Create a module at runtime, with given exports and imports.\n\nArguments\n   Module    Atom.\n   Exports    A list of export specifications as in export/1\n   Imports    An atom or a list of atoms\n\nType\n   Modules\n\nDescription\n   create_module/3 creates the given module if it does not exist yet.\n   If the module already exists, an exception is raised (error 97).\n\n   Once the module is created, the module (or list of modules) given as\n   Imports is imported.\n\n   The list Exports must contain valid export specifications as\n   described in export/1.  It defines the initial part of the module's\n   interface, subsequent export and reexport directives can add to that.\n\n   Note that modules are normally created by the compiler when it\n   encounters a module/1 or module/3 directive.  The create_module/3\n   predicate however creates modules dynamically at runtime.  The\n   intended applications are therefore mainly source processing tools,\n   e.g. compilers and loaders, or programs that need a clean name\n   space to store code and data.\n\n   The system does not allow the atom [] to be used as a module name!\n   If [] is given as the Imports argument, it indicates the empty list,\n   rather than a module with name [].\n\nModes and Determinism\n   create_module(+, ++, ++) is det\n\nExceptions\n     4 --- Module, Imports or Exports is not instantiated.\n     5 --- Module is not an atom, or Module is the atom [].\n     5 --- Imports is not an atom or list of atoms.\n     5 --- Exports is not a list of exportable items.\n    97 --- Module already exists.\n\nExamples\n   \nSuccess:\n    [eclipse 1]: create_module(m, [data/1], []).\n    yes.\n    [eclipse 2]: compile_term(data(99))@m.\n    yes.\n    [eclipse 3]: m:data(X).\n\n    X = 99\n    yes.\n    [eclipse 4]: erase_module(m).\n    yes.\n\nError:\n    create_module(M, [], []).    (Error 4).\n    create_module(m, _, _).    (Error 4).\n    create_module(m, [], library(iso)).      (Error 5).\n    create_module(m,[],[]), create_module(m,[],[]). (Error 97).\n\nSee Also\n   module / 1, module / 3, create_module / 1, erase_module / 1, get_module_info / 3, current_module / 1"},"write_term/2":{"prefix":"write_term","body":"write_term(${1:Term}, ${2:Options})$3\n$0","description":"write_term(?Term, ++Options)\n\n   The term Term is written to the current output in a format specified by Options\n\nArguments\n   Term    An arbitrary term\n   Options    List of option terms\n\nType\n   Term I/O\n\nDescription\n\n    This is a generalisation of the predicates write/1, writeq/1, print/1,\n    display/1, write_canonical/1. It is used to write an arbitrary term\n    Term onto the current output stream according to the given options.\n\n    write_term(Term, Options) is equivalent to\n    write_term(output, Term, Options).\n    For details see write_term/3.\n\n    \n\nModes and Determinism\n   write_term(?, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    Equivalent to write_term(output, Term, Options).\n    See write_term/3 for examples.\n\nSee Also\n   write_term / 3, display / 1, print / 1, printf / 2, write / 1, writeq / 1, write_canonical / 1"},"create_module/1":{"prefix":"create_module","body":"create_module(${1:Module})$2\n$0","description":"create_module(+Module)\n\n   Create a module at runtime\n\nArguments\n   Module    Atom.\n\nType\n   Modules\n\nDescription\n   create_module/1 creates the given module if it does not exist yet.\n   If the module already exists, an exception is raised (error 97).\n\n   Note that modules are normally created by the compiler when it\n   encounters a module/1 directive.  The create_module/1 predicate\n   however creates modules dynamically at runtime.  The intended\n   applications are therefore mainly source processing tools, e.g.\n   compilers and loaders, or programs that need a clean name space\n   to store code and data.\n\n   Note that the created module will by default import the language\n   module eclipse_language.  To create a completely empty\n   module, use the more general predicate create_module/3.  In fact, \n   create_module/1 is defined as\n\n   create_module(Module) :-\n       create_module(Module, [], eclipse_language).\n\n   The system does not allow the atom [] to be used as a module name!\n\nModes and Determinism\n   create_module(+) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom, or Module is the atom [].\n    97 --- Module already exists.\n\nExamples\n   \nSuccess:\n    [eclipse 1]: create_module(m).\n    yes.\n    [eclipse 2]: export(data/1)@m.\n    yes.\n    [eclipse 3]: compile_term(data(99))@m.\n    yes.\n    [eclipse 4]: m:data(X).\n\n    X = 99\n    yes.\n    [eclipse 5]: erase_module(m).\n    yes.\n\nError:\n    create_module(M).    (Error 4).\n    create_module(1).    (Error 5).\n    create_module(m), create_module(m). (Error 97).\n\nSee Also\n   module / 1, create_module / 3, erase_module / 1, get_module_info / 3, current_module / 1"},"current_module/1":{"prefix":"current_module","body":"current_module(${1:Module})$2\n$0","description":"current_module(?Module)\n\n   Succeeds if Module is an existing module.\n\nArguments\n   Module    Atom or variable.\n\nType\n   Modules\n\nDescription\n   current_module/1 checks if there exists a module of a given name, or\n   finds on backtracking the names of all the existing modules.  A module\n   exists in the system iff it has been compiled or explicitely created.\n\nModes and Determinism\n   current_module(-) is nondet\n   current_module(+) is semidet\n\nFail Conditions\n   Fails if Module does not unify with an existing module\n\nExceptions\n     5 --- Module is instantiated, but not to an atom.\n\nExamples\n   \nSuccess:\n\n    [eclipse]: current_module(M).\n    M = eclipse     More? (;)\n    M = sepia_kernel     More? (;)\n    M = eclipse_language     More? (;)\n    M = lists     More? (;)\n    M = profile     More? (;)\n    M = suspend     More? (;)    % type <cr>\n    yes.\nFail:\n    current_module(not_a_module).\nError:\n    current_module(\"eclipse\").    (Error 5).\n\nSee Also\n   create_module / 1, create_module / 3, erase_module / 1, module / 1, get_module_info / 3"},"erase_module/1":{"prefix":"erase_module","body":"erase_module(${1:Module})$2\n$0","description":"erase_module(+Module)\n\n   Erase the given module Module.  \n\nArguments\n   Module    Atom.\n\nType\n   Modules\n\nDescription\n    erase_module/1 erases the given module.  This means that the module\n    will not exists any more.  All predicates and data (non-logical variables,\n    records, etc) defined in the module will be destroyed.  Subsequent calls\n    to the module's exported predicates will raise 'undefined procedure'\n    errors.\n\n    If the Module does not exist, erase_module/1 simply succeeds.\n\n    An error (101) is raised when trying to erase a module from within itself.\n\n    Note that a module gets erased (and re-created) implicitly when the\n    compiler encounters a module/1 directive and that module already exists.\n\nModes and Determinism\n   erase_module(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom.\n   101 --- Trying to erase Module from itself.\n\nExamples\n   \nSuccess:\n[eclipse]:  [user].\n :- module(m).\n :- export a/0.\n a :- writeln(hello).\n user    compiled 60 bytes in 0.00 seconds\nyes.\n[eclipse]: import a/0 from m.\nyes.\n[eclipse]: a.\nhello\nyes.\n[eclipse]: erase_module(m).\nyes.\n[eclipse]: a.\ncalling an undefined procedure a in module eclipse\n\nError:\n    erase_module(M).    (Error 4).\n    erase_module(1).    (Error 5).\n    erase_module(mod)@mod.    (Error 101).\n\nSee Also\n   module / 1, create_module / 1, create_module / 3, current_module / 1, get_module_info / 3"},"get_module_info/3":{"prefix":"get_module_info","body":"get_module_info(${1:Module}, ${2:What}, ${3:Info})$4\n$0","description":"get_module_info(+Module, ?What, -Info)\n\n   Retrieves information about a loaded module.\n\nArguments\n   Module    Atom.\n   What    An atom.\n   Info    A variable.\n\nType\n   Modules\n\nDescription\n   This utility can retrieve information about any module that is currently\n   loaded into the system. The information that can be requested is:\n\nraw_interface (list of export/1 and reexport/1)\n\tthis returns a list of all the export and reexport directives that\n\toccurred in the definition of the module and thus comprise the module's\n\tinterface.\ninterface (list of export/1)\n\tLike raw_interface, but all reexports are replaced by the\n\tactual exports which result from them.\nimports (list of modules)\n\ta list of the modules that have been imported as a whole.\nlocked (on/off)\n\tindicates whether the module is locked or unlocked.\n\nModes and Determinism\n   get_module_info(+, -, -) is nondet\n   get_module_info(+, +, -) is semidet\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom.\n    80 --- Module is not a loaded module.\n\nExamples\n   \n[eclipse 1]: get_module_info(lists, X,Y).\n\nX = raw_interface\nY = [export maplist / 3, export checklist / 2, ...]\n\nX = interface\nY = [export reverse / 2, export subtract / 3, ...]\n\nX = imports\nY = [eclipse_language]     More? (;) \n\nX = locked\nY = off\nyes.\n\nSee Also\n   import / 1, export / 1, reexport / 1, document : icompile / 1, document : icompile / 2, lock / 0, lock_pass / 1, unlock / 2"},"lock/0":{"prefix":"lock","body":"lock","description":"lock\n\n   Locks access to internals of the current module\n\nType\n   Modules\n\nDescription\n    Used to forbid access from outside the current module to its internals,\n    except through the module interface (i.e. its exports).\n\n    This primitive is usually used a directive in the source code of the\n    module to be locked.\n\n    A module locked with lock/0 cannot be unlocked.  Repeated locking\n    (from within the module) is silently accepted.\n\nModes and Determinism\n   lock is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % After compiling the following code:\n     :- module(m).\n     :- export pub/0.\n     pub :- writeln(pub).\n     priv :- writeln(priv).\n     :- lock.\n\n    ?- module(m).\n    trying to access a locked module in module(m)\n\n    ?- call(pub) @ m.\n    pub\n    yes.\n\n    ?- call(priv) @ m.\n    trying to access a locked module in priv\n\n    ?- assert(foo) @ m.\n    trying to access a locked module in assert_(foo, m)\n\nSee Also\n   lock_pass / 1, unlock / 2, get_module_info / 3"},"local/1":{"prefix":"local","body":"local","description":"local +SpecList\n\n   Declare all items specified by SpecList as local to the caller module.\n\nArguments\n   SpecList    One or a comma-separated sequence of valid local specifications\n\nType\n   Modules\n\nDescription\n\n    This declaration is used to declare the visibility of procedures\n    and other items as local to the caller module.  SpecList is a\n    comma-separated sequence of one or more items of the following form:\n\nName/Arity\n    procedure specification\n\ndomain(Spec)\n\tdomain declaration\n\nstruct(Prototype)\n\tstructure declaration\n\nvariable(Name)\n\tnon-logical variable declaration\n\nvariable(Name,InitialValue)\n\tnon-logical variable declaration with initial value\n\nreference(Name)\n\treference declaration\n\nreference(Name,InitialValue)\n\treference declaration with initial value (ground term)\n\narray(Name)\n\tuntyped non-logical array declaration\n\narray(Name,Type)\n\ttyped non-logical array declaration\n\nrecord(Name)\n\trecord key declaration\n\nshelf(Name,InitialValue)\n\tshelf name declaration with initial value\n\nstore(Name)\n\tstore name declaration\n\nop(Prec,Assoc,Name)\n\toperator declaration\n\nchtab(Char,Class)\n\tcharacter class declaration\n\nsyntax_option(Option)\n\tsyntax option setting\n\nmacro(Functor,Transformation,Options)\n\tmacro (input transformation) declaration\n\nportray(Functor,Transformation,Options)\n\tportray (output transformation) declaration\n\ninitialization(Goal)\n\tgoal to be executed just after the module has been loaded\n\nfinalization(Goal)\n\tgoal to be executed just before the module is erased (whether\n\texplicitly, or implicitly during recompilation or exiting ECLiPSe)\n\n   The effect of the local-declaration is that the declared items are\n   only visible inside the module where they have been declared.\n\n   Local Procedures\n\n   For procedures, the local-declaration is normally redundant because\n   local visibility is the default.  However, it might be necessary to\n   explicitly declare a procedure as local to resolve a name conflict\n   when an imported module exports a procedure of the same name.\n\n   Local declarations should be placed at the beginning of a module text.\n   They must occur before the first reference to the declared prodecure:\n\n   A procedure can have four kinds of visibility in a given module:\n   local, exported, imported or reexported.  A local-declaration is\n   silently ignored if the procedure has already been exported before.\n   If a procedure of the given name has already been imported or\n   reexported, the local-declaration raises an error 94.\n   If there is one or more imported modules which export a procedure of\n   the same name, these all get hidden silently by the local declaration.\n\n   A local procedure can only be called from within the module where it is\n   defined, even when explicit module qualification via :/2 is used.\n\n   Local Initialization and Finalization\n\n   The local initialization declaration is used to specify an initialization\n   goal. All initialization goals which occur within a compilation unit\n   (file or module), will be executed just after this compilation unit\n   has been loaded by the system.\n\n   A finalization goal will be executed just before the module containing\n   the declaration gets erased. This can happen either explicitly through\n   erase_module/1, or implicitly when the module gets recompiled or when\n   ECLiPSe exits. Finalisation goals should not do any I/O because in the\n   case of an embedded ECLiPSe, I/O may no longer be available at\n   finalisation time.\n\n   Other Local Items\n\n   All other local declarations also have an effect only in the module\n   where they occur.  Some of them have corresponding export-variants.\n\n   Further Hints\n\n   The local/1 primitive can not only occur as a directive but can also\n   be called at runtime.\n\n   Duplicate local declarations are accepted silently.\n\nModes and Determinism\n   local(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but not to a sequence of valid local specifications.\n    94 --- SpecList is already imported.\n\nExamples\n   \n% Normally, local declarations for predicates are redundant:\n  :- module(m).\n\n  :- local p/1.    % can be omitted since the default is local\n  p(99).\n\n% Redefining a built-in predicate:\n\n    :- module(m)\n    :- local writeln/1.   % stop writeln/1 from being imported\n\n    main :-\n       writeln(hello).    % local-declaration must be before this use!\n\n    writeln(X) :-    % the local version\n       printf(\"I don't like the normal writeln/1 predicate: %w%n\",[X]).\n\n% Redefining an imported predicate:\n\n    :- module(m)\n    :- lib(lists).    % module 'lists' defines a predicate subtract/3\n    :- local subtract/3.  % stop subtract/3 being imported from 'lists'\n\n    decr(N, N1) :-\n       subtract(N,1,N1).  % local-declaration must be before this use!\n\n    subtract(X,Y,Z) :-    % the local version of subtract/3\n       Z is X-Y.\n\n% Other local declarations:\n\n   :- local\n   \top(500, xfx, before),\n\tstruct(book(author,title,publisher)).\n\n   :- local initialization(writeln(\"I am being initialized!\")).\n\n% Error cases:\n\n  :- local P.    (Error 4).\n  :- local p/a.    (Error 5).\n  :- (import p/0 from m), local(p/0)    (Error 94).\n\nSee Also\n   export / 1, reexport / 1, import / 1, module / 1, array / 1, array / 2, domain / 1, macro / 3, op / 3, portray / 3, reference / 1, reference / 2, set_flag / 2, store / 1, struct / 1, variable / 1, variable / 2"},"export/1":{"prefix":"export","body":"export","description":"export ++SpecList\n\n   Exports from the caller module all items specified by SpecList.\n\nArguments\n   SpecList    One or a comma-separated sequence of valid export specifications\n\nType\n   Modules\n\nDescription\n    To make definitions from one module accessible in others, they\n    have to be exported.  The following type of items can occur in\n    SpecList and can thus be exported:\n\nName/Arity\n    procedure  specification\n\ndomain(Spec)\n\tdomain declaration\n\nstruct(Prototype)\n\tstructure declaration\n\nop(Prec,Assoc,Name)\n\toperator declaration\n\nchtab(Char,Class)\n\tcharacter class declaration\n\nsyntax_option(Option)\n\tsyntax option setting\n\nmacro(Functor,Transformation,Options)\n\tmacro (input transformation) declaration\n\nportray(Functor,Transformation,Options)\n\tportray (output transformation) declaration\n\ninitialization(Goal)\n\tinitialization goal specification\n\n    SpecList is a comma-separated sequence of one or more of such items.\n    The export/1 primitive usually occurs as a directive in compiled\n    module files. It can occur anywhere in the file.\n\n   Exporting Procedures\n\n   A procedure can be (and usually is) declared as exported before it\n   is actually defined.  Export declarations should occur either at the\n   beginning of a module text, or just before the procedure definition,\n   e.g\n\n       :- export double/2.\n       double(X, Y) :-\n\t   Y is 2*X.\n\n   You can only export procedures that are defined in the exporting\n   module.  Imported procedures cannot be exported with export/1 (it\n   raises error 94) - use reexport/1 to do this.\n\n   Declaring a procedure as exported will make it accessible to other modules.\n   That means that it can either be called with explicit module qualification\n   using :/2, or it can be imported and thus made visible elsewhere.\n\n   Procedures can be imported and calls to them compiled before they have\n   been exported, e.g. when an importing module is compiled before the\n   exporting module.  This mechanism should be used only in exceptional\n   situations, normally the exporting module should be compiled first. \n   The reason is that the compiler needs some information about the\n   predicate when compiling a call to it. If this information is not\n   available at call time, an incompatibility may occur later when the\n   exported definition is encountered.\n\n   Exporting Other Declarations\n\n   Exported structure, operator, syntax, macro and portray\n   declarations have the same effect as the corresponding local\n   declarations in the module where they occur.  In addition, they are\n   available in every module where they are imported.\n\n   Exporting Initializations\n\n   The exported initialization directive does not have any effect in\n   the exporting module, but only in the module where it is\n   imported.  The initialization goal is called once in the context of\n   every importing module.\n\n   Further Hints\n\n   All the export (and reexport) directives of a module together form\n   what is called the module's interface. The module interface\n   can be extracted from a module source file using the icompile/2\n   utility from library(document). The interface can also be retrieved\n   from a loaded module by calling get_module_info/3.\n\n   Exporting the same item twice, or exporting something that has\n   previously been declared local, is accepted silently.\n\n   The following primitives implicitly export items:  The module/3\n   directive and the create_module/3 predicate export the list of\n   items given in their second argument.  The tool/2 declaration\n   implicitly exports the tool body predicate.  Event handlers, error\n   handlers and interrupt handlers are implicitly exported by the\n   corresponding set_xxx_handler primitive.\n\n   The export/1 primitive can not only occur as a directive but can also\n   be called at runtime.\n\nModes and Determinism\n   export(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList contains an invalid specification.\n    94 --- SpecList is already imported.\n\nExamples\n   \n% A module that exports a predicate and an operator:\n\n    :- module(m1).\n\n    :- export\n    \tbefore/2,\n\top(700, xfx, before).\n\n    A before B :-\n    \tA < B.\n\n% Using this module elsewhere:\n\n    :- module(m2).\n\n    :- import m1.    % or :- use_module(\".../m1...\").\n\n    main :-\n    \t3 before 7.  % operator and procedure definition are visible!\n\n% Using before/2 without import, via explicit qualification:\n% We can call before/2, but we cannot use the infix syntax!\n\n    :- module(m3).\n\n    main :-\n    \tm1:before(3,7).\n\n% Error cases:\n\n  :- export Q.    (Error 4).\n  :- export p/a.    (Error 5).\n  :- import p/1 from m.\n  :- export p/1.    (Error 94).\n\nSee Also\n   import / 1, reexport / 1, local / 1, use_module / 1, module / 1, : / 2, get_module_info / 3, document : icompile / 1, document : icompile / 2, domain / 1, macro / 3, op / 3, portray / 3, struct / 1"},"module/1":{"prefix":"module","body":"module(${1:Module})$2\n$0","description":"module(+Module)\n\n   Begin of the definition of module Module.\n\nArguments\n   Module    Atom.\n\nType\n   Modules\n\nDescription\n   This is a directive that can occur only in a compiled file.  If Module\n   is an existing module, it is first erased.  Then a new module is created\n   and all subsequent definitions, declarations and directives are taken\n   in the context of that new module.\n\n   The new module implicitly imports the module eclipse_language,\n   which means that all ECLiPSe built-ins are visible there.\n\n   module(m) is equivalent to module(m,[],eclipse_language).\n\n   Note that module/1 is not a predicate, it can only occur as a\n   directive in a compiled file.  However, the console based ECLiPSe\n   toplevel also interprets module/1 commands, but in the following\n   way:  when the module already exists, the toplevel-module (i.e. \n   the context in which toplevel queries are interpreted) is changed\n   to this module.  When the module does not exist, it gets created\n   and a warning is issued.\n\n   The system does not allow the atom [] to be used as a module name!\n\nModes and Determinism\n   module(+) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom, or Module is the atom [].\n    68 --- When called from Prolog.\n    82 --- Module is locked.\n\nExamples\n   \n% A very small module:\n     :- module(m).\n     :- export hello/0.\n     hello :- writeln(\"Welcome to module m!\").\n\nSee Also\n   module / 1, module / 3, create_module / 1, create_module / 3, erase_module / 1, current_module / 1, export / 1"},"module/3":{"prefix":"module","body":"module(${1:Module}, ${2:Exports}, ${3:Language})$4\n$0","description":"module(+Module, ++Exports, ++Language)\n\n   Begin the definition of module Module, define some of its exports and the language it is written in.\n\nArguments\n   Module    Atom.\n   Exports    A list of export specifications.\n   Language    An atom or a list of atoms.\n\nType\n   Modules\n\nDescription\n   This is a directive that can occur only in a compiled file.  If Module\n   is an existing module, it is first erased.  Then a new module is created\n   and all subsequent definitions, declarations and directives are taken\n   in the context of that new module.\n\n   The list Exports must contain valid export specifications as\n   described in export/1.  It defines the first part of the module's\n   interface, subsequent export and reexport directives can add to that.\n\n   Unlike with module/1, the new module does not implicitly import anything.\n   In particular, no built-in predicates are available inside the module\n   unless a language-module is specified in the Language argument.\n   This module (or a list of them) is imported just after the new module\n   is created.\n\n   The main use of this feature is to write different parts of a program\n   in different language dialects. For example, a module that contains code\n   written in ISO-Prolog should be encapsulated in a module starting with:\n\n\t:- module(mymodule, [], iso).\n\n   In this module, ISO language features can be used, but not (all)\n   Eclipse features.\n\n   The system does not allow the atom [] to be used as a module name!\n   If [] is given as the Language argument, it indicates the empty list,\n   rather than a module with name [].\n\nModes and Determinism\n   module(+, ++, ++) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom, or Module is the atom [].\n    68 --- When called from Prolog.\n    82 --- Module is locked.\n\nExamples\n   \n% A module in C-Prolog syntax:\n\n     :- module(m, [p/1], cprolog).\n\n     p(\"this is a list not a string\").\n\nSee Also\n   module / 1, create_module / 1, create_module / 3, erase_module / 1, current_module / 1, export / 1"},"lock_pass/1":{"prefix":"lock_pass","body":"lock_pass(","description":"lock_pass(+)\n\n   Locks access to internals of the current module\n\nType\n   Modules\n\nDescription\n    Used to forbid access from outside the current module to its internals,\n    except through the module interface (i.e. its exports).\n\n    This primitive is usually used a directive in the source code of the\n    module to be locked.\n\n    A module locked with lock_pass/1 can be unlocked using unlock/2, and\n    giving the same pass-string that was used in locking.  The pass-string\n    can be changed by calling lock_pass/1 again from within the module.\n\nModes and Determinism\n   lock_pass(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % After compiling the following code:\n     :- module(m).\n     :- export pub/0.\n     pub :- writeln(pub).\n     priv :- writeln(priv).\n     :- lock_pass(\"secret\").\n\n    ?- module(m).\n    trying to access a locked module in module(m)\n\n    ?- call(pub) @ m.\n    pub\n    yes.\n\n    ?- call(priv) @ m.\n    trying to access a locked module in priv\n\n    ?- assert(foo) @ m.\n    trying to access a locked module in assert_(foo, m)\n\n    ?- unlock(m, \"secret\").\n    yes.\n\n    ?- call(priv) @ m.\n    priv\n    yes.\n\n    ?- assert(foo) @ m.\n    yes.\n\nSee Also\n   lock / 0, unlock / 2, get_module_info / 3"},"tool/2":{"prefix":"tool","body":"tool(${1:PredSpecI}, ${2:PredSpecB})$3\n$0","description":"tool(++PredSpecI, ++PredSpecB)\n\n   Declares PredSpecI as a tool interface procedure and PredSpecB as its body\nprocedure.\n\nArguments\n   PredSpecI    Expression of the form Atom/Integer.\n   PredSpecB    Expression of the form Atom/Integer.\n\nType\n   Modules\n\nDescription\n   It defines PredSpecI as a tool interface procedure in the caller module\n   and declares PredSpecB as its body procedure.  The arity of PredSpecB\n   must be one higher than the arity of PredSpecI, otherwise an exception\n   is raised.  This is because when PredSpecI is called, the system puts\n   the name of the caller module in the additional argument and calls\n   PredSpecB.\n\n   The default visibility for the interface procedure is local.\n   The body procedure gets exported implicitly.\n\n   The tool/2 declaration can be used before the body procedure is defined.\n\n   If PredSpecI already exists and if the system has already compiled some\n   calls to it, tool/2 gives error 62 (``inconsistent procedure\n   redefinition'') since the system cannot provide the caller's home module\n   for calls which are already compiled.\n\n   Therefore, the tool/2 declaration should be always textually precede the\n   first call to enable to compiler to compile the call correctly.\n\nModes and Determinism\n   tool(++, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either PredSpecI or PredSpecB is not instantiated.\n     5 --- Either PredSpecI or PredSpecB is instantiated, but not to an    expression of the form Atom/Integer.\n     6 --- The arity of PredSpecB is not one greater than that of    PredSpecI.\n    62 --- A call to PredSpec has already been compiled before the    tool declaration (``inconsistent procedure redefinition'').\n\nExamples\n   \n% A typical meta-predicate, wrong and right way:\n\n    [eclipse 1]: [user].\n\t:- module(m1).\n\t:- export twice/1.\n\ttwice(P):-\n\t    call(P),\n\t    call(P).\n    yes.\n\n    [eclipse 2]: [user].\n     p(1).\n    yes.\n\n    [eclipse 3]: import twice/1 from m1.\n    yes.\n\n    [eclipse 4]: twice(p(X)).\n    calling an undefined procedure p(X) in module m1\n    yes.\n\n    [eclipse 5]: [user].\n\t:- module(m1).\n\t:- export twice/1.\n\t:- tool(twice/1,twice_body/2).\n\ttwice_body(P,M):-\n\t    call(P)@M,\n\t    call(P)@M.\n    yes.\n\n    [eclipse 6]: twice(p(X)).\n    X = 1\n    yes.\n\n% define a predicate that prints its caller module:\n\n    [eclipse]: tool(where_am_i/0, writeln/1).\n    yes.\n\n    [eclipse]: where_am_i.\n    eclipse\n    yes.\n\n% Error:\n     tool(L, tb/1).    (Error 4).\n     tool(ti/0, L).    (Error 4).\n     tool(ti, tb/1).    (Error 5).\n     tool(ti/0, tb).    (Error 5).\n     tool(ti/0, tb/2).    (Error 6).\n\n     [eclipse]: [user].\n      p :- ti. % call compiled before tool declaration\n      user    compiled 32 bytes in 0.02 seconds\n     yes.\n     [eclipse]: tool(ti/0, tb/1).     (Error 62).\n\nSee Also\n   tool_body / 3, @ / 2"},"reexport/1":{"prefix":"reexport","body":"reexport","description":"reexport +Module\nreexport +SpecList from +Module\nreexport +Module except +SpecList\n\n   Reexports a module's interface or a subset of it.\n\nArguments\n   Module    Atom.\n   SpecList    One or a comma-separated sequence of valid export specifications\n\nType\n   Modules\n\nDescription\n    A reexport is conceptually an import combined with an export.  That\n    means that a reexported definition becomes visible inside the\n    reexporting module and is at the same time exported again.  A user\n    of a module's interface sees virtually no difference between\n    exported and reexported definitions.  Reexporting is a flexible\n    way to create tailored module interfaces, e.g. extend the interface\n    of an existing module, restrict it, combine features from several\n    modules, or create specific modifications of existing modules.\n\n    The reexport declaration comes in three flavours. To reexport the\n    complete interface of another module, use\n\n\t:- reexport amodule.\n\n    However, often it is desirable or necessary to restrict the set of\n    reexported items.  This can be done in two ways, either by\n    explicitly listing the items to reexport, e.g.\n\n\t:- reexport useful/3, good/1 from amodule.\n\n    or else by listing the exception that should not be reexported, e.g.\n\n\t:- reexport amodule except useless/3, unwanted/1.\n\n   SpecList can contain any valid export specification, i.e.\n\nName/Arity\n    procedure  specification\n\ndomain(Spec)\n\tdomain declaration\n\nstruct(Prototype)\n\tstructure declaration\n\nop(Prec,Assoc,Name)\n\toperator declaration\n\nchtab(Char,Class)\n\tcharacter class declaration\n\nsyntax_option(Option)\n\tsyntax option setting\n\nmacro(Functor,Transformation,Options)\n\tmacro (input transformation) declaration\n\nportray(Functor,Transformation,Options)\n\tportray (output transformation) declaration\n\ninitialization(Goal)\n\tinitialization goal specification\n\n    Procedure specifications must be fully instantiated with name and\n    arity. All other specifications may contain anonymous variables\n    which serve as wildcards when matching the exports.  For example,\n    to reexport all operator declarations of another module use\n\n\t:- reexport op(_,_,_) from amodule.\n\n    To reexport only the operator declaration for the operator 'before',\n    whatever it is defined to, use\n\n\t:- reexport op(_,_,before) from amodule.\n\n    or to prevent a macro declaration for internal/3 from being reexported, use\n\n\t:- reexport amodule except macro(internal/3,_,_).\n\n   When explicitly reexporting procedures, it is required that they are\n   actually exported from the other module. In all other cases, the items\n   listed in SpecList do not have to correspond to actually exported items\n   in the other module.\n\n   Reexported procedures are made accessible to other modules in the\n   same way as exported ones.  That means they can either be called by\n   explicitly qualifying them with the name of the reexporting module\n   (using :/2), or they can be imported from the reexporting module\n   and thus made visible elsewhere.\n\n   All the export (and reexport) directive of a module together form\n   what is called the module's interface. The module interface\n   can be extracted from a module source file using the icompile/2\n   utility from library(document). The interface can also be retrieved\n   from a loaded module by calling get_module_info/3.\n\n   Rexporting the same item twice, or reexporting something that has\n   previously been declared imported, is accepted silently.\n\n   Reexporting is not compatible with a local definition of the same\n   name (because reexport always implies an import as well), it raises\n   error 92.\n\n   The reexport/1 primitive can not only occur as a directive but can also\n   be called at runtime.\n\nModes and Determinism\n   reexport(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList or Module is insufficiently instantiated.\n     5 --- Module is not an atom.\n     5 --- SpecList contains an invalid specification.\n    92 --- One of the reexported procedures has the same name as a local procedure.\n\nExamples\n   \n% A module that is like m1 but adds something extra:\n\n    :- module(m).\n    :- reexport m1.\n    :- export extra/1.\n    extra(99).\n\n% A module that makes a subset of m1 available:\n\n    :- module(m).\n    :- reexport m1 except useless/3, unwanted/1.\n\n% A module that combines m1 and m2:\n\n    :- module(m).\n    :- reexport m1 except also_in_m2/2.\n    :- reexport m2.\n\n% A module that modifies m1:\n\n    :- module(m).\n    :- reexport m1 except different/1.\n    :- export different/1.\n    different(better).\n\n% Error cases:\n\n  :- reexport Q.    (Error 4).\n  :- reexport p/a.    (Error 5).\n\n  :- local p/1.\n  :- export p/1.    (Error 92).\n\nSee Also\n   import / 1, export / 1, local / 1, use_module / 1, module / 1, : / 2, get_module_info / 3, document : icompile / 1, document : icompile / 2, domain / 1, macro / 3, op / 3, portray / 3, struct / 1"},"tool_body/3":{"prefix":"tool_body","body":"tool_body(${1:PredSpecI}, ${2:PredSpecB}, ${3:Module})$4\n$0","description":"tool_body(++PredSpecI, -PredSpecB, -Module)\n\n   Succeeds if PredSpecI is a tool interface procedure, PredSpecB is its body\nprocedure, and Module the module where it is defined.\n\nArguments\n   PredSpecI    Expression of the form Atom/Integer.\n   PredSpecB    Expression of the form Atom/Integer.\n   Module    Atom or variable.\n\nType\n   Modules\n\nDescription\n   To a given tool interface procedure it finds the corresponding body\n   procedure and the module where it is defined.\n\nModes and Determinism\n   tool_body(++, -, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- PredSpecI is not instantiated.\n     5 --- Either PredSpecI or PredSpecB is instantiated, but not to    the form Atom/Integer.\n    91 --- PredSpecI is not a tool interface procedure.\n\nExamples\n   \nSuccess:\n      [eclipse]: tool_body(write/1, P, M), (import P from M).\n      P = write_ / 2    % find the body\n      M = sepia_kernel    %   procedure and\n      yes.    %   import it\n\nFail:\n      tool_body(write/1, true/0, M).\n\nError:\n      tool_body(L, P, M).    (Error 4).\n      tool_body(\"current_functor/1\", P, M). (Error 5).\n      tool_body(current_functor/1, P, M).   (Error 91).\n\nSee Also\n   tool / 2"},"unlock/2":{"prefix":"unlock","body":"unlock(${1:Module}, ${2:Password})$3\n$0","description":"unlock(+Module, +Password)\n\n   Unlocks the access to the module Module, if the password given in Password\nis correct\n\nArguments\n   Module    Atom.\n   Password    String.\n\nType\n   Modules\n\nDescription\n   unlock(Module, Password) unlock a module previously locked with\n   lock_pass(Password).  The access to the module is now again possible.\n\n   An error is raised (and the module not unlocked) when trying to unlock a\n   module with a wrong password or when trying to unlock a module locked\n   with lock/0.\n\nModes and Determinism\n   unlock(+, +) is det\n\nExceptions\n     4 --- Module or Password is/are not instantiated.\n     5 --- Module is instantiated, but not to an atom or Password is    instantiated but not to a string.\n    80 --- Module is not a module.\n    82 --- Trying to access a locked module Module\n    98 --- Key not correct\n\nExamples\n   \n    % After compiling the following code:\n     :- module(m).\n     :- export pub/0.\n     pub :- writeln(pub).\n     priv :- writeln(priv).\n     :- lock_pass(\"secret\").\n\n    ?- module(m).\n    trying to access a locked module in module(m)\n\n    ?- call(pub) @ m.\n    pub\n    yes.\n\n    ?- call(priv) @ m.\n    trying to access a locked module in priv\n\n    ?- assert(foo) @ m.\n    trying to access a locked module in assert_(foo, m)\n\n    ?- unlock(m, \"pass\").\n    key not correct in unlock(m, \"pass\")\n\n    ?- unlock(m, \"secret\").\n    yes.\n\n    ?- call(priv) @ m.\n    priv\n    yes.\n\n    ?- assert(foo) @ m.\n    yes.\n\nSee Also\n   lock / 0, lock_pass / 1, get_module_info / 3"},"modules_desc":{"prefix":"lib","body":"lib(${1:modules})$2\n$0","description":"lib(modules)\n\nSee also the User Manual chapter about the module system."},"use_module/1":{"prefix":"use_module","body":"use_module(${1:ModuleFile})$2\n$0","description":"use_module(++ModuleFile)\n\n   Load and import the module from the given ModuleFile.\n\nArguments\n   ModuleFile    Atom, String, compound term library(Name), or a list of such.\n\nType\n   Modules\n\nDescription\n   This is a combination of ensure_loaded/1 and import/1, i.e. it\n   loads a module file and imports everything the module exports.\n\n   ModuleFile is a module name, a source file name, a library\n   specification (e.g. library(util)) or a list of such items. \n   First, ModuleFile is converted to a file name and that file is\n   loaded, compiled or recompiled as with ensure_loaded/1.\n   Then, a module name is extracted from the base name of ModuleFile\n   (the loading is expected to create that module, i.e. the file is\n   expected to follow the naming convention for module files).\n   That module is then imported as with import/1.\n\n   The rules for finding the source file from the ModuleFile specification\n   are the same as for ensure_loaded/1 and compile/1, i.e. object or\n   source file suffixes are appended, and the library path is searched\n   if the name is specified as library(FileName).\n\nModes and Determinism\n   use_module(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is instantiated, but not to an atom.\n    80 --- Module is not defined in the compiled file.\n   171 --- The file does not exist or is not readable.\n\nExamples\n   \nSuccess:\n    :- use_module(library(util)).\n    :- use_module(\"/usr/local/eclipse/lib/util\").\n    :- use_module(util).\n    :- use_module(\"util.pl\").\n\nError:\n    :- use_module(M).    (Error 4).\n    :- use_module(file(f)).    (Error 5).\n\nSee Also\n   module / 1, module / 3, compile / 1, ensure_loaded / 1, import / 1, lib / 1, existing_file / 4"},"argv/2":{"prefix":"argv","body":"argv(${1:N}, ${2:Argument})$3\n$0","description":"argv(+N, -Argument)\n\n   Succeeds if the Nth argument given on the command line when invoking\nECLiPSe is the string Argument.\n\nArguments\n   N    Integer or the atom all.\n   Argument    String, List or variable.\n\nType\n   Operating System\n\nDescription\n   Used to find any argument used when invoking ECLiPSe at the operating\n   system prompt.  The zero'th argument is the name of the eclipse binary.\n   When N is the atom all, then a list of all arguments is returned instead\n   of a single argument.  When the command line contains the special\n   argument --, then all arguments before and including that one are\n   suppressed.\n\nModes and Determinism\n   argv(+, -) is det\n\nExceptions\n     4 --- N is not instantiated.\n     5 --- N is not an integer or an atom.\n     6 --- N is an atom different from all.\n     6 --- There was not N arguments when calling ECLiPSe .\n\nExamples\n   \nSuccess:\n   % eclipse hello world\n   [eclipse]: argv(0,A0), argv(1,A1), argv(2,A2).\n   A0 = \"/usr/local/eclipse/bin/sun4/eclipse.exe\"\n   A1 = \"hello\"\n   A2 = \"world\"\n   yes.\n   [eclipse]: argv(all, [_A0|Args]).\n   Args = [\"hello\", \"world\"]\n   yes.\n   % eclipse -e \"argv(all,[_|A]),writeq(A),nl\" -- hello world\n   [\"hello\", \"world\"]\nError:\n   argv(N,A).    (Error 4).\n   argv(1.0,A).    (Error 5).\n   argv(-1,A).    (Error 6).\n\nSee Also\n   argc / 1"},"argc/1":{"prefix":"argc","body":"argc(${1:Number})$2\n$0","description":"argc(-Number)\n\n   Succeeds if Number is the number of arguments given on the command line to\ninvoke ECLiPSe .\n\nArguments\n   Number    Variable or integer.\n\nType\n   Operating System\n\nDescription\n   Used to find the number of arguments used when invoking ECLiPSe at the\n   operating system prompt, including eclipse itself.\n\nModes and Determinism\n   argc(-) is det\n\nExceptions\n     5 --- Number is instantiated, but not to an integer.\n\nExamples\n   \nSuccess:\n   % eclipse -g 10000\n   [eclipse]: argc(N).\n   N = 3\n   yes.\n\nFail:\n   % eclipse -g 10000\n   [eclipse]: argc(2).\n   no.\n\nError:\n   argc('3').    (Error 5).\n\nSee Also\n   argv / 2"},"alarm/1":{"prefix":"alarm","body":"alarm(${1:Clock})$2\n$0","description":"alarm(+Clock)\n\n   The operating system will send the signal 14 to the ECLiPSe system Clock\nseconds after the command was entered.\n\nArguments\n   Clock    Integer\n\nType\n   Operating System\n\nDescription\n   Used to send the signal 14 (SIGALRM) to the ECLiPSe system Clock seconds\n   after the alarm/1 command is entered.  If there is already a pending\n   alarm, its clock is merely reset, i.e.  there cannot be multiple alarm\n   requests.\n\n   If Clock is 0, any pending alarm is cancelled.  If Clock is negative, it\n   is nevertheless interpreted as an unsigned integer.\n\nModes and Determinism\n   alarm(+) is det\n\nExceptions\n     4 --- Clock is not instantiated.\n     5 --- Clock is not an integer.\n\nExamples\n   \nSuccess:\n      [eclipse]: alarm(1).\n      yes.\n      [eclipse]: Signal 14    % 1 second later\n\nError:\n      alarm(I).    (Error 4).\n      alarm(2.0).    (Error 5).\n\nSee Also\n   sleep / 1"},"cd/1":{"prefix":"cd","body":"cd(${1:Directory})$2\n$0","description":"cd(+Directory)\n\n   Directory is made the current working directory.  Equivalent to\nset_flag(cwd, Directory).\n\nArguments\n   Directory    Atom or string of any form acceptable to the operating    system.\n\nType\n   Operating System\n\nDescription\n   Changes the current working directory to Directory.  Directory may be an\n   absolute or relative pathname.\n\nModes and Determinism\n   cd(+) is det\n\nExceptions\n     4 --- Directory is not instantiated.\n     5 --- Directory is neither an atom nor a string.\n   170 --- Directory doesn't exist.\n\nExamples\n   \nSuccess:\n      cd(workdir).\n      cd(\"workdir\").\n      cd('/home/lp/user/workdir').\n      cd('..').\n      cd('../workdir').\n\nError:\n      cd(Dir).    (Error 4).\n      cd(20).    (Error 5).\n      cd('nonexist').    (Error 170).\n\nSee Also\n   getcwd / 1, set_flag / 2"},"canonical_path_name/2":{"prefix":"canonical_path_name","body":"canonical_path_name(${1:Path}, ${2:CanonicalPath})$3\n$0","description":"canonical_path_name(+Path, -CanonicalPath)\n\n   Expand a path name into the full `canonical' form.\n\nArguments\n   Path    A pathname (atom or string)\n   CanonicalPath       Canonical pathname for Path\n\nType\n   Operating System\n\nDescription\n   This predicate expands a given pathname, and converts it into the\n   `canonical' form of the pathname. The following are done to the path:\n\n    An absolute path is returned. If a relative path is supplied, the\n   path is prefixed with the current working directory. On Windows, a\n   drive name is prefixed, if necessary.\n\n    Leading '~' and environment variables (such as '$HOME') are\n   substituted by the appropriate value. If this substitution is not\n   possible (e.g. if the environment variable does not exist), nothing\n   is changed.\n\n    Special sequences such as '.', '..', extra '/' are appropriately\n   removed/replaced. \n\n    The non-aliased path is returned, i.e. any symbolic links are\n   replaced by the non-symbolic linked version of the path.\n   \n    On Windows and Mac OS X, where different cases of letters in\n   path names are allowed but ignored (so e.g. \"foo\" and \"Foo\" are\n   aliases), the `normalised' version of the name, using the letter\n   cases when each file/directory was created, is returned\n   (not supported in older versions of Windows before 2000).\n\n    If the path denotes an existing directory, the canonical path\n   is terminated with a '/'.\n\n   Not all components of Path need to exist.  The removal of aliasing\n   is performed only on the part of the path that does exist.\n\n   The type of the returned CanonicalPath is the same as the type of\n   Path (string or atom).  If Path is empty, it is replaced by the\n   current working directory. \n\n    The predicates canonical_path_name/2 and existing_file/4 are intended\n    as replacement for absolute_file_name/2 in previous releases. The\n    functionality of completing an incomplete name and returning an\n    absolute path of absolute_file_name/2 has been separated. The following\n    approximately implements the old absolute_file_name/2:\n\n    absolute_file_name(Rel, Abs) :-\n\t(Rel == user ->\n\t    Abs == user  % treat user specially\n\t; get_flag(prolog_suffix, Sufs),\n\t  (existing_file(Rel, Sufs, [], ExtRel) -> true ; ExtRel = Rel),\n\t  canonical_path_name(ExtRel, Abs)\n    ).\n\nModes and Determinism\n   canonical_path_name(+, -) is det\n\nExceptions\n     5 --- Path is not a string or atom.\n\nExamples\n    [eclipse]: canonical_path_name(\"file\", Full).  %cwd is /homes/tom\n      Full = \"/homes/tom/file\"\n      yes\n\n      [eclipse]: canonical_path_name(file, Full).\n      Full = '/homes/tom/file'\n      yes\n\n      [eclipse]: canonical_path_name(\"~/file\", Full).\n      Full = \"/homes/tom/file\"\n      yes\n\n      [eclipse]: canonical_path_name('file/..', Full).\n      Full = '/homes/tom/'\n\n      [eclipse]: canonical_path_name('/users/tom', Full). \n      % /users/tom is a symbolic link for /homes/tom\n      Full = '/homes/tom/'\n\nSee Also\n   existing_file / 4, os_file_name / 2, pathname / 4"},"cputime/1":{"prefix":"cputime","body":"cputime(${1:Time})$2\n$0","description":"cputime(-Time)\n\n   Succeeds if Time is the elapsed user cpu time in seconds.\n\nArguments\n   Time    Float number or variable.\n\nType\n   Operating System\n\nDescription\n   Used to find the elapsed user cpu time in seconds, it is equivalent to\n   statistics(times, [Time|_]).\n\n   The cpu time is the `user' time i.e.  the CPU time used while executing\n   instructions in the user space of the calling process.\n\n   Note that the granularity of the system clock is usually 1/60 or 1/50 of\n   a second.  Hence if you use cputime/1 to measure runtimes make sure that\n   the measured intervals are long enough.\n\n   The time given by the ps command gives the sum of `user' time and\n   `system' time, which is the CPU time used by the system on behalf of the\n   calling process.\n\n    Note that (like all predicates that return a number as their last\n    argument), this predicate can be used as a function inside arithmetic\n    expressions.\n\nModes and Determinism\n   cputime(-) is det\n\nExceptions\n     5 --- Time is instantiated, but not to a float.\n\nExamples\n   \nSuccess:\n   [eclipse]: cputime(T).\n   T = 0.0333333\n   yes.\n\nFail:\n      cputime(0.000001).\nError:\n      cputime(2).    (Error 5).\n\nSee Also\n   statistics / 0, statistics / 2, date / 1, get_flag / 2"},"delete/1":{"prefix":"delete","body":"delete(${1:File})$2\n$0","description":"delete(+File)\n\n   The file File (with absolute or relative pathname) is deleted.\n\nArguments\n   File    An atom or a string of a form acceptable to the operating    system.\n\nType\n   Operating System\n\nDescription\n   Used to delete the file or directory File.  File may be an absolute or\n   relative filename.\n\nModes and Determinism\n   delete(+) is det\n\nExceptions\n     4 --- File is not instantiated.\n     5 --- File is neither an atom nor a string.\n   170 --- File does not exist.\n\nExamples\n   \nSuccess:\n      [eclipse]: sh('ls file.pl').\n      file.pl\n      yes.\n      [eclipse]: delete('file.pl').\n      yes.\n      [eclipse]: sh('ls file.pl').\n      file.pl not found\n      yes.\n\nError:\n      delete(File).    (Error 4).\n      delete([file]).    (Error 5).\n      delete(nofile).    (Error 170).\n\nSee Also\n   sh / 1, system / 1, exists / 1, mkdir / 1"},"date/1":{"prefix":"date","body":"date(${1:Date})$2\n$0","description":"date(-Date)\n\n   Date is bound to the string giving the date and time.\n\nArguments\n   Date    Variable or string.\n\nType\n   Operating System\n\nDescription\n   Unifies Date with the current date and time.\n\nModes and Determinism\n   date(-) is det\n\nExceptions\n     5 --- Date is instantiated, but not to a string.\n\nExamples\n   \nSuccess:\n      [eclipse]: date(Date).\n      Date = \"Fri Aug  25 12:00:00 1989\\n\"\n      yes.\n\nFail:\n      date(\"Fri Aug  24 12:00:00 1989\\n\").\n\nError:\n      date(thursday).    (Error 5).\n\nSee Also\n   get_flag / 2, local_time / 8, local_time_string / 3, library(calendar)"},"exec/2":{"prefix":"exec","body":"exec(${1:Command}, ${2:Streams})$3\n$0","description":"exec(++Command, ++Streams)\n\n   A child process Command is forked, its standard streams are connected to\nStreams and the ECLiPSe process waits until it terminates.\n\nArguments\n   Command    String, atom or list of atomic terms.\n   Streams    List of stream ids.\n\nType\n   Operating System\n\nDescription\n   This predicate is used to fork a child process and to set up pipes to\n   its standard streams.  After the process is forked, ECLiPSe blocks, i.e.\n   it waits until the child process terminates.\n\n   Command should be a list with at least one element: The first list element\n   (a path name in ECLiPSe path name syntax, atom or string) specifies the\n   program to be executed, and the subsequent list elements are its arguments.\n   The arguments can be atoms, strings or numbers.  They are passed to the\n   executed program literally (in particular, no path name syntax conversion\n   is applied).\n\n   For backward compatibility, Command can be a simple atom or string, in\n   which case the first word in Command specifies the program to be executed,\n   and the following words are its command-line arguments.\n   This form is deprecated since it creates problems with argument quoting\n   and operating system dependent path name syntax.\n\n   By specifying the Streams argument it is possible to control which of\n   the process' standard streams are connected to ECLiPSe streams.  The\n   form of Streams is [Stdin, Stdout, Stderr].  If some of these streams\n   are specified and not null, a pipe is opened which connects the standard\n   stream of the child process with the specified ECLiPSe stream, e.g.\n   Stdin must be an output stream because it is connected to the standard\n   input of the child process.  If the list Streams is shorter, only the\n   specified streams are connected with a pipe.  The streams can be\n   specified like for open/3.  If the stream is a variable, it is bound to\n   the physical stream number, if it is an atom different from null, that\n   symbolic stream is used.  Specifying a null stream means that no pipe is\n   set up for this stream.\n\n   Each stream can also be specified as sigio(Stream) (UNIX systems only).\n   In this case a pipe is set up to the stream Stream and in addition the\n   pipe is instructed to send the signal io each time new data appears in\n   it.  In this way the two processes can communicate in a truly\n   asynchronous way.  When one process sends data to the other one, the\n   interrupt handler is invoked and it can read and process the data.  When\n   it finishes, it can continue where it was interrupted.\n\n   exec(Command, Streams) is equivalent to\n\n   exec(Command, Streams, Pid), wait(Pid, _)\n\n   exec(Command, []) is very similar to system(Command).\n\nModes and Determinism\n   exec(++, ++) is det\n\nExceptions\n     4 --- Command is not instantiated.\n     5 --- Command is instantiated, but not to a string or an atom.\n     5 --- Streams is instantiated, but not to a list.\n     5 --- A stream in Streams is instantiated, but not to an atom.\n   170 --- System error, it was not possible to fork the child or the    exec system call in the child failed.\n   192 --- The specified stream is not open in the appropriate mode.\n\nExamples\n   \nSuccess:\n      % exec/2 wait for the child process\n      [eclipse]: exec(ls, []), write(end_exec).\n      aux.o    coroutine.pl    kegi.pl    sepia.o\n      bsi.pl    cprolog.pl      lint.pl    sorts.pl\n      cio.pl    history.pl      lists.pl    strings.pl\n      cn.pl    k_env.pl    quintus.pl      t_all.pl\n      end_exec\n      yes.\n\n      % exec/3 return immediately\n      [eclipse]: exec(ls, [], Pid), write(end_exec).\n      end_exec\n      Pid = 16054\n      yes.\n      [eclipse]: aux.o  coroutine.pl    kegi.pl    sepia.o\n      bsi.pl    cprolog.pl      lint.pl    sorts.pl\n      cio.pl    history.pl      lists.pl    strings.pl\n      cn.pl    k_env.pl    quintus.pl      t_all.pl\n\nError:\n      exec(S, [output]).    (Error 4).\n      exec(ls, null).    (Error 5).\n      exec(chipc, [f(output)]).  (Error 5).\n      exec(date, [input]).       (Error 192).\n\nSee Also\n   call_c / 2, exec / 3, exec_group / 3, setenv / 2, wait / 2, kill / 2, sh / 1, system / 1, open / 3"},"errno_id/1":{"prefix":"errno_id","body":"errno_id(${1:Message})$2\n$0","description":"errno_id(-Message)\n\n   Message is bound to the message string that corresponds to most recent\noperating system error that occurred during the execution.\n\nArguments\n   Message    Variable.\n\nType\n   Operating System\n\nDescription\n   This predicate unifies Message with the string that corresponds to the\n   most recent operating system error that occurred during the execution.\n   These messages differ between different operating systems.\n   Operating system interface errors which occur within built-in predicates\n   are normally indicated by the predicate raising event 170\n   \"system interface error\". The event handler then retrieves the\n   error message using errno_id/1. The system remembers the last error\n   message until a new error occurs.\n\nModes and Determinism\n   errno_id(-) is det\n\nExceptions\n     5 --- Message is neither variable nor string.\n\nExamples\n   \n[eclipse 3]: delete(nofile).\nsystem interface error: No such file or directory in delete(nofile)\n\n[eclipse 4]: errno_id(Msg).\nMsg = \"No such file or directory\"\nyes.\n\nSee Also\n   set_event_handler / 2"},"import/1":{"prefix":"import","body":"import","description":"import +Module\nimport +PredSpecs from +Module\n\n   Import a module, or import certain procedures from a module.\n\nArguments\n   Module    Atom.\n   PredSpecs    One or more comma-separated terms of the form Name/Arity\n\nType\n   Modules\n\nDescription\n   Importing is the way to make definitions from another module visible\n   as if they were local definitions. Only items that have been exported\n   from another module can be imported. Imports should usually be done\n   at the beginning of module texts.\n\n   Importing a Module as a Whole\n\n   If the first form of import is used, e.g.\n\n   \t:- import amodule.\n\n   then all of the specified module's interface (i.e. everything that\n   is exported or reexported there) gets imported.\n\n   Note that the module to import must already have been loaded, e.g. \n   via compile/1 or ensure_loaded/1.  To simplify this, you can use\n   use_module/1 which is simply a combination of ensure_loaded/1 and\n   import/1.  If an attempt is make to import a module that does not\n   exist yet, the system tries to create it by trying to load a\n   library of that name. \n\n   Note that procedure imports a treated slightly differently from\n   other (e.g.  structure declaration) imports:  While other imports\n   have an immediate effect (e.g.  making the structure declaration\n   available), procedures are actually imported lazily:  they are only\n   made visible when they are referred to (e.g.  called) subsequently\n   in the importing module.  This has the advantage that import\n   ambiguities (i.e.  the same procedure is exported from multiple\n   imported modules) do not pose any problem as long as the ambiguous\n   procedure is not actually used.  When it is used, however, the\n   system will report the conflict.  The conflict can then either be\n   resolved by using the import ... from ... construct,\n   or it can be avoided by using explicit module qualification via :/2\n   everywhere.\n\n   When a local procedure is defined while a procedure with the same\n   name could be lazily imported from an imported module, the system\n   issues a warning (or even an error in the case of built-ins).  If\n   that was the intention, the warning should be suppressed by using\n   an explicit local-declaration.\n\n   Importing Specific Procedures from a Module\n\n   An example of the second form of the import declaration is\n\n   \t:- import p/3,q/1 from amodule.\n\n   This causes only the specified procedures to be imported from the\n   given module.  Unlike above, this import has an immediate effect,\n   and any attempt to import the same name from elsewhere, or to declare\n   a local procedure of the same name will raise an error 94.\n   Only procedures can be imported using this form of import/1.\n\n   Another difference compared to the first form of import/1 is that\n   the module from which we import does not have to exist yet, and no\n   attempt is made to load the module. This is therefore a way to overcome\n   the otherwise enforced export-before-import rule and it allows a\n   certain degree of circularity in the export-import relationship\n   between modules. However, it is usually considered better programming\n   style to have a strictly hierarchical module structure rather than\n   circular dependencies, and to always build a new module on top of\n   a self-contained set of more basic modules.\n\n   Note that when the compiler compiles a call to an imported procedure\n   whose export is not yet known, it may use the wrong calling convention.\n   This will lead to an incompatibility error later when the export\n   becomes known. Forward declarations like tool/2 and external/1 can\n   sometimes be used to prevent this problem.\n\n   Implicit Imports\n\n   Modules are implicitly imported by the module/3 and create_module/3\n   primitives, which import the modules given in their third argument. \n   Modules created with module/1 or create_module/1 implicitly import\n   the module eclipse_language.\n\nModes and Determinism\n   import(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is instantiated, but not to an atom.\n    80 --- Library file does not define Module.\n   171 --- Library file does not exist.\n    92 --- Conflict with local definition.\n    93 --- Conflict with exported definition.\n    94 --- Conflict with another imported procedure.\n\nExamples\n   \n% A module that exports a predicate and an operator:\n\n    :- module(m1).\n\n    :- export\n    \tbefore/2,\n\top(700, xfx, before).\n\n    A before B :-\n    \tA < B.\n\n% Importing this module elsewhere:\n\n    :- module(m2).\n\n    :- import m1.    % or :- use_module(\".../m1...\").\n\n    main :-\n    \t3 before 7.  % operator and procedure definition are visible!\n\n% Importing a procedure:\n\n    :- module(m3).\n\n    :- import before/2 from m1.\n\n    main :-\n    \tbefore(3,7).  % only procedure definition is visible!\n\n% Error cases:\n\n     :- import L.    (Error 4).\n     :- import 1.    (Error 5).\n     :- import a,b.    (Error 5).\n     :- import op(X,Y,before) from eclipse_language.  (Error 5).\n     :- import xxxx.    (Error 171).\n\n     :- import p/1 from a.\n     :- import p/1 from b.    (Error 94).\n\n     :- export p/1.\n     :- import p/1 from b.    (Error 93).\n\n     p(99).\n     :- import p/1 from b.    (Error 92).\n\nSee Also\n   export / 1, reexport / 1, local / 1, get_module_info / 3, module / 1, create_module / 3"},"exec/3":{"prefix":"exec","body":"exec(${1:Command}, ${2:Streams}, ${3:Pid})$4\n$0","description":"exec(++Command, ++Streams, -Pid)\n\n   A child process Command is forked, its standard streams are connected to\nStreams and its process ID is Pid.\n\nArguments\n   Command    String, atom or list of atomic terms.\n   Streams    List of stream ids.\n   Pid    Integer or a variable.\n\nType\n   Operating System\n\nDescription\n   This predicate is used to fork a child process and to set up pipes\n   to its standard streams.  After the process is forked, ECLiPSe\n   continues normally, without waiting for the child to terminate.\n\n   Command should be a list with at least one element: The first list element\n   (a path name in ECLiPSe path name syntax, atom or string) specifies the\n   program to be executed, and the subsequent list elements are its arguments.\n   The arguments can be atoms, strings or numbers.  They are passed to the\n   executed program literally (in particular, no path name syntax conversion\n   is applied).\n\n   For backward compatibility, Command can be a simple atom or string, in\n   which case the first word in Command specifies the program to be executed,\n   and the following words (separated by blank space) are its command-line\n   arguments.  This form is deprecated since it creates problems with argument\n   quoting and operating system dependent path name syntax.\n\n   By specifying the Streams argument it is possible to control which of\n   the process' standard streams are connected to ECLiPSe streams.  The\n   form of Streams is [Stdin, Stdout, Stderr].  If some of these streams\n   are specified and not null, a pipe is opened which connects the standard\n   stream of the child process with the specified ECLiPSe stream, e.g.\n   Stdin must be an output stream because it is connected to the standard\n   input of the child process.  If the list Streams is shorter, only the\n   specified streams are connected with a pipe.  The streams can be\n   specified like for open/3.  If the stream is a variable, it is bound to\n   the physical stream number, if it is an atom different from null, that\n   symbolic stream is used.  Specifying a null stream means that no pipe is\n   set up for this stream.\n\n   Each stream can also be specified as sigio(Stream) (UNIX systems only).\n   In this case a pipe is set up to the stream Stream and in addition the\n   pipe is instructed to send the signal io each time new data appears in\n   it.  In this way the two processes can communicate in a truly\n   asynchronous way.  When one process sends data to the other one, the\n   interrupt handler is invoked and it can read and process the data.  When\n   it finishes, it can continue where it was interrupted.\n\n   After forking the process, Pid is unified with its process ID, which can\n   be used e.g.  in wait/2 or kill/2.  If the exec system call in the child\n   process failed, the child exits with status 128 + errno (Unix).\n\nModes and Determinism\n   exec(++, ++, -) is det\n\nExceptions\n     4 --- Command is not instantiated.\n     5 --- Command is instantiated, but not to a string or an atom.\n     5 --- Streams is instantiated, but not to a list.\n     5 --- A stream in Streams is instantiated, but not to an atom or a    sigio structure.\n     5 --- Pid is instantiated.\n   170 --- System error, it was not possible to fork the child.\n   192 --- The specified stream is not open in the appropriate mode.\n\nExamples\n   \n% execute an ls-command\n\n    ?- exec([ls,\"-C\"], [null, out], Pid).\n    Pid = 10885\n    yes.\n\n    ?- read_string(out, end_of_file, _, S), write(S).\n    aux.o    coroutine.pl    kegi.pl    sepia.o\n    bsi.pl    cprolog.pl      lint.pl    sorts.pl\n    cio.pl    history.pl      lists.pl    strings.pl\n    cn.pl    k_env.pl    quintus.pl      t_all.pl\n\n    S = \"...\"\n\n    ?- close(out), wait(Pid, S).\n    Pid = 10885\n    S = 0\n    yes.\n\n% execute another eclipse\n\n    ?- argv(0,Ecl),\t% get name of the eclipse executable\n       exec([Ecl,\"-e\",\"read(X),Y is X*X,printf('%w. %b',[Y])\"], [in,out], P).\n\n    E = \"/usr/local/eclipse/bin/sparc_sunos5/eclipse.exe\"\n    P = 10741\n    yes.\n\n    [eclipse 2]: printf(in, '%w. %b', [12]), read(out, Result).\n    Result = 144\n    yes.\n\n    [eclipse 3]: close(in), close(out), wait(10741, S).\n    S = 0\n    yes.\n\nError:\n      exec(S, [], Pid).    (Error 4).\n      exec([ls], null, Pid).       (Error 5).\n      exec([chipc], [1], P).       (Error 5).\n      exec([date], [input], P).    (Error 192).\n\nSee Also\n   exec / 2, exec_group / 3, setenv / 2, wait / 2, kill / 2, sh / 1, system / 1, open / 3"},"exit/1":{"prefix":"exit","body":"exit(${1:Status})$2\n$0","description":"exit(+Status)\n\n   The Prolog session is ended and the specified status returned to the\noperating system.\n\nArguments\n   Status    Integer\n\nType\n   Operating System\n\nDescription\n   Used to exit from the Prolog session.  If user_end/0 is defined and\n   global, it is called.  All buffers are flushed, streams are closed and\n   ECLiPSe exits.  The specified status code is returned to the operating\n   system.  exit(0) is identical with halt.\n\nModes and Determinism\n   exit(+) is erroneous\n\nExceptions\n     4 --- Status is not instantiated.\n     5 --- Status is instantiated to a non-integer.\n\nExamples\n   \nSuccess:\n      [eclipse]: exit(5).\n      csh% echo $status\n      5\n      csh%\n\nSee Also\n   halt / 0, quintus : break / 0, toplevel : break / 0, pause / 0"},"existing_file/4":{"prefix":"existing_file","body":"existing_file(${1:Base}, ${2:Completions}, ${3:Permissions}, ${4:MatchedFile})$5\n$0","description":"existing_file(++Base, ++Completions, ++Permissions, -MatchedFile)\n\n   Finds any existing file subject to the specified conditions.\n\nArguments\n   Base    The start of a file or path name (atom or string, possibly with a library/1 wrapper)\n   Completions    Possible completions for Base (list of atomic elements)\n   Permissions    Permissions (list of readable,writable,executable)\n   MatchedFile    An existing file that matches the specification.\n\nType\n   Operating System\n\nDescription\n    This predicate will search for any existing files that match the\n    specifications given in the first three arguments: the file starts with\n    Base, which is an absolute or relative partial file name.  Possible\n    completions (usually file extensions) given in Completions are appended\n    to Base, in the order they are given, to give a complete name.\n    If a proper file (i.e. non-directory) with this name exists, the\n    ECLiPSe process's permission for this file are checked against the\n    Permissions list (readable, writable, executable).  If the\n    permissions match, then the filename is returned in MatchedFile.\n    \n\n    Base may have a library/1 wrapper around the name.  If this is\n    used, the file is searched for in the directories specified in\n    library path (including any subdirectory with the same name as\n    given in the library/1 wrapper, i.e. we check for both lib/foo.eco\n    and lib/foo/foo.eco).  The search order is the order in which the\n    library directories appear in the library_path flag of get_flag/2,\n    and for each directory, the completions are tried in the order in\n    which they appear in the list Completions.\n\n    All matching files are returned via backtracking.  If only the\n    first one is required, use once/1.\n\n    MatchedFile is the same type as Base (atom or string).  Also, if \n    Base is a relative (absolute) pathname, then so is MatchedFile.\n    If Base starts with '~' or enviroment variables (specified with a\n    leading '$'), these are substituted.  If the library(...) wrapper\n    is used, the proper library path is substituted.\n\n    Note that the executable permission for Windows may be approximate,\n    because Windows (especially Vista) has a different system for\n    dealing with execute permission.\n    \n\n    The predicates canonical_path_name/2 and existing_file/4 are intended\n    as replacement for absolute_file_name/2 in previous releases. The\n    functionality of completing an incomplete name and returning an\n    absolute path of absolute_file_name/2 has been separated. The following\n    approximately implements the old absolute_file_name/2:\n\n    absolute_file_name(Rel, Abs) :-\n\t(Rel == user ->\n\t    Abs == user\n\t; get_flag(prolog_suffix, Sufs),\n\t  (existing_file(Rel, Sufs, [], ExtRel) -> true ; ExtRel = Rel),\n\t  canonical_path_name(ExtRel, Abs)\n    ).\n\nModes and Determinism\n   existing_file(++, ++, ++, -) is nondet\n\nFail Conditions\n   MatchedFile cannot be found.\n\nResatisfiable\n   Succeeds once for every matching file\n\nExceptions\n     5 --- Base, Completions, Permissions not of right type.\n     6 --- Base is an empty atom or string.\n\nExamples\n   \nSuccess: \n\n      % Trying different file extensions, including the empty one:\n      ?- existing_file(\"hello\", [\".ecl\",\".txt\",\"\"], [], File).\n      File = \"hello.txt\"     More? (;) \n      No (0.00s cpu)    % assuming hello.ecl and hello do not exist\n\n      % Looking for one of several files in the parent directory:\n      ?- existing_file(\"../\", [\"a.txt\",\"b.txt\",\"c.txt\"], [readable], File).\n      File = \"../a.txt\"     More? (;) \n      File = \"../c.txt\"     More? (;) \n      No (0.00s cpu)    % assuming b.txt does not exist or is not readable\n\n      % Looking for a precompiled library:\n      ?- existing_file(library(fd), [\".eco\"], [readable], File).\n      File = '/homes/ks15/Eclipse/lib/fd.eco'     More? (;) \n      No (0.00s cpu)\n\n      % Looking for source files:\n      ?- get_flag(prolog_suffix, Exts),\n    existing_file(\"hello\", Exts, [readable], File).\n      File = \"hello.ecl\"     More? (;) \n      No (0.00s cpu)\n\n      % Looking for different file names:\n      [eclipse 1]: existing_file(test, [1,2,3], [], File).\n      File = test1     More? (;) \n      File = test3     More? (;) \n      No (0.00s cpu)\n\nFailure:\n\n      [eclipse 1]:  existing_file(library(fd), [], [readable], File).\n      % no Completions at all; will always fail\n\n      [eclipse 1]:  existing_file(library(fd), [\"\"], [readable], File).\n      % no library file with just 'fd' as the name (file has a suffix)\n\nSee Also\n   canonical_path_name / 2, get_flag / 2, os_file_name / 2, pathname / 4"},"exists/1":{"prefix":"exists","body":"exists(${1:File})$2\n$0","description":"exists(+File)\n\n   Succeeds if the file File (with absolute or relative pathname) exists.\nFile can be a directory.\n\nArguments\n   File    Atom or string.\n\nType\n   Operating System\n\nDescription\n   Used to see if the file File exists.  File can be a directory.\n   exists(File) is equivalent to get_file_info(File, mode, _).\n\nModes and Determinism\n   exists(+) is semidet\n\nFail Conditions\n   Fails if the file File (with absolute or relative pathname) does not exist\n\nExceptions\n     4 --- File is not instantiated.\n     5 --- File is neither an atom nor a string.\n\nExamples\n   \nSuccess:\n   [eclipse]: sh('ls myfile').\n   myfile\n   [eclipse]: exists(myfile).\n   yes.\n\n   [eclipse]: sh('ls /home/user/workdir').\n   myfile\n   [eclipse]: exists('/home/user/workdir').\n   yes.\n\nFail:\n   [eclipse]: sh('ls nofile').\n   nofile not found\n   [eclipse]: exists(nofile).\n   no.\n\nError:\n   exists(File).    (Error 4).\n   exists([file]).    (Error 5).\n\nSee Also\n   existing_file / 4, get_file_info / 3, sh / 1, system / 1, delete / 1, mkdir / 1"},"exec_group/3":{"prefix":"exec_group","body":"exec_group(${1:Command}, ${2:Streams}, ${3:Pid})$4\n$0","description":"exec_group(++Command, ++Streams, -Pid)\n\n   A child process Command is forked in a new process group, its standard\nstreams are connected to Streams and its process ID is Pid.\n\nArguments\n   Command    String, atom or list of atomic terms.\n   Streams    List of stream ids.\n   Pid    Integer or a variable.\n\nType\n   Operating System\n\nDescription\n   UNIX:  This predicate is used to fork a child process in its own\n   process group and to set up pipes to its standard streams.  After\n   the process is forked, ECLiPSe continues normally, without waiting\n   for the child to terminate.\n   \n\n   Command should be a list with at least one element: The first list element\n   (a path name in ECLiPSe path name syntax, atom or string) specifies the\n   program to be executed, and the subsequent list elements are its arguments.\n   The arguments can be atoms, strings or numbers.  They are passed to the\n   executed program literally (in particular, no path name syntax conversion\n   is applied).\n\n   For backward compatibility, Command can be a simple atom or string, in\n   which case the first word in Command specifies the program to be executed,\n   and the following words are its command-line arguments.\n   This form is deprecated since it creates problems with argument quoting\n   and operating system dependent path name syntax.\n\n   By specifying the Streams argument it is possible to control which of\n   the process' standard streams are connected to ECLiPSe streams.  The\n   form of Streams is [Stdin, Stdout, Stderr].  If some of these streams\n   are specified and not null, a pipe is opened which connects the standard\n   stream of the child process with the specified ECLiPSe stream, e.g.\n   Stdin must be an output stream because it is connected to the standard\n   input of the child process.  If the list Streams is shorter, only the\n   specified streams are connected with a pipe.  The streams can be\n   specified like for open/3.  If the stream is a variable, it is bound to\n   the physical stream number, if it is an atom different from null, that\n   symbolic stream is used.  Specifying a null stream means that no pipe is\n   set up for this stream.\n\n   Each stream can also be specified as sigio(Stream) (UNIX systems only).\n   In this case a pipe is set up to the stream Stream and in addition the\n   pipe is instructed to send the signal io each time new data appears in\n   it.  In this way the two processes can communicate in a truly\n   asynchronous way.  When one process sends data to the other one, the\n   interrupt handler is invoked and it can read and process the data.  When\n   it finishes, it can continue where it was interrupted.\n\n   After forking the process, Pid is unified with its process ID, which can\n   be used e.g.  in wait/2 or kill/2.  If the exec system call in the child\n   process failed, the child exits with status 128 + errno.\n\n   As oppsed to exec/3, the child process is created in a new process group\n   (UNIX), and as a consequence does not get the interrupt, hangup and kill\n   signals sent to the parent.  This feature might be needed if e.g. a\n   separate ECLiPSe process is forked which should not be influenced when\n   the user types Ctrl-C to the main ECLiPSe process.\n\nModes and Determinism\n   exec_group(++, ++, -) is det\n\nExceptions\n     4 --- Command is not instantiated.\n     5 --- Command is instantiated, but not to a string or an atom.\n     5 --- Streams is instantiated, but not to a list.\n     5 --- A stream in Streams is instantiated, but not to an atom or a    sigio structure.\n     5 --- Pid is instantiated, but not to an integer.\n   170 --- System error, it was not possible to fork the child.\n   192 --- The specified stream is not open in the appropriate mode.\n\nExamples\n   \nSuccess:\n      % the child process does not get the signal if ^C is typed\n      [eclipse]: exec_group(eclipse, [output], Pid).\n\n      Pid = 11459\n      yes.\n      [eclipse]:\n      ECLiPSe Constraint Logic Programming System [kernel]\n      Kernel and basic libraries copyright Cisco Technology Inc\n      Academic licensing through Imperial College London, see legal/licence_acad.txt\n      GMP library copyright Free Software Foundation, see legal/lgpl.txt\n      For other libraries see their individual copyright notices\n      Version 5.8 #72, Fri Nov 26 00:12 2004\n      [eclipse]: ^C\n      interruption: type a, b, c, e, or h for help : ?\n\n      % when exec/3 is used, both processes get the signal\n      [eclipse]: exec(eclipse, [output], Pid).\n\n      Pid = 11440\n      yes.\n      [eclipse]:\n      ECLiPSe Constraint Logic Programming System [kernel]\n      Kernel and basic libraries copyright Cisco Technology Inc\n      Academic licensing through Imperial College London, see legal/licence_acad.txt\n      GMP library copyright Free Software Foundation, see legal/lgpl.txt\n      For other libraries see their individual copyright notices\n      Version 5.8 #72, Fri Nov 26 00:12 2004\n      [eclipse]: ^C\n\n      interruption: type a, b, c, e, or h for help : ?\n      interruption: type a, b, c, e, or h for help : ?\nError:\n      exec_group(S, [], Pid).    (Error 4).\n      exec_group(ls, null, Pid).       (Error 5).\n      exec_group(chipc, [1], P).       (Error 5).\n      exec_group(date, [input], P).    (Error 192).\n\nSee Also\n   exec / 2, exec / 3, setenv / 2, kill / 2, sh / 1, system / 1, open / 3, wait / 2"},"getcwd/1":{"prefix":"getcwd","body":"getcwd(${1:Cwd})$2\n$0","description":"getcwd(-Cwd)\n\n   Unifies the current working directory with Cwd.\n\nArguments\n   Cwd    String or Variable.\n\nType\n   Operating System\n\nDescription\n   Cwd is unified with the current working directory including the final\n   \"/\".\n\n   Equivalent to get_flag(cwd, Cwd).  To set the current working directory,\n   use set_flag(cwd, Directory) or cd(Directory).\n\nModes and Determinism\n   getcwd(-) is det\n\nExceptions\n     5 --- Cwd is instantiated but not to a string.\n\nExamples\n   \nSuccess:\n     [eclipse]: sh(pwd).\n     /home/user/test\n     yes.\n     [eclipse]: getcwd(Cwd).\n     Cwd = \"/home/user/test/\"\n     yes.\n\nFail:\n    getcwd(\"nodirectory\").\n\nError:\n      getcwd(1).    (Error 5).\n      getcwd(atom).    (Error 5).\n\nSee Also\n   cd / 1, get_flag / 2, set_flag / 2, mkdir / 1"},"get_file_info/3":{"prefix":"get_file_info","body":"get_file_info(${1:File}, ${2:Attr}, ${3:Value})$4\n$0","description":"get_file_info(+File, ?Attr, -Value)\n\n   Succeeds if the file File (with absolute or relative pathname) exists and\nthe value of its attribute Attr unfies with Value.\n\nArguments\n   File    Atom or string.\n   Attr    Atom or variable.\n   Value    Constant or variable.\n\nType\n   Operating System\n\nDescription\n   This predicate is used to test the properties of a specified file.\n   If Attr specifies one of the attributes listed below, then Value is\n   unified with the attribute value on return.\n   If Attr is a variable, the predicate on backtracking returns all\n   attribute-value pairs that are relevant for the given file.\n\n   The possible attributes and their meanings are:\n\n    Attribute  Type    Meaning\n   ---------------------------------------------------------\n    mode       integer     file mode (see table below)\n    size       integer     file size in bytes\n    type       atom    file type: file,directory,link,socket,\n    fifo,char_device or block_device\n\n    device     integer     device number\n    inode      integer     inode number (Unix)\n    nlink      integer     number of links (Unix)\n    uid    integer     user ID of the owner (Unix)\n    uname      string      user name of the owner (Unix)\n    gid    integer     group ID of the owner (Unix)\n    gname      string      group name of the owner (Unix)\n\n    atime      integer     time of last access\n    mtime      integer     time of last data modification\n    ctime      integer     time of last status change\n    adate      string      date of last access (text)\n    mdate      string      date of last data modification (text)\n    cdate      string      date of last status change (text)\n\n    readable   on/off      file is/isn't readable by this process\n    writable   on/off      file is/isn't writable by this process\n    executable on/off      file is/isn't executable by this process\n\n   The *name attributes are string representation of the corresponding *id\n   attributes.  The *date attributes are string representation of the\n   corresponding *time attributes.  The time for the *time attributes is\n   measured as seconds elapsed since 00:00:00 GMT, Jan 1, 1970.\n\n   The flags readable, writable and executable indicate whether the running\n   ECLiPSe process has the corresponding permissions on the file.  Note that\n   the executable permission for Windows may be approximate, because Windows\n   (especially Vista) has a different system for dealing with execute\n   permission.\n\n   The use of the 'mode' attribute and the following numbers is deprecated\n   in favour of the 'type', 'readable', 'writable' and 'executable'\n   attributes.  The meaning of the bits in the mode attribute is as follows:\n\n Mode     Meaning\n------------------------------------------------\n 8'170000 file type\n 8'040000 directory\n 8'020000 character special\n 8'060000 block special\n 8'100000 normal file\n 8'120000 symbolic link\n 8'140000 socket\n------------------------------------------------\n 8'004000 set user ID on execution\n 8'002000 set group ID on execution\n------------------------------------------------\n 8'000700 owner access\n 8'000400 read permission for owner\n 8'000200 write permission for owner\n------------------------------------------------\n 8'000070 group access\n 8'000040 read permission for group\n 8'000020 write permission for group\n------------------------------------------------\n 8'000007 other access\n 8'000004 read permission for others\n 8'000002 write permission for others\n 8'000001 execute/search permission for others\n\nModes and Determinism\n   get_file_info(+, -, -) is nondet\n   get_file_info(+, +, -) is semidet\n\nFail Conditions\n   Fails if the file File does not exist, or doesn't have the attribute Attr\n\nExceptions\n     4 --- File is not instantiated.\n     5 --- File is neither an atom nor a string.\n     5 --- Attr is instantiated but not to an atom.\n     5 --- Value is instantiated but not to a constant.\n\nExamples\n   \nSuccess:\n   is_directory(File) :-\n    get_file_info(File, type, directory),\n\n   % the same test via mode bits:\n   is_directory(File) :-\n    get_file_info(File, mode, Mode),\n    Mode /\\ file_type =:= directory_flag.\n\n   file_type(8'170000).\n   directory_flag(8'40000).\n\n   % A file is younger if its time is greater\n   is_younger(File1, File2) :-\n    get_file_info(File1, mtime) > get_file_info(File2, mtime).\n\nFail:\n   get_file_info(nofile, mode, Mode).\n   get_file_info('/', mode, 8'100000).\n\nError:\n   get_file_info(File, ctime, T).    (Error 4).\n   get_file_info([file], gid, G).    (Error 5).\n   get_file_info(file, 1, X).    (Error 5).\n\nSee Also\n   exists / 1, delete / 1, exec / 3, local_time / 8, local_time_string / 3"},"getenv/2":{"prefix":"getenv","body":"getenv(${1:Name}, ${2:Value})$3\n$0","description":"getenv(+Name, -Value)\n\n   Succeeds if Name is the name of an environment variable or registry entry, and returns the corresponding value.\n\nArguments\n   Name    String or atom.\n   Value    String or variable.\n\nType\n   Operating System\n\nDescription\n    The first argument must be a string or an atom. The predicate looks\n    up a value which the operating system has stored under this key.\n\n    UNIX:  If Name is the name of a UNIX environment variable, this\n    variable's value is returned.  As an additional feature, if there\n    exists an environment variable whose name is the concatenation of\n    the value of Name and the ECLiPSe version number (e.g. \n    \"ECLIPSEDIR_4_9\" if Name is \"ECLIPSEDIR\" and the version\n    is 4.9), then this variable's value is returned instead.\n\n   WINDOWS: The name Name is looked up in the registry under the key\n    HKEY_LOCAL_MACHINE\\SOFTWARE\\IC-Parc\\ECLiPSe\\<version>. If there is\n    such an entry, its value is returned. Otherwise, Name is taken as\n    the name of an environment variable, whose value is returned if it\n    exists.\n\n    If the lookup operation is unsuccessful, the predicate fails.\n\nModes and Determinism\n   getenv(+, -) is semidet\n\nFail Conditions\n   Fails if none of the lookup methods yielded any result for the given name\n\nExceptions\n     4 --- Name is not instantiated.\n     5 --- Name is instantiated, but not to a string or an atom.\n     5 --- Value is instantiated, but not to a string.\n\nExamples\n   \nSuccess:\n      getenv('HOME',V).    (gives V=\"/home/username\").\n      getenv(\"SHELL\",V).   (gives V=\"/bin/csh\").\n      getenv('TERM',V).    (gives V=\"sun-cmd\").\n      getenv('USER',V).    (gives V=\"username\").\n\nFail:\n      getenv('HOEM',V).\n\nError:\n      getenv(TERM,V).    (Error 4).\n      getenv('TERM',atom).    (Error 5).\n      getenv(1,V).    (Error 5).\n\nSee Also\n   setenv / 2, sh / 1, argv / 2, argc / 1"},"kill/2":{"prefix":"kill","body":"kill(${1:Pid}, ${2:Signal})$3\n$0","description":"kill(+Pid, +Signal)\n\n   Send the signal Signal to the process number Pid\n\nArguments\n   Pid    Integer\n   Signal    Atom or Integer\n\nType\n   Operating System\n\nDescription\n    Send the signal Signal to the process with process ID Pid.\n    If Signal is 0, then only a check for existence of the process\n    is performed, i.e. kill/2 fails if the process does not exist.\n    A process ID of 0 can be used as a shorthand for the current process.\n\n    This predicate is modelled after the UNIX system call kill(2).\n    Signal names are derived from their official names by stripping\n    SIG and using lower case, e.g. 'segv' for SIGSEGV.\n\n    On Windows, a subset of the functionality is supported:\n    \n    Checking for process existence using signal 0\n    Terminating a process using signal 'term'\n    Sending signals 'abrt, 'fpe, 'ill, 'int, 'segv' or 'term'\n\tto the current process/LI>\n    \n\nModes and Determinism\n   kill(+, +) is semidet\n\nFail Conditions\n   Fails if Signal is 0 and process Pid does not exist\n\nExceptions\n     4 --- Pid or Signal are not instantiated.\n     5 --- Pid is instantiated to a non-integer.\n     5 --- Signal is instantiated to neither an integer nor an atom.\n     6 --- Signal is not a signal name or number.\n   170 --- Pid or Signal has an invalid value.\n   170 --- No permission to access process Pid.\n\nExamples\n   \nSuccess:\n      [eclipse]: get_flag(pid, Pid), kill(Pid, 31).\n      Signal 31\n      Pid = 2929\n      yes.\n\n      [eclipse]: kill(2929, 0)\n      yes.\n\n      [eclipse]: kill(1234, term)\n      yes.\nFailure:\n      [eclipse]: kill(9999, 0)\n      no.\n\nSee Also\n   exec / 2, exec / 3, exec_group / 3, get_flag / 2, wait / 2"},"halt/0":{"prefix":"halt","body":"halt","description":"halt\n\n   The Prolog session is ended (the same as Control-D at the top-level loop).\n\nArguments\n\nType\n   Operating System\n\nDescription\n   Used to exit from the Prolog session.  If user_end/0 is defined and\n   global, it is called.  All buffers are flushed, streams are closed and\n   ECLiPSe exits.  Zero as status code is returned to the operating system.\n   halt is identical with exit(0).\n\nModes and Determinism\n   halt is erroneous\n\nExamples\n   \nSuccess:\n      [eclipse]: halt.\n      cygnus% echo $status\n      0\n      cygnus%\n\n      [eclipse]: [user].\n       problem_exit :-\n    writeln(debug_output, 'PROBLEM IN RECOVERY PROCEDURE'),\n    halt.\n       user compiled 132 bytes in 0.02 seconds\n      yes.\n      [eclipse]: problem_exit.\n      PROBLEM IN RECOVERY PROCEDURE\n      %\n\nSee Also\n   exit / 1, quintus : break / 0, toplevel : break / 0, pause / 0"},"os_file_name/2":{"prefix":"os_file_name","body":"os_file_name(${1:InternalName}, ${2:ExternalName})$3\n$0","description":"os_file_name(?InternalName, ?ExternalName)\n\n   Conversion between internal ECLiPSe file name and Operating\nSystem file name syntax.\n\nArguments\n   InternalName    String, atom or variable.\n   ExternalName    String, atom or variable.\n\nType\n   Operating System\n\nDescription\n   This predicate converts between internal (ECLiPSe) and external\n   (operating system) file names. It works in both directions. \n\n   \n\nModes and Determinism\n   os_file_name(+, -) is det\n   os_file_name(-, +) is det\n\nExceptions\n     4 --- Neither InternalName nor ExternalName are instantiated.\n     5 --- InternalName or ExternalName are instantiated to something other than string or atom.\n     5 --- InternalName or ExternalName are instantiated to different types.\n\nExamples\n   \nSuccess:\n    On UNIX:\n      [eclipse]: os_file_name(\"//a/b/c.def\", OS).\n      OS = \"//a/b/c.def\"\n      yes\n\n    On Windows:\n      [eclipse]: os_file_name(\"//a/b/c.def\", OS), write(OS).\n      a:\\b\\c.def\n      OS = \"a:\\\\b\\\\c.def\"\n      yes\n\n      [eclipse]: os_file_name(File, \"a:\\\\b\\\\c.def\").\n      File = \"//a/b/c.def\"\n      yes\n\nError:\n      os_file_name(X, Y).    (Error 4).\n      os_file_name(4, X).    (Error 5).\n      os_file_name(\"/home/file\", '/home/file').    (Error 5).\n\nSee Also\n   existing_file / 4, pathname / 4"},"local_time/8":{"prefix":"local_time","body":"local_time(${1:Year}, ${2:Month}, ${3:Day}, ${4:Hour}, ${5:Minute}, ${6:Second}, ${7:DST}, ${8:UnixTime})$9\n$0","description":"local_time(?Year, ?Month, ?Day, ?Hour, ?Minute, ?Second, ?DST, ?UnixTime)\n\n   Conversion between local time and universal time\n\nArguments\n   Year    Integer or variable\n   Month    Integer or variable\n   Day    Integer or variable\n   Hour    Integer or variable\n   Minute    Integer or variable\n   Second    Integer or variable\n   DST    0, 1 or variable (daylight savings time flag)\n   UnixTime    Variable or integer (seconds since 1/1/1970)\n\nType\n   Operating System\n\nDescription\n\tThis predicate is used to convert between local time (taking\n\tinto account time zone and daylight savings time settings) and\n\tUTC (Universal Coordinated Time, represented as 'Unix time', i.e.\n\tin seconds since 1970-01-01, 00:00).\n\t\n\tThe conversion works in both directions. If the UnixTime argument\n\tis instantiated, it gets converted to the local date and time, and\n\tthe first 6 arguments get unified accordingly.\n\t\n\tIf the first 6 (or 7) arguments are instantiated, they will be\n\tinterpreted under the current time zone and daylight savings time\n\trules, and converted into 'Unix time', which is unified with the\n\tlast argument.\n\t\n\tIn both directions, the DST argument can usually remain uninstantiated,\n\tand will be unified with 1 if the date specified is while daylight\n\tsavings time is in effect, and 0 otherwise. Note however, that during\n\tthe switch from summer to winter time, there is usually a one hour\n\toverlap, where the same time of day exists twice, once in summer and\n\tonce in winter time.  In this case, when converting from local time\n\tto UTC, the caller should instantiate DST in order to disambiguate.\n\t\n\tThe predicate can also be used to test for valid local date and time:\n\tIf the first 6 (or 7) arguments do not represent a valid date, the\n\tpredicate fails.\n\t\n\tThis predicate is based on the POSIX localtime() and mktime() functions.\n\nModes and Determinism\n   local_time(+, +, +, +, +, +, ?, -) is semidet\n   local_time(-, -, -, -, -, -, -, +) is det\n\nFail Conditions\n   The first 7 arguments do not represent a valid date\n\nExceptions\n     4 --- The arguments are insufficiently instantiated\n     5 --- Any of the arguments is not of the expected numerical type\n     6 --- UnixTime is out of range\n\nExamples\n   \n    ?- get_flag(unix_time,T), local_time(Yr,Mo,Dy,Hr,Mi,Sc,Ds,T).\n    Yr = 2003\n    Mo = 4\n    Dy = 4\n    Hr = 16\n    Mi = 38\n    Sc = 30\n    Ds = 1\n    T = 1049470710\n    Yes (0.00s cpu)\n\n    ?- local_time(2003,4,4,16,38,30,1,T).\n    T = 1049470710\n    Yes (0.00s cpu)\n\n    ?- local_time(2003,4,4,16,38,30,_,T).\n    T = 1049470710\n    Yes (0.00s cpu)\n\n    ?- local_time(2003,1,1,25,0,0,_,_).   % invalid hour\n    No (0.00s cpu)\n\n    ?- local_time(2003,2,29,12,0,0,_,_).  % invalid date (no leap year)\n    No (0.00s cpu)\n\n    % The following examples assume DST rules for Britain\n    ?- local_time(2003,3,30,1,30,0,_,_).  % invalid time (skipped hour)\n    No (0.00s cpu)\n\n    ?- local_time(2003,10,26,1,0,0,1,T).  % 1h before end of summer time\n    T = 1067126400\n    Yes (0.01s cpu)\n\n    ?- local_time(2003,10,26,1,0,0,0,T).  % 1 hour later\n    T = 1067130000\n    Yes (0.00s cpu)\n\nSee Also\n   date / 1, local_time_string / 3, library(calendar)"},"local_time_string/3":{"prefix":"local_time_string","body":"local_time_string(${1:UnixTime}, ${2:Format}, ${3:TimeString})$4\n$0","description":"local_time_string(+UnixTime, +Format, -TimeString)\n\n   Create a string representation of the local time\n\nArguments\n   UnixTime    Integer (seconds since 1/1/1970)\n   Format    String or Atom\n   TimeString    Variable or string\n\nType\n   Operating System\n\nDescription\n\tThis predicate converts UTC (Universal Coordinated Time, represented\n\tas 'Unix time', i.e. in seconds since 1970-01-01, 00:00) into a\n\ttextual representation of the local time (taking into account time\n\tzone and daylight savings time settings), according to the given\n\tformat string.\n\t\n\tThe format string is similar to the format string in the printf/2,3\n\tpredicate, but accepts different format specifiers. The exact set of\n\tformat specifiers available depends on the underlying operating\n\tsystem (refer to the description of strftime()), but the following\n\tare generally available:\n\t\n\t%a  Abbreviated weekday name for current locale\n\n\t%A  Full weekday name for current locale\n\n\t%b  Abbreviated month name for current locale\n\n\t%B  Full month name for current locale\n\n\t%c  Preferred date and time representation for current locale\n\n\t%d  Day of month as decimal number (01-31)\n\n\t%H  Hour in 24-hour format (00-23)\n\n\t%I  Hour in 12-hour format (01-12)\n\n\t%j  Day of year as decimal number (001-366)\n\n\t%m  Month as decimal number (01-12)\n\n\t%M  Minute as decimal number (00-59)\n\n\t%p  Current locale's A.M./P.M. indicator for 12-hour clock\n\n\t%S  Second as decimal number (00-59)\n\n\t%U  Week of year (00-53), with first Sunday first day of week 01\n\n\t%w  Weekday as decimal number (0-6, Sunday is 0)\n\n\t%W  Week of year (00-53), with first Monday first day of week 01\n\n\t%x  Date representation for current locale\n\n\t%X  Time representation for current locale\n\n\t%y  Year without century, as decimal number (00-99)\n\n\t%Y  Year with century, as decimal number\n\n\t%Z  Time-zone name or abbreviation, empty if time zone is unknown\n\n\t%%  Percent sign\n\t\n\t\n\tThis predicate is based on POSIX strftime().\n\nModes and Determinism\n   local_time_string(+, +, -) is det\n\nExceptions\n     4 --- UnixTime or Format are uninstantiated\n     5 --- UnixTime, Format or TimeString are instantiated, but not strings\n\nExamples\n   \n    ?- get_flag(unix_time, T), local_time_string(T, \"%c\", S).\n    T = 1049564174\n    S = \"Sat Apr 05 18:36:14 2003\"\n    Yes (0.00s cpu)\n\n    ?- get_flag(unix_time, T),\n\t     local_time_string(T, \"We write the year %Y in time zone %Z\", S).\n    T = 1049564247\n    S = \"We write the year 2003 in time zone BST\"\n    Yes (0.00s cpu)\n\nSee Also\n   date / 1, local_time / 8, library(calendar)"},"mkdir/1":{"prefix":"mkdir","body":"mkdir(${1:Path})$2\n$0","description":"mkdir(+Path)\n\n   Create a directory/folder with the given name.\n\nArguments\n   Path    An atom or a string.\n\nType\n   Operating System\n\nDescription\n   Used to create directories (folders) in the filesystem.\n   Path may be an absolute or relative name.\n\nModes and Determinism\n   mkdir(+) is det\n\nExceptions\n     4 --- Path is not instantiated.\n     5 --- Path is neither an atom nor a string.\n\nExamples\n   \n      [eclipse 1]: mkdir(tmpdir).\n\n      yes.\n      [eclipse 1]: mkdir(tmpdir).\n      system interface error: File exists in mkdir(tmpdir)\n\nSee Also\n   sh / 1, system / 1, exists / 1, delete / 1"},"pathname/4":{"prefix":"pathname","body":"pathname(${1:FilePath}, ${2:Path}, ${3:BaseName}, ${4:Suffix})$5\n$0","description":"pathname(+FilePath, -Path, -BaseName, -Suffix)\n\n   Decomposes a filename into its directory path, base name and suffix\n\nArguments\n   FilePath    String or atom.\n   Path    Variable or string.\n   BaseName    Variable or string.\n   Suffix    Variable or string.\n\nType\n   Operating System\n\nDescription\n   This predicate is used to decompose FilePath which is either a relative\n   or absolute pathname of a file, into three components, namely the pathname\n   of its parent directory including the trailing \"/\" if any, the `base'\n   name of the file (the plain file name without the suffix), and the\n   suffix, if any. The concatenation of Path, BaseName and Suffix yields\n   the original filename FilePath.\n\nModes and Determinism\n   pathname(+, -, -, -) is det\n\nExceptions\n     4 --- FilePath is not instantiated.\n     5 --- FilePath is neither a string nor an atom.\n     5 --- Path, BaseName or Suffix is neither a string nor a variable.\n\nExamples\n   \nSuccess:\n\n     [eclipse]: pathname(\"/home/user/userfile.pl\", P, B, S).\n\n     P = \"/home/user/\"\n     B = \"userfile\"\n     S = \".pl\"\n     yes.\n\n      [eclipse]: pathname(\"/home/user/userfile\", P, B, S).\n      P = \"/home/user/\"\n      B = \"userfile\"\n      S = \"\"\n      yes.\n\nFail:\n      pathname(\"/home/file.pl\",\"/home/\",\"file\", \"pl\").\n\nError:\n      pathname(F,P,R,S).    (Error 4).\n      pathname(\"/home/file.pl\",P,file,'.pl')    (Error 5).\n\nSee Also\n   pathname / 3, split_string / 4, join_string / 3, canonical_path_name / 2"},"pathname/3":{"prefix":"pathname","body":"pathname(${1:FilePath}, ${2:Path}, ${3:Name})$4\n$0","description":"pathname(+FilePath, -Path, -Name)\n\n   If FilePath is a pathname of a file, succeed if Path is the pathname of its\nparent directory and Name is the local file name.\n\nArguments\n   FilePath    String or atom.\n   Path    Variable or string.\n   Name    Variable or string.\n\nType\n   Operating System\n\nDescription\n   This predicate is used to decompose FilePath which is either a relative\n   or absolute pathname of a file, into two components, namely the pathname\n   of its parent directory including the trailing \"/\" if any, and the plain\n   name of the file Name.\n\nModes and Determinism\n   pathname(+, -, -) is det\n\nExceptions\n     4 --- FilePath is not instantiated.\n     5 --- FilePath is neither a string nor an atom.\n     5 --- Path is neither a string nor a variable.\n     5 --- Name is neither a string nor a variable.\n\nExamples\n   \nSuccess:\n      [eclipse]: pathname(\"/home/user/userfile\", P, F).\n      P = \"/home/user/\"\n      F = \"userfile\"\n      yes.\n\n      pathname(\"/home/user\",\"/home/\").\n      pathname(\"/home/\",\"/home/\",\"\").\n      pathname(\"home\",\"\",\"home\").\n\nFail:\n      pathname(\"/home/file\",\"/home\",\"file\").\n\nError:\n      pathname(F,P,R).    (Error 4).\n      pathname(\"/home/file\",P,file)    (Error 5).\n\nSee Also\n   pathname / 4"},"pause/0":{"prefix":"pause","body":"pause","description":"pause\n\n   The ECLiPSe session is suspended (the same as Control-Z at the top-level\nloop).\n\nArguments\n\nType\n   Operating System\n\nDescription\n   Used to suspend the ECLiPSe session.\n\nModes and Determinism\n   pause is det\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       w(X) :- write(X).\n       user compiled 92 bytes in 0.02 seconds\n      yes.\n      [eclipse]: w(bird).\n      bird\n      yes.\n      [eclipse]: pause.\n      Stopped (signal)\n      % fg    % foreground command\n      eclipse\n      yes.\n      [eclipse]: w(duck).\n      duck\n      yes.\n      [eclipse]: ^D\n      bye\n      % eclipse\n      [eclipse]: w(cow).\n      calling an undefined procedure\n\nSee Also\n   halt / 0"},"rename/2":{"prefix":"rename","body":"rename(${1:OldName}, ${2:NewName})$3\n$0","description":"rename(+OldName, +NewName)\n\n   Renames the file OldName to NewName.\n\nArguments\n   OldName    String or atom.\n   NewName    String or atom.\n\nType\n   Operating System\n\nDescription\n   OldName and NewName are absolute or relative pathnames of files.  Used\n   to rename the file OldName with the name NewName.\n\nModes and Determinism\n   rename(+, +) is det\n\nExceptions\n     4 --- Either OldName or NewName are not instantiated.\n     5 --- Either OldName or NewName are neither a string nor an atom.\n   190 --- File OldName does not exist.\n\nExamples\n   \nSuccess:\n      [eclipse]: sh('ls file1').\n      file1\n      [eclipse]: rename(file1, file2).\n      yes.\n      [eclipse]: sh('ls file1 file2').\n      file1 not found\n      file2\n      yes.\n\nError:\n      rename(Old, any).    (Error 4).\n      rename(any, New).    (Error 4).\n      rename(1, any).    (Error 5).\n      rename(notfile, newfile).     (Error 190).\n\nSee Also\n   exists / 1, delete / 1, mkdir / 1"},"read_directory/4":{"prefix":"read_directory","body":"read_directory(${1:Directory}, ${2:Pattern}, ${3:SubdirList}, ${4:FileList})$5\n$0","description":"read_directory(+Directory, +Pattern, -SubdirList, -FileList)\n\n   Unifies SubdirList with a list of subdirectories and FileList with a list\nof matching files in the specified directory.\n\nArguments\n   Directory    Atom or String\n   Pattern    Atom or String\n   SubdirList    Free variable or (maybe partial) list of strings\n   FileList    Free variable or (maybe partial) list of strings\n\nType\n   Operating System\n\nDescription\n   read_directory/4 scans the directory specified by Directory.  It\n   collects the names of the subdirectories in SubdirList and the names of\n   the files matching Pattern in FileList.  SubdirList and FileList are\n   lists of strings.  Pattern is a string containing a filename\n   specification similar to the usual UNIX convention.  The metacharacters\n   recognised are:  * matches an arbitrary sequence of characters, ?\n   matches any single character, [] matches one of the characters inside\n   the brackets unless the first one is a ^ in which case it matches any\n   character but those inside the brackets.\n\n   Filenames beginning with a dot are not suppressed by default, but the\n   directories \".\" and \"..\" are omitted from SubdirList.\n\nModes and Determinism\n   read_directory(+, +, -, -) is det\n\nExceptions\n     4 --- Directory or Pattern is not instantiated.\n     5 --- Directory or Pattern is neither atom nor string.\n     5 --- SubdirList or FileList are instantiated, but not to lists.\n   170 --- An error occurred trying to access Directory.\n\nExamples\n   \n   Success:\n   [eclipse]: read_directory(\"/usr/john\", \"*\", Dirlist, Filelist).\n   Dirlist = [\"subdir1\", \"subdir2\"]\n   Filelist = [\"one.c\", \"two.c\", \"three.pl\", \"four.pl\"]\n   yes.\n   [eclipse]: read_directory(., \"[^t]*.pl\", Dirlist, Filelist).\n   Dirlist = [\"subdir1\", \"subdir2\"]\n   Filelist = [\"four.pl\"]\n   yes.\n   Fail:\n   [eclipse]: read_directory(\".\", \"*.c\", _, [\"one.c\"]).\n   no.\n   Error:\n   read_directory(_, \"*\", Dirs, Files).    (error 4)\n   read_directory([46], \"*\", Dirs, Files).       (error 5)\n   read_directory(\".\", _, Dirs, Files).    (error 4)\n   read_directory(\".\", 3, Dirs, Files).    (error 5)\n   read_directory(\".\", \"*.pl\", Dirs, file).      (error 5)\n   read_directory(\"/private\", \"*\", _, Files).    (error 170)\n\n    % EXAMPLE: find_tree(+Root, +Pattern, -ListOfRelativeFiles)\n    % Recursively find all files matching Pattern below the directory\n    % or list of directories Roots.\n\n    find_tree(Root, Pattern, AllFiles) :- (atom(Root);string(Root)), !,\n\t    find_dir(Root, \"\", \"\", Pattern, AllFiles, []).\n    find_tree(Roots, Pattern, AllFiles) :-\n\t    find_tree(Roots, Pattern, AllFiles, []).\n\n    find_tree([], _Pattern, AllFiles, AllFiles).\n    find_tree([Root|Roots], Pattern, AllFiles, AllFiles0) :-\n\t    find_dir(Root, \"\", \"\", Pattern, AllFiles, AllFiles1),\n\t    find_tree(Roots, Pattern, AllFiles1, AllFiles0).\n\n    find_dir(_, _, [], _, AllFiles, AllFiles) :- !.\n    find_dir(Root, RelPath, [Dir|Dirs], Pattern, AllFiles, AllFiles0) :- !,\n\t    find_dir(Root, RelPath, Dir, Pattern, AllFiles, AllFiles1),\n\t    find_dir(Root, RelPath, Dirs, Pattern, AllFiles1, AllFiles0).\n    find_dir(Root, RelPath, Dir, Pattern, AllFiles, AllFiles0) :-\n\t    ( RelPath==\"\" -> RelDir=Dir\n\t    ; concat_string([RelPath,/,Dir], RelDir) ),\n\t    ( RelDir==\"\" -> AbsDir=Root\n\t    ; concat_string([Root,/,RelDir], AbsDir) ),\n\t    read_directory(AbsDir, Pattern, SubDirs, Files),\n\t    find_files(Root, RelDir, Files, AllFiles, AllFiles1),\n\t    find_dir(Root, RelDir, SubDirs, Pattern, AllFiles1, AllFiles0).\n\n    find_files(_, _, [], AbsFiles, AbsFiles).\n    find_files(Root, RelDir, [File|Files], [AbsFile|AbsFiles], AbsFiles0) :-\n\t    ( RelDir==\"\" -> concat_string([Root,/,File], AbsFile)\n\t    ; concat_string([Root,/,RelDir,/,File], AbsFile) ),\n\t    find_files(Root, RelDir, Files, AbsFiles, AbsFiles0).\n\nSee Also\n   cd / 1, getcwd / 1, get_flag / 2, pathname / 4, existing_file / 4, exists / 1, mkdir / 1"},"sh/1":{"prefix":"sh","body":"sh(${1:ShellCommand})$2\n$0","description":"sh(+ShellCommand)\n\n   The string or atom ShellCommand is passed as a command to the operating\nsystem, and the command is executed there (it is a synonym for system/1).\n\nArguments\n   ShellCommand    String or atom.\n\nType\n   Operating System\n\nDescription\n   Used to send a command ShellCommand to the operating system.  The\n   command uses the streams input, output and error as the UNIX streams\n   stdin, stdout and stderr respectively.  ECLiPSe -specific streams, like\n   null or a string stream, can not be used.\n\nModes and Determinism\n   sh(+) is semidet\n\nFail Conditions\n   Fails if the Shell couldn't be executed or if the command returned a non-zero status\n\nExceptions\n     4 --- ShellCommand is not instantiated.\n     5 --- ShellCommand is instantiated, but not to a string or atom.\n\nExamples\n   \nSuccess:\n      [eclipse]: sh('ls -F').\n      file1       dir1/\n      yes.\n\n      [eclipse]: sh(date).\n      Fri Aug  25 12:00:00 MET DST 1989\n      yes.\n\n      [eclipse]: sh(\"cd ..\").\n      yes.\n\n      [eclipse]: sh('which eclipse').\n      /home/user/eclipse\n      yes.\n\nError:\n      sh(S).    (Error 4).\n      sh(40).    (Error 5).\n\nSee Also\n   exec / 2, exec / 3, exec_group / 3, setenv / 2, wait / 2"},"setenv/2":{"prefix":"setenv","body":"setenv(${1:Name}, ${2:Value})$3\n$0","description":"setenv(+Name, +Value)\n\n   Sets the environment variable Name to the given value\n\nArguments\n   Name    String or atom.\n   Value    String, atom or number.\n\nType\n   Operating System\n\nDescription\n    The first argument must be a string or an atom and is taken as the\n    name of an operating system environment variable.  The value of this\n    environment variable is set, or changed to, the new value Value.\n\n    When Value is an atom or number, it is first converted to a string,\n    and the environment variable is set to the resulting string value.\n\n    The mechanism can be used to pass information from an eclipse-process\n    to its sub-processes.  Note however, that due to operating system\n    limitations, environment strings cannot contain null characters\n    (unlike ECLiPSe strings).  Also, the strings used as arguments to\n    setenv/2 cannot be garbage collected and will accumulate.\n\n    Operating system dependencies: Because of portability issues, on UNIX\n    there is currently no facility to unset an environment variable\n    completely, but it can set to an empty string. On Windows on the other\n    hand, an environment variable's value cannot be the empty string:\n    setting an environment variable to the empty string makes it\n    indistinguishable from an unset or nonexisting one.\n\nModes and Determinism\n   setenv(+, +) is det\n\nExceptions\n     4 --- Name or Value is not instantiated.\n     5 --- Name is instantiated, but not to a string or an atom.\n     5 --- Value is instantiated, but not to a string, atom or number.\n   170 --- The environment could not be changed\n\nExamples\n   \n   ?- setenv(abc, hello), getenv(abc, X).\n   X = \"hello\"\n   Yes (0.00s cpu)\n\n   ?- setenv(\"abc\", \"world\"), getenv(abc, X).\n   X = \"world\"\n   Yes (0.00s cpu)\n\n   ?- setenv(abc, 999), getenv(abc, X).\n   X = \"999\"\n   Yes (0.00s cpu)\n\n   ?-  setenv(abc, data), sh(\"echo $abc\").\n   data\n   Yes (0.00s cpu)\n\n   ?- setenv(abc, data), exec([sh,\"-c\",\"echo $abc\"], []).\n   data\n   Yes (0.00s cpu)\n\n   ?- setenv(abc, data), exec([eclipse,\"-e\",\"getenv(abc,X),writeln(X)\"], []).\n   data\n   Yes (0.00s cpu)\n\n   ?- setenv(abc, \"\"), getenv(abc, X).\t% on UNIX\n   X = \"\"\n   Yes (0.00s cpu)\n\n   ?- setenv(abc, \"\"), getenv(abc, X).\t% on Windows\n   No (0.00s cpu)\n\nSee Also\n   exec / 2, exec / 3, getenv / 2, sh / 1"},"sleep/1":{"prefix":"sleep","body":"sleep(${1:Seconds})$2\n$0","description":"sleep(+Seconds)\n\n   The execution of ECLiPSe is suspended for Seconds number of seconds.\n\nArguments\n   Seconds    Positive number (integer or float).\n\nType\n   Operating System\n\nDescription\n   sleep/1 causes the the suspension of execution of ECLiPSe for Seconds\n   number of seconds.\n\n   However, ECLiPSe will respond to interrupts while asleep.  On most\n   operating systems, interrupts will terminate the sleep prematurely.\n\nModes and Determinism\n   sleep(+) is det\n\nExceptions\n     4 --- Seconds is uninstantiated.\n     5 --- Seconds is not an integer or float.\n\nExamples\n   \nSuccess:\n      [eclipse]: sleep(0.3).\n    % short sleep\n      yes.    % \"yes\" appears after 0.3 seconds.\n\n      [eclipse]: sleep(63072000).\n    % long sleep\n      yes.    % \"yes\" appears after 2 years.\n\nSee Also\n   alarm / 1, pause / 0"},"wait/2":{"prefix":"wait","body":"wait(${1:Pid}, ${2:Status})$3\n$0","description":"wait(?Pid, -Status)\n\n   Wait for a child process to terminate and report its process ID and status.\n\nArguments\n   Pid    Integer or variable\n   Status    Integer or variable\n\nType\n   Operating System\n\nDescription\n   This predicate is used to make the ECLiPSe process wait until a\n   child process (created e.g. by exec/3 and identified by its process id Pid)\n   terminates.  Status is unified with the child process exit status.\n\n   A child process created with exec/3 still exists in the operating system\n   even after it exits, as long as it was not waited for.  Therefore it is\n   advisable to use a wait/2 call after every exec/3 (note that exec/2 waits\n   for the child process internally).\n\n   UNIX specific behaviour:\n   The predicate can be invoked with Pid uninstantiated. In this case it will\n   be resatisfiable and succeed once for every child process that terminates,\n   as soon as a child process terminates, as long as there are child processes.\n\n   If the child process created by exec/3 or exec_group/3 could not be\n   executed, the child exits with status 128 + errno.\n\n   When wait/2 is interrupted by a signal, the signal handler will be allowed\n   to execute, and if it does not abort, wait/2 will be restarted subsequently.\n\n   When the child process terminated normally, then Status is the value\n   that the child process exited with, multiplied by 256 (see wait(2)).\n\n   WINDOWS specific behaviour:\n   The predicate can only be used to wait for one specific process, i.e. the\n   Pid argument must be instantiated and the predicate is not resatisfiable.\n\n   When the child process terminated normally, then Status is the value\n   that the child process exited with.\n\nModes and Determinism\n   wait(+, -) is semidet\n   wait(-, -) is nondet\n\nFail Conditions\n   Fails if there are no child processes or the specified process does not exist\n\nExceptions\n     5 --- Pid or Status are instantiated to non-integers.\n\nExamples\n   \nSuccess:\n    [eclipse]: exec([true], [], Pid), wait(Pid, Status).\n    Pid = 3417\n    Status = 0\n    Yes (0.00s cpu)\n\n    [eclipse]: exec([true], [], Pid), exec([date], [], Pid2), wait(Pid2, S2).\n    Thu May 17 16:58:45 MET DST 1990\n\n    Pid = 10617\n    Pid2 = 10618\n    S2 = 0\n    Yes (0.00s cpu)\n\n    % Unix only\n    [eclipse 7]: exec([true],[],Pid1), exec([true],[],Pid2), wait(P,S).\n\n    Pid1 = 13718\n    Pid2 = 13719\n    P = 13718\n    S = 0\n    More (0.00s cpu) ? ;\n\n    Pid1 = 13718\n    Pid2 = 13719\n    P = 13719\n    S = 0\n    More (0.00s cpu) ? ;\n\n    No (0.00s cpu)\n\nFail:\n    [eclipse]: exec(\"true\", [], Pid), wait(1111, S).\n\n    No (0.00s cpu)\n\nExample (UNIX only):\n\n    % Kill the process in case the wait is aborted,\n    % e.g. due to a timeout or after-event handler\n\n    wait_with_cleanup(Pid, Status) :-\n\tcatch(\n\t    wait(Pid, Status),\n\t    Tag,\n\t    ( kill(Pid, 2), wait(Pid, _), throw(Tag) )\n\t).\n\nSee Also\n   exec / 2, exec / 3, exec_group / 3, kill / 2, sh / 1"},"system/1":{"prefix":"system","body":"system(${1:ShellCommand})$2\n$0","description":"system(+ShellCommand)\n\n   The string or atom ShellCommand is passed as a command to the operating\nsystem, and the command is executed there (it is a synonym for sh/1).\n\nArguments\n   ShellCommand    String or atom.\n\nType\n   Operating System\n\nDescription\n   Used to send a command ShellCommand to the operating system.  The\n   command uses the streams input, output and error as the UNIX streams\n   stdin, stdout and stderr respectively.  ECLiPSe -specific streams, like\n   null or a string stream, can not be used.\n\nModes and Determinism\n   system(+) is semidet\n\nFail Conditions\n   Fails if the Shell couldn't be executed or if the command returned a non-zero status\n\nExceptions\n     4 --- ShellCommand is not instantiated.\n     5 --- ShellCommand is instantiated, but not to a string or atom.\n\nExamples\n   \nSuccess:\n      [eclipse]: system('ls -F').\n      file1       dir1/\n      yes.\n\n      [eclipse]: system(date).\n      Fri Aug  25 12:00:00 MET DST 1989\n      yes.\n\n      [eclipse]: system(\"cd ..\").\n      yes.\n\n      [eclipse]: system('which eclipse').\n      /home/user/eclipse\n      yes.\n\nError:\n      system(S).    (Error 4).\n      system(40).    (Error 5).\n\nSee Also\n   exec / 2, exec / 3, exec_group / 3, setenv / 2, sh / 1, wait / 2"},"abolish_op/2":{"prefix":"abolish_op","body":"abolish_op(${1:Name}, ${2:Associativity})$3\n$0","description":"abolish_op(+Name, +Associativity)\n\n   Remove the declaration of the visible operator +Name of associativity\nAssociativity.\n\nArguments\n   Name    Atom\n   Associativity       Atom.\n\nType\n   Obsolete\n\nDescription\n   Used to remove the local declaration of the operator Name defined in the\n   caller module or to remove the hiding of a global operator declaration\n   (made with local_op(0, Associativity, Name)) so that the global operator\n   declaration becomes visible again.\n\n   If no operator Name with associativity Associativity is visible from the\n   caller module, error 72 is raised.\n\n   If Associativity is not one of following atoms, a range error is raised:\n\n----------------------------\n xfx    infix\n xfy    infix\n yfx    infix\n fx    prefix\n fy    prefix\n xf    postfix\n yf    postfix\n\nModes and Determinism\n   abolish_op(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Name or Associativity is uninstantiated.\n     5 --- Name is not an atom.\n     5 --- Associativity is not an atom.\n     6 --- Associativity is not a valid associativity name.\n    72 --- there is no operator Name with associativity Associativity    visible from the caller module.\n\nExamples\n   \nSuccess:\n      [eclipse]: op(100, fx, -+-).\n      yes. % defined a global prefix operator\n      [eclipse]: local_op(0, fy, -+-).\n      yes. % hide any global prefix operator\n      [eclipse]: current_op(X, Y, -+-).\n      no (more) solution.\n      [eclipse]: abolish_op(-+-, fy).\n      yes. % remove the hiding\n      [eclipse]: current_op(X, Y, -+-).\n      X = 100\n      Y = fx     More? (;)  % global visible again\n      no (more) solution.\n      [eclipse]: abolish_op(-+-, fx).\n      yes. % remove the global definition\n      [eclipse]: current_op(X, Y, -+-).\n      no (more) solution.\n\nError:\n      abolish_op(X, yfx).    (Error 4)\n      abolish_op(+, X).    (Error 4)\n      abolish_op(\"+\", yfx).       (Error 5)\n      abolish_op(+, 12).    (Error 5)\n      abolish_op(+, fff).    (Error 6)\n      abolish_op(no_op, fx).      (Error 72)\n      local_op(100, fx, +),\n    abolish_op(+, fy).      (Error 72).\n\nSee Also\n   current_op / 3, global_op / 3, op / 3"},"autoload/2":{"prefix":"autoload","body":"autoload(${1:Library}, ${2:ListOfPredSpecList})$3\n$0","description":"autoload(+Library, ++ListOfPredSpecList)\n\n   Declares the predicates in ListOfPredSpec to be autoloading from the module\nLibrary, which is in the file Library.pl in one of the library directories.\n\nArguments\n   Library    Atom.\n   ListOfPredSpecList  of expressions of the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   Declares the predicates in the list ListOfPredSpec as defined in the\n   file Library.  If any of the specified predicates is called, the system\n   looks in the library_path directories for the file Library.pl, compiles\n   it using lib/2 and then re-calls the predicate.  The file is supposed to\n   contain a module_interface/1 or begin_module/1 directive at its\n   beginning but it can be omitted and then Library is used as the module\n   name.\n\n   Predicates declared as autoloaded are always defined as global but note\n   that the module directive in a file erases the module completely so that\n   the autoloaded procedure (and its visibility) are removed completely\n   before being recompiled.  This means that the global declaration must be\n   present in the file.\n\n   The predicate autoload_tool/2 is the same except that all the predicates\n   are declared to be tools, using tool/1.\n\nModes and Determinism\n   autoload(+, ++) is det\n\nExceptions\n     4 --- Library or ListOfPredSpec is not instantiated.\n     5 --- Library is instantiated, but not to an atom.\n     5 --- ListOfPredSpec is instantiated, but not to list a of    expressions of the form Atom/Integer.\n   173 --- Library file Library.pl not found.  (when calling an    autoloaded predicate)\n\nExamples\n   \nSuccess:\n     [eclipse]: get_flag(library_path, Path),\n    get_flag(cwd, Cwd),\n    set_flag(library_path, [Cwd | Path]).\n     Cwd = \"/home/user/\"\n     Path = [\"/usr/local/ECLIPSE/lib\"]\n     yes.\n     [eclipse]: open(\"my_lib.pl\", write, s),\n      write(s, \":- module(my_lib).\\n\"),\n      write(s, \":- global p/0.\\n\"),\n      write(s, \"p :- write(hello).\\n\"),\n    close(s).\n     yes.\n     [eclipse]: autoload(my_lib, [p/0]).\n     yes.\n     [eclipse]: p.  % when p/0 is called, the library is\n    % compiled first, ie. autoloaded.\n     loading the library /home/user/my_lib.pl\n     hello\n     yes.\n     [eclipse]: p.  % p/0 is not an autoloaded pred anymore\n     hello\n     yes.\n\nError:\n     autoload(Lib, [p/0]).    (Error 4).\n     autoload(a_lib, L).    (Error 4).\n     autoload(a_lib, [1]).    (Error 5).\n     autoload(a_lib, p/0).    (Error 5).\n     autoload(\"a_lib\", [p/0]).    (Error 5).\n     autoload(no_file, [p/0]).    (Error 173).\n\nSee Also\n   ensure_loaded / 1, autoload_tool / 2, lib / 1, lib / 2, tool / 1"},"autoload_tool/2":{"prefix":"autoload_tool","body":"autoload_tool(${1:Library}, ${2:ListOfPredSpecList})$3\n$0","description":"autoload_tool(+Library, ++ListOfPredSpecList)\n\n   Declares the predicates in ListOfPredSpec to be autoloading tools from the\nmodule (file) Library.pl.\n\nArguments\n   Library    Atom.\n   ListOfPredSpecList  of expressions of the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   Declares the predicates in the list ListOfPredSpec as tools defined in\n   the file Library.  If any of the specified tools is called, the system\n   looks in the library_path directories for the file Library.pl, compiles\n   it using lib/1  and re-calls the tool.  The file is supposed to contain\n   a module_interface/1 or begin_module/1 directive at its beginning but it\n   can be omitted and then Library is used as the module name.\n\n   The library file Library.pl must contain a tool/2 call for each of the\n   specified predicates.\n\n   Predicates declared as autoloaded are always defined as global but note\n   that the module directive in a file erase the module completely so that\n   the autoloaded procedure (and its visibility) are removed completely\n   before being recompiled.  This means that the global declaration must be\n   present in the file.\n\nModes and Determinism\n   autoload_tool(+, ++) is det\n\nExceptions\n     4 --- Library or ListOfPredSpec is not instantiated.\n     5 --- Library is instantiated, but not to an atom.\n     5 --- ListOfPredSpec is instantiated, but not to a list of    expressions of the form Atom/Integer.\n    62 --- a call to PredSpec has already been compiled before the    tool declaration (``inconsistent procedure redefinition'').\n   173 --- Library file Library.pl not found.  (when calling an    autoloaded predicate)\n\nExamples\n   \nSuccess:\n     [eclipse]: get_flag(library_path, Path),\n    get_flag(cwd, Cwd),\n    set_flag(library_path, [Cwd | Path]).\n     Cwd = \"/home/user/\"\n     Path = [\"/usr/local/ECLIPSE/lib\"]\n     yes.\n     [eclipse]: open(\"my_lib.pl\", write, s),\n    write(s, \":- module(my_lib).\\n\"),\n    write(s, \":- global p/0.\\n\"),\n    write(s, \":- tool(p/0, writeln/1).\"),\n    close(s).\n     yes.\n     [eclipse]: autoload_tool(my_lib, [p/0]).\n     yes.\n     [eclipse]: p.       % when p/0 is called, the library is\n    % compiled first, ie. autoloaded.\n     loading the library /home/user/my_lib.pl\n     eclipse\n     yes.\n     [eclipse]: p.       % p/0 is not an autoloaded pred anymore\n     eclipse\n     yes.\n\nError:\n     autoload_tool(Lib, [p/0]).    (Error 4).\n     autoload_tool(a_lib, L).    (Error 4).\n     autoload_tool(\"a_lib\", [p/0]).    (Error 5).\n     autoload_tool(a_lib, [1]).    (Error 5).\n     autoload_tool(a_lib, p/0).    (Error 5).\n\n     [eclipse]: [user].\n      p :- t. % call compiled before tool declaration\n      user compiled 32 bytes in 0.00 seconds\n     yes.\n     [eclipse]: autoload_tool(a_lib, [t/0]). (Error 62).\n\n     autoload_tool(not_a_file, [p/0]).     (Error 173).\n\nSee Also\n   ensure_loaded / 1, autoload / 2, lib / 1, lib / 2, tool / 1"},"abolish_record/1":{"prefix":"abolish_record","body":"abolish_record(${1:Key})$2\n$0","description":"abolish_record(++Key)\n\n   Remove the local record Key and all its recorded values.\n\nArguments\n   Key    Key specification of the form Name/Arity or just Name.\n\nType\n   Obsolete\n\nDescription\n   Remove the local record Key visible from the caller module and all its\n   recorded values.  If global records are recorded under the key Key, they\n   become visible to that module.\n\n   Key is equal to Key/0.\n\n   If there is no local key declared in the caller module (with\n   local record/1), error 45 is raised.\n\n   Note that abolish_record/1 is used to remove a records completely (even\n   its local declaration) so that a global record (if any) becomes visible\n   whereas erase_all/1 does not remove the local declaration.\n\nModes and Determinism\n   abolish_record(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is not of the form Atom or Atom/Integer.\n    45 --- No local key Key is declared in the caller module.\n\nExamples\n   \nSuccess:\n      [eclipse]: record(type, integer). % global by default\n      yes.\n      [eclipse]: module(beer).\n      [beer]: record(type, string).   % added global\n      yes.\n      [beer]: local record(type).     % define a local\n      yes.\n      [beer]: record(type, lager),\n    record(type, stout).\n      yes.\n      [beer]: recorded(type, X).\n      X = lager     More? (;)\n      X = stout     More? (;)\n      no (more) solution.\n      [beer]: abolish_record(type/0).\n      yes. % the visible is now the global one again\n      [beer]: recorded(type, X).\n      X = integer     More? (;)\n      X = string     More? (;)\n      no (more) solution.\n\nError:\n      abolish_record(X).    (Error 4).\n      abolish_record(123).    (Error 5).\n      local(record(key/3)),\n    abolish_record(key/3),\n    abolish_record(key/3).       (Error 45).\n\nSee Also\n   erase / 2, erase_all / 1, record / 1, record / 2, recorded / 2, recorded / 3"},"b_external/1":{"prefix":"b_external","body":"b_external(${1:PredSpec})$2\n$0","description":"b_external(++PredSpec)\n\n   Declares PredSpec to be a non-deterministic external predicate.\n\nArguments\n   PredSpec    Of the form Atom/Integer (predicate name/arity).\n\nType\n   Obsolete\n\nDescription\n   Declares the (may be not yet visible) predicate PredSpec to be a\n   non-deterministic external predicate.\n\n   This declaration is needed to compile calls to an external predicate\n   before it is actually defined with b_external/2.\n\nModes and Determinism\n   b_external(++) is det\n\nExceptions\n     4 --- PredSpec is not instantiated.\n     5 --- PredSpec is not of the form Atom/Integer.\n    62 --- A call to PredSpec has already been compiled as a    deterministic external call.\n\nExamples\n   \nSuccess:\n\n   % compiling a call to an external before its definition (see description\n   % of b_external/2 for detail on creating external predicates).\n      [eclipse]: [user].\n       :- import sines/2 from trig_lib.\n       :- b_external(sines/2). % declare its call_type\n       p(Values) :- sines(Res, Values), writeln(Res), fail.\n       p(_).\n       user      compiled 216 bytes in 0.03 seconds\n\n   % definition of sines/2 will not raise an inconsistent type definition\n   % thanks to the proper declaration above.\n      [eclipse]: sh(\"cat trig_lib.pl\").\n      :- module(trig_lib).\n      :- load('sin.o', \"-lm\"). % see example in b_external/2\n      :- b_external(sines/2, p_sines).\n      :- export sines/2.\n\n      yes\n      [eclipse]: [trig_lib].\n       trig_lib.pl      compiled 0 bytes in 0.18 seconds\n      yes.\n      [eclipse]: p([0.0,45.0,90.0,270.0]).\n      0.0\n      0.707107\n      1.0\n      -1.0\n      yes.\n\nError:\n      b_external(PredSpec).    (Error 4).\n      b_external(\"p/0\").    (Error 5).\n\n      [eclipse]: [user].\n       :- external(a/0).\n       p :- a.\n       user   compiled 32 bytes in 0.00 seconds\n      yes.\n      [eclipse]: b_external(a/0).     (Error 62).\n\nSee Also\n   external / 1, b_external / 2, external / 2, load / 1"},"b_external/2":{"prefix":"b_external","body":"b_external(${1:PredSpec}, ${2:CName})$3\n$0","description":"b_external(++PredSpec, +CName)\n\n   Defines PredSpec to be a nondeterministic external predicate linked to the\nC function whose system name is CName.\n\nArguments\n   PredSpec    Of the form Atom/Integer (predicate name/arity).\n   CName    Atom or a string.\n\nType\n   Obsolete\n\nDescription\n   Declares the PredSpec to be a non-deterministic Prolog predicate (in the\n   caller module) linked to the ``C'' function whose system name is CName.\n\n   If the visibility of PredSpec is not declared, it is set to local.\n\n   If necessary, an underscore is prepended to CName to get its form as\n   used by the C compiler.\n\n   If a call to PredSpec has already been compiled as a deterministic\n   external call, error 62 is raised (``inconsistent procedure\n   redefinition'').  This can be prevented by defining the external before\n   compiling any call to it or by using the declaration predicate\n   b_external/1.\n\nModes and Determinism\n   b_external(++, +) is det\n\nExceptions\n     4 --- Either PredSpec or CName is not instantiated.\n     5 --- PredSpec is not of the form Atom/Integer.\n     5 --- CName is not an atom or a string.\n    62 --- A call to PredSpec has already been compiled as a    deterministic external call.\n   211 --- External function does not exist.\n\nExamples\n   \n\n   % file to create an external predicate.\n      % cat sin.c\n\n   % external.h contains the macros for the external interface.\n      #include    \"external.h\"\n      #include    <math.h>\n\n      p_sines(vel, tel, vlist, tlist)\n      value    vel, vlist;\n      type    tel, tlist;\n      {\n    pword *p;\n\n    Error_If_Ref(tlist);\n    if (IsNil(tlist))\n    {\n    Fail;\n    }\n    Check_List(tlist);\n    p = vlist.ptr + 1;\n    Dereference(p);\n    Remember(2, p->val, p->tag);\n    Dereference(vlist.ptr);\n    Check_Float(vlist.ptr->tag);\n    Return_Unify_Float(vel, tel,\n      (float)sin(((vlist.ptr->val.real)*3.1415926535)/180.0));\n      }\n\n   % compile with ECLiPSe include files.\n      % cc -c -I/usr/local/ECLIPSE/include sin.c\n      % eclipse\n\n   % load the .o file dynamically into the system with math option.\n      [eclipse]: load('sin.o',\"-lm\").\n      yes.\n\n   % link the object file with a predicate definition.\n      [eclipse]: b_external(sines/2,p_sines).\n      yes.\n\n   % check on existence and flags of sines/2.\n      [eclipse]: get_flag(sines/2, type, T),\n    get_flag(sines/2, call_type, C_type),\n    get_flag(sines/2, visibility, Vis).\n      T = user\n      C_type = b_external\n      Vis = local     More? (;)\n      yes.\n\n   % use sines/2.\n      [eclipse]: sines(E,[0.0,45.0,90.0,270.0]).\n      E = 0.0     More? (;)\n      E = 0.707107     More? (;)\n      E = 1.0     More? (;)\n      E = -1.0     More? (;)\n      no (more) solution.\n\nError:\n      b_external(p/0, S).    (Error 4).\n      b_external(PredSpec, p_pred).   (Error 4).\n      b_external(\"p/0\", p_p0).    (Error 5).\n      b_external(p/0, 123).    (Error 5).\n\n      [eclipse]: [user].\n       :- external(a/0, c_a). % should use b_external/1.\n       p :- a.\n       user   compiled 60 bytes in 0.00 seconds\n      yes.\n      [eclipse]: b_external(a/0, c_a).  (Error 62).\n\n      b_external(mess/1,\"p_messg\").   (Error 211).\n% call load/1,2 first.\n\nSee Also\n   external / 1, external / 2, b_external / 1, load / 1"},"call/2":{"prefix":"call","body":"call(${1:Goal}, ${2:Module})$3\n$0","description":"call(+Goal, +Module)\n\n   Succeeds if Goal (which is visible in module Module) succeeds.\n\nArguments\n   Goal    Atom or compound term.\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   Calls a goal Goal from the module Module.  This predicate is used to\n   call goals whose functors and visibility are known only at the time they\n   are called.  It may be used to implement tool bodies.\n\n   Note that !/0 does not cut through call/2.\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal is not instantiated.\n     4 --- Module is not instantiated.\n     5 --- Goal is neither an atom nor a compound term.\n     5 --- Module is not an atom.\n    68 --- Goal is an undefined procedure in Module.\n\nExamples\n   \nSuccess:\n      [eclipse]: [user].\n       :-module(m).\n       p.\n       user    compiled 28 bytes in 0.00 seconds\n      yes.\n      [eclipse]: p.\n      calling an undefined procedure p in module eclipse\n      [eclipse]: call(p, m).\n      yes.\n\nFail: call(fail, any).\n\nError:\n      call(Var,eclipse).    (Error 4).\n      call(ls,Var).    (Error 4).\n      call(\"write(a)\",eclipse).    (Error 5).\n      call(foo(a),eclipse).    (Error 68).\n\nSee Also\n   call / 1, @ / 2, : / 2"},"begin_module/1":{"prefix":"begin_module","body":"begin_module(${1:Module})$2\n$0","description":"begin_module(+Module)\n\n   Start the definition of the body of the Module.\n\nArguments\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   This is a directive that can occur only in a compiled file.  Module must\n   be an existing, non-locked module.  All following code will be added to\n   the module Module up to the next begin_module/1 or module_interface/1\n   directive or up to the file end.\n\nModes and Determinism\n   begin_module(+) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom.\n    68 --- When called from Prolog.\n    80 --- Module is not a module.\n    82 --- Module is locked.\n\nExamples\n   \nSuccess:\n     [eclipse 2]: [user].\n     :- module_interface(m).\n     :- op(700, xf, there).\n     :- export p/1.\n     :- begin_module(m).\n      p(X) :- writeln(X).\n      user compiled 56 bytes in 0.03 seconds\n     yes.\n     [eclipse 3]: p(hello there).\n     syntax error: postfix/infix operator expected\n     | p(hello there).\n     |    ^ here\n     [eclipse 3]: use_module(m).\n\n     yes.\n     [eclipse 4]: p(hello there).\n     hello there\n\n     yes.\n\nError:\n    begin_module(M).    (Error 4).\n    begin_module(1).    (Error 5).\n    begin_module(a_locked_module).   (Error 82).\n\nSee Also\n   module / 1, create_module / 1, erase_module / 1, current_module / 1, module_interface / 1"},"cancel_after_event/1":{"prefix":"cancel_after_event","body":"cancel_after_event(${1:Event})$2\n$0","description":"cancel_after_event(+Event)\n\n      Cancel all pending instances of after event Event.\n\nArguments\n   Event    Atom\n\nType\n   Obsolete\n\nDescription\n   All instances of the pending after event Event is \n   cancelled so that the event will not be triggered. A pending after event \n   is an event which is setup by either event_after/2, event_after/3 or \n   event_after_every/2, and which is waiting to be raised \n   (event_after_every/2 will always be pending as it is raised repeatedly).\n\n   Note that the processing of an already raised, but as yet unprocessed\n   event will not be cancelled by this predicate. \n\n   This is equivalent to\n\n\tcancel_after_event(Event) :-\n\t    cancel_after_event(Event, [_|_]).\n\nModes and Determinism\n   cancel_after_event(+) is semidet\n\nFail Conditions\n   Fails if Event is not a pending after event\n\nExceptions\n     5 --- Event is not an atom.\n\nExamples\n   \n   setup :-\n      set_event_handler(hi, hi/0),\n      event_after_every(hi, 3.2).\n\n   hi :-\n      writeln(hi).\n\n   kill :-\n      ( cancel_after_event(hi) ->\n    writeln('event cancelled')\n      ;\n    writeln('no event to cancel')\n      ).\n\nSee Also\n   cancel_after_event / 2, event_after / 2, event_after / 3, event_after_every / 2, event / 1, set_event_handler / 2, current_after_events / 1"},"call_explicit/2":{"prefix":"call_explicit","body":"call_explicit(${1:Goal}, ${2:Module})$3\n$0","description":"call_explicit(+Goal, +Module)\n\n   Succeeds if Goal which is defined in module Module succeeds.\n\nArguments\n   Goal    Atom or compound term.\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   This predicate provides a means to override the module system's\n   visibility rules.  While the builtins call/1 and call/2 call the\n   predicate that is visible from a certain module, call_explicit/2 allows\n   to call a predicate which is defined in a certain module.  This allows\n   calling a predicate that is otherwise not visible in the caller module.\n   The most plausible use of this feature is to allow local redefinition of\n   a predicate using the existing definition in the implementation.\n\n   Note that call_explicit can only call exported or global predicates in\n   order to preserve module privacy.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal is not instantiated.\n     4 --- Module is not instantiated.\n     5 --- Goal is neither an atom nor a compound term.\n     5 --- Module is not an atom.\n    68 --- Goal is an undefined procedure in Module.\n\nExamples\n   \nSuccess:\n     [eclipse]: cd(~).\n     system interface error:\n    No such file or directory in cd(~)\n\n     [eclipse]: [user].    % redefine cd/1, using its\n    % original definition\n      cd(~) :- !,\n    getenv('HOME', Home),\n    call_explicit(cd(Home), sepia_kernel).\n      cd(Dir) :-\n    call_explicit(cd(Dir), sepia_kernel).\n\n      [eclipse]: cd(~).\n      yes.\n\nFail:\n      call_explicit(fail, sepia_kernel).\n\nError:\n      call_explicit(Var,eclipse).    (Error 4).\n      call_explicit(ls,Var).    (Error 4).\n      call_explicit(\"write(a)\",eclipse).    (Error 5).\n      call_explicit(foo(a),eclipse).    (Error 68).\n\nSee Also\n   : / 2, call / 1, @ / 2"},"coroutine/0":{"prefix":"coroutine","body":"coroutine","description":"coroutine\n\n   Switches on the coroutine flag, equivalent to set_flag(coroutine, on).\n\nType\n   Obsolete\n\nDescription\n   Used to switch the global coroutine-flag to on.  This causes a subset of\n   the built-in predicates not to raise instantiation faults any longer but\n   to delay instead.  This concerns all sufficiently logical predicates\n   like the arithmetic built-ins, functor/3, arg/3, and many others.\n\nModes and Determinism\n   coroutine is det\n\nExamples\n   \n[eclipse 1]: X>0.\ninstantiation fault in X > 0\n[eclipse 2]: coroutine.\n\nyes.\n[eclipse 3]: X>0.\n\nX = X\n\nDelayed goals:\n    X > 0\nyes.\n\nSee Also\n   set_flag / 2"},"current_after_event/1":{"prefix":"current_after_event","body":"current_after_event(${1:Event})$2\n$0","description":"current_after_event(?Event)\n\n      Check or find currently pending after events (inside handler).\n\nArguments\n   Event    Atom or variable\n\nType\n   Obsolete\n\nDescription\n\n   If Event is an atom, succeeds if Event is a currently pending after\n   event, i.e. an event which is setup by either event_after/2 or\n   event_after_every/2, and which is waiting to be raised\n   (event_after_every/2 will always be pending as it is raised\n   repeatedly). If Event is a variable, then all the currently pending\n   events are returned as a list. An event will appear as many times as it\n   had been setup. \n\n   Note that this predicate can only be called from within an after event \n   handler, i.e. when the timer is paused, and the after event state can be\n   safely examined. An error would be raised otherwise.\n\nModes and Determinism\n   current_after_event(+) is semidet\n   current_after_event(-) is det\n\nFail Conditions\n   Fails if Event is not a pending after event\n\nExceptions\n     1 --- Predicate is called while after events was not frozen.\n     5 --- Event is not an atom or variable.\n\nExamples\n   \n   setup :-\n      set_event_handler(hi, hi/0),\n      event_after_every(hi, 3.2).\n\n   hi :-\n      current_after_event(Es),\n      writeln(hi),\n      writeln('Pending events'-Es).\n\n   :- setup, repeat, fail.  \n   % just spinning after the setup for events to be raised.\n\nSee Also\n   event_after / 2, event_after_every / 2, event / 1, set_event_handler / 2, cancel_after_event / 1"},"dbgcomp/0":{"prefix":"dbgcomp","body":"dbgcomp","description":"dbgcomp\n\n   Tells the compiler to generate code with debug instructions.  Equivalent to\nthe call to set_flag(debug_compile, on).\n\nType\n   Obsolete\n\nDescription\n   Only predicates that have been compiled with debug instructions can be\n   traced by the debugger.\n\n   The generation of debug instruction is switched on by default, and is\n   only switched off using nodbgcomp/0 or else using\n   set_flag(debug_compile, off).  This can be reversed using dbgcomp/0 or\n   else using\n   set_flag(debug_compile, on).\n\n   Predicates that have been compiled without debug instructions cannot be\n   traced by the debugger (only entering and leaving such a predicate can\n   be shown).\n\n   On the other hand, this code uses less space and runs slightly faster\n   than code with debug instructions.  So it makes sense to compile\n   well-tested predicates without debug instructions.\n\n   Note however that predicates with debug instructions that are called by\n   predicates without debug instructions are invisible to the debugger.\n\nModes and Determinism\n   dbgcomp is det\n\nExamples\n   \nSuccess:\n      [eclipse]: dbgcomp, [user].\n       p :- writeln(hello).\n       user compiled 60 bytes in 0.02 seconds.\n      [eclipse]: nodbgcomp, [user].\n       q :- writeln(hello).\n       % generated code is smaller\n       user compiled 44 bytes in 0.00 seconds.\n      [eclipse]: trace.\n      yes.\n      Debugger switched on - creep mode\n      [eclipse]: p.\n    (1) 0  CALL   p (dbg)?- creep\n      B (2) 1  CALL   writeln(hello) (dbg)?- creep\n      hello\n      B (2) 1  EXIT   writeln(hello) (dbg)?- creep\n    (1) 0  EXIT   p (dbg)?- creep\n      yes.\n      [eclipse]: q.\n      N (1) 0  CALL   q (dbg)?- creep  % the inside of q/0\n      hello    % is invisible\n      N (1) 0  EXIT   q (dbg)?- creep  % to the debugger\n      yes.\n\nSee Also\n   pragma / 1, nodbgcomp / 0, get_flag / 2, set_flag / 2"},"char_int/2":{"prefix":"char_int","body":"char_int(${1:Char}, ${2:Integer})$3\n$0","description":"char_int(?Char, ?Integer)\n\n   Succeeds if Integer is the ASCII code of the one-character string Char.\n\nArguments\n   Char    One-character string or variable.\n   Integer    Integer (in the range 0 to 255) or variable.\n\nType\n   Obsolete\n\nDescription\n   If Char is instantiated, converts it to its corresponding ASCII code.\n\n   If Integer is instantiated, converts it to its corresponding\n   one-character string.\n\nModes and Determinism\n   char_int(+, -) is det\n   char_int(-, +) is det\n\nExceptions\n     5 --- Char is instantiated, but not to a 1-character string.\n     5 --- Integer is instantiated, but not to an integer.\n     6 --- Integer is instantiated to an integer outside the range 0 to 255.\n     4 --- Neither Char nor Integer are instantiated (non-coroutine    mode only).\n\nExamples\n   \n   Success:\n   char_int(\"b\",98).\n   char_int(C,99).     (gives C=\"c\").\n   char_int(\"a\",I).    (gives I=97).\n   Fail:\n   char_int(\"a\",98).\n   Error:\n   char_int(C,I).       (Error 4).\n   char_int(\"ab\",I).    (Error 5).\n   char_int('a',I).     (Error 5).\n   char_int(C,'30').    (Error 5).\n   char_int(C,128).     (Error 6).\n\nSee Also\n   char_code / 2, get_char / 1, get_char / 2, put_char / 1, put_char / 2, string_list / 2, string_list / 3"},"current_stream/3":{"prefix":"current_stream","body":"current_stream(${1:Name}, ${2:Mode}, ${3:Stream})$4\n$0","description":"current_stream(-Name, -Mode, ?Stream)\n\n   Succeeds if there is currently an open stream Stream open to the file Name\nin the mode Mode. This predicate is obsolete, use current_stream/1 and\nget_stream_info/3 instead.\n\nArguments\n   Name    Filename (atom or string), contents of string stream    (string) or variable.\n   Mode    One of the atoms read, write, update, string or a variable.\n   Stream    Physical stream number (integer), or a variable.\n\nType\n   Obsolete\n\nDescription\n   Unifies Name with the file name and Mode with the mode of the stream\n   Stream.  If Stream is a variable, it is bound to all open streams on\n   backtracking.\n\n   If the stream is not a file, the Name argument has different\n   meanings:  If it is the user's console, the pseudo file names\n   'user' or 'error' are returned.  If the stream is a string stream,\n   Name returns the current contents of the string stream.\n\n   The following table illustrates the predefined symbolic system streams\n   with the name, mode, and initial physical stream number that they are\n   initially assigned to.\n\n    Logical    Name    Mode    Number\n    input    user    read    0\n    stdin    user    read    0\n    output    user    write   1\n    stdout    user    write   1\n    warning_output  user    write   1\n    log_output      user    write   1\n    error    error    write   2\n    stderr    error    write   2\n    null    null    update  3\n\n   Also see set_stream/2 for details on how to assign a symbolic stream\n   name to a physical stream, or to redirect a symbolic stream name.\n\nModes and Determinism\n   current_stream(-, -, -) is nondet\n   current_stream(-, -, +) is semidet\n\nFail Conditions\n   Fails if Stream is not a stream\n\nExceptions\n     5 --- Name is instantiated, but not to an atom or a string.\n     5 --- Mode is not an atom.\n     5 --- Stream is instantiated, but not to an atom or an integer.\n\nExamples\n   \nSuccess:\n      current_stream(Name,Mode,Stream). % returns all\n    %   open streams.\n\n      [eclipse]: current_stream(error,Mode,Stream).\n      Mode = write\n      Stream = 2      More? (;)\n      yes.\n\n      [eclipse]: open(file,update,s), current_stream(file,M,s).\n      M = update\n      yes.\n\n      [eclipse]: open(F,string(10),f), writeln(f, \"bigstring\"),\n      > current_stream(Data,M,f).\n      F = \"bigstring\\n\"\n      Data = \"bigstring\\n\"\n      M = string\n      yes.\n\nFail:\n      open(file,update,f), current_stream(\"file\",M,f).\n      current_stream(X,no,Y).\n\nError:\n      current_stream(12,Mode,String).     (Error 5).\n\nSee Also\n   current_stream / 1, open / 3, open / 4, get_stream_info / 3"},"current_struct/1":{"prefix":"current_struct","body":"current_struct(${1:Struct})$2\n$0","description":"current_struct(?Struct)\n\n   Succeeds if Struct is a currently visible structure specification.\n\nArguments\n   Struct    Variable or structure.\n\nType\n   Obsolete\n\nDescription\n   Used to retrieve the definition of a defined structure, or to\n   enumerate all visible structure definitions.\n\nModes and Determinism\n   current_struct(+) is semidet\n   current_struct(-) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   There is no declared structure with Struct's functor\n\nExceptions\n     5 --- Struct is neither variable nor structure.\n\nExamples\n   \n    [eclipse 1]: local struct(employee(name,age,salary)).\n    yes.\n\n    [eclipse 2]: current_struct(employee(A,B,C)).\n    A = name\n    B = age\n    C = salary\n    yes.\n\n    [eclipse 3]: Emp = employee{}, current_struct(Emp).\n    Emp = employee(name, age, salary)\n    yes.\n\n    [eclipse 4]: current_struct(S).\n    S = employee(name, age, salary)     More? (;) \n    S = suspend(inst, constrained, bound)\n    yes.\n\nError:\n   current_struct(a).    (Error 5).\n\nSee Also\n   current_struct / 2, local / 1, struct / 1"},"define_macro/3":{"prefix":"define_macro","body":"define_macro(${1:TermClass}, ${2:TransPred}, ${3:Options})$4\n$0","description":"define_macro(++TermClass, ++TransPred, ++Options)\n\n   Defines a macro transformation for the functor or type specified by\nTermClass.  The transformation predicate is TransPred and Options is a list\nof options.\n\nArguments\n   TermClass    Term in the form Atom, Atom/Integer or type(Type).\n   TransPred    Term in the form Atom/Integer.\n   Options    Possibly empty list of option flags.\n\nType\n   Obsolete\n\nDescription\n   This predicate is used to define a macro transformation on a class of\n   terms.  Macro transformation can be performed in two different\n   situations, when a term is read by one of the read predicates (read\n   macros) and when a term is written by one of the write predicates (write\n   macros).\n\n   The TermClass specifies to which terms the transformation will be\n   applied:\n\nName/Arity transform all terms with the specified functor\n\ntype(Type) transform all terms of the specified type, where Type is one of\n    compound, string, integer, rational, float, breal, goal, atom, meta.\n\n   The +TransPred argument specifies the predicate that will perform the\n   transformation.  TransPred must be of arity 2 or 3 and be in the form:\n    trans_function(OldTerm, NewTerm [, Module]):- ... .\n\n   At transformation time, the system will call TransPred in the module\n   where define_macro/3 was invoked.  The term to transform is passed as\n   the first argument, the second is a free variable which should be bound\n   to the transformed term, and the optional third argument is the module\n   where the term is read or written.\n\n   Options is a list which may be empty (in this case the macro defaults to\n   a local read term macro) or contain specifications from the following\n   categories:\n\n  * visibility\n\n    local: The transformation is only visible in this module (default).\n\n    global: The transformation is globally visible.\n\n  * mode\n\n    read: This is a read macro and shall be applied after reading a term\n    (default).\n\n    write: This is a write macro and shall be applied before printing a term.\n\n  * type\n\n    term: Transform all terms (default).\n\n    clause: Transform only if the term is a program clause, i.e.  inside\n    compile/1, assert/1 etc.  Write macros are applied using the 'C'\n    option in the printf/2 predicate.\n\n    goal: Write macros are applied when using the 'G' option in the\n    \tprintf/2 predicate. Note that goal (read) macros are obsolete,\n\tplease use inline/2 instead.\n\n  * additional specification\n\n    protect_arg: Disable transformation of subterms (optional).\n\n    top_only: Consider only the whole term, not subterms (optional).\n\n   A TermClass can have a read and a write macro attached at the same time.\n   By default, macro transformations are local to the module where they\n   were defined.  That means, only read/write built-ins that are called\n   from inside this module do these transformations.  Local macros hide\n   global ones.\n\nModes and Determinism\n   define_macro(++, ++, ++) is det\n\nExceptions\n     4 --- One or more arguments not instantiated.\n     5 --- TermClass not of form Atom, Atom/Integer or type(Type).\n     5 --- TransPred not of form Atom/Integer.\n     5 --- Options not a list or contains invalid flags.\n     6 --- Arity of TransPred is not 2 or 3.\n     6 --- Illegal flag in Options.\n   161 --- Transformation already defined in the current module for    TermClass\n\nExamples\n   \nSuccess:\n   % The following example illustrates how a/1 may be\n   % transformed into b/2 using the reader.\n   [eclipse]: [user].\n    trans_a(a(X),b(X,10)).\n    :-define_macro(a/1,trans_a/2,[]).\n\n   yes.\n   [eclipse]: read(X).\n   > a(fred).\n\n   X = b(fred, 10)\n   yes.\n\n   %\n   % Example showing use of protect_arg\n   %\n   [eclipse]: [user].\n    ?- define_macro(b/1, trb/2, []),\n       define_macro(b_protect/1, trb/2, [protect_arg]),\n       define_macro(d/0, trd/2, []).\n    trb(X, newfunctor(Arg)) :- arg(1, X, Arg).\n    trd(d, newd).\n\n   yes.\n   [eclipse]: read(X1),read(X2).\n   > b(d).\n   > b_protect(d).\n\n   X1 = newfunctor(newd)    % d is transformed\n   X2 = newfunctor(d)       % d is not transformed\n   yes.\n\n   %\n   % Example showing use of type macros\n   %\n    [eclipse 1]: [user].\n     tr_int(0, 0).\n     tr_int(N, s(S)) :- N > 0, N1 is N-1, tr_int(N1, S).\n     :- define_macro(type(integer), tr_int/2, []).\n\n    yes.\n    [eclipse 2]: read(X).\n    3.\n\n    X = s(s(s(0)))\n    yes.\n\n   %\n   % Example showing use of write macros\n   %\n    [eclipse 1]: [user].\n     tr_s(0, 0).\n     tr_s(s(S), N) :- tr_s(S, N1), N is N1+1.\n     :- define_macro(s/1, tr_s/2, [write]).\n\n    yes.\n    [eclipse 2]: write(s(s(s(0)))).\n    3\n    yes.\n\nError:\n   define_macro(X, trx/2, []).    (Error 4).\n   define_macro(a/1, tra/2, [c]).    (Error 6).\n\nSee Also\n   macro / 3, portray / 3, current_macro / 4, erase_macro / 1, phrase / 2, phrase / 3, inline / 2"},"define_error/2":{"prefix":"define_error","body":"define_error(${1:Message}, ${2:N})$3\n$0","description":"define_error(+Message, -N)\n\n   Error number N is newly defined to give the message Message.\n\nArguments\n   Message    String.\n   N    Variable.\n\nType\n   Obsolete\n\nDescription\n   This predicate is used to define new user error types.  Message is a\n   string which is going to be printed when this error occurs (the string\n   returned by error_id/2).  N is bound to the new error number.  The\n   default error handler for the new error is error_handler/2.\n\n   Note that the error numbers should not be hard-coded in subsequent calls\n   to error/2 etc., as the error numbers are arranged at run time and may\n   be changed between releases.\n\nModes and Determinism\n   define_error(+, -) is det\n\nExceptions\n     4 --- Message is not instantiated.\n     5 --- Message is instantiated, but not to a string.\n     5 --- N is instantiated.\n\nExamples\n   \nSuccess:\n      define_error(\"my first error message\",N).  (gives N=340).\n      define_error(\"my second error message\",N). (gives N=341).\n\n      [eclipse]: [user].\n       :- define_error(\"1st arg should be number\",N),\n    setval(usererror, N).\n       do(N,Res) :-(number(N) ->\n    Res is sqrt(N)\n    ;\n    getval(usererror, Err),\n    error(Err, do(N,Res))).\n       user compiled 232 bytes in 0.00 seconds\n      yes.\n      [eclipse]: do(4,2.0).\n      yes.\n      [eclipse]: do(four,2.0).\n      1st arg should be number in do(four, 2.0)\nError:\n      define_error(M,N).    (Error 4).\n      define_error(atom,N).    (Error 5).\n      define_error(\"incorrect module\",340). (Error 5).\n\nSee Also\n   set_event_handler / 2, error_id / 2"},"erase_macro/1":{"prefix":"erase_macro","body":"erase_macro(${1:TransTerm})$2\n$0","description":"erase_macro(+TransTerm)\n\n   Erases the macro definition for TransTerm done in the current module\n\nArguments\n   TransTerm    Term in the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   The macro (either global or local) defined for TransTerm in the current\n   module is erased.  If there was no macro definition, an error is raised.\n\nModes and Determinism\n   erase_macro(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- TransTerm is not instantiated.\n     5 --- TransTerm not of form Atom/Integer.\n   162 --- No macro transformation defined in this module for    TransTerm.\n\nExamples\n   \n   Success:\n   erase_macro(a/1).    (if a macro was defined for a/1)\n   Error:\n   erase_macro(X).      (Error 4).\n   erase_macro(a).      (Error 5).\n   erase_macro(a/1).    (Error 162). % if no macro was defined.\n\nSee Also\n   erase_macro / 2, current_macro / 4, define_macro / 3, phrase / 2, phrase / 3"},"event_create/2":{"prefix":"event_create","body":"event_create(${1:Goal}, ${2:EventHandle})$3\n$0","description":"event_create(+Goal, -EventHandle)\n\n   Create an ECLiPSe event from an arbitrary goal.\n\nArguments\n   Goal    An arbitrary goal\n   EventHandle    A free variable\n\nType\n   Obsolete\n\nDescription\n\tThis creates an event from the goal provided, which can be raised \n\twith the standard event handling predicates (e.g. event / 1, event_after / 2\n\tand event_after_every / 2) using the associated handle.\n    \n\tThe event creation requires non-logical copying of the goal.\n\tAs a result, if the goal contains variables, they lose their identity \n\tand are replaced with fresh ones.\n    \n\tThe intended use of such events are for localised event handling\n\tor when it is necessary to pass ground parameters to the event goal,\n\ti.e. when the use of a global event handler is unnecessary or does not suffice.\n    \n\tIt should be noted that the event handle is the only way to uniquely\n\tidentify a given event.  E.g. if an event has been scheduled as an\n\tafter-event (using event_after/3 or events_after/2), it can only be\n\tcancelled by invoking cancel_after_event/2 with the correct handle.\n    \n\nModes and Determinism\n   event_create(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Goal is not instantiated\n     5 --- Goal is not a valid goal\n     5 --- EventHandle is not a free variable\n\nExamples\n       ?- event_create(writeln('Goodbye cruel world!'), Event),\n    \twriteln('Hello world!'),\n\tevent(Event).\n    Hello world!\n    Goodbye cruel world!\n    Event = 'EVENT'(16'503f0238)\n    Yes (0.00s cpu)\n\n    ?- event_create(writeln('e1'), E1Event),\n\tevent_create(writeln('e2'), E2Event),\n\tevents_after([E1Event-every(0.2), E2Event-0.5]),\n\trepeat, fail.\n    e1\n    e1\n    e2\n    e1\n    e1\n    ^C\n    interruption: type a, b, c, e, or h for help : ? e1\n    abort\n    Aborting execution ...\n    \n\nSee Also\n   event_create / 3"},"errno_id/2":{"prefix":"errno_id","body":"errno_id(${1:N}, ${2:Message})$3\n$0","description":"errno_id(+N, -Message)\n\n   Message is bound to the message string that corresponds to the UNIX message\nfor a system call error when the UNIX errno has the value N.\n\nArguments\n   N    Positive integer.\n   Message    Variable.\n\nType\n   Obsolete\n\nDescription\n   This predicate unifies Message with the string that corresponds to the\n   UNIX message for a system call error when errno has the value N.\n\n   The errors are system dependent.  In SunOS 4.0, there are 89 defined\n   UNIX system call errors.\n\nModes and Determinism\n   errno_id(+, -) is det\n\nExceptions\n     4 --- N is not instantiated.\n     5 --- N is instantiated, but not to an integer.\n     5 --- Message is instantiated.\n\nExamples\n   \nSuccess:\n    % the following sample errors are for SunOS 4.0\n      errno_id(1,M).  (gives M = \"Not owner\").\n      errno_id(2,M).  (gives M = \"No such file or directory\").\n      errno_id(3,M).  (gives M = \"No such process\").\n      errno_id(4,M).  (gives M = \"Interrupted system call\").\n      errno_id(5,M).  (gives M = \"I/O error\").\n      errno_id(6,M).  (gives M = \"No such device or address\").\n      errno_id(89,M). (gives M = \"Remote address changed\").\n      errno_id(90,M). (gives M = \"Unknown system error\").\n    % the latter occurs for all errors greater than 89.\nError:\n      errno_id(N,M).    (Error 4).\n      errno_id(1.0,M).       (Error 5).\n      errno_id(1,\"message\"). (Error 5).\n\nSee Also\n   errno_id / 1"},"event_retrieve/2":{"prefix":"event_retrieve","body":"event_retrieve(${1:EventHandle}, ${2:Goal})$3\n$0","description":"event_retrieve(+EventHandle, -Goal)\n\n   Given the handle with which an event is associated, retrieve the event goal.\n\nArguments\n   EventHandle    An event handle\n   Goal    A free variable or goal to unify\n\nType\n   Obsolete\n\nDescription\n\tThe goal associated with an event handle, created using event_create / 3, is\n\tretrieved using this predicate.\n    \n\tLike event creation, retrieval of the goal produces a copy of the\n\tgoal. As a result, if the goal contains variables, they lose their identity \n\tand are replaced with fresh ones.\n    \n    If the event was disabled, the goal 'true' is retrieved instead of the\n\toriginal goal.\n    \n\nModes and Determinism\n   event_retrieve(+, -) is det\n\nExceptions\n     4 --- EventHandle is un-instantiated\n     5 --- EventHandle is not a handle\n\nExamples\n       ?- event_create(writeln('Hello world!'), [], Event), event_retrieve(Event, EventGoal).\n\n\tEvent = 'EVENT'(16'50421bd0)\n\tEventGoal = writeln('Hello world!')\n\tYes (0.00s cpu)\n    \n\nSee Also\n   event_retrieve / 3"},"flatten_array/2":{"prefix":"flatten_array","body":"flatten_array(${1:Array}, ${2:List})$3\n$0","description":"flatten_array(+Array, -List)\n\n   Returns a flat list of the elements of a multi-dimensional array.\n\nArguments\n   Array    Array.\n   List    List of terms.\n\nType\n   Obsolete\n\nDescription\n   List is unified with a flat list of the elements of the array Array.  The\n   elements are returned in the same order as they would be encountered in a\n   depth-first left-to-right traversal of the array structure.\n\nModes and Determinism\n   flatten_array(+, -) is det\n\nExceptions\n     4 --- Array is a variable.\n     5 --- Array is not an array.\n\nExamples\n   \n?- flatten_array([]([](a,b,c),[](d,e,f)), List).\nList = [a, b, c, d, e, f]\nyes.\n?- flatten_array([](a,b,c), List).\nList = [a, b, c]\nyes.\n?- flatten_array([](a(b),[c,d],[]), List).\nList = [a(b), [c, d], []]\nyes.\n?- flatten_array(Array, List).\ninstantiation fault in flatten_array(Array, List)\nAbort\n?- flatten_array([a,b,c], List).\ntype error in flatten_array([a,b,c], List)\nAbort\n\nSee Also\n   dim / 2, subscript / 3, lists : flatten / 2"},"fail_if/1":{"prefix":"fail_if","body":"fail_if(${1:Goal})$2\n$0","description":"fail_if(+Goal)\n\n   Succeeds if Goal cannot be satisfied.  Uses negation as failure (synonym of\nnot/1 and \\+/1).\n\nArguments\n   Goal    Atom or compound term.\n\nType\n   Obsolete\n\nDescription\n   Used to fail if Goal succeeds.  Uses the standard Prolog form of\n   negation as failure.\n\n   To check whether a call Goal succeeds without binding variables, the\n   call fail_if( fail_if( Goal)) can be used.\n\n   Not that !/0 does not cut through fail_if/1.  Unlike not/1 and \\+/1,\n   fail_if/1 is a protected predicate and cannot be redefined.\n\nModes and Determinism\n   fail_if(+) is semidet\n\nFail Conditions\n   Fails if Goal succeeds\n\nExamples\n   \nSuccess:\n      fail_if(fail).\n      fail_if(1 == 2).\n      fail_if(X == 1).\n      fail_if(fail_if(X = 1)).\n    % does not bind X\n\nFail:\n      fail_if(X = 1).\n      fail_if(true).\n      fail_if(3 == 3).\n\nSee Also\n   \\+ / 1, not / 1, ~ / 1"},"get_error_handler/3":{"prefix":"get_error_handler","body":"get_error_handler(${1:Number}, ${2:PredSpec}, ${3:Module})$4\n$0","description":"get_error_handler(+Number, -PredSpec, -Module)\n\n   Returns the error_handler for error number Number and its home module\nModule.\n\nArguments\n   Number    Integer.\n   PredSpec    Term which unifies with atom/integer.\n   Module    Atom or variable.\n\nType\n   Obsolete\n\nDescription\n   Given the error number Number, PredSpec is unified with the specification\n   (i.e.  a term of the form name/arity) of the current handler for error\n   with number Number; Module is unified with its home module.\n\n   The errors which exist are implementation defined.\n\nModes and Determinism\n   get_error_handler(+, -, -) is det\n\nExceptions\n     4 --- Number is not instantiated.\n     5 --- Number is not an integer.\n     5 --- PredSpec is neither a variable nor of the form Atom/Integer.\n     6 --- Number is not a valid error number.\n\nExamples\n   \nSuccess:\n   [eclipse]: string_list(S,L).\n   instantiation fault in string_list(_g50, _g52)\n   [eclipse]: get_error_handler(4,M,N).\n   M = error_handler/2\n   N = sepia_kernel\n   yes.\n   [eclipse]: set_event_handler(4,true/0), string_list(S,L).\n   > get_error_handler(4,true/0,sepia_kernel).\n   S = _g56\n   L = _g58\n   yes.\nFail:\n   get_error_handler(4, error/2, sepia_kernel).\n\n   [eclipse]: set_event_handler(4,true/0),\n   > get_error_handler(4,error_handler/2,M).\n   no.\nError:\n   get_error_handler(N,true/0,sepia_kernel).   (Error 4).\n   get_error_handler(5,1.2,sepia_kernel).      (Error 5).\n   get_error_handler(5.0,true/0,sepia_kernel). (Error 5).\n   get_error_handler(1000,X, sepia_kernel).    (Error 6).\n   get_error_handler(-1,X,sepia_kernel).       (Error 6).\n   get_error_handler(6,t/0,\"sepia_kernel\").    (Error 6).\n\nSee Also\n   set_event_handler / 2, error / 2, error / 3, error_id / 2"},"delay/2":{"prefix":"delay","body":"delay(${1:Variables}, ${2:Goal})$3\n$0","description":"delay(?Variables, +Goal)\n\n   Delay the Goal on all variables in the term Variables.\n\nArguments\n   Variables    Any Prolog term.\n   Goal    A callable term.\n\nType\n   Obsolete\n\nDescription\n   The specified goal Goal is made a suspended goal such that it will be\n   woken whenever any of the variables in the term Variables is bound (even\n   to another variable).  This predicate is obsolete, a more precise\n   control over suspending and waking is obtained using make_suspension/3\n   and insert_suspension/3,4 and with the suspend.pl library.\n\nModes and Determinism\n   delay(?, +) is det\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is not a callable term.\n    60 --- Goal does not refer to an existing procedure.\n\nExamples\n   \n[eclipse 1]: delay(X, writeln(hello)).\n\nX = X\n\nDelayed goals:\n    writeln(hello)\nyes.\n[eclipse 2]: delay(X, writeln(hello)),\n    writeln(one),\n    X=1,    % causes waking\n    writeln(two).\none\nhello\ntwo\n\nX = 1\nyes.\n[eclipse 3]: delay([X,Y], writeln(X)), X=Y.\nX\n\nX = X\nY = X\nyes.\n\nSee Also\n   suspend / 3, make_suspension / 3, insert_suspension / 3"},"global/1":{"prefix":"global","body":"global","description":"global ++SpecList\n\n   Declares the procedure(s) and other modular items specified by SpecList\nto be global.\n\nArguments\n   SpecList    Sequence of modular item specifications.\n\nType\n   Obsolete\n\nDescription\n   This predicate is obsolete - global visibility is being deprecated.\n   For procedures, use export declarations instead. For other global\n   items, replace them by local ones and, if necessary, provide exported\n   access procedures to manipulate them.\n\n   This predicate was used to declare the visibility of procedures\n   and other names as global. SpecList is a comma-separated list\n   of expressions of the following form:\n\n Name/Arity\n    procedure specification (since global procedures are no longer\n\tsupported, this is now the same as exporting)\n\n variable(Name)\n\tnon-logical variable declaration\n\n reference(Name)\n\treference declaration\n\n array(Name)\n\tuntyped non-logical array declaration\n\n array(Name,Type)\n\ttyped non-logical array declaration\n\n record(Name)\n\trecord key declaration\n\n struct(Prototype)\n\tstructure declaration\n\n op(Prec,Assoc,Name)\n\toperator declaration\n\nmacro(Functor,Transformation,Options)\n\tmacro (input transformation) declaration\n\nportray(Functor,Transformation,Options)\n\tportray (output transformation) declaration\n\n    For backward compatibility, global declarations of variables,\n    references, arrays, records, structures, operators and macros\n    still work. However, global procedure declarations now have the\n    same effect as an export declaration and generate a warning message.\n\nModes and Determinism\n   global(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- SpecList is not instantiated.\n     5 --- SpecList is instantiated, but not to a valid global specification\n    94 --- SpecList is already imported.\n\nExamples\n   \nSuccess:\n\n  [eclipse]: [user].\n   :- global p/1.\n   p(eclipse).\n   user compiled 40 bytes in 0.00 seconds\n  yes.\n  [eclipse]: module(m).\n  [m]: [user].\n   :- local p/1. % can be omitted here since default is local.\n   p(m).\n   user compiled 40 bytes in 0.00 seconds\n  yes.\n  [m]: p(X).\n  X = m\n  yes.\n  [m]: abolish(p/1).\n  yes. % local predicate is abolished, global is visible again\n  [m]: p(X).\n  X = eclipse\n  yes.\n\nError:\n\n  global(Q).    (Error 4).\n  global(\"Pred\").    (Error 5).\n\n  [eclipse]: [user].\n   % :- tool(t/0) here would prevent error 62 in global(t/0) below\n   p :- t.\n   user   compiled 32 bytes in 0.02 seconds\n  yes.\n  [eclipse]: module(m).\n  [m]: [user].\n   :- tool(t/0, writeln/1).\n   :- global(t/0).    (Error 62).\n\n  global(p/0), global(p/0).    (Error 89). (warning)\n  (import p/0 from m), global(p/0). (Error 94).\n  global(true/0).    (Error 95).\n\nSee Also\n   export / 1, import / 1, local / 1"},"get_timer/2":{"prefix":"get_timer","body":"get_timer(${1:Timer}, ${2:Interval})$3\n$0","description":"get_timer(+Timer, -Interval)\n\n   Succeed if the specified Timer is running and sends signals in intervals of\nInterval seconds.\n\nArguments\n   Timer    One of the atoms real, virtual or profile.\n   Interval    A variable or a float number.\n\nType\n   Obsolete\n\nDescription\n   Used to examine the states of the 3 system interval timers.  When the\n   specified timer is switched off, the predicate fails.  Otherwise, the\n   Interval argument is unified with a float number indicating the timer\n   interval in seconds.  The names of the timers are real, virtual and\n   profile.\n\nModes and Determinism\n   get_timer(+, -) is semidet\n\nFail Conditions\n   Fails if the timer is not running\n\nExceptions\n     4 --- Timer is not instantiated.\n     5 --- Timer is not an atom.\n     6 --- Timer is an atom not naming a timer.\n     5 --- Interval neither a variable nor a float number.\n\nExamples\n   \n[eclipse 1]: set_timer(virtual, 9), get_timer(virtual, I).\n\nI = 9.0\nyes.\n[eclipse 2]: set_timer(virtual, 0), get_timer(virtual, I).\n\nno (more) solution.\n\nSee Also\n   event_after / 2, event_after_every / 2, alarm / 1, current_interrupt / 2, sleep / 1, set_interrupt_handler / 2, set_timer / 2"},"get_prompt/3":{"prefix":"get_prompt","body":"get_prompt(${1:InStream}, ${2:Prompt}, ${3:OutStream})$4\n$0","description":"get_prompt(+InStream, -Prompt, -OutStream)\n\n   Succeeds if the prompt for the stream InStream is Prompt and is written to\nthe stream OutStream.\n\nArguments\n   InStream    Integer (stream number) or Atom (reserved or user-defined    symbolic stream name).\n   Prompt    String, atom or variable.\n   OutStream    Variable,Integer or Atom.\n\nType\n   Obsolete\n\nDescription\n   Used to get the prompt Prompt of the input stream InStream which is\n   output to the stream OutStream.\n\n   When new data is to be read from an input stream, the system prints on\n   the specified output stream a prompt, to notify the user.\n\n   InStream (and OutStream, when instantiated) can be a symbolic stream name\n   (atom) or a physical stream number (integer).  InStream must be an\n   existing stream open in read or update mode.  OutStream must be open in\n   write or update mode.\n\n   Note that the prompt for toplevel-input printed by the system at the end\n   of each query is made using the predicate toplevel-prompt/1 and not by\n   using the string set by set_prompt/3.\n\nModes and Determinism\n   get_prompt(+, -, -) is det\n\nExceptions\n     4 --- InStream is not instantiated.\n     5 --- Either InStream or OutStream (or both) is instantiated, but    is neither an atom nor an integer.\n     5 --- Prompt is instantiated, but to neither an atom nor a string.\n   192 --- InStream is not an input stream.\n   192 --- OutStream is not an output stream.\n   193 --- Either InStream or OutStream is an illegal stream    specification (e.g.  does not exist).\n\nExamples\n   \nSuccess:\n    [eclipse]: get_prompt(debug_input,_,input),% find where the\n    % prompt is output;\n    > set_prompt(debug_input,\"> \",input).    % change it\n    yes.    % destructively.\n\n    [eclipse]: read(X).\n    > a.\n    X = a\n    yes.\n    [eclipse]: get_prompt(input, Old, Out),\n    > set_prompt(input, \"Enter a term: \", Out), read(X).\n    Enter a term: a.\n    Old = \"> \"\n    Out = 1\n    X = a\n    yes.\n\n    [eclipse]: get_stream(debug_input,S), % debug input prompt\n    > set_prompt(S, \" DEBUG: \", 1).\n    S = 3\n    yes.\n    [eclipse]: trace.\n    yes.\n    [eclipse]: atom_string(atom, String).\n    B (1) 0  CALL   atom_string(atom, _g52) DEBUG: creep\n    B (1) 0  EXIT   atom_string(atom, \"atom\") DEBUG: creep\n    String = \"atom\"\n    yes.\n\nFail:\n    get_prompt(0,\"\",S).\n\nError:\n    get_prompt(I, \"p\", Stream).  (Error 4).\n    get_prompt(0, Prompt, \"5\").  (Error 5).\n    get_prompt(1, Prompt, 2).    (Error 192). % 1 in write mode\n    get_prompt(0, Prompt, 30).   (Error 193). % no such stream\n\nSee Also\n   set_prompt / 3, get_stream_info / 3"},"is_locked/1":{"prefix":"is_locked","body":"is_locked(${1:Module})$2\n$0","description":"is_locked(+Module)\n\n   Succeeds if the module Module is locked.\n\nArguments\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   Used to test whether the module Module is locked.\n\nModes and Determinism\n   is_locked(+) is semidet\n\nFail Conditions\n   Fails if the module Module is not locked\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is instantiated, but not to an atom.\n    80 --- Module is not a module.\n\nExamples\n   \nSuccess:\n      [eclipse]: create_module(m).\n      yes.\n      [eclipse]: lock(m, \"pass\").\n      yes.\n      [eclipse]: module(m).\n      trying to access a locked module in module(m)\n      [eclipse]: is_locked(m), unlock(m, \"pass\").\n      yes.\n      [eclipse]: is_locked(m).\n      no.\n      [eclipse]: module(m).\n      [m]:\nError:\n      is_locked(M).    (Error 4).\n      is_locked(1).    (Error 5).\n      is_locked(not_a_module).       (Error 80).\n\nSee Also\n   lock / 1, lock / 2, unlock / 2, get_module_info / 3"},"is_built_in/1":{"prefix":"is_built_in","body":"is_built_in(${1:PredSpec})$2\n$0","description":"is_built_in(++PredSpec)\n\n   Succeeds if PredSpec is a system built-in predicate.\n\nArguments\n   PredSpec    Term of the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   Used to test whether PredSpec is a ECLiPSe built-in predicate.\n\n   This predicate only succeeds for a PredSpec which is known to be a\n   built-in.  Undefined Predspec's raise an exception.\n\nModes and Determinism\n   is_built_in(++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if PredSpec is not a built-in predicate\n\nExceptions\n     4 --- PredSpec is not fully instantiated.\n     5 --- PredSpec is not in the format Atom/Integer.\n    60 --- PredSpec is not a defined procedure.\n\nExamples\n   \nSuccess:\n   is_built_in(nl/0).\n   is_built_in(write/1).\n\nFail:\n   is_built_in(append/3). % append/3 is a library\n    % predicate, not a built-in.\nError:\n   is_built_in(X).    (Error 4).\n   is_built_in(a/X).    (Error 4).\n   is_built_in(a).    (Error 5).\n   is_built_in(1).    (Error 5).\n   is_built_in(undefined/0). (Error 60).\n\nSee Also\n   current_built_in / 1, is_predicate / 1, get_flag / 3"},"global_op/3":{"prefix":"global_op","body":"global_op(${1:Precedence}, ${2:Associativity}, ${3:Name})$4\n$0","description":"global_op(+Precedence, +Associativity, ++Name)\n\n   Defines the global operator(s) in Name to have precedence Precedence and\nassociativity Associativity.  If Precedence is 0 then the operator\ndefinition is removed.\n\nArguments\n   Precedence    Integer\n   Associativity       Atom\n   Name    Atom or List of atoms\n\nType\n   Obsolete\n\nDescription\n   Defines Name as an operator of precedence Precedence and associativity\n   Associativity.  Name may be a single operator or a list of operators, in\n   which each is given the specified precedence and associativity.\n\n   The operator is defined to be globally available, ie. visible in every\n   module, unless hidden by a local operator.\n\n   Precedence is an integer in the range 0 to 1200.  If the precedence is 0\n   the definition of the operator is removed.\n\n   Associativity must be one of the following atoms:\n\n xfx    infix\n xfy    infix\n yfx    infix\n fx    prefix\n fy    prefix\n xf    postfix\n yf    postfix\n\n   x represents an argument whose precedence must be lower than that of the\n   operator.  y represents an argument whose precedence must be lower or\n   equal to that of the operator.\n\n   Prefix, infix and postfix operators are independent of each other and\n   may coexist.  See the manual chapter on syntax about how ambiguities are\n   resolved in this case.\n\nModes and Determinism\n   global_op(+, +, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Any of the input arguments is uninstantiated.\n     5 --- Precedence is not an integer.\n     5 --- Name is not an atom or list of atoms.\n     6 --- Precedence is not in range 0 to 1200.\n     6 --- Associativity is not xf, xfx, fy etc.\n    43 --- Multiple definition of postfix and infix for Name.\n\nExamples\n   \nSuccess:\n   [eclipse]: global_op(100,fx,hello).  % define prefix operator\n\n   yes.\n   [eclipse]: read(X).\n   > hello david.    % read using operator\n\n   X = hello david\n   yes.\n   [eclipse]: global_op(200, xfy, -+-),\n    global_op(300, fx, -+-).    % multiple infix/prefix\n\n   yes.\n   [eclipse]: global_op(100,xfx,[a,b,c,d]).  % define list of op's\n\n   yes.\n   [eclipse]: current_op(100,xfx,Y).    % return defined op's\n\n   Y = d     More? (;)\n\n   Y = a     More? (;)\n\n   Y = c     More? (;)\n\n   Y = b     More? (;)    % RETURN pressed\n\n   yes.\n   [eclipse]: global_op(300,xfy,?), global_op(300,yfx,:).\n\n   yes.\n   [eclipse]: display(a ? b ? c), display(a : b : c).\n   ?(a, ?(b, c))    % xfy operator\n\n   :(:(a, b), c)    % yfx operator\n   yes.\n   [eclipse]:\n\nError:\n   global_op(X,fx,aaa).    (Error 4)\n   global_op(a,fx,aaa).    (Error 5)\n   global_op(100,xfx,1).    (Error 5)\n   global_op(100,abc,fred).    (Error 6)\n\n   global_op(100,xfx,aaa),global_op(100,xf,aaa).     (Error 43)\n\nSee Also\n   current_op / 3, op / 3"},"local_record/1":{"prefix":"local_record","body":"local_record(${1:Key})$2\n$0","description":"local_record(++Key)\n\n   Declare the record with key Key to be local to the caller module\n\nArguments\n   Key    Key specification of the form Name/Arity or just Name.\n\nType\n   Obsolete\n\nDescription\n   Declare the record with key Key to be local to the caller module.\n\n   Key is equal to Key/0.\n\nModes and Determinism\n   local_record(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is not of the form Atom or Atom/Integer.\n    44 --- Key is already the key of a local record.\n\nExamples\n   \nSuccess:\n      [eclipse]: module(numbers).\n      [numbers]: local_record(type/0).\n      yes\n      [numbers]: record(type, integer),\n    record(type, real),\n    record(type, fractional).\n      yes.\n      [numbers]: module(beer).\n      [beer]: local_record(type),\n    record(type, lager),\n    record(type, stout).\n      yes.\n      [beer]: recorded(type, Type).\n      Type = lager     More? (;)\n      Type = stout     More? (;)\n      no (more) solution.\n      [beer]: module(numbers).\n      [numbers]: recorded(type, Type).\n      Type = integer     More? (;)\n      Type = real     More? (;)\n      Type = fractional     More? (;)\n      no (more) solution.\n      [numbers]: module(other).\n      [other]: recorded(type, Type).\n      no (more) solution.\n\nError:\n      local_record(X).    (Error 4).\n      local_record(123).    (Error 5).\n      local_record(key/3),\n    local_record(key/3).       (Error 44).\n\nSee Also\n   record / 1, abolish_record / 1, erase / 2, erase_all / 1, record / 2, recorded / 2"},"lib/2":{"prefix":"lib","body":"lib(${1:LibraryName}, ${2:ModuleName})$3\n$0","description":"lib(++LibraryName, +ModuleName)\n\n   The library LibraryName is loaded into the module ModuleName if not loaded\nalready.\n\nArguments\n   LibraryName    String or Atom.\n   ModuleName    Atom.\n\nType\n   Obsolete\n\nDescription\n\n   lib(Lib, Mod) is identical to use_module(library(Lib))@Mod.\n\nModes and Determinism\n   lib(++, +) is det\n\nExceptions\n     4 --- LibraryName is not instantiated.\n     5 --- LibraryName is neither a string nor an atom.\n   173 --- The library file LibraryName cannot be found.\n\nSee Also\n   ensure_loaded / 1, lib / 1, use_module / 1, @ / 2"},"lock/2":{"prefix":"lock","body":"lock(${1:Module}, ${2:Password})$3\n$0","description":"lock(+Module, +Password)\n\n   Locks the access to the module Module, but allow unlocking with the\npassword Password\n\nArguments\n   Module    Atom.\n   Password    String.\n\nType\n   Obsolete\n\nDescription\n   Used to forbid the access to the given module when not using its\n   interface.\n\n   The module can later be unlocked by calling unlock(Module, Password).\n\n   An error is raised (error 82) when trying to re-lock a locked module.\n   It must be unlocked first.\n\nModes and Determinism\n   lock(+, +) is det\n\nExceptions\n     4 --- Module or Password is/are not instantiated.\n     5 --- Module is instantiated, but not to an atom or Password is    instantiated but not to a string.\n    80 --- Module is not a module.\n    82 --- Trying to access a locked module Module.\n\nExamples\n   \nSuccess:\n     [eclipse]: [user].\n      :- module(m).\n      :- export p/0.\n      p :- writeln(hello).\n      user    compiled 60 bytes in 0.00 seconds\n     yes.\n     [eclipse]: lock(m, \"pass\").\n     yes.\n     [eclipse]: module(m).\n     trying to access a locked module in module(m)\n     [eclipse]: import p/0 from m.\n     yes.\n     [eclipse]: p.\n     hello\n     yes.\n     [eclipse]: call(p) @ m.\n     trying to access a locked module in p\n     [eclipse]: unlock(m, \"pass\").\n     yes.\n     [eclipse]: call(p) @ m.\n     hello\n     yes.\n\nError:\n     lock(M, \"pass\").    (Error 4).\n     lock(m, Pass).    (Error 4).\n     lock(1, \"pass\").    (Error 5).\n     lock(not_a_module, \"pass\").    (Error 80).\n     lock(m, \"pass\"), call(p) @ m.    (Error 82).\n     lock(m, \"pass\"), lock(m, \"new_pass\").  (Error 82).\n\nSee Also\n   lock / 0, lock_pass / 1, lock / 1, unlock / 2, get_module_info / 3"},"lock/1":{"prefix":"lock","body":"lock(${1:Module})$2\n$0","description":"lock(+Module)\n\n   Locks the access to the module Module.\n\nArguments\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   Used to forbid the access to the given module when not using its\n   interface.\n\n   It is impossible to unlock a module locked with lock/1.  However, a\n   module locked using lock/2, can still be unlocked with unlock/2.\n\n   An error is raised (error 82) when trying to lock a locked module.\n\nModes and Determinism\n   lock(+) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is instantiated, but not to an atom.\n    80 --- Module is not a module.\n    82 --- Trying to access a locked module Module.\n\nExamples\n   \nSuccess:\n     [eclipse]: [user].\n      :- module(m).\n      :- export p/0.\n      p :- writeln(hello).\n      user compiled 60 bytes in 0.00 seconds\n     yes.\n     [eclipse]: lock(m).\n     yes.\n     [eclipse]: module(m).\n     trying to access a locked module in module(m)\n     [eclipse]: import p/0 from m.\n     yes.\n     [eclipse]: call(p) @ m.\n     trying to access a locked module in p\n     [eclipse]: p.\n     hello\n     yes.\nError:\n     lock(M).    (Error 4).\n     lock(1).    (Error 5).\n     lock(not_a_module).    (Error 80).\n     lock(m), call(p) @ m.      (Error 82).\n\nSee Also\n   lock / 0, lock_pass / 1, lock / 2, unlock / 2, get_module_info / 3"},"make_array/2":{"prefix":"make_array","body":"make_array(${1:Array}, ${2:Type})$3\n$0","description":"make_array(++Array, +Type)\n\n   Creates the global array or global variable Array of type Type.\n\nArguments\n   Array    Atom or ground compound term with integer arguments.\n   Type    Atom, one of float, integer, byte, prolog, global_reference.\n\nType\n   Obsolete\n\nDescription\n   If Array is an atom, a global variable only visible from the caller\n   module is created.  The only type allowed for a global variable is\n   prolog or global_reference.  However a typed gobal variable can be\n   create with make_local_array(a(1), Type) (accessed a a(0)).\n\n   If Array is a compound term, a local array of type Type is created, its\n   dimension is the arity of the term Array and the size of each dimension\n   is specified by the corresponding argument of the term Array.  The sizes\n   must be greater than 0, Type must not be global_reference.\n\n   The elements of Prolog arrays are initialised depending on the type:\n   float, integer, byte and global_reference arrays are initialised with 0\n   values, prolog arrays are initialised with free variables.\n\n   The valid elements indexes in the array range from 0 to the dimension\n   minus one.  For example myarray created with make_array(myarray(3,4,5),\n   integer) contains 60 integers that may be accessed from myarray(0,0,0)\n   to myarray(2,3,4).\n\n   Typed array use less space that untyped (i.e.  prolog) ones.\n\n   Global references access the original term with is variables, other\n   array types store a copy of the term.\n\nModes and Determinism\n   make_array(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either or both of the arguments are not ground.\n     5 --- Array is not an atom or a compound term with integer    arguments.\n     5 --- Type is not an atom.\n     6 --- The ground compound term Array has arguments that are    integers not greater than 0.\n     6 --- Type is not an atom in the above set.\n    42 --- An array with the same name and dimension as Array already    exists.\n\nExamples\n   \nSuccess:\n      make_array(a, prolog).\n      make_array(a(1), integer).\n      make_array(a(4), prolog).\n      make_array(b(2,3), float).\n      make_array(a(2), float),\n    make_array(a(3,2), byte).\n\nError:\n      make_array(a(7), X).    (Error 4).\n      make_array(a(6.0), float).    (Error 5).\n      make_array(a(0), float).    (Error 6).\n      make_array(a(2), atom).    (Error 6).\n      make_array(a(4), float),\n    make_array(a(5), byte).    (Error 42).\n\nSee Also\n   array / 2, current_array / 2, getval / 2, make_array / 1, make_local_array / 1, make_local_array / 2, setval / 2"},"make_array/1":{"prefix":"make_array","body":"make_array(${1:Array})$2\n$0","description":"make_array(++Array)\n\n   Creates the untyped array or global variable Array.\n\nArguments\n   Array    Atom or ground compound term with integer arguments.\n\nType\n   Obsolete\n\nDescription\n   If Array is an Atom, a global variable (visible from all modules where a\n   local one of the same name is not defined) is created.  Its value is\n   initialised to a free variable.\n\n   If Array is a compound term, a global array of type prolog is created,\n   its dimension is the arity of the term Array and the size of each\n   dimension is specified by the corresponding argument of the term Array.\n   The elements of arrays of type prolog are initialised to free variables.\n\nNote\n   make_array(A) is equivalent to make_array(A, prolog).\n\nModes and Determinism\n   make_array(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Array is not ground.\n     5 --- Array is not an atom or structure with integer arguments.\n     6 --- The ground structure Array has arguments that are integers    not greater than 0.\n    42 --- An array with the same name and dimension as Array already    exists.\n\nExamples\n   \nSuccess:\n      make_array(a(4)).\n      make_array(b(2,3)).\n      make_array(a(4)), make_array(a(4,1)).\n      make_array(a), make_array(a(1)).\n\nError:\n      make_array(X).    (Error 4).\n      make_array(a(6.0)).    (Error 5).\n      make_array(a(0)).    (Error 6).\n      make_array(a(-2)).    (Error 6).\n      make_array(a(4)), make_array(a(5)).   (Error 42).\n\nSee Also\n   array / 1, current_array / 2, decval / 1, incval / 1, make_array / 2, make_local_array / 1, make_local_array / 2, getval / 2, setval / 2"},"module_interface/1":{"prefix":"module_interface","body":"module_interface(${1:Module})$2\n$0","description":"module_interface(+Module)\n\n   Create the module Module and start defining its interface.\n\nArguments\n   Module    Atom.\n\nType\n   Obsolete\n\nDescription\n   This is a directive that can occur only in a compiled file.  If Module\n   is an existing module, it is first erased.  Then a new module is created\n   and all following code up to the next begin_module/1 or\n   module_interface/1 directive or the file end defines the interface part\n   of this module.  The module interface can contain both queries and\n   predicate definitions, however usually only those predicates need to be\n   defined in the interface that must be always compiled in order to read\n   the module body.  For instance, macro transformation predicates for\n   macros used in the file must be compiled, otherwise the parser cannot\n   parse the file.  If another module uses this module by means of the\n   use_module/1 predicate, all queries in the module interface except\n   export/1 and global/1 will be executed in that module, and exported\n   predicates will be imported into it.\n\nModes and Determinism\n   module_interface(+) is det\n\nExceptions\n     4 --- Module is not instantiated.\n     5 --- Module is not an atom.\n    68 --- When called from Prolog.\n    82 --- Module is locked.\n\nExamples\n   \nSuccess:\n     [eclipse 2]: [user].\n     :- module_interface(m).\n     :- op(700, xf, there).\n     :- export p/1.\n     :- begin_module(m).\n      p(X) :- writeln(X).\n      user compiled 56 bytes in 0.03 seconds\n     yes.\n     [eclipse 3]: p(hello there).\n     syntax error: postfix/infix operator expected\n     | p(hello there).\n     |    ^ here\n     [eclipse 3]: use_module(m).\n\n     yes.\n     [eclipse 4]: p(hello there).\n     hello there\n\n     yes.\n\nError:\n    module_interface(M).    (Error 4).\n    module_interface(1).    (Error 5).\n    module_interface(a_locked_module).   (Error 82).\n\nSee Also\n   module / 1, begin_module / 1, create_module / 1, erase_module / 1, current_module / 1"},"nodbgcomp/0":{"prefix":"nodbgcomp","body":"nodbgcomp","description":"nodbgcomp\n\n   Tells the compiler to generate code without debug instructions and not to\nretain the source variable names.\n\nType\n   Obsolete\n\nDescription\n   Only predicates that have been compiled with debug instructions can\n   be traced by the debugger.  The generation of debug instruction is\n   switched on by default, and can be switched off globally using\n   nodbgcomp/0 or set_flag(debug_compile, off).  This can be reversed\n   using dbgcomp/0 or set_flag(debug_compile, on).  This global\n   setting can always be overruled on a file-by-file basis using\n   pragma(debug) and pragma(nodebug) respectively. \n\n   Internals of predicates that have been compiled without debug\n   instructions cannot be traced by the debugger (only entering and\n   leaving such a predicate can be shown).  On the other hand, this\n   code uses less space and runs slightly faster than code with debug\n   instructions.  So it makes sense to compile well-tested predicates\n   without debug instructions.  Note however that predicates with\n   debug instructions that are called by predicates without debug\n   instructions are also invisible to the debugger.\n\n   Calling nodbgcomp/0 is equivalent to set_flag(debug_compile, off),\n   set_flag(variable_names, off).\n\nModes and Determinism\n   nodbgcomp is det\n\nExamples\n   \nSuccess:\n      [eclipse]: nodbgcomp, [user], dbgcomp, [user].\n       q :- writeln(hi).\n       user compiled 36 bytes in 0.00 seconds\n       p :- q.\n       user compiled 32 bytes in 0.00 seconds\n      yes.\n      [eclipse]: trace.\n      Debugger switched on - creep mode\n      yes.\n      [eclipse]: p.\n    (1) 0  CALL   p (dbg)?- creep\n      N (2) 1  CALL   q (dbg)?- creep\n      hi\n      N (2) 1  EXIT   q (dbg)?- creep     % call to writeln/1\n    (1) 0  EXIT   p (dbg)?- creep     % invisible to the\n      yes.    % debugger.\n\nSee Also\n   pragma / 1, dbgcomp / 0, get_flag / 2, set_flag / 2, pragma / 1"},"make_local_array/1":{"prefix":"make_local_array","body":"make_local_array(${1:Array})$2\n$0","description":"make_local_array(++Array)\n\n   Creates an array or global variable Array visible only in the caller\nmodule.\n\nArguments\n   Array    Atom or Ground compound term with integer arguments.\n\nType\n   Obsolete\n\nDescription\n   If Array is an atom, a global variable only visible from the caller\n   module is created.  Its value is initialised to a free variable.\n\n   If Array is a compound term, a local array of type prolog is created,\n   its dimension is the arity of the term Array and the size of each\n   dimension is specified by the corresponding argument of the term Array.\n   The elements of arrays of type prolog are initialised to free variables.\n\nNote\n   make_local_array(A) is equivalent to make_local_array(A, prolog).\n\nModes and Determinism\n   make_local_array(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Array is not ground.\n     5 --- Array is not an atom or a structure with integer arguments.\n     6 --- The ground structure Array has arguments that are integers    not greater than 0.\n    42 --- A local array with the same name and dimension as Array    already exists.\n\nExamples\n   \nSuccess:\n      make_local_array(a).\n      make_local_array(a(1)).\n      make_local_array(a(4)).\n      make_local_array(b(2,3)).\n      make_local_array(a(4)), make_local_array(a(4,1)).\n      make_local_array(a), make_local_array(a(1)).\n\nError:\n      make_local_array(X).    (Error 4).\n      make_local_array(a(6.0)).    (Error 5).\n      make_local_array(a(0)).    (Error 6).\n      make_local_array(a(-2)).    (Error 6).\n      make_local_array(a(4)),\n    make_local_array(a(5)).       (Error 42).\n\nSee Also\n   array / 1, current_array / 2, decval / 1, incval / 1, make_array / 1, make_array / 2, make_local_array / 2, getval / 2, setval / 2"},"make_local_array/2":{"prefix":"make_local_array","body":"make_local_array(${1:Array}, ${2:Type})$3\n$0","description":"make_local_array(++Array, +Type)\n\n   Creates an array or global variable Array of type Type visible only in the\ncaller module.\n\nArguments\n   Array    Atom or ground compound term with integer arguments.\n   Type    Atom, one of float, integer, byte, prolog, global_reference.\n\nType\n   Obsolete\n\nDescription\n   If Array is an atom, a global variable only visible from the caller\n   module is created.  The only type allowed for a global variable is\n   prolog or global_reference.  However a typed gobal variable can be\n   create with make_local_array(a(1), Type) (accessed a a(0)).\n\n   If Array is a compound term, a local array of type Type is created, its\n   dimension is the arity of the term Array and the size of each dimension\n   is specified by the corresponding argument of the term Array.  The sizes\n   must be greater than 0, Type must not be global_reference.\n\n   The elements of Prolog arrays are initialised depending on the type:\n   float, integer, byte and global_reference arrays are initialised with 0\n   values, prolog arrays are initialised with free variables.\n\n   The array indexes in the array range from 0 to the dimension minus one.\n   For example myarray create with make_local_array(myarray(3,4,5),\n   integer) contains 60 integers that may be accessed from myarray(0,0,0)\n   to myarray(2,3,4).\n\n   Global references access the original term with is variables, other\n   array types store a copy of the term.\n\nModes and Determinism\n   make_local_array(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either or both of the arguments are not ground.\n     5 --- Array is not an atom or a compound term with integer    arguments.\n     5 --- Type is not an atom.\n     6 --- The ground compound term Array has arguments that are    integers not greater than 0.\n     6 --- Type is not an atom in the above set.\n    42 --- An array with the same name and dimension as Array already    exists.\n\nExamples\n   \nSuccess:\n      make_local_array(a, prolog).\n      make_local_array(a(1), integer).\n      make_local_array(a(4), prolog).\n      make_local_array(b(2,3), float).\n      make_local_array(a(2), float),\n    make_local_array(a(3,2), byte).\n      make_array(a(2,3), integer),\n    make_local_array(a(2,3), integer).\n\nError:\n      make_local_array(a(7), X).    (Error 4).\n      make_local_array(a(6.0), float).    (Error 5).\n      make_local_array(a(0), float).    (Error 6).\n      make_local_array(a(2), atom).    (Error 6).\n      make_local_array(a(4), float),\n    make_local_array(a(5), byte).    (Error 42).\n\nSee Also\n   array / 2, current_array / 2, getval / 2, make_array / 1, make_array / 2, make_local_array / 1, setval / 2"},"name/2":{"prefix":"name","body":"name(${1:Atomnumber}, ${2:List})$3\n$0","description":"name(?Atomnumber, ?List)\n\n   Succeeds if List is the corresponding list of ASCII codes for the atom or\nnumber Atomnumber.\n\nArguments\n   Atomnumber    Atom, number or variable.\n   List    List of integers (each in the range 1 to 127) and/or    variables, or else a variable.\n\nType\n   Obsolete\n\nDescription\n   If Atomnumber is an atom or a number, unifies List with the list of its\n   corresponding ASCII codes.  Real numbers can be any length in decimal\n   format, though fractions are evaluated to 6 decimal places.  The codes\n   are of each character of the atom, or of each digit (or decimal point)\n   of the number.\n\n   If List is instantiated, unifies Atomnumber with the atom or number\n   corresponding to this list of ASCII integers.\n\nModes and Determinism\n   name(+, -) is det\n   name(-, +) is det\n\nExceptions\n     4 --- Neither Atomnumber nor List are ground.\n     5 --- Atomnumber is instantiated, but not to an atom or a number.\n     5 --- List is instantiated, but not to a list.\n     6 --- List is a list containing an integer outside the range 1 to    127.\n\nExamples\n   \n   Success:\n   name(atom,[97,116,111,109]).\n   name(atom,[X,116|T]).    (gives X=97,T=[111,109]).\n   name(/,[47]).\n   name(10,[49,48]).\n   name(20.0,[50,48,46,48]).\n   name(2,[50]).\n   name(+2,L).    (gives L=[50]).\n   name(-2,L).    (gives L=[45,50]).\n   name('1',[0'1]).\n   X is 1/3, name(X,Y).    % X unifies with 0.333333\n   (gives Y=[48,46,51,51,51,51,51,51]).\n   Fail:\n   name(atom,[98,116,111,109]).\n   name('1',B), name(C,B), C='1'. % 1 does not unify with '1'.\n   name(1.0,[0'1,0'.,0'0,0'0]).   % 1.0 is not 1.00\n   Error:\n   name(AN,[1,M]).     (Error 4).\n   name(AN,L).    (Error 4).\n   name(f(1,2),L).     (Error 5).\n   name(AN,[128]).     (Error 6).\n   name(AN,[0]).       (Error 6).\n\nSee Also\n   number_string / 2, atom_string / 2, char_int / 2, integer_atom / 2, string_list / 2, string_list / 3, term_string / 2"},"pathname/2":{"prefix":"pathname","body":"pathname(${1:FilePath}, ${2:Path})$3\n$0","description":"pathname(+FilePath, -Path)\n\n   Succeeds if the pathname FilePath, if stripped of its file name, gives\nPath, the path up to the parent directory of the file.\n\nArguments\n   FilePath    String or atom.\n   Path    Variable or string.\n\nType\n   Obsolete\n\nDescription\n   Used to check if the pathname FilePath, when stripped of its file name,\n   unifies with Path, the path up to the parent directory of the file.\n   pathname(File, Path) is equal to pathname(File, Path, _).\n\nModes and Determinism\n   pathname(+, -) is det\n\nExceptions\n     4 --- FilePath is not instantiated.\n     5 --- FilePath is not a string or atom.\n     5 --- Path is neither a string nor a variable.\n\nExamples\n   \nSuccess:\n      [eclipse]: pathname(\"/home/user/userfile\", P).\n      P = \"/home/user/\"\n      yes.\n\n      pathname(\"/home/user\",\"/home/\").\n      pathname(\"/home/\",\"/home/\").\n      pathname(\"/home\",\"/\").\n      pathname(\"/\",\"/\").\n\nFail:\n      pathname(\"/home/\",\"/\").\n\nError:\n      pathname(F,P).    (Error 4).\n      pathname('/home/user/',P).       (Error 5).\n\nSee Also\n   pathname / 4, pathname / 3, suffix / 2"},"portray_goal/2":{"prefix":"portray_goal","body":"portray_goal(${1:Term}, ${2:TransTerm})$3\n$0","description":"portray_goal(+Term, -TransTerm)\n\n   Apply the goal portray (write macro) transformation to Term\n\nArguments\n   Term    A callable term.\n   TransTerm    A variable or callable term.\n\nType\n   Obsolete\n\nDescription\n    Applies the goal-portray-transformation to Term, if any is visible in the\n    caller module. If no transformation is visible, TransTerm is identical\n    to Term.\n    \n    This predicate is intended mainly for testing purposes, because\n    portray-transformations are normally performed implicitly by the\n    term output predicates write/1,2, writeln/1,2, print/1,2,\n    display/1,2, printf/2,3 or write_term/2,3.  \n    \n    This predicate can defined in terms of portray_term/3 as\n    \n\tportray_goal(Term, TransTerm) :-\n\t    portray_term(Term, TransTerm, goal).\n    \n    and is therefore deprecated.\n\nModes and Determinism\n   portray_goal(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    [eclipse 1]: lib(fd).\n    yes.\n\n    [eclipse 4]: X#>Y, delayed_goals([G]), portray_goal(G, PG)@fd.\n    X = X{[-9999999..10000000]}\n    Y = Y{[-10000000..9999999]}\n    G = gec(X{[-9999999..10000000]}, -1, Y{[-10000000..9999999]}, -1)\n    PG = X{[-9999999..10000000]} - Y{[-10000000..9999999]}#>=1\n\n    Delayed goals:\n\t    X{[-9999999..10000000]} - Y{[-10000000..9999999]}#>=1\n    yes.\n\nSee Also\n   portray_term / 3, expand_goal / 2, portray / 3"},"pipe/2":{"prefix":"pipe","body":"pipe(${1:StreamIn}, ${2:StreamOut})$3\n$0","description":"pipe(?StreamIn, ?StreamOut)\n\n   Creates a pipe and two streams StreamIn and StreamOut to its read and write ends\n\nArguments\n   StreamIn    Atom or variable.\n   StreamOut    Atom or variable.\n\nType\n   Obsolete\n\nDescription\n   Opens a pipe, i.e.  two streams, StreamIn for for reading and StreamOut\n   for writing, which are connected together.  This can be used, for\n   example, to temporarily store data instead of writing it to a file.\n\n   Prolog data Data may be written using write( StreamOut,Data).  Note that\n   in order to read data using read/1,2, it must have been written in\n   Prolog term format (i.e.  ended with a period and a blank space\n   character).  Before reading is possible the output must be flushed with\n   the call flush(StreamOut).\n\n   StreamIn and StreamOut can be symbolic stream names (atom) or variable,\n   in which case they will get instantiated to stream handles.\n\n   Each stream can also be specified as sigio(Stream) (BSD systems only).\n   In this case a pipe is set up and in addition it is instructed to send\n   the signal io each time new data appears in it.  In this way it is\n   possible to set up an interrupt handler that reads the data from the\n   pipe and behaves as a lightweight consumer process.\n\n   Note that when StreamIn is closed, writing to StreamOut will cause\n   signal 13.\n\nModes and Determinism\n   pipe(-, -) is det\n   pipe(+, +) is det\n\nExceptions\n     5 --- Either StreamIn or StreamOut is instantiated, but not to an    atom or a sigio structure.\n   193 --- StreamIn or StreamOut have wrong mode or are equal.\n\nExamples\n   \nSuccess:\n      pipe(a,b).\n\n      [eclipse]: pipe(in, out), printf(out, \"a. %b\", []), read(in, A).\n\n      A = a\n      yes.\nError:\n      pipe(0,1).    (Error 5).\n      pipe(26.9,M).    (Error 5).\n      pipe(output, X).     (Error 193).\n      pipe(a, a).    (Error 193).\n\nSee Also\n   open / 3, open / 4, close / 1, get_stream_info / 3, stream_select / 3"},"reset_error_handler/1":{"prefix":"reset_error_handler","body":"reset_error_handler(${1:Number})$2\n$0","description":"reset_error_handler(+Number)\n\n   Resets the handler for error number Number to its default value.\n\nArguments\n   Number    Integer.\n\nType\n   Obsolete\n\nDescription\n   The error handler for the specified error number is reset to its default\n   value, cancelling any previous redefinition.\n\n   The errors which exist are implementation defined.\n\nModes and Determinism\n   reset_error_handler(+) is det\n\nExceptions\n     4 --- Number is not instantiated.\n     5 --- Number is instantiated, but not to an integer.\n     6 --- Number is not a valid error number.\n\nExamples\n   \nSuccess:\n      [eclipse]: string_list(S,L).\n      instantiation fault in string_list(_g50, _g52)\n      [eclipse]: set_error_handler(4,true/0), string_list(S,L).\n      S = _g56\n      L = _g58\n      yes.\n      [eclipse]: reset_error_handler(4), string_list(S,L).\n      instantiation fault in string_list(_g62, _g64)\n\nError:\n      reset_error_handler(N).    (Error 4).\n      reset_error_handler(5.0).  (Error 5).\n      reset_error_handler(1000). (Error 6).\n\nSee Also\n   reset_event_handler / 1"},"schedule_woken/1":{"prefix":"schedule_woken","body":"schedule_woken(${1:SuspList})$2\n$0","description":"schedule_woken(++SuspList)\n\n   Pass the suspension list SuspList to the waking scheduler.\n\nArguments\n   SuspList    Suspension list or difference list or variable\n\nType\n   Obsolete\n\nDescription\n   Suspensions in ECLiPSe are executed in two stages:  first the suspension\n   is processed by the waking scheduler which puts it into a global\n   priority list where it waits until the wake/0 predicate is called by a\n   predicate which is running with lower priority than the priority of the\n   suspension.  The predicate schedule_woken/1 is the interface to the\n   waking scheduler.  It accepts a list or a difference list of\n   suspensions.  Executed suspensions are ignored, sleeping suspensions are\n   inserted into the corresponding priority list.\n\nModes and Determinism\n   schedule_woken(++) is det\n\nExceptions\n     5 --- SuspList is not a list nor a difference list nor free.\n\nExamples\n   \n[eclipse 1]: make_suspension(writeln(hello), 1, S),\n    schedule_woken([S]), wake.\nhello\n\nS = 'WOKEN GOAL'\nyes.\n[eclipse 2]: make_suspension(writeln(hello), 255, S),\n    schedule_woken([S]), wake.\n\nS = 'GOAL'(writeln(hello), eclipse)\n\nDelayed goals:\nwriteln(hello)\nyes.\n\nSee Also\n   schedule_suspensions / 2, insert_suspension / 3, insert_suspension / 4, is_suspension / 1, suspension_to_goal / 3, wake / 0"},"retract_all/1":{"prefix":"retract_all","body":"retract_all(${1:Head})$2\n$0","description":"retract_all(+Head)\n\n   Removes from the database all clauses whose heads match Head\n\nArguments\n   Head    Atom, variable or compound term.\n\nType\n   Obsolete\n\nDescription\nAn obsolete synonym for retractall/1.\n\nModes and Determinism\n   retract_all(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Head is not instantiated\n     5 --- Head is not a callable term\n    63 --- Procedure is not dynamic\n    70 --- Procedure is undefined\n\nSee Also\n   retractall / 1"},"set_error_handler/2":{"prefix":"set_error_handler","body":"set_error_handler(${1:Number}, ${2:PredSpec})$3\n$0","description":"set_error_handler(+Number, ++PredSpec)\n\n   Set an error handler PredSpec for the error with number Number.\n\nArguments\n   Number    Integer.\n   PredSpec    Term of the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   Assigns the procedure specified by PredSpec (specified as name/arity) as\n   the error handler for the error whose number is given by Number.\n\n   An error handler such as PredSpec can have 3 optional arguments:  the\n   1st argument is the number of the error; the 2nd argument is the culprit\n   (a structure corresponding to the call which caused it); the 3rd is the\n   caller module or a free variable (if the module is unknown).  The error\n   handler is free to use less than 3 arguments.\n\n   The errors which exist are implementation defined.\n\nModes and Determinism\n   set_error_handler(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Either Number or PredSpec is not instantiated.\n     5 --- Number is not an integer.\n     5 --- PredSpec is not of the form Atom/Integer.\n     6 --- Number is not a valid error number.\n     6 --- PredSpec is of the form Atom/Integer, but the integer is    greater than 3.\n    60 --- PredSpec is of the form Atom/Integer, but no such predicate    has been defined.\n\nExamples\n   \nSuccess:\n      [eclipse]: string_list(S,L).\n      instantiation fault in string_list(_g50, _g52)\n      [eclipse]: get_error_handler(4,M,N).\n      M = error_handler/2\n      N = sepia_kernel\n      yes.\n      [eclipse]: set_error_handler(4,true/0), string_list(S,L).\n      S = _g56\n      L = _g58\n      yes.\n\n      [eclipse]: [user].\n       a :- write(warning_output, \"typo\"), fail.\n       user compiled 100 bytes in 0.03 seconds\n      [eclipse]: set_error_handler(5,a/0).\n      yes.\n      [eclipse]: atom_length(\"atom\",L).\n      typo\n      no.\n\nError:\n      set_error_handler(N,true/0).   (Error 4).\n      set_error_handler(5,P).    (Error 4).\n      set_error_handler(5.0,true/0). (Error 5).\n      set_error_handler(1000,X).     (Error 6).\n      set_error_handler(-1,X).       (Error 6).\n      set_error_handler(6,a/4).      (Error 6).  % arity > 3.\n      set_error_handler(6,t/2).      (Error 60). % no t/2.\n\nSee Also\n   set_event_handler / 2, get_error_handler / 3"},"select/3":{"prefix":"select","body":"select(${1:StreamList}, ${2:Timeout}, ${3:ReadyStreams})$4\n$0","description":"select(++StreamList, +Timeout, -ReadyStreams)\n\n   Obsolete synonym for stream_select/3\n\nArguments\n   StreamList    A list of atoms or integers.\n   Timeout    A number or an atom.\n   ReadyStreams    A term unifiable with a list of integers and atoms.\n\nType\n   Obsolete\n\nModes and Determinism\n   select(++, +, -) is det\n\nSee Also\n   stream_select / 3"},"set_timer/2":{"prefix":"set_timer","body":"set_timer(${1:Timer}, ${2:Interval})$3\n$0","description":"set_timer(+Timer, +Interval)\n\n   Start (or stop) the specified Timer to send signals in intervals of\nInterval seconds.\n\nArguments\n   Timer    One of the atoms real, virtual or profile.\n   Interval    Number (integer or float)\n\nType\n   Obsolete\n\nDescription\n   Used to initialise one of the 3 operating system's interval timers.\n   After a call to this predicate, the corresponding timer will start\n   sending signals to the ECLiPSe process every Interval seconds.  Every\n   call will change the previous interval of the specified timer.  A timer\n   is switched off by setting its Interval to 0.\n\n    -----------------\n    |Timer   |Signal |\n    -----------------\n    |real    |alrm   |\n    |virtual |vtalrm |\n    |profile |prof   |\n    -----------------\n\nModes and Determinism\n   set_timer(+, +) is det\n\nExceptions\n     4 --- Timer orInterval is not instantiated.\n     5 --- Timer is not an atom.\n     5 --- Interval is not integer or float.\n     6 --- Timer is an atom not naming a timer.\n   170 --- Interval is an out of range timer interval.\n\nExamples\n   \n[eclipse]: [user].\n handler(N) :-\n    getval(count, Count),\n    writeln(signal(N)-Count),\n    ( Count > 0 ->\n    decval(count)\n    ;\n    set_timer(real, 0)      % switch off the timer\n    ).\n\n :- set_interrupt_handler(alrm, handler/1).\n user       compiled traceable 372 bytes in 0.00 seconds\n\nyes.\n[eclipse]: setval(count, 4), set_timer(real, 0.5).\n\nyes.\n[eclipse]: signal(14) - 4\nsignal(14) - 3\nsignal(14) - 2\nsignal(14) - 1\nsignal(14) - 0\n\nSee Also\n   event_after / 2, event_after_every / 2, alarm / 1, current_interrupt / 2, get_timer / 2, sleep / 1, set_interrupt_handler / 2"},"set_suspension_priority/2":{"prefix":"set_suspension_priority","body":"set_suspension_priority(${1:Susp}, ${2:Priority})$3\n$0","description":"set_suspension_priority(+Susp, +Priority)\n\n   Change the priority of the suspended goal Susp to Priority.\n\nArguments\n   Susp    A variable\n   Priority    A small integer\n\nType\n   Obsolete\n\nDescription\n   Every suspended goal has an associated priority. The initial priority\n   is specified when the suspension is created with make_suspension/3.\n   The priority can be changed anytime, but when the suspension has\n   already been scheduled for execution (by schedule_suspensions/2),\n   the change has no effect on this already scheduled execution.\n\n   Changing priorities is most useful for demons (where the same\n   suspension is used for arbitrary many wakings) and where one might\n   like to vary its urgency. Typically, the cheaper a goal is, and\n   the more likely it is to fail or to produce useful information,\n   the higher should it priority be. However, the relative priorities\n   of other suspended goals must be kept in mind as well.\n\n   Note that a suspension is not a standard Prolog data structure and can\n   only be manipulated in a restricted way.\n\nModes and Determinism\n   set_suspension_priority(+, +) is det\n\nExceptions\n     4 --- Susp or Priority are not instantiated.\n     5 --- Susp is not a live suspension or Priority is not an integer.\n     6 --- Priority is not a valid priority.\n\nExamples\n   \n\nSee Also\n   set_suspension_data / 3, demon / 1, is_suspension / 1, kill_suspension / 1, make_suspension / 3, schedule_suspensions / 2, suspension_to_goal / 3"},"suffix/2":{"prefix":"suffix","body":"suffix(${1:FileName}, ${2:Suffix})$3\n$0","description":"suffix(+FileName, -Suffix)\n\n   Succeeds if the string Suffix is the extension part of the input string\nFileName.\n\nArguments\n   FileName    String or atom.\n   Suffix    String or variable.\n\nType\n   Obsolete\n\nDescription\n   Used to find the extension (i.e.  suffix) Suffix of the input string\n   file name FileName.  FileName is a string of a (relative or absolute)\n   file pathname.  Suffix includes the leading ``.''.\n\nModes and Determinism\n   suffix(+, -) is det\n\nExceptions\n     4 --- FileName is not instantiated.\n     5 --- FileName is not a string or atom.\n     5 --- Suffix is neither a string nor a variable.\n\nExamples\n   \nSuccess:\n      suffix(\"a.b\",\".b\").\n      suffix(\"dead.letter\",\".letter\").\n      suffix(\"top.pl\",S).    (gives S=\".pl\").\n      suffix(\"bugs\",S).    (gives S=\"\").\n      suffix(\"../my.pl\",S).    (gives S=\".pl\").\n      suffix(\"../user/my.c\",S).    (gives S=\".c\").\n      suffix(\"/home/user/pl/.trace\",S).  (gives S=\".trace\").\n\nFail:\n      suffix(\"file.pl\",\".c\").\n\nError:\n      suffix(F,S).    (Error 4).\n      suffix('file1.pl',S).    (Error 5).\n      suffix(\"file1.pl\",'.pl').    (Error 5).\n\nSee Also\n   pathname / 4, pathname / 2"},"current_record/1":{"prefix":"current_record","body":"current_record(${1:Key})$2\n$0","description":"current_record(?Key)\n\n   Succeeds if Key is the key of a recorded item.\n\nArguments\n   Key    Variable, atom, compound term, or handle.\n\nType\n   Recorded Database\n\nDescription\n   Used to backtrack over the keys currently recorded in the indexed\n   database.  Key must be either a variable, an atom or a compound term.\n   In the case of compound terms, all keys of the same name and arity are\n   treated as equal.\n\nModes and Determinism\n   current_record(+) is semidet\n   current_record(-) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Key is not a current key\n\nExceptions\n     5 --- Key is neither a variable, an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(whiskey,jameson),\n   >    record(whiskey,bushmills),\n   >    record(beer,lowenbrau),\n   >    record(car(bmw), 735).\n   yes.\n   [eclipse]: current_record(Key).\n   Key = beer     More? (;)\n   Key = whiskey     More? (;)\n   Key = car(_g62)     More? (;)\n   no (more) solution.\n   Fail:\n   record(whiskey,bushmills),current_record(bushmills).\n   Error:\n   current_record(1).    (Error 5)\n   current_record(\"whiskey\").    (Error 5)\n\nSee Also\n   is_record / 1"},"erase/1":{"prefix":"erase","body":"erase(${1:DBRef})$2\n$0","description":"erase(+DBRef)\n\n   Succeeds if the database reference DBRef designates a term recorded in the\nindexed database and this term is successfully erased.\n\nArguments\n   DBRef    A database reference.\n\nType\n   Recorded Database\n\nDescription\n   The database reference DBRef must refer to a term that has been recorded\n   in the indexed database.  Database references can be obtained from the\n   predicates recorda/3, recordz/3 and recorded/3.  If the referenced term\n   has already been erased, erase/1 fails.  Backtracking through calls of\n   erase/1 does not undo an erasure.  Note that an erased term can still\n   be retrieved via the database reference, but it can no longer be found\n   by lookup under the recording-key.\n\nModes and Determinism\n   erase(+) is semidet\n\nFail Conditions\n   Fails if DBRef refers to an already erased record\n\nExceptions\n     4 --- DBRef is not instantiated.\n     5 --- DBRef is not a database reference.\n\nExamples\n   \n   Success:\n   [eclipse]: recordz(whiskey, jameson, _),\n   recordz(whiskey, glenfiddich, Ref),\n   recordz(whiskey, dimple, _),\n   erase(Ref).\n   Ref = 'DBREF'(16'50470d28)\n   yes.\n   [eclipse]: recorded(whiskey, L, _).\n   L = jameson     More? (;)\n   L = dimple     More? (;)\n   no (more) solution.\n   Fail:\n   [eclipse]: recorded(whiskey,_,R), !, erase(R), erase(R).\n   no (more) solution.\n   Error:\n   erase(Var).    (Error 4)\n   erase(123).    (Error 5)\n\nSee Also\n   erase_all / 1, is_handle / 1, recorda / 3, recordz / 3, recorded / 3, referenced_record / 2"},"suspension_to_goal/3":{"prefix":"suspension_to_goal","body":"suspension_to_goal(${1:Susp}, ${2:Goal}, ${3:Module})$4\n$0","description":"suspension_to_goal(+Susp, -Goal, -Module)\n\n   Succeeds for an unwoken suspension and returns the corresponding Goal\nstructure and caller module.\n\nArguments\n   Susp    A suspension.\n   Goal    A variable or a callable term.\n   Module    A variable or a module.\n\nType\n   Obsolete\n\nDescription\n   This built-in is used to access the contents of the abstract suspension\n   data type.  It is complementary to make_suspension/2 as it returns the\n   original goal structure and the module where make_suspension/2 was\n   executed.  If applied to an already woken suspension it fails.\n\n   Note that a suspension is not a standard Prolog data structure and can\n   only be manipulated in a restricted way.  In particular, a suspension is\n   not a term with functor 'GOAL' or 'WOKEN GOAL' although it is printed\n   this way by default.  suspension_to_goal/3 is the only way to access the\n   contents of a suspension.\n\nModes and Determinism\n   suspension_to_goal(+, -, -) is semidet\n\nFail Conditions\n   Fails if the suspension is already dead\n\nExceptions\n     4 --- Susp is not instantiated.\n     5 --- Susp is not a suspension.\n     5 --- Goal is neither variable nor a callable term.\n     5 --- Module is neither variable nor atom.\n\nExamples\n   \n[eclipse 1]: make_suspension(writeln(hello),S),\n    suspension_to_goal(S, Goal, Module).\nS = 'GOAL'(writeln(hello), eclipse)\nGoal = writeln(hello)\nModule = eclipse\nDelayed goals:\n    writeln(hello)\nyes.\n[eclipse 2]: make_suspension(writeln(hello),S),\n    call_suspension(S),\n    suspension_to_goal(S, Goal, Module).\nhello\n\nno (more) solution.\n\nSee Also\n   get_suspension_data / 3, delayed_goals / 1, kill_suspension / 1, make_suspension / 3"},"erase_all/1":{"prefix":"erase_all","body":"erase_all(${1:Key})$2\n$0","description":"erase_all(+Key)\n\n   All the the values associated with key Key are removed from the indexed\ndatabase.\n\nArguments\n   Key    An atom, compound term or handle.\n\nType\n   Recorded Database\n\nDescription\n   Used to remove all entries from the indexed database with the associated\n   key Key.  In the case of compound terms, all keys of the same name and\n   arity are treated as equal.\n\nModes and Determinism\n   erase_all(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is uninstantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(whiskey,jameson),\n   >    record(whiskey,bushmills),\n   >    record(whiskey,glenfiddich),\n   >    record(whiskey,dimple).\n   yes.\n   [eclipse]: erase_all(whiskey).\n   yes.\n   [eclipse]: recorded(whiskey,L).\n   no (more) solution.\n   Error:\n   erase_all(Key).    (Error 4)\n   erase_all(\"key\").    (Error 5)\n   erase_all(1).    (Error 5)\n\nSee Also\n   erase / 2"},"erase/2":{"prefix":"erase","body":"erase(${1:Key}, ${2:Value})$3\n$0","description":"erase(+Key, ?Value)\n\n   Succeeds if the term Value associated with key Key is removed as an entry\nin the indexed database.\n\nArguments\n   Key    Atom, compound term, or handle.\n   Value    Any Prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Finds the first term associated with Key that can be unified with Value\n   and removes its entry from the indexed database.  It fails if such an\n   entry cannot be found.  If Value is uninstantiated, the first value\n   under the key Key is removed.  In the case of compound terms, all keys\n   of the same name and arity are treated as equal.  Backtracking through\n   calls of erase/2 does not undo an erasure.\n\nModes and Determinism\n   erase(+, +) is semidet\n   erase(+, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Value does not unify with any term recorded under the key Key\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(whiskey,jameson),\n   >    record(whiskey,bushmills),\n   >    record(whiskey,glenfiddich),\n   >    record(whiskey,dimple).\n   yes.\n   [eclipse]: erase(whiskey,dimple),erase(whiskey,Value).\n   Value = jameson\n   yes.\n   [eclipse]: recorded(whiskey,L).\n   L = bushmills     More? (;)\n   L = glenfiddich     More? (;)\n   no (more) solution.\n   Fail:\n   erase(whiskey,jameson).\n   Error:\n   erase(Key,anything).    (Error 4)\n   erase(\"whiskey\",anything).    (Error 5)\n\nSee Also\n   erase_all / 1"},"record/2":{"prefix":"record","body":"record(${1:Key}, ${2:Value})$3\n$0","description":"record(+Key, ?Value)\n\n   Records the term Value at the end of key Key in the indexed database.\n\nArguments\n   Key    An atom, compound term, or handle.\n   Value    Any prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Used to record any prolog term Value at the end of the indexed database\n   entry associated with the key Key.  A synonym for recordz/2.  In the\n   case of compound terms, all keys of the same name and arity are treated\n   as equal.\n\n   If backtracking occurs through the call of record/2 the associated Value\n   is not removed from the indexed database.  Recording the same Value\n   twice results in two identical entries in the indexed database.  All\n   variables are recorded according to their internal representations.\n\nModes and Determinism\n   record(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n    record(a(compound,term),value1).\n    record([a,different,term],value2).\n\n    [eclipse]: record(whiskey,jameson),\n    >    record(whiskey,glenlivet),\n    >    record(whiskey,bushmills).\n    yes.\n    [eclipse]: recorded(whiskey,Value).\n    Value = jameson     More (;)\n    Value = glenlivet     More (;)\n    Value = bushmills     More (;)\n    no (more) solution.\nError:\n    record(Key, anything).    (Error 4)\n    record(\"key\",anything).    (Error 5)\n\nSee Also\n   recorda / 2, recordz / 2"},"tool/1":{"prefix":"tool","body":"tool(${1:PredSpec})$2\n$0","description":"tool(++PredSpec)\n\n   Declares PredSpec as a tool interface procedure.\n\nArguments\n   PredSpec    Expression of the form Atom/Integer.\n\nType\n   Obsolete\n\nDescription\n   Informs the system that the (may be not yet visible) procedure PredSpec\n   is a tool interface procedure.  Normally, tool(PredSpecI, PredSpecB) is\n   used to define a tool interface procedure and declare its body.\n   However, if PredSpecI is not yet declared as a tool and if the system\n   has already compiled some calls to it, the tool/2 declaration will cause\n   an error since the system cannot provide the caller's home module for\n   calls which are already compiled.\n\n   Therefore, when there are modules which are compiled before the tool/2\n   declaration but which call PredSpecI, tool/1 should be used before the\n   first call to inform the system that this is a tool interface procedure.\n\nModes and Determinism\n   tool(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- PredSpec is not instantiated.\n     5 --- PredSpec is instantiated, but not to an expression of the    form Atom/Integer.\n    62 --- A call to PredSpec has already been compiled before the    tool declaration (``inconsistent procedure redefinition'').\n\nExamples\n   \nSuccess:\n      [eclipse]: tool(list_name/1). % declare as tool\n    % procedure before\n      yes.    % compiling calls to it.\n      [eclipse]: [user].\n       p :- list_name(p).\n       user compiled 52 bytes in 0.00 seconds\n      yes.\n      [eclipse]: tool_body(current_predicate/1,P,M),\n    (import P from M).\n      P = current_predicate_body / 2\n      M = sepia_kernel\n      yes.\n      [eclipse]: tool(list_name/1,list_name_body/2).\n      yes.\n      [eclipse]: [user].\n       :- export list_name/1.\n       list_name_body(Name, Module) :-\n    current_predicate_body(Name/A, Module),\n    writeln(Name/A),\n    fail.\n       list_name_body(_, _).\n       user compiled 260 bytes in 0.03 seconds\n      yes.\n      [eclipse]: module(m).\n      [m]: [user].\n       p(a,b,c,d,e).\n       user compiled 84 bytes in 0.00 seconds\n      yes.\n      [m]: import list_name/1 from eclipse.\n      yes.\n      [m]: list_name(p).\n      p / 5\n      yes.\n      [m]: module(eclipse).\n      [eclipse]: list_name(p).\n      p / 0\n      yes.\n\nError:\n      tool(L).    (Error 4).\n      tool(list_name).    (Error 5).\n      tool(list_name/n).  (Error 5).\n\n      [eclipse]: [user].\n       p :- t. % call compiled before tool declaration\n       user compiled 32 bytes in 0.00 seconds\n      yes.\n      [eclipse]: tool(t/0). (Error 62).\n\nSee Also\n   tool / 2, tool_body / 3"},"is_record/1":{"prefix":"is_record","body":"is_record(${1:Key})$2\n$0","description":"is_record(+Key)\n\n   Succeeds if Key is a key of a recorded item.\n\nArguments\n   Key    An atom, compound term or handle.\n\nType\n   Recorded Database\n\nDescription\n   Used to test whether Key is a key of a recorded item.  Fails if Key is\n   not a key for a recorded item.  In the case of compound terms, all keys\n   of the same name and arity are treated as equal.\n\nModes and Determinism\n   is_record(+) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Key is not a key for a recorded item\n\nExceptions\n     4 --- Key is uninstantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(whiskey,jameson),\n   >    record(whiskey,bushmills),\n   >    record(beer,lowenbrau).\n   yes.\n   [eclipse]: is_record(whiskey).\n   yes.\n   [eclipse]: is_record(beer).\n   yes.\n   Fail:\n   [eclipse]: is_record(wine).\n   no.\n   Error:\n   is_record(Key).    (Error 4)\n   is_record(\"whiskey\").    (Error 5)\n\nSee Also\n   current_record / 1, record / 1"},"record_create/1":{"prefix":"record_create","body":"record_create(${1:Handle})$2\n$0","description":"record_create(-Handle)\n\n   Create an anonymous record handle\n\nArguments\n   Handle    Variable, will be bound to a handle.\n\nType\n   Recorded Database\n\nDescription\n\n    \tThis creates an anonymous 'record' object which can store an\n\tordered list of terms, and whose contents are unaffected by\n\tbacktracking.\n\n\tRecords can be referred to either by handle or by name. Whenever\n\tpossible, handles should be used, because this naturally leads to\n\trobust, reentrant code, and avoids the danger of memory leaks.\n\tAn anonymous record disappears when the system backtracks over\n\tits creation, when the record handle gets garbage collected,\n\tor when it is explicitly destroyed.\n\n\tWhen named records are used, the visibility of the record name is\n\tlocal to the module where it was created. A named record never\n\tdisappears, therefore, in order to free the associated memory,\n\tits contents should be erased when no longer needed.\n    \n\nModes and Determinism\n   record_create(-) is det\n\nExamples\n   \n\t?- record_create(R), record(R,a), record(R,b), recorded_list(R,L).\n\tL = [a,b]\n\n\t?- record_create(R),\n\t   ( member(X,[a,b,c]), record(R,X), fail\n\t   ; recorded_list(R,L)\n\t   ).\n\tL = [a,b,c]\n\nSee Also\n   is_record / 1, record / 1, record / 2, recorded / 2"},"set_prompt/3":{"prefix":"set_prompt","body":"set_prompt(${1:InStream}, ${2:Prompt}, ${3:OutStream})$4\n$0","description":"set_prompt(+InStream, +Prompt, +OutStream)\n\n   The prompt Prompt is output on the stream OutStream for input to the input\nstream InStream.\n\nArguments\n   InStream    Integer (stream number) or Atom (reserved or user-defined    symbolic stream name).\n   Prompt    String or atom.\n   OutStream    Integer (stream number) or Atom (reserved or user-defined    symbolic stream name).\n\nType\n   Obsolete\n\nDescription\n   The prompt Prompt is output on the stream OutStream for input to the\n   input stream InStream.\n\n   When new data is to be read from an input stream, the system prints on\n   the specified output stream a prompt, to notify the user for input.\n\n   InStream and OutStream can be symbolic stream names (atom) or physical\n   stream numbers (integer).\n\n   InStream must be an existing stream open in read or update mode.\n   OutStream must be an existing stream open in write or update mode.\n\n   Note that the prompt for toplevel-input printed by the system at the end\n   of each query is made using the predicate toplevel-prompt/1 and not by\n   using the string set by set_prompt/3.\n\nModes and Determinism\n   set_prompt(+, +, +) is det\n\nExceptions\n     4 --- One or more of InStream, Prompt or OutStream are not    instantiated.\n     5 --- Either InStream or OutStream (or both) is neither an atom    nor an integer.\n     5 --- Prompt is neither an atom nor a string.\n   192 --- InStream is in write mode.\n   192 --- OutStream is in read mode.\n\nExamples\n   \nSuccess:\n  [eclipse]: get_prompt(input,_,Out),\n  > set_prompt(input,\"myprompt> \",Out).\n  Out = 1\n  yes.\n  [eclipse]: get_prompt(input,Prompt,_),\n  myprompt> !.\n  Prompt = \"myprompt> \"\n  yes.\n\n  [eclipse]: read( input,X).\n  > a.\n  X = a\n  yes.\n  [eclipse]: set_prompt(input, \"Enter a term: \", output).\n  yes.\n  [eclipse]: read(input,X).\n  Enter a term: a.\n  X = a\n  yes.\n\n  [eclipse]: get_stream(debug_input,S),\n  > set_prompt(S, \"   DEBUG: \", 1).\n  S = 3\n  yes.\n  [eclipse]: trace.\n  yes.\n  [eclipse]: length([a,b],N).\n  S (1) 0  CALL   length([a, b], _g52)   DEBUG: creep\n  S (1) 0  EXIT   length([a, b], 2)   DEBUG: creep\n  N = 2\n  yes.\n\nError:\n  set_prompt(4, Prompt, 1).    (Error 4).\n  set_prompt(4, 4, 1).    (Error 5).\n  set_prompt(output, \"p> \", Stream). (Error 192).\n\nSee Also\n   set_stream_property / 3, get_prompt / 3"},"record_desc":{"prefix":"lib","body":"lib(${1:record})$2\n$0","description":"lib(record)\n\n\tECLiPSe provides several facilities to store information across\n\tbacktracking. The following table gives an overview. If at all\n\tpossible, the handle-based facilities (bags, records, shelves,\n\tstores) should be preferred because they lead to cleaner, reentrant\n\tcode (without global state) and reduce the risk of memory leaks.\n\n    Facility    Type    Reference       See\n    ================================================================\n    bags    unordered bag   by handle       bag_create/1\n    ----------------------------------------------------------------\n    anon.records    ordered list    by handle       record_create/1\n    ----------------------------------------------------------------\n    shelves    array    by handle       shelf_create/2,3\n    ----------------------------------------------------------------\n    stores    hash table      by handle       store_create/1\n    ----------------------------------------------------------------\n    named shelves   array    by name    shelf/2\n    ----------------------------------------------------------------\n    named stores    hash table      by name    store/1\n    ----------------------------------------------------------------\n    non-logical     single cell     by name    variable/1,2\n    variables\n    ----------------------------------------------------------------\n    non-logical     array    by name    array/1,2\n    arrays\n    ----------------------------------------------------------------\n    named records   ordered list    by name    record/1,2\n    ----------------------------------------------------------------\n    dynamic    ordered list    by name    dynamic/1,assert/1\n    predicates\n    ----------------------------------------------------------------"},"recorda/3":{"prefix":"recorda","body":"recorda(${1:Key}, ${2:Value}, ${3:DBRef})$4\n$0","description":"recorda(+Key, ?Value, -DBRef)\n\n   Records the term Value at the beginning of key Key in the indexed database.\n\nArguments\n   Key    An atom, compound term, or handle.\n   Value    Any prolog term.\n   DBRef    A variable.\n\nType\n   Recorded Database\n\nDescription\n   Used to record any prolog term Value at the beginning of the indexed\n   database entry associated with the key Key.  Unlike recorda/2, this\n   predicate delivers a so-called database reference in DBRef which is a\n   unique handle for the indexed database entry that is created.\n   In the case of compound terms, all keys of the same name and arity are\n   treated as equal.\n\n   If backtracking occurs through the call of recorda/3 the associated\n   Value is not removed from the indexed database.\n\nModes and Determinism\n   recorda(+, ?, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n     5 --- DBRef neither a variable nor a database reference.\n\nExamples\n   \n   Success:\n    [eclipse]: recorda(whiskey,jameson,Ref1),\n    recorda(whiskey,bushmills,Ref2).\n    Ref1 = 'DBREF'(16'50470dc8)\n    Ref2 = 'DBREF'(16'50470de0)\n    yes.\nError:\n    recorda(Key, anything, Ref).    (Error 4)\n    recorda(\"key\",anything, Ref).    (Error 5)\n    recorda(key,anything, 99).    (Error 5)\n\nSee Also\n   recordz / 3, recorded / 3, is_handle / 1, erase / 1, referenced_record / 2"},"recorda/2":{"prefix":"recorda","body":"recorda(${1:Key}, ${2:Value})$3\n$0","description":"recorda(+Key, ?Value)\n\n   Records the term Value at the beginning of key Key in the indexed database.\n\nArguments\n   Key    An atom, compound term, or handle.\n   Value    Any prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Used to record any prolog term Value at the beginning of the indexed\n   database entry associated with the key Key.  In the case of compound\n   terms, all keys of the same name and arity are treated as equal.\n\n   If backtracking occurs through the call of recorda/2 the associated\n   Value is not removed from the indexed database.\n\nModes and Determinism\n   recorda(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n    recorda(a(compound,term),value1).\n    recorda([a,compound,term],value2).\n\n    [eclipse]: recorda(whiskey,jameson),\n    >    recorda(whiskey,bushmills),\n    >    recorda(whiskey,glenlivet).\n    yes.\n    [eclipse]: recorded(whiskey,Value).\n    Value = glenlivet     More (;)\n    Value = bushmills     More (;)\n    Value = jameson     More (;)\n    no (more) solution.\nError:\n    recorda(Key, anything).    (Error 4)\n    recorda(\"key\",anything).    (Error 5)\n\nSee Also\n   record / 2, recordz / 2"},"recorded/3":{"prefix":"recorded","body":"recorded(${1:Key}, ${2:Value}, ${3:DBRef})$4\n$0","description":"recorded(+Key, ?Value, -DBRef)\n\n   Succeeds if the term Value has been recorded in the indexed database under\nthe key Key and DBRef is its unique reference.\n\nArguments\n   Key    An atom or a compound term.\n   Value    Any Prolog term.\n   DBRef    A variable.\n\nType\n   Recorded Database\n\nDescription\n   Used to find all values associated with a key.  Value is unified with\n   the first term that is associated with Key.  DBRef is unified with the\n   unique database reference of this database entry.  In the case of\n   compound terms, all keys of the same name and arity are treated as\n   equal. If Value is instantiated, the instantiated term is used as a\n   filter to reduce the number of terms returned by the recorded database\n   and unified with Value, thus improving the speed of retrieving the term.\n\n   Backtracking will unify Value and DBRef with the value resp.  the\n   database reference of successive values associated with Key in the order\n   in which they were recorded.\n\nModes and Determinism\n   recorded(+, -, -) is nondet\n   recorded(+, +, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if nothing is recorded under the key Key\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n     5 --- DBRef is neither a variable nor a database reference.\n\nExamples\n   \n   Success:\n   [eclipse]: recordz(beer, paulaner, _),\n   recordz(beer, lowenbrau, _),\n   recorded(beer, Value, Ref).\n   Value = paulaner\n   Ref = 'DBREF'(16'50470e90)     More? (;)\n   Value = lowenbrau\n   Ref = 'DBREF'(16'50470ea8)     More? (;)\n   no (more) solution.\n   Fail:\n   erase_all(beer),recorded(beer,guiness, Ref).\n   Error:\n   recorded(Beer,Value,Ref).    (Error 4)\n   recorded(\"beer\",Value,Ref).    (Error 5)\n   recorded(1,Value,Ref).    (Error 5)\n\nSee Also\n   recorda / 3, recordz / 3, erase / 1, is_handle / 1, referenced_record / 2"},"recordz/2":{"prefix":"recordz","body":"recordz(${1:Key}, ${2:Value})$3\n$0","description":"recordz(+Key, ?Value)\n\n   Records the term Value at the end of key Key in the indexed database.\n\nArguments\n   Key    An atom, compound term, or handle.\n   Value    Any prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Used to record any prolog term Value at the end of the indexed database\n   entry associated with the key Key.  A synonym for record/2.  In the case\n   of compound terms, all keys of the same name and arity are treated as\n   equal.\n\n   If backtracking occurs through the call of recordz/2 the associated\n   Value is not removed from the indexed database.\n\nModes and Determinism\n   recordz(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n    [eclipse]: recordz(whiskey,jameson),\n    > recordz(whiskey,[scotch,irish,canadian,american]),\n    > recordz(whiskey,bushmills).\n    yes.\n    [eclipse]: recorded(whiskey,Value).\n    Value = jameson     More (;)\n    Value = [scotch,irish,canadian,american]     More (;)\n    Value = bushmills     More (;)\n    no (more) solution.\n\n    recordz(a(compound,term),value1).\n    recordz([a,compound,term],value2).\nError:\n    recordz(Key, anything).    (Error 4)\n    recordz(\"key\",anything).    (Error 5)\n    recordz(1,anything).    (Error 5)\n\nSee Also\n   record / 2, recorda / 2"},"recorded_list/2":{"prefix":"recorded_list","body":"recorded_list(${1:Key}, ${2:List})$3\n$0","description":"recorded_list(+Key, -List)\n\n   Succeeds if the List is the list of all terms that are currently recorded\nin the indexed database under the key Key.\n\nArguments\n   Key    An atom or a compound term.\n   List    A (possibly empty) list of Prolog terms.\n\nType\n   Recorded Database\n\nDescription\n   Unifies List with a list of all the terms that are currently recorded\n   under the key Key.  While recorded/2 returns the terms one by one on\n   backtracking, recorded_list/2  gives them all at once.  The order of the\n   list corresponds to the order in which the terms would be delivered by\n   recorded/2.  recorded_list/2  could be defined as\n\n    recorded_list(Key, List) :-\n    findall(Term, recorded(Key, Term), List).\n\n   In the case of compound terms, all keys of the same name and arity are\n   treated as equal.\n\nModes and Determinism\n   recorded_list(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n     5 --- List is neither an variable nor a list.\n\nExamples\n   \n   Success:\n   [eclipse]: erase_all(beer), recorded_list(beer,List).\n   List = []\n   yes.\n   [eclipse]: record(beer,paulaner), record(beer,lowenbrau),\n   recorda(beer,spaten), recorded_list(beer,List).\n   List = [spaten, paulaner, lowenbrau]\n   yes.\n   Fail:\n   erase_all(beer), recorded_list(beer,[paulaner]).\n   Error:\n   recorded_list(Beer,Value).    (Error 4)\n   recorded_list(1,Value).    (Error 5)\n   recorded_list(beer,lowenbrau).    (Error 5)\n\nSee Also\n   record / 2, recorded / 2"},"recorded/2":{"prefix":"recorded","body":"recorded(${1:Key}, ${2:Value})$3\n$0","description":"recorded(+Key, ?Value)\n\n   Succeeds if the term Value has been recorded in the indexed database under\nthe key Key.\n\nArguments\n   Key    An atom or a compound term.\n   Value    Any Prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Used to find all values associated with a key.  Unifies Value with the\n   first term that has been associated with Key.  In the case of compound\n   terms, all keys of the same name and arity are treated as equal. If\n   Value is instantiated, the instantiated term is used as a filter to reduce \n   the number of terms returned by the recorded database and unified with Value,\n   thus improving the speed of retrieving the term.\n\n   Backtracking will unify Value with successive values associated with Key\n   in the order in which they were recorded.\n\nModes and Determinism\n   recorded(+, -) is nondet\n   recorded(+, +) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if nothing is recorded under the key Key\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(beer,paulaner),\n   >    record(beer,lowenbrau),\n   >    record(beer,spaten),\n   >    recorded(beer,Value).\n   Value = paulaner     More? (;)\n   Value = lowenbrau     More? (;)\n   Value = spaten     More? (;)\n   no (more) solution.\n   Fail:\n   erase_all(beer),recorded(beer,guiness).\n   Error:\n   recorded(Beer,Value).    (Error 4)\n   recorded(\"beer\",Value).    (Error 5)\n   recorded(1,Value).    (Error 5)\n\nSee Also\n   record / 2"},"rerecord/2":{"prefix":"rerecord","body":"rerecord(${1:Key}, ${2:Value})$3\n$0","description":"rerecord(+Key, ?Value)\n\n   Erases all entries recorded under the key Key and replaces them with the\ngiven value Value.\n\nArguments\n   Key    An atom or a compound term.\n   Value    Any prolog term.\n\nType\n   Recorded Database\n\nDescription\n   Used to erase all values associated with Key and then record the term\n   Value under the key Key.  If Key does not exist previously, it will\n   record Value under Key in the indexed database.  In the case of compound\n   terms, all keys of the same name and arity are treated as equal.\n\n   Backtracking through a call of rerecord/2 does not undo erasure of the\n   erased values and the value Value is not removed.\n\nModes and Determinism\n   rerecord(+, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n\nExamples\n   \n   Success:\n   [eclipse]: record(beer,lowenbrau),\n   >    record(beer,paulaner),\n   >    record(beer,spaten),\n   >    rerecord(beer,guinness).\n   yes.\n   [eclipse]: recorded(beer,Value).\n   Value = guinness     More? (;)\n   no (more) solution.\n   [eclipse]: erase_all(beer),rerecord(beer,guinness).\n   yes.\n   [eclipse]: recorded(beer,guinness).\n   yes.\n   Error:\n   rerecord(Beer,anything).    (Error 4)\n   rerecord(1,anything).    (Error 5)\n   rerecord(1.0,anything).    (Error 5)\n   rerecord(\"str\",anything).    (Error 5)\n\nSee Also\n   erase_all / 1"},"recordz/3":{"prefix":"recordz","body":"recordz(${1:Key}, ${2:Value}, ${3:DBRef})$4\n$0","description":"recordz(+Key, ?Value, -DBRef)\n\n   Records the term Value at the end of key Key in the indexed database.\n\nArguments\n   Key    An atom, compound term, or handle.\n   Value    Any prolog term.\n   DBRef    A variable.\n\nType\n   Recorded Database\n\nDescription\n   Used to record any prolog term Value at the end of the indexed database\n   entry associated with the key Key.  Unlike recordz/2, this predicate\n   delivers a so-called database reference in DBRef which is a unique handle\n   for the indexed database entry that is created.  In the case of\n   compound terms, all keys of the same name and arity are treated as equal.\n\n   If backtracking occurs through the call of recordz/3 the associated\n   Value is not removed from the indexed database.\n\nModes and Determinism\n   recordz(+, ?, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Key is not instantiated.\n     5 --- Key is neither an atom nor a compound term.\n     5 --- DBRef neither a variable nor a database reference.\n\nExamples\n   \n   Success:\n    [eclipse]: recordz(whiskey,jameson,Ref1),\n    recordz(whiskey,bushmills,Ref2).\n    Ref1 = 'DBREF'(16'50470f10)\n    Ref2 = 'DBREF'(16'50470f28)\n    yes.\nError:\n    recordz(Key, anything, Ref).    (Error 4)\n    recordz(\"key\",anything, Ref).    (Error 5)\n    recordz(key,anything, 99).    (Error 5)\n\nSee Also\n   recorda / 3, recorded / 3, erase / 1, is_handle / 1, referenced_record / 2"},"referenced_record/2":{"prefix":"referenced_record","body":"referenced_record(${1:DBRef}, ${2:Value})$3\n$0","description":"referenced_record(+DBRef, -Value)\n\n   Succeeds if Value is the Term recorded under the database reference DBRef.\n\nArguments\n   DBRef    A database reference.\n   Value    Any Prolog term.\n\nType\n   Recorded Database\n\nDescription\n   The database reference DBRef must refer to a term that has previously\n   been recorded in the indexed database.  Database references can be\n   obtained from the predicates recorda/3, recordz/3 and recorded/3.\n   Value is unified with a copy of the recorded term.  Note that this\n   is the case even if the original database entry has been removed since\n   the database reference was obtained (logical update semantics).\n\nModes and Determinism\n   referenced_record(+, -) is det\n\nExceptions\n     4 --- DBRef is not instantiated.\n     5 --- DBRef is neither a variable nor a database reference.\n\nExamples\n   \n   [eclipse]: recordz(beer, paulaner, Ref), referenced_record(Ref, X).\n   Ref = 'DBREF'(16'50470d00)\n   X = paulaner\n   yes.\n\n   [eclipse]: recorded(beer, _, Ref), referenced_record(Ref, X).\n   Ref = 'DBREF'(16'50470d00)\n   X = paulaner     More? (;)\n   yes.\n\n   [eclipse]: recorded(beer, _, Ref), erase(Ref), referenced_record(Ref, X).\n   Ref = 'DBREF'(16'50470d00)\n   X = paulaner     More? (;)\n   yes.\n\nError:\n   referenced_record(_, Value).    (Error 4)\n   referenced_record(123, Value).       (Error 5)\n\nSee Also\n   recorda / 3, recordz / 3, recorded / 3, erase / 1, referenced_record / 2"},"array/1":{"prefix":"local","body":"local","description":"local array(++Array)\n\n   Creates the untyped non-logical array Array.\n\nArguments\n   Array    Ground compound term with integer arguments.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   If Array is a compound term, a non-logical array (visible only in\n   the caller module) of type prolog is created.  Its dimension is the\n   arity of the term Array and the size of each dimension is specified\n   by the corresponding argument of the term Array.  The elements of\n   arrays of type prolog are initialised to free variables.\n\n   The array indexes in the array range from 0 to the dimension minus one.\n   For example myarray create with local array(myarray(3,4,5))\n   contains 60 elements that may be accessed from myarray(0,0,0)\n   to myarray(2,3,4).\n\n   The contents of the array persists across failures.\n   The value of the array elements can be changed with\n   setval/2 and retrieved with getval/2.  Setting and retrieving terms\n   from a non-logical arrays involves copying the term each time. \n   In particular, if the term contains variables, they lose their\n   identity and are replaced with fresh ones.\n\n   Notes:\n\n   local array(A) is equivalent to local array(A, prolog).\n\nModes and Determinism\n   array(++) is det\n\nExceptions\n     4 --- Array is not ground.\n     5 --- Array is not a structure with integer arguments.\n     6 --- The ground structure Array has arguments that are integers not greater than 0.\n    24 --- The ground structure Array has arguments that are non-numbers.\n    42 --- An array with the same name and dimension as Array already exists.\n\nExamples\n   \nSuccess:\n      local array(a(4)).\n      local array(b(2,3)).\n      local array(a(4)), array(a(4,1)).\n\nError:\n      local array(X).    (Error 4).\n      local array(a(6.0)).    (Error 5).\n      local array(a(0)).    (Error 6).\n      local array(a(-2)).    (Error 6).\n      local array(a(4)), array(a(5)).    (Warning 42).\n\nSee Also\n   current_array / 2, array / 2, decval / 1, incval / 1, bag_create / 1, shelf_create / 2, shelf_create / 3, getval / 2, setval / 2"},"array/2":{"prefix":"local","body":"local","description":"local array(+Array, +Type)\n\n   Creates a non-logical array Array with given Type.\n\nArguments\n   Array    Ground compound term with integer arguments.\n   Type    One of the atoms: float, integer, byte, prolog\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   If Array is a compound term, a non-logical array (visible only in\n   the caller module) of type prolog is created.  Its dimension is the\n   arity of the term Array and the size of each dimension is specified\n   by the corresponding argument of the term Array.\n   The elements of the array are initialised depending on the type:\n   float, integer and byte arrays are initialised with 0 values, prolog\n   arrays are initialised with free variables.\n\n   The array indexes in the array range from 0 to the dimension minus one.\n   For example myarray create with local array(myarray(3,4,5), integer)\n   contains 60 integers that may be accessed from myarray(0,0,0) to\n   myarray(2,3,4).\n\n   The contents of the array persists across failures.\n   The value of the array elements can be changed with\n   setval/2 and retrieved with getval/2.  Setting and retrieving terms\n   from a non-logical arrays involves copying the term each time. \n   In particular, if the term contains variables, they lose their\n   identity and are replaced with fresh ones.\n\n   Notes:\n\n   Re-declaring an existing array with the same dimension but different\n   sizes or type raises a warning.\n\nModes and Determinism\n   array(++, +) is det\n\nExceptions\n     4 --- Array or Type is not ground.\n     5 --- Array is not a structure with integer arguments.\n     5 --- Type is not an atom.\n     6 --- Type is not a valid type name.\n     6 --- The ground structure Array has arguments that are integers not greater than 0.\n    24 --- The ground structure Array has arguments that are non-numbers.\n    42 --- An array with the same name and dimension as Array already exists.\n\nExamples\n   \nSuccess:\n      local array(a(4), prolog).\n      local array(b(2,3), integer).\n      local array(a(4), float), array(a(4,1), byte).\n\nError:\n      local array(X, prolog).    (Error 4).\n      local array(a(6.0), integer).    (Error 5).\n      local array(a(0), integer).    (Error 6).\n      local array(a(-2), integer).    (Error 6).\n      local array(a(4), integer), array(a(5), float).  (Warning 42).\n\nSee Also\n   current_array / 2, array / 2, decval / 1, incval / 1, bag_create / 1, shelf_create / 2, shelf_create / 3, getval / 2, setval / 2"},"bag_create/1":{"prefix":"bag_create","body":"bag_create(${1:BagHandle})$2\n$0","description":"bag_create(-BagHandle)\n\n   Create a bag object which can store data across failures\n\nArguments\n   BagHandle    A free variable\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates an anonymous bag object which can be used to store\n\tinformation across failures.  A typical application is the\n\timplementation of the findall/3 predicate or similar functionality.\n\tBags are similar to records, with two differences: First, a bag\n\tis considered unordered, so one should not expect the bag content\n\tto indicate the order in which information was entered.\n\tSecond, bags are referred to by handle, not by name, so they make\n\tit much easier to write robust, reentrant code.\n    \n\nModes and Determinism\n   bag_create(-) is det\n\nExceptions\n     5 --- BagHandle is not a variable\n\nExamples\n   \n    simple_findall(Goal, Solutions) :-\n    \tbag_create(Bag),\n\t(\n\t    call(Goal),\n\t    bag_enter(Bag, Goal),\n\t    fail\n\t;\n\t    true\n\t),\n\tbag_dissolve(Bag, Solutions).\n    \n\nSee Also\n   bag_erase / 1, bag_enter / 2, bag_count / 2, bag_dissolve / 2, bag_retrieve / 2, bag_abolish / 1"},"bag_dissolve/2":{"prefix":"bag_dissolve","body":"bag_dissolve(${1:BagHandle}, ${2:List})$3\n$0","description":"bag_dissolve(+BagHandle, -List)\n\n   Retrieve a bag's contents and destroy the bag\n\nArguments\n   BagHandle    A bag\n   List    A variable or list of terms\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis returns a list containing a copy of every term that has\n\tbeen entered into the bag since it was created.  The bag is\n\talso destoyed.  It should not be assumed that the list order\n\treflects the order in which the terms were entered into the\n\tbag.  Entering and retrieving terms from a bag involves\n\tcopying the term each time, similar to what happens in\n\tsetval/getval and record/recorded.  In particular, if the term\n\tcontains variables, they lose their identity and are replaced\n\twith fresh ones.\n\n\tbag_dissolve/2 is equivalent to bag_retrieve/2, followed by\n\tbag_abolish/1.  Using the BagHandle after it has been dissolved\n\twill lead to an error message.\n    \n\nModes and Determinism\n   bag_dissolve(+, -) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nExamples\n   \n    simple_findall(Goal, Solutions) :-\n    \tbag_create(Bag),\n\t(\n\t    call(Goal),\n\t    bag_enter(Bag, Goal),\n\t    fail\n\t;\n\t    true\n\t),\n\tbag_dissolve(Bag, Solutions).\n    \n\nSee Also\n   bag_create / 1, bag_enter / 2, bag_count / 2, bag_erase / 1, bag_retrieve / 2, bag_abolish / 1"},"bag_enter/2":{"prefix":"bag_enter","body":"bag_enter(${1:BagHandle}, ${2:Term})$3\n$0","description":"bag_enter(+BagHandle, +Term)\n\n   Enter a term into an existing bag object\n\nArguments\n   BagHandle    A bag\n   Term    An arbitrary term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis enters an arbitrary term into a bag object that has previously\n\tbeen created with bag_create/1. The order in which terms are entered\n\tinto a bag should not be considered relevant, a bag is conceptually\n\tunordered. Entering and retrieving terms from a bag involves\n\tcopying the term each time, similar to what happens in setval/getval\n\tand record/recorded. In particular, if the term contains variables,\n\tthey lose their identity and are replaced with fresh ones.\n    \n\nModes and Determinism\n   bag_enter(+, +) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nExamples\n   \n    simple_findall(Goal, Solutions) :-\n    \tbag_create(Bag),\n\t(\n\t    call(Goal),\n\t    bag_enter(Bag, Goal),\n\t    fail\n\t;\n\t    true\n\t),\n\tbag_dissolve(Bag, Solutions).\n    \n\nSee Also\n   bag_create / 1, bag_count / 2, bag_abolish / 1, bag_erase / 1, bag_retrieve / 2, bag_dissolve / 2"},"bag_count/2":{"prefix":"bag_count","body":"bag_count(${1:BagHandle}, ${2:Count})$3\n$0","description":"bag_count(+BagHandle, -Count)\n\n   Get the number of entries in a bag\n\nArguments\n   BagHandle    A bag\n   Count    A variable or integer\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis returns an integer corresponding to the number of entries\n\tcurrently in the bag. A fresh or erased bag has zero entries.\n    \n\nModes and Determinism\n   bag_count(+, -) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nExamples\n   \n    ?- bag_create(B), bag_count(B, N0), bag_enter(B, one), bag_count(B, N1).\n    N0 = 0\n    B = 'BAG'(16'0030dc48)\n    N1 = 1\n    Yes (0.00s cpu)\n    \n\nSee Also\n   bag_create / 1, bag_enter / 2, bag_count / 2, bag_erase / 1, bag_abolish / 1, bag_retrieve / 2, bag_dissolve / 2"},"bag_abolish/1":{"prefix":"bag_abolish","body":"bag_abolish(${1:BagHandle})$2\n$0","description":"bag_abolish(+BagHandle)\n\n   Destroy a bag explicitly\n\nArguments\n   BagHandle    A bag handle\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis explicitly destroys a previously created bag object and\n\tfrees all its memory.  Invoking bag_abolish/1 is optional,\n\tthe bag will be automatically destroyed when the system\n\tbacktracks across the call to bag_create/1, or when the\n\tBagHandle is no longer needed and gets garbage collected.\n\tbag_dissolve/2 will also destroy the bag.\n\n\tUsing the BagHandle after it has been destroyed will lead\n\tto an error message. Destroying an already destroyed bag\n\tdoes nothing and is silently accepted.\n    \n\nModes and Determinism\n   bag_abolish(+) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nSee Also\n   bag_create / 1, bag_enter / 2, bag_count / 2, bag_erase / 1, bag_retrieve / 2, bag_dissolve / 2"},"bag_erase/1":{"prefix":"bag_erase","body":"bag_erase(${1:BagHandle})$2\n$0","description":"bag_erase(+BagHandle)\n\n   Erase the contents of a bag\n\nArguments\n   BagHandle    A bag handle\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis explicitly erases the contents of a previously created\n\tbag object and frees the associated memory. After erasing,\n\tthe bag is in the same state as immediately after creation,\n\tand can be filled with new contents.\n    \n\nModes and Determinism\n   bag_erase(+) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nExamples\n   \n    ?- bag_create(B), bag_enter(B, one), bag_erase(B), bag_enter(B, two), bag_retrieve(B, L).\n    B = 'BAG'(16'0030db60)\n    L = [two]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   bag_create / 1, bag_abolish / 1, bag_enter / 2, bag_count / 2, bag_retrieve / 2, bag_dissolve / 2"},"bag_retrieve/2":{"prefix":"bag_retrieve","body":"bag_retrieve(${1:BagHandle}, ${2:List})$3\n$0","description":"bag_retrieve(+BagHandle, -List)\n\n   Retrieve a bag's contents\n\nArguments\n   BagHandle    A bag\n   List    A variable or list of terms\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis returns a list containing a copy of every term that has\n\tbeen entered into the bag since it was created.  It should not\n\tbe assumed that the list order reflects the order in which the\n\tterms were entered into the bag.  Entering and retrieving\n\tterms from a bag involves copying the term each time, similar\n\tto what happens in setval/getval and record/recorded.  In\n\tparticular, if the term contains variables, they lose their\n\tidentity and are replaced with fresh ones.\n    \n\nModes and Determinism\n   bag_retrieve(+, -) is det\n\nExceptions\n     4 --- BagHandle is not instantiated\n     5 --- BagHandle is not a bag\n    40 --- BagHandle refers to an already destroyed bag\n\nExamples\n   \n    simple_findall(Goal, Solutions) :-\n    \tbag_create(Bag),\n\t(\n\t    call(Goal),\n\t    bag_enter(Bag, Goal),\n\t    fail\n\t;\n\t    true\n\t),\n\tbag_retrieve(Bag, Solutions),\n\tbag_abolish(Bag).\n    \n\nSee Also\n   bag_create / 1, bag_enter / 2, bag_count / 2, bag_erase / 1, bag_abolish / 1, bag_dissolve / 2"},"current_array/2":{"prefix":"current_array","body":"current_array(${1:Array}, ${2:Options})$3\n$0","description":"current_array(?Array, -Options)\n\n   Succeeds if there exists an array as denoted by Array and with type and\nvisibility as given in the list Options.\n\nArguments\n   Array    Atom or compound term.\n   Options    Variable or list.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   current_array/2 is used to retrieve information about existing\n   visible arrays, non-logical variables and references.  Array is a\n   term denoting the array's name and dimensions and Options is a list\n   describing the array's type (prolog, float, integer or byte) and visibility.\n\nModes and Determinism\n   current_array(-, -) is nondet\n   current_array(+, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if there is no array whose name unifies with ArrayName\n\nExceptions\n     5 --- Array is neither variable, atom nor compound term.\n     5 --- Options is neither a list nor a variable.\n\nExamples\n   \n[eclipse 1]: local array(a(2)), array(b(2,3,4), float).\n\nyes.\n[eclipse 2]: current_array(a(Size), [Type,Vis|_]).\n\nSize = 2\nType = prolog\nVis = local\nyes.\n[eclipse 3]: current_array(Array, Props).\n\nArray = a(2)\nProps = [prolog, local]     More? (;)\n\nArray = b(2, 3, 4)\nProps = [float, local]     More? (;)\n\nno (more) solution.\n\nError:\n      current_array(\"a\", L).    (Error 5).\n      current_array(a, 9).      (Error 5).\n\nSee Also\n   array / 1, array / 2, variable / 1"},"erase_array/1":{"prefix":"erase_array","body":"erase_array(${1:ArraySpec})$2\n$0","description":"erase_array(++ArraySpec)\n\n   Erases existing visible array, non-logical variable or reference.\n\nArguments\n   ArraySpec    Of the form Atom/Integer or just atom.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   Used to erase the visible array uniquely specified by ArraySpec.\n\n   Also used to erase the existing non-logical variable or reference ArraySpec.\n   ArraySpec is of the form Atom/0, or just Atom.\n\n   Erasing reclaims the memory occupied by the array or variable.\n\nModes and Determinism\n   erase_array(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ArraySpec is not instantiated.\n     5 --- ArraySpec is not an atom or of the form Atom/Integer.\n    41 --- ArraySpec specifies an array, variable or reference which does not exist.\n\nExamples\n   \nSuccess:\n      local(array(a(4,3))), erase_array(a/2).\n      setval(i,1), erase_array(i).\n      setval(i,1), erase_array(i/0).\n\nError:\n      erase_array(X).    (Error 4).\n      local(array(a(4,2))),\n    erase_array(a(4,2)).    (Error 5).\n      erase_array(no_array/1).    (Error 41).\n      erase_array(no_array).    (Error 41).\n\nSee Also\n   current_array / 2, array / 1, array / 2, variable / 1, setval / 2"},"current_store/1":{"prefix":"current_store","body":"current_store(${1:StoreHandle})$2\n$0","description":"current_store(?StoreHandle)\n\n   StoreName is a visible store name\n\nArguments\n   StoreHandle    A variable or a store name (atom or compound)\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tUsed to check whether StoreName is the name of a visible store,\n\tor to enumerate all visible store names in the context module. \n\n\tNote that this predicate will only accept/generate store names\n\tthat have been created with local/1, store/1, not anonymous\n\tstore handles created via store_create/1.\n\n\tNote: StoreHandle gets unified with an atom or a compound term,\n\tand the store is identified by this term's toplevel functor\n\ttogether with the context module.\n    \n\nModes and Determinism\n   current_store(+) is semidet\n   current_store(-) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   StoreName is not a visible store name\n\nExceptions\n     5 --- StoreHandle is neither atom nor compound term nor variable\n\nExamples\n   \n    :- local store(shed).\n    :- local store(warehouse/3).\n\n    ?- current_store(shed).\n    Yes (0.00s cpu)\n\n    ?- current_store(heap).\n    No (0.00s cpu)\n\n    ?- current_store(X).\n    X = shed\n    More (0.00s cpu) ? ;\n\n    X = warehouse(_184, _185, _186)\n    More (0.00s cpu) ? ;\n\n    No (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1"},"decval/1":{"prefix":"decval","body":"decval(${1:ElemSpec})$2\n$0","description":"decval(++ElemSpec)\n\n   Decrements the contents of the visible non-logical variable or array element ElemSpec by one.\n\nArguments\n   ElemSpec    Atom or ground compound term whose arguments are non negative integers.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   Decrements by one the value of ElemSpec that must be of type integer.\n\n   If ElemSpec is an atom, it must specify a non-logical variable visible\n   from the caller module.\n\n   If ElemSpec is a compound term, it must specify an element visible\n   array.  All its arguments must be non negative integer smallers than the\n   bound specified with array/1/2 or variable/1.\n\nModes and Determinism\n   decval(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ElemSpec is not instantiated.\n     5 --- ElemSpec is a structure whose arguments are not all integers.\n     5 --- ElemSpec is neither an atom nor a ground structure.\n     5 --- The value or type of ElemSpec is not integer.\n     6 --- Array index in ElemSpec is out of bounds.\n    41 --- ElemSpec does not designate an existing array, variable or reference.\n\nExamples\n   \nSuccess:\n      [eclipse]: local(array(a(4), prolog)),\n    setval(a(0), -2),\n    decval(a(0)),\n    getval(a(0),X).\n      X = -3\n      yes.\n\n      [eclipse]: local(array(g(4, 5), integer)),\n    decval(g(3, 2)),\n    getval(g(3, 2), X).\n      X = -1\n      yes.\n\n      [eclipse]: setval(a, 3),\n    decval(a),\n    getval(a, X).\n      X = 2\n      yes.\n\nError:\n      decval(X).    (Error 4).\n      setval(a, 2.0),\n    decval(a).    (Error 5).\n      local(array(a(2), float)),\n    decval(a(1)).    (Error 5).\n      local(array(a(2))),\n    decval(a(2)).    (Error 6).\n      decval(no_var).    (Error 41).\n      decval(noarray(2, 4)).    (Error 41).\n\nSee Also\n   getval / 2, incval / 1, array / 1, array / 2, variable / 1, setval / 2"},"incval/1":{"prefix":"incval","body":"incval(${1:ElemSpec})$2\n$0","description":"incval(++ElemSpec)\n\n   Increments the contents of the visible non-logical variable or array element ElemSpec by one.\n\nArguments\n   ElemSpec    Atom or ground compound term with non negative integer arguments.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   Increments the value of the element ElemSpec that must be of type\n   integer.\n\n   If ElemSpec is an atom, it must specify a non-logical variable visible from\n   the caller module.\n\n   If ElemSpec is a compound term, it must specify a visible array element.\n   all its arguments must be non negative integers smaller than the bounds\n   specified with array/1/2 or variable/1.\n\nModes and Determinism\n   incval(++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ElemSpec is not instantiated.\n     5 --- ElemSpec is a structure whose arguments are not all    integers.\n     5 --- ElemSpec is neither an atom nor a ground structure.\n     5 --- The value or type of ElemSpec is not integer.\n     6 --- Array index in ElemSpec is out of range.\n    41 --- ElemSpec does not designate an existing array, variable or reference.\n\nExamples\n   \nSuccess:\n      [eclipse]: local(array(a(4), prolog)),\n    setval(a(1), -2),\n    incval(a(1)),\n    getval(a(1), X).\n      X = -1\n      yes.\n\n      [eclipse]: local(array(g(4), integer)),\n    incval(g(1)),\n    getval(g(1), X).\n      X = 1\n      yes.\n\n      [eclipse]: setval(count, 0),\n    repeat,\n    writeln(hello),\n    incval(count),\n    getval(count, X),\n    X >= 3, !.\n      hello\n      hello\n      hello\n      X = 3\n      yes.\n\nError:\n\n      incval(X).    (Error 4).\n      incval(a(2.0)).    (Error 5).\n      setval(a, 2.0), incval(a).    (Error 5).\n      local(array(a(2), float)),\n    incval(a(1)).    (Error 5).\n      local(array(a(10), integer)),\n    incval(a(-2)).    (Error 6).\n      incval(no_array(0)).    (Error 41).\n      incval(no_var).    (Error 41).\n\nSee Also\n   decval / 1, array / 1, array / 2, variable / 1, getval / 2, setval / 2"},"getval/2":{"prefix":"getval","body":"getval(${1:ElemSpec}, ${2:Value})$3\n$0","description":"getval(++ElemSpec, -Value)\n\n   Retrieves the value of the visible array element, non-logical variable or reference ElemSpec\n\nArguments\n   ElemSpec    Atom or ground compound term with non negative integer arguments.\n   Value    Prolog term.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   If ElemSpec is the name of a visible non-logical variable, it unifies\n   the copied value of the variable with Value.\n\n   If ElemSpec is a compound term, it must specify an element of a visible\n   non-logical array, all its arguments must be non negative integers smaller\n   than the bounds specified with array/1/2 or variable/1. The copied value\n   of the array element is unified with Value.\n\n   If Element is the name of a reference, Value is unified with\n   the actual term the reference refers to (no copying involved).\n\nModes and Determinism\n   getval(++, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ElemSpec is not ground.\n     5 --- ElemSpec is neither an atom nor a structure whose arguments are integers.\n     6 --- An array index in ElemSpec is out of bounds\n    41 --- ElemSpec does not designate an existing array, variable or reference.\n\nExamples\n   \nSuccess:\n      local(array(a(4), float)),\n    setval(a(2), 2.0),\n    getval(a(2), 2.0).\n      setval(i, \"2\"),\n    getval(i, V)).   (gives V = \"2\").\n\nFailure:\n      local(array(a(2))),\n    setval(a(1), 8.6),\n    getval(a(1), 10.0).\n      setval(i, 3),\n    getval(i, 0)).\n\nError:\n      getval(X, 1).    (Error 4).\n      getval(a(X), 1).    (Error 4).\n      getval(\"a\", V).    (Error 5).\n      getval(a(2.0), V).    (Error 5).\n      getval(a(-1), V).    (Error 6).\n      getval(no_array(0), X).    (Error 41).\n      getval(no_var, X).    (Error 41).\n\nSee Also\n   decval / 1, incval / 1, array / 1, array / 2, variable / 1, setval / 2"},"reference/1":{"prefix":"local","body":"local","description":"local reference(+Name)\n\n   Creates a named reference called Name.\n\nArguments\n   Name    An atom.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   This creates a named reference with the atomic name Name.  A named\n   reference can be used to hold a reference to a term in the same way\n   as a logical variable.  Unlike the non-logical variables, the value\n   of a reference is not a copy, but identical to the original term it\n   was set to.  This implies that the value behaves logically, i.e. \n   it disappears on backtracking, bindings to the variables inside it\n   are undone on backtracking etc.  A typical example of it use is global\n   state that a set of predicates wants to share without having to\n   pass an argument pair through all the predicate invocations. \n\n   Changing the value of a reference is similar to changing an argument\n   of a compound term using setarg/3.\n\n   The initial value of a reference is the integer 0. To have a different\n   initial value, use reference/2.\n\n   There are no arrays of references, but the same effect can be\n   achieved by storing a structure in a reference and using the\n   structure's arguments.  The arguments can then be accessed and\n   modified using arg/3 and setarg/3 respectively. \n\n   Note: Declaring a reference twice is silently accepted, and the second\n   declaration is ignored.\n\nModes and Determinism\n   reference(+) is det\n\nExceptions\n     4 --- Name is not instantiated.\n     5 --- Name is not an atom.\n\nExamples\n   \n% comparison between references and nonlogical variables\n\n      [eclipse 1]: local reference(a), variable(b).\n\n      yes.\n      [eclipse 2]: Term = p(X), setval(a, Term), getval(a, Y), Y == Term.\n      X = X\n      Y = p(X)\n      Term = p(X)\n      yes.\n      [eclipse 3]: Term = p(X), setval(b, Term), getval(b, Y), Y == Term.\n\n      no (more) solution.\n\n% values of references are subject to backtracking:\n\n    [eclipse 4]: setval(a, 1), (setval(a, 2), getval(a, X); getval(a, Y)).\n      X = 2\n      Y = Y     More? (;) \n\n      X = X\n      Y = 1\n\nSee Also\n   reference / 2, setval / 2, getval / 2, setarg / 3, arg / 3"},"reference/2":{"prefix":"local","body":"local","description":"local reference(+Name, ++Init)\n\n   Creates a named reference called Name with intial value Init.\n\nArguments\n   Name    An atom.\n   Init    A ground term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   This creates a named reference with the atomic name Name.  A named\n   reference can be used to hold a reference to a term in the same way\n   as a logical variable.  Unlike the non-logical variables, the value\n   of a reference is not a copy, but identical to the original term it\n   was set to.  This implies that the value behaves logically, i.e. \n   it disappears on backtracking, bindings to the variables inside it\n   are undone on backtracking etc.  A typical example of it use is global\n   state that a set of predicates wants to share without having to\n   pass an argument pair through all the predicate invocations. \n\n   Changing the value of a reference is similar to changing an argument\n   of a compound term using setarg/3.\n\n   The initial value of the reference is Init, which must be a ground term.\n\n   There are no arrays of references, but the same effect can be\n   achieved by storing a structure in a reference and using the\n   structure's arguments.  The arguments can then be accessed and\n   modified using arg/3 and setarg/3 respectively. \n\n   Note: Declaring a reference twice is silently accepted, and the second\n   declaration is ignored.\n\nModes and Determinism\n   reference(+, ++) is det\n\nExceptions\n     4 --- Name is not instantiated.\n     4 --- Init is not a ground term.\n     5 --- Name is not an atom.\n\nExamples\n   \n\n      [eclipse 1]: local reference(a,0).\n\n      yes.\n      [eclipse 2]: ( getval(a, Old), setval(a, 27), getval(a, New)\n\t\t   ; getval(a, Then) ).\n      Old = 0\n      New = 27\n      Then = Then\n      Yes (0.00s cpu, solution 1, maybe more) ? ;\n\n      Old = Old\n      New = New\n      Then = 0\n      Yes (0.00s cpu, solution 2)\n\nSee Also\n   reference / 1, setval / 2, getval / 2, setarg / 3, arg / 3"},"setval/2":{"prefix":"setval","body":"setval(${1:ElemSpec}, ${2:Value})$3\n$0","description":"setval(++ElemSpec, ?Value)\n\n   Sets the value of a non-logical variable, array element, or reference to the value Value.\n\nArguments\n   ElemSpec    Atom (non-logical variable or reference) or fully instantiated compound term with positive integer arguments (array element specification).\n   Value    Prolog term.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   If ElemSpec is the name of a visible non-logical variable, its\n   value gets set to a copy of the term value.  If there was no\n   variable visible from the caller module, a local non-logical\n   variable is created and its value is set.  The value of a\n   non-logical variable can be overwritten any number of times with\n   any data type, including a free variable. Values of non-logical\n   variables are copies of the original term and persist across failures.\n\n   If ElemSpec is a compound term, it must specify a visible array element:\n   all its argument must be non negative integers smaller than the bounds\n   specified with array/1 or array/2.\n   If the array has been created with array/2, then Value is restricted\n   to the type given in the declaration; otherwise Value can have any type,\n   including a free variable.  Its value can be overwritten any number of times.\n   Values of non-logical arrays are copies of the original term and persist\n   across failures.\n\n   If ElemSpec is the name of a visible reference, its value will be set\n   to the term value.  Unlike for non-logical variables, the value of a\n   reference is the original term, not a copy. Setting the value of a\n   reference is undone on backtracking, i.e. the value of the reference\n   reverts to what it was before being changed.\n\nModes and Determinism\n   setval(++, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ElemSpec is not ground\n     4 --- ElemSpec is of an array of type integer, float or byte and Value is not instantiated\n     5 --- the type of Value is not of the declared type of ElemSpec.\n     5 --- ElemSpec is a structure whose arguments are not all integers.\n     5 --- ElemSpec is neither an atom nor a ground structure.\n     6 --- Array index in ElemSpec is out of bounds.\n    41 --- ElemSpec is an element of an array which does not exist.\n\nExamples\n   \nSuccess:\n      local(array(a(4,3))),\n    setval(a(0,0), 2),\n    setval(a(1,2), \"string\"),\n    % overwrite a(0,0) (= 2) with a free variable\n    setval(a(0,0), X).\n      local(array(a(4), float)),\n    setval(a(0), 2.0),\n    setval(a(3), -19.6).\n      setval(i, 4).\n      setval(j, 4),\n    setval(j, \"string data\").\n\nError:\n      setval(A, 2.0).    (Error 4).\n      setval(a(V), 2.0).    (Error 4).\n      setval(a(1.0), 2).    (Error 5).\n      setval(\"b(0)\", 2.0).       (Error 5).\n      local(array(a(4))),\n    setval(a(-2), 2).      (Error 6).\n      local(array(a(9), integer)),\n    setval(a(9), 4).       (Error 6).\n      setval(no_array(1), 2.0).  (Error 41).\n\nSee Also\n   decval / 1, erase_array / 1, incval / 1, array / 1, array / 2, variable / 1, getval / 2"},"shelf_create/3":{"prefix":"shelf_create","body":"shelf_create(${1:ShelfSpec}, ${2:SlotInit}, ${3:ShelfHandle})$4\n$0","description":"shelf_create(++ShelfSpec, ?SlotInit, -ShelfHandle)\n\n   Create a shelf object which can store data across failures\n\nArguments\n   ShelfSpec    A term of the form Name/Arity\n   SlotInit    The value used to initialize the slots (any term)\n   ShelfHandle    A free variable\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates a 'shelf' object which can be used to store\n\tinformation across failures.  A typical application is counting\n\tof solutions, keeping track of the best solution, aggregating\n\tinformation across multiple solutions etc.\n\n\tA shelf is an object with multiple slots whose contents survive\n\tbacktracking. The content of each slot can be set and retrieved\n\tindividually, or the whole shelf can be retrieved as a term.\n\n\tShelves are referred to by handle, not by name, so they make\n\tit easy to write robust, reentrant code. A shelf disappears when\n\tthe system backtracks over its creation, when the shelf handle\n\tgets garbage collected, or when it is explicitly destroyed.\n\n\tWhen using shelf_create/3, ShelfSpec determines the number of\n\tslots on the shelf, and all slots get initialized identically\n\twith the value SlotInit.\n    \n\nModes and Determinism\n   shelf_create(++, ?, -) is det\n\nExceptions\n     4 --- ShelfSpec is not fully instantiated\n     5 --- ShelfSpec is fully instantiated but not to a term of the form Atom/Integer\n     5 --- ShelfHandle is not a variable\n\nExamples\n   \n% finding the sum and maximum of data/1 facts:\n\n    data(2).\n    data(9).\n    data(3).\n    data(5).\n    data(7).\n\n    sum_and_max(Sum, Max) :-\n    \tshelf_create(agg/2, 0, Shelf),\n\t(\n\t    data(X),\n\t    shelf_get(Shelf, 1, OldMax),\n\t    ( X > OldMax -> shelf_set(Shelf, 1, X) ; true ),\n\t    shelf_get(Shelf, 2, OldSum),\n\t    NewSum is OldSum + X,\n\t    shelf_set(Shelf, 2, NewSum),\n\t    fail\n\t;\n\t    shelf_get(Shelf, 0, agg(Max, Sum))\n\t),\n\tshelf_abolish(Shelf).\n    \n\nSee Also\n   shelf_create / 2, shelf_set / 3, shelf_get / 3, shelf_abolish / 1"},"shelf/2":{"prefix":"local","body":"local","description":"local shelf(++Name, +Init)\n\n   Create a named shelf object which can store data across failures\n\nArguments\n   Name    An atom, or an atom/integer structure\n   Init    A structure\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates a 'shelf' object which can be used to store\n\tinformation across failures.  A typical application is counters\n\tfor statistics, etc.\n\n\tA shelf is an object with multiple slots whose contents survive\n\tbacktracking. The content of each slot can be set and retrieved\n\tindividually, or the whole shelf can be retrieved as a term.\n\n\tShelves can be referred to either by handle or by name. Whenever\n\tpossible, handles should be used, because this naturally leads to\n\trobust, reentrant code, and avoids the danger of memory leaks.\n\tSee shelf_create/2,3 for how to create shelves with a handle.\n\n\tNamed shelves are identified by a functor. This is usually simply\n\tan atom, but in general it can be name/arity pair.\n\n\tWhen named shelves are used, the visibility of the shelf name is\n\tlocal to the module where it was created. A named shelf never\n\tdisappears, therefore, in order to free the associated memory,\n\tits contents should be erased when no longer needed.\n\n\tDuplicate shelf declarations are silently ignored.\n    \n\nModes and Determinism\n   shelf(++, +) is det\n\nExceptions\n     4 --- Name or Init is uninstantiated\n     5 --- Init is not a structure\n     5 --- Name is neither an atom nor an atom/integer structure\n\nExamples\n   \n\n    % A store with the simple, atomic name 'counters'\n\n    :- local shelf(counters, count(0,0,0)).\n\n    main :-\n\tshelf_get(counters,1,N0), N1 is N0+1, shelf_set(counters,1,N1),\n\tprintf(\"main has been called %d times%n\", [N1]).\n    \n\nSee Also\n   shelf_create / 2, shelf_create / 3, local / 1, shelf_set / 3, shelf_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_erase / 1, store_count / 2"},"shelf_abolish/1":{"prefix":"shelf_abolish","body":"shelf_abolish(${1:ShelfHandle})$2\n$0","description":"shelf_abolish(+ShelfHandle)\n\n   Destroy a shelf explicitly\n\nArguments\n   ShelfHandle    A shelf handle\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis explicitly destroys a previously created shelf object and\n\tfrees all its memory.  Invoking shelf_abolish/1 is optional,\n\tthe shelf will be automatically destroyed when the system\n\tbacktracks across the call to shelf_create/2,3, or when the\n\tShelfHandle is no longer needed and gets garbage collected.\n\n\tUsing the ShelfHandle after it has been destroyed will lead\n\tto an error message. Destroying an already destroyed shelf\n\tdoes nothing and is silently accepted.\n    \n\nModes and Determinism\n   shelf_abolish(+) is det\n\nExceptions\n     4 --- ShelfHandle is not instantiated\n     5 --- ShelfHandle is not a shelf\n    40 --- ShelfHandle refers to an already destroyed shelf\n\nExamples\n   For examples see shelf_create/2,3.\n\nSee Also\n   shelf_create / 2, shelf_create / 3, shelf_get / 3, shelf_set / 3"},"shelf_create/2":{"prefix":"shelf_create","body":"shelf_create(${1:InitTerm}, ${2:ShelfHandle})$3\n$0","description":"shelf_create(+InitTerm, -ShelfHandle)\n\n   Create a shelf object which can store data across failures\n\nArguments\n   InitTerm    A compound term\n   ShelfHandle    A free variable\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates a 'shelf' object which can be used to store\n\tinformation across failures.  A typical application is counting\n\tof solutions, keeping track of the best solution, aggregating\n\tinformation across multiple solutions etc.\n\n\tA shelf is an object with multiple slots whose contents survive\n\tbacktracking. The content of each slot can be set and retrieved\n\tindividually, or the whole shelf can be retrieved as a term.\n\n\tShelves are referred to by handle, not by name, so they make\n\tit easy to write robust, reentrant code. A shelf disappears when\n\tthe system backtracks over its creation, when the shelf handle\n\tgets garbage collected, or when it is explicitly destroyed.\n\n\tA shelf is initialized from a compound term InitTerm. InitTerm's\n\tarity determines the number of slots the shelf provides, and\n\tInitTerm's arguments are used to initialize the corresponding\n\tshelf slots.\n    \n\nModes and Determinism\n   shelf_create(+, -) is det\n\nExceptions\n     4 --- InitTerm is not instantiated\n     5 --- InitTerm is instantiated but not to a compound term\n     5 --- ShelfHandle is not a variable\n\nExamples\n   \n\n% a meta-predicate to count the number of solutions to a goal:\n\n    count_solutions(Goal, Total) :-\n    \tshelf_create(count(0), Shelf),\n\t(\n\t    call(Goal),\n\t    shelf_inc(Shelf, 1),\n\t    fail\n\t;\n\t    shelf_get(Shelf, 1, Total)\n\t),\n\tshelf_abolish(Shelf).\n\n% finding the sum and maximum of data/1 facts:\n\n    data(2).\n    data(9).\n    data(3).\n    data(5).\n    data(7).\n\n    sum_and_max(Sum, Max) :-\n    \tshelf_create(agg(0,0), Shelf),\n\t(\n\t    data(X),\n\t    shelf_get(Shelf, 1, OldMax),\n\t    ( X > OldMax -> shelf_set(Shelf, 1, X) ; true ),\n\t    shelf_get(Shelf, 2, OldSum),\n\t    NewSum is OldSum + X,\n\t    shelf_set(Shelf, 2, NewSum),\n\t    fail\n\t;\n\t    shelf_get(Shelf, 0, agg(Max, Sum))\n\t),\n\tshelf_abolish(Shelf).\n\n% if-then-else with backtracking over the condition:\n\n    if(Cond, Then, Else) :-\n\tshelf_create(sol(no), SolFlag),\n\t(\n\t    call(Cond),\n\t    shelf_set(SolFlag, 1, yes),   % remember there was a solution\n\t    call(Then)\n\t;\n\t    shelf_get(SolFlag, 1, no),    % fail if there was a solution\n\t    call(Else)\n\t).\n    \n\nSee Also\n   shelf_create / 3, shelf_set / 3, shelf_get / 3, shelf_abolish / 1, array / 1, bag_create / 1"},"shelf_dec/2":{"prefix":"shelf_dec","body":"shelf_dec(${1:ShelfHandle}, ${2:Index})$3\n$0","description":"shelf_dec(+ShelfHandle, +Index)\n\n   Decrement an integer slot within a shelf object but fail if is zero\n\nArguments\n   ShelfHandle    A shelf handle or shelf name\n   Index    An integer\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis looks up the entry in the Index'th slot of the shelf object\n\tdenoted by ShelfHandle, and if such an entry exists, and is of integer\n\ttype, it is decremented by one.  If the old value is already zero\n\t(or less), the predicate fails and the shelf remains unchanged.\n\tThis predicate is a shorthand for:\n\n\tshelf_dec(ShelfHandle, Index) :-\n\t    shelf_get(ShelfHandle, Index, C0),\n\t    C0 > 0,\n\t    C1 is C0 - 1,\n\t    shelf_set(ShelfHandle, Index, C1).\n\n\tThe slots are numbered from 1 to the maximum which was determined\n\tduring shelf creation (but note that ECLiPSe's struct-syntax can\n\tbe used to give the slots symbolic names, see struct/1).\n\n\tNote: If ShelfHandle is not a handle, then it must be an atom or a\n\tcompound term, and the shelf is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   shelf_dec(+, +) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if decrementing the value would result in a negative number\n\nExceptions\n     4 --- ShelfHandle is not instantiated\n     5 --- Index is not instantiated\n     5 --- ShelfHandle is not a shelf\n     5 --- Index is not an integer\n     6 --- Index is less than 1 or greater than the number of slots on the shelf\n     6 --- The old counter value exceeds an implementation-defined limit (at least 2^31)\n    40 --- ShelfHandle refers to an already destroyed shelf\n\nExamples\n   \n    :- local shelf(backtrack_limit, count(100)).\n\n    nat(0).\n    nat(N) :-\n\tshelf_dec(backtrack_limit, 1),   % fail when limit reached\n\tnat(N0),\n    \tN is N0+1.\n\n    ?- shelf_set(backtrack_limit, 1, 5),\n       findall(X, nat(X), L).\n\n    X = X\n    L = [0, 1, 2, 3, 4, 5]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   shelf_create / 2, shelf_create / 3, shelf_inc / 2, shelf_set / 3, shelf_abolish / 1, struct / 1"},"storage_desc":{"prefix":"lib","body":"lib(${1:storage})$2\n$0","description":"lib(storage)\n\n\tECLiPSe provides several facilities to store information across\n\tbacktracking. The following table gives an overview. If at all\n\tpossible, the handle-based facilities (bags, records, shelves,\n\tstores) should be preferred because they lead to cleaner, reentrant\n\tcode (without global state) and reduce the risk of memory leaks.\n\n    Facility    Type    Reference       See\n    ================================================================\n    bags    unordered bag   by handle       bag_create/1\n    ----------------------------------------------------------------\n    anon.records    ordered list    by handle       record_create/1\n    ----------------------------------------------------------------\n    shelves    array    by handle       shelf_create/2,3\n    ----------------------------------------------------------------\n    stores    hash table      by handle       store_create/1\n    ----------------------------------------------------------------\n    named shelves   array    by name    shelf/2\n    ----------------------------------------------------------------\n    named stores    hash table      by name    store/1\n    ----------------------------------------------------------------\n    non-logical     single cell     by name    variable/1,2\n    variables\n    ----------------------------------------------------------------\n    non-logical     array    by name    array/1,2\n    arrays\n    ----------------------------------------------------------------\n    named records   ordered list    by name    record/1,2\n    ----------------------------------------------------------------\n    dynamic    ordered list    by name    dynamic/1,assert/1\n    predicates\n    ----------------------------------------------------------------"},"shelf_inc/2":{"prefix":"shelf_inc","body":"shelf_inc(${1:ShelfHandle}, ${2:Index})$3\n$0","description":"shelf_inc(+ShelfHandle, +Index)\n\n   Increment an integer slot within a shelf object\n\nArguments\n   ShelfHandle    A shelf handle or shelf name\n   Index    An integer\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis looks up the entry in the Index'th slot of the shelf object\n\tdenoted by ShelfHandle, and if such an entry exists, and is of integer\n\ttype, it is incremented by one.  This predicate is a shorthand for:\n\n\tshelf_inc(ShelfHandle, Index) :-\n\t    shelf_get(ShelfHandle, Index, C0),\n\t    C1 is C0 + 1,\n\t    shelf_set(ShelfHandle, Index, C1).\n\n\tThe slots are numbered from 1 to the maximum which was determined\n\tduring shelf creation (but note that ECLiPSe's struct-syntax can\n\tbe used to give the slots symbolic names, see struct/1).\n\n\tNote: If ShelfHandle is not a handle, then it must be an atom or a\n\tcompound term, and the shelf is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   shelf_inc(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ShelfHandle is not instantiated\n     5 --- Index is not instantiated\n     5 --- ShelfHandle is not a shelf\n     5 --- Index is not an integer\n     6 --- Index is less than 1 or greater than the number of slots on the shelf\n     6 --- The counter value exceeds an implementation-defined limit (at least 2^31)\n    40 --- ShelfHandle refers to an already destroyed shelf\n\nExamples\n   For examples see shelf_create/2,3.\n\nSee Also\n   shelf_create / 2, shelf_create / 3, shelf_dec / 2, shelf_set / 3, shelf_abolish / 1, struct / 1"},"shelf_set/3":{"prefix":"shelf_set","body":"shelf_set(${1:ShelfHandle}, ${2:Index}, ${3:Term})$4\n$0","description":"shelf_set(+ShelfHandle, +Index, ?Term)\n\n   Store a term in a shelf object\n\nArguments\n   ShelfHandle    A shelf handle or shelf name\n   Index    An integer\n   Term    An arbitrary term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis stores an arbitrary term in the Index'th slot of the\n\tshelf object denoted by ShelfHandle.  All other slots of the\n\tshelf remain untouched.  The setting will persist until it is\n\treplaced with a new setting, or until the shelf is destroyed. \n\tIn particular, the setting will survive backtracking across\n\tthe call to shelf_set/3.\n\n\tThe slots are numbered from 1 to the maximum which was determined\n\tduring shelf creation (but note that ECLiPSe's struct-syntax can\n\tbe used to give the slots symbolic names, see struct/1).\n\n\tCalling shelf_set/3 with an Index of 0 can be used to set all\n\tslots at once. In this case, Term must be a compound term whose\n\tfunctor corresponds to the one that was given during shelf creation.\n\tEvery shelf slot is set from the corresponding term argument.\n\n\tStoring and retrieving terms from a shelf involves copying the\n\tterm each time, similar to what happens in setval/getval and\n\trecord/recorded.  In particular, if the term contains variables,\n\tthey lose their identity and are replaced with fresh ones.\n\tAlso, the different slots of a shelf are separate entities,\n\tin particular, they cannot share variables between each other.\n\n\tNote: If ShelfHandle is not a handle, then it must be an atom or a\n\tcompound term, and the shelf is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   shelf_set(+, +, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ShelfHandle is not instantiated\n     5 --- Index is not instantiated\n     5 --- ShelfHandle is not a shelf\n     5 --- Index is not an integer\n     6 --- Index is negative or greater than the number of slots on the shelf\n    40 --- ShelfHandle refers to an already destroyed shelf\n\nExamples\n   For examples see shelf_create/2,3.\n\nSee Also\n   shelf_create / 2, shelf_create / 3, shelf_get / 3, shelf_abolish / 1, struct / 1"},"shelf_get/3":{"prefix":"shelf_get","body":"shelf_get(${1:ShelfHandle}, ${2:Index}, ${3:Term})$4\n$0","description":"shelf_get(+ShelfHandle, +Index, -Term)\n\n   Retrieve a stored term from a shelf object\n\nArguments\n   ShelfHandle    A shelf handle or shelf name\n   Index    An integer\n   Term    An arbitrary term or a variable\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis retrieves a copy of the stored term from the Index'th slot\n\tof the shelf object denoted by ShelfHandle.\n\n\tThe slots are numbered from 1 to the maximum which was determined\n\tduring shelf creation (but note that ECLiPSe's struct-syntax can\n\tbe used to give the slots symbolic names, see struct/1).\n\n\tCalling shelf_get/3 with an Index of 0 retrieves the whole\n\tshelf with all its slots as a single compound term whose functor\n\tcorresponds to the one that was given during shelf creation.\n\n\tStoring and retrieving terms from a shelf involves copying the\n\tterm each time, similar to what happens in setval/getval and\n\trecord/recorded.  In particular, if the term contains variables,\n\tthey lose their identity and are replaced with fresh ones.\n\n\tNote: If ShelfHandle is not a handle, then it must be an atom or a\n\tcompound term, and the shelf is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   shelf_get(+, +, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ShelfHandle is not instantiated\n     5 --- Index is not instantiated\n     5 --- ShelfHandle is not a shelf\n     5 --- Index is not an integer\n     6 --- Index is negative or greater than the number of slots on the shelf\n    40 --- ShelfHandle refers to an already destroyed shelf\n\nExamples\n   For examples see shelf_create/2,3.\n\nSee Also\n   shelf_create / 2, shelf_create / 3, shelf_set / 3, shelf_abolish / 1, struct / 1"},"store/1":{"prefix":"local","body":"local","description":"local store(++Name)\n\n   Create a named store object which can store indexed data across failures\n\nArguments\n   Name    An atom, or an atom/integer structure\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates a 'store' object which provides indexed access to\n\tkey-value pairs, and whose contents are unaffected by backtracking.\n\n\tA store is a persistent (w.r.t. backtracking) hash table. It can\n\tstore arbitrary ECLiPSe terms under arbitrary ground keys.\n\n\tStores can be referred to either by handle or by name. Whenever\n\tpossible, handles should be used, because this naturally leads to\n\trobust, reentrant code, and avoids the danger of memory leaks.\n\tSee store_create/1 for how to create stores with a handle.\n\n\tNamed stores are identified by a functor. This is usually simply\n\tan atom, but in general it can be name/arity pair.\n\n\tWhen named stores are used, the visibility of the store name is\n\tlocal to the module where it was created. A named store never\n\tdisappears, therefore, in order to free the associated memory,\n\tits contents should be erased when no longer needed.\n\n\tDuplicate store declarations are silently ignored.\n    \n\nModes and Determinism\n   store(++) is det\n\nExceptions\n     4 --- Name is uninstantiated\n     5 --- Name is neither an atom nor an atom/integer structure\n\nExamples\n   \n\n    % A store with the simple, atomic name 'phone_numbers'\n\n    :- local store(phone_numbers).\n\n    main1 :-\n\tstore_set(phone_numbers, name(peter,panther), data(1234,mobile)),\n\tstore_set(phone_numbers, name(tom,tiger), data(4567,home)),\n\tstored_keys_and_values(phone_numbers, Contents),\n\twriteln(Contents).\n\n    % A store identified by the functor foo/3\n\n    :- local store(foo/3).\n\n    main2 :-\n\tstore_set(foo(_,_,_), key_1, value_1),\n\tstore_set(foo(_,_,_), key_2, value_2),\n\tstored_keys_and_values(foo(_,_,_), Contents),\n\twriteln(Contents).\n    \n\nSee Also\n   current_store / 1, store_create / 1, local / 1, store_set / 3, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_erase / 1, store_count / 2"},"store_contains/2":{"prefix":"store_contains","body":"store_contains(${1:StoreHandle}, ${2:Key})$3\n$0","description":"store_contains(+StoreHandle, ++Key)\n\n   Check for an entry in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Key    A ground term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis checks whether a given store object contains an entry for a\n\tgiven key.  If so, the predicate succeeds, otherwise it fails.\n\n\tThe key can be arbitrarily complex, but must be a ground term.\n\n\tThe complexity of this  operation is linear in the size\n\tof the key, since the key needs to be compared. For indexing purposes,\n\ta hash value is computed from the key, and the full depth of the key\n\tis taken into account.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\n    \n\nModes and Determinism\n   store_contains(+, ++) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The store does not contain an entry for Key\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     4 --- Key is not ground\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_contains(Handle, tom).\n\n    Yes (0.00s cpu)\n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_contains(Handle, harry).\n\n    No (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_set / 3, store_delete / 2, store_get / 3, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"store_create/1":{"prefix":"store_create","body":"store_create(${1:StoreHandle})$2\n$0","description":"store_create(-StoreHandle)\n\n   Create an anonymous store object which can store indexed data across failures\n\nArguments\n   StoreHandle    A free variable\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis creates a 'store' object which provides indexed access to\n\tkey-value pairs, and whose contents are unaffected by backtracking.\n\n\tA store is a persistent (w.r.t. backtracking) hash table. It can\n\tstore arbitrary ECLiPSe terms under arbitrary ground keys.\n\n\tStores can be referred to either by handle or by name. Whenever\n\tpossible, handles should be used, because this naturally leads to\n\trobust, reentrant code, and avoids the danger of memory leaks.\n\tA store disappears when the system backtracks over its creation,\n\twhen the store handle gets garbage collected, or when it is\n\texplicitly destroyed.\n\n\tWhen named stores are used, the visibility of the store name is\n\tlocal to the module where it was created. A named store never\n\tdisappears, therefore, in order to free the associated memory,\n\tits contents should be erased when no longer needed.\n    \n\nModes and Determinism\n   store_create(-) is det\n\nExceptions\n     5 --- StoreHandle is not a variable\n\nExamples\n   \n\n% Creating and using an 'anonymous store'\n\n    main2 :-\n\tstore_create(Handle),\n\tstore_set(Handle, name(peter,panther), data(1234,mobile)),\n\tstore_set(Handle, name(tom,tiger), data(4567,home)),\n\tstored_keys_and_values(Handle, Contents),\n\twriteln(Contents).\n\n% Creating and using a 'named store'\n\n    :- local store(phone_numbers).\n\n    main1 :-\n\tstore_set(phone_numbers, name(peter,panther), data(1234,mobile)),\n\tstore_set(phone_numbers, name(tom,tiger), data(4567,home)),\n\tstored_keys_and_values(phone_numbers, Contents),\n\twriteln(Contents).\n    \n\nSee Also\n   store / 1, local / 1, store_set / 3, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_erase / 1, store_count / 2"},"store_delete/2":{"prefix":"store_delete","body":"store_delete(${1:StoreHandle}, ${2:Key})$3\n$0","description":"store_delete(+StoreHandle, ++Key)\n\n   Delete an entry in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Key    A ground term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis deletes any entry for a given key in a given store object.\n\tIf the store does not contain such an entry, the predicate\n\tsilently succeeds anyway.\n\n\tThe key can be arbitrarily complex, but must be a ground term.\n\n\tThe complexity of this operation is linear in the size\n\tof the key, since the key needs to be compared. For indexing purposes,\n\ta hash value is computed from the key, and the full depth of the key\n\tis taken into account.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\n    \n\nModes and Determinism\n   store_delete(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     4 --- Key is not ground\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       stored_keys_and_values(Handle, Before),\n       store_delete(Handle, tom),\n       stored_keys_and_values(Handle, After).\n\n    Handle = 'STORE'(16'001b3d40)\n    Before = [tom - 12345]\n    After = []\n    Yes (0.00s cpu)\n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_delete(Handle, tom),\n       store_delete(Handle, tom).\n\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_set / 3, store_contains / 2, store_get / 3, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"store_count/2":{"prefix":"store_count","body":"store_count(${1:StoreHandle}, ${2:Count})$3\n$0","description":"store_count(+StoreHandle, -Count)\n\n   Retrieve the number of entries in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Count    Variable or integer\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis returns the count of the number of entries in a store object.\n    \tFor an empty store, 0 (zero) is returned.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   store_count(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_count(Handle, N1),\n       store_set(Handle, tom, 12345),\n       store_count(Handle, N2),\n       store_set(Handle, dick, 42376),\n       store_count(Handle, N3),\n       store_set(Handle, harry, 84223),\n       store_count(Handle, N4),\n       store_delete(Handle, dick),\n       store_count(Handle, N5),\n       store_erase(Handle),\n       store_count(Handle, N6).\n\n    Handle = 'STORE'(16'002f4ef8)\n    N1 = 0\n    N2 = 1\n    N3 = 2\n    N4 = 3\n    N5 = 2\n    N6 = 0\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_set / 3, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"store_erase/1":{"prefix":"store_erase","body":"store_erase(${1:StoreHandle})$2\n$0","description":"store_erase(+StoreHandle)\n\n   Erase the contents of the specified store object\n\nArguments\n   StoreHandle    A store handle or store name\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n    \tThis erases the contents of the store object and frees the associated\n\tmemory. The store object itself remains valid and is equivalent to a\n\tnewly created store.\n\n\tNote that anonymous stores (which are referred to by handle rather\n\tthan name) are automatically erased and destroyed when their handle\n\tgets garbage collected, or when failing across their creation point.\n\n\tOn the other hand, named stores should be explicitly erased,\n\totherwise their contents will continue to occupy memory.\n\n\tCalling store_erase/1 is equivalent to deleting every entry in\n\tthe store via store_delete/2.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\t.\n    \n\nModes and Determinism\n   store_erase(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, key, value),\n       stored_keys_and_values(Handle, Data1),\n       store_count(Handle, N1),\n       store_erase(Handle),\n       stored_keys_and_values(Handle, Data2),\n       store_count(Handle, N2).\n\n    Handle = 'STORE'(16'002f4da0)\n    Data1 = [key - value]\n    N1 = 1\n    Data2 = []\n    N2 = 0\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_set / 3, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"store_inc/2":{"prefix":"store_inc","body":"store_inc(${1:StoreHandle}, ${2:Key})$3\n$0","description":"store_inc(+StoreHandle, ++Key)\n\n   Increment an integral entry within a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Key    A ground term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis looks up an entry under a given key in a given store object, and\n\tif such an entry exists, and is of integer type, it is incremented by\n\tone.  If no entry exists, an entry with integer value 1 is created.\n\n\tThis predicate is a shorthand for:\n\n\tstore_inc(Handle, Key) :-\n\t    ( store_get(Handle, Key, C0) ->\n\t\tC1 is C0 + 1,\n\t\tstore_set(Handle, Key, C1)\n\t    ;\n\t\tstore_set(Handle, Key, 1)\n\t    ).\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   store_inc(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     4 --- Key is not a ground term\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n    ?- store_create(Handle),\n       store_set(Handle, count, 7),\n       store_inc(Handle, count),\n       store_get(Handle, count, N).\n    Handle = 'STORE'(16'00334e20)\n    N1 = 8\n    Yes (0.00s cpu)\n\n    ?- store_create(Handle),\n       store_inc(Handle, foo),\n       store_get(Handle, foo, N).\n    Handle = 'STORE'(16'00334e20)\n    N = 1\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_set / 3, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"store_get/3":{"prefix":"store_get","body":"store_get(${1:StoreHandle}, ${2:Key}, ${3:Value})$4\n$0","description":"store_get(+StoreHandle, ++Key, -Value)\n\n   Look up an entry in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Key    A ground term\n   Value    A variable or arbitrary term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis looks up an entry under a given key in a given store object.\n\tIf an entry for this key exists, the corresponding value is returned,\n\totherwise the predicate fails.\n\n\tThe key can be arbitrarily complex, but must be a ground term.\n\tThe value can be an arbitrary term, and may contain uninstantiated\n\tvariables. Note that values are copied when being stored or\n\tretrieved, therefore a retrieved nonground value will contain\n\tfresh variables rather than the original ones (this is similar\n\tto the behaviour of bags, shelves and global variables).\n\n\tThe complexity of the retrieval operation is linear in both the size\n\tof the key and the value, since the value is being copied and the key\n\tneeds to be compared. For indexing purposes, a hash value is computed\n\tfrom the key, and the full depth of the key is taken into account.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\n    \n\nModes and Determinism\n   store_get(+, ++, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The store does not contain an entry for Key\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     4 --- Key is not ground\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_set(Handle, name(dick,tracy), phone(42376,home)),\n       store_set(Handle, numbers:prime, [2,3,5,7|_More]),\n       store_get(Handle, tom, Value1),\n       store_get(Handle, name(dick,tracy), Value2),\n       store_get(Handle, numbers:prime, Value3).\n\n    Handle = 'STORE'(16'001b3c50)\n    Value1 = 12345\n    Value2 = phone(42376, home)\n    Value3 = [2, 3, 5, 7|_More]\n    Yes (0.00s cpu)\n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_get(Handle, harry, Value).\n\n    No (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_set / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2, store_inc / 2"},"store_set/3":{"prefix":"store_set","body":"store_set(${1:StoreHandle}, ${2:Key}, ${3:Value})$4\n$0","description":"store_set(+StoreHandle, ++Key, ?Value)\n\n   Make an entry into a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Key    A ground term\n   Value    An arbitrary term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis stores an arbitrary ECLiPSe term under a given key into\n\tthe given store object. If an entry for this key already exists,\n\tit will be replaced by the new entry. \n\n\tThe key can be arbitrarily complex, but must be a ground term.\n\tThe value can be an arbitrary term, and may contain uninstantiated\n\tvariables. Note that values are copied when being stored or\n\tretrieved, therefore a retrieved nonground value will contain\n\tfresh variables rather than the original ones (this is similar\n\tto the behaviour of bags, shelves and global variables).\n\n\tThe complexity of the store operation is linear in both the size\n\tof the key and the value, since both are being copied. For indexing\n\tpurposes, a hash value is computed from the key, and the full depth\n\tof the key is taken into account.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\n    \n\nModes and Determinism\n   store_set(+, ++, ?) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     4 --- Key is not ground\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_set(Handle, name(dick,tracy), phone(42376,home)),\n       store_set(Handle, numbers:prime, [2,3,5,7|_More]),\n       stored_keys_and_values(Handle, Data).\n\n    Handle = 'STORE'(16'003130e8)\n    Data = [(numbers : prime) - [2, 3, 5, 7|_123],\n    tom - 12345,\n\t    name(dick, tracy) - phone(42376, home)]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_get / 3, store_delete / 2, store_contains / 2, stored_keys / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2, store_inc / 2"},"stored_keys_and_values/2":{"prefix":"stored_keys_and_values","body":"stored_keys_and_values(${1:StoreHandle}, ${2:KeysValues})$3\n$0","description":"stored_keys_and_values(+StoreHandle, -KeysValues)\n\n   Retrieve all data stored in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   KeysValues    A variable or list\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis retrieves a list of all key/value pairs which are stored\n\tin the given store object. If the store is empty, the empty list\n\tis returned. Otherwise, a list of Key - Value terms is returned.\n\n\tThe order of the returned list is undefined.\n\n\tThe complexity of this operation is linear in the size of all keys\n\tand values, since they need to be copied.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n\n    \n\nModes and Determinism\n   stored_keys_and_values(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_set(Handle, name(dick,tracy), phone(42376,home)),\n       store_set(Handle, numbers:prime, [2,3,5,7|_More]),\n       stored_keys_and_values(Handle, Data).\n\n    Handle = 'STORE'(16'003130e8)\n    Data = [(numbers : prime) - [2, 3, 5, 7|_More],\n    tom - 12345,\n\t    name(dick, tracy) - phone(42376, home)]\n    Yes (0.00s cpu)\n\n    ?- store_create(Handle),\n       stored_keys_and_values(Handle, Data).\n\n    Handle = 'STORE'(16'003130e8)\n    Data = []\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_set / 3, store_contains / 2, store_get / 3, store_delete / 2, stored_keys / 2, store_create / 1, store_count / 2"},"test_and_setval/3":{"prefix":"test_and_setval","body":"test_and_setval(${1:VarName}, ${2:Old}, ${3:New})$4\n$0","description":"test_and_setval(+VarName, ?Old, ?New)\n\n   Test whether a non-logical variable has value Old and if so, set it to New.\n\nArguments\n   VarName    An atom\n   Old    A term\n   New    A term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   VarName must be the name of a non-logical variable (not an array\n   element and not a reference).  If the current value of this\n   variable is not identical to Old, the predicate fails.  If it is\n   identical, the variable's value gets changed to the value New. \n   Test and set is done as an atomic operation.\n\nModes and Determinism\n   test_and_setval(+, ?, ?) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails it the current value of the variable is not identical to Old\n\nExceptions\n     4 --- VarName is not ground\n     5 --- VarName not an atom\n     5 --- VarName is the name of a reference\n    41 --- VarName is not the name of a non-logical variable.\n\nExamples\n   \nSuccess:\n     ?- setval(k, 3), test_and_setval(k, 3, 5).\n\n     wait_for_lock :-\n\t    ( test_and_setval(lock, 0, 1) ->\n\t\ttrue\n\t    ;\n\t    wait_for_lock\n\t    ).\n\nFail:\n      setval(k, 1), test_and_setval(k, 3, 5).\n\nSee Also\n   decval / 1, incval / 1, variable / 1, setval / 2, getval / 2"},"variable/1":{"prefix":"local","body":"local","description":"local variable(+Name)\n\n   Creates the untyped non-logical variable Name.\n\nArguments\n   Name    An atom.\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   If Name is an Atom, a non-logical variable (visible only in the\n   caller module) is created.  Its value is initialised to a free\n   variable.  The contents of the variable persists across failures.\n   The value of a non-logical variable can be changed with\n   setval/2 and retrieved with getval/2.  Setting and retrieving terms\n   from a non-logical variable involves copying the term each time. \n   In particular, if the term contains variables, they lose their\n   identity and are replaced with fresh ones.\n\n   Notes:\n\n   Declaring a variable twice is silently accepted.\n\nModes and Determinism\n   variable(+) is det\n\nExceptions\n     4 --- Name is not instantiated.\n     5 --- Name is not an atom.\n\nExamples\n   \nSuccess:\n      :- local variable(a).\n      :- local variable(count), variable(value).\n\nError:\n      :- local variable(X).    (Error 4).\n      :- local variable(6).    (Error 5).\n\nSee Also\n   current_array / 2, array / 1, array / 2, decval / 1, incval / 1, bag_create / 1, getval / 2, setval / 2, reference / 1, reference / 2, variable / 2"},"variable/2":{"prefix":"local","body":"local","description":"local variable(+Name, ?Init)\n\n   Creates the untyped non-logical variable Name.\n\nArguments\n   Name    An atom.\n   Init    Any term\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n   A non-logical variable with name Name (visible only in the\n   caller module) is created.  Its value is initialised to Init.\n   The contents of the variable persists across failures.\n   The value of a non-logical variable can be changed with\n   setval/2 and retrieved with getval/2.  Setting and retrieving terms\n   from a non-logical variable involves copying the term each time. \n   In particular, if the term contains variables, they lose their\n   identity and are replaced with fresh ones.\n\n   Notes:\n\n   Declaring a variable twice is silently accepted, and the second\n   declaration is ignored.\n\nModes and Determinism\n   variable(+, ?) is det\n\nExceptions\n     4 --- Name is not instantiated.\n     5 --- Name is not an atom.\n\nExamples\n   \nSuccess:\n      :- local variable(a,[]).\n      :- local variable(count,0), variable(value,colour(red)).\n\nError:\n      :- local variable(X, []).    (Error 4).\n      :- local variable(6, 0).    (Error 5).\n\nSee Also\n   current_array / 2, array / 1, array / 2, decval / 1, incval / 1, bag_create / 1, getval / 2, setval / 2, reference / 1, reference / 2, variable / 1"},"append_strings/3":{"prefix":"append_strings","body":"append_strings(${1:String1}, ${2:String2}, ${3:String3})$4\n$0","description":"append_strings(?String1, ?String2, ?String3)\n\n   Succeeds if String3 is the concatenation of String1 and String2.\n\nArguments\n   String1    String or variable.\n   String2    String or variable.\n   String3    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Succeeds if String3 is the concatenation of String1 and String2.\n\n   Used to find all possible solutions for the concatenation of String1 and\n   String2 to make String3.\n\n   Note that if String1 and String2 are instantiated, it is more efficient\n   to use the predicate concat_strings/3.\n\nModes and Determinism\n   append_strings(+, +, -) is det\n   append_strings(+, -, +) is det\n   append_strings(-, +, +) is det\n   append_strings(-, -, +) is multi\n\nExceptions\n     5 --- One (or more) of the arguments is instantiated, but not to a    string.\n     4 --- String3 and at least one other argument are uninstantiated.\n\nExamples\n   \nSuccess:\n      append_strings(\"a\",B,\"abc\"). (gives B = \"bc\").\n      append_strings(A,B,\"a\").     (gives A=\"\"  B=\"a\";\n    A=\"a\" B=\"\").\nFail:\n      append_strings(\"a\",\"b\",\"abc\").\nError:\n      append_strings(A,\"bc\",C).    (Error 4).\n      append_strings(5,B,C).    (Error 5).\n      append_strings(A,'me',\"meme\").   (Error 5).\n\nSee Also\n   concat_strings / 3, concat_string / 2, join_string / 3, sprintf / 3"},"atom_length/2":{"prefix":"atom_length","body":"atom_length(${1:Atom}, ${2:Length})$3\n$0","description":"atom_length(+Atom, -Length)\n\n   Succeeds if Length is the length of Atom.\n\nArguments\n   Atom    Atom.\n   Length    Integer or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   The length of an atom Atom is unified with Length.  The length of an\n   atom is the number of characters in the atom's name.\n\n    Note that (like all predicates that return a number as their last\n    argument), this predicate can be used as a function inside arithmetic\n    expressions.\n\nModes and Determinism\n   atom_length(+, -) is det\n\nExceptions\n     4 --- Atom is not instantiated (non-coroutine mode only).\n     5 --- Atom is instantiated, but not to an atom.\n     5 --- Length is neither an integer nor a variable.\n\nExamples\n   \nSuccess:\n      atom_length(test, 4).\n      atom_length(test,L).    (gives L = 4).\n      atom_length(as, X).    (gives X = 2).\n      atom_length('4', 1).\n\nFail:\n      atom_length(test, 5).\n\nError:\n      atom_length(Atom, 2).    (Error 4).\n      atom_length(Atom, 2.0).      (Error 5).\n      atom_length(4, 1).    (Error 5).\n      atom_length(as, 2.0).    (Error 5).\n\nSee Also\n   atom / 1, atom_string / 2, string_length / 2"},"concat_atom/2":{"prefix":"concat_atom","body":"concat_atom(${1:List}, ${2:Dest})$3\n$0","description":"concat_atom(++List, -Dest)\n\n   Succeeds if Dest is the concatenation of the atomic terms contained in List.\nIt is more efficient to use concat_string/2 whenever possible.\n\nArguments\n   List    List of atomic terms.\n   Dest    Atom or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Dest is unified with the concatenation of the atomic terms contained in\n   List.  List may contain numbers, atoms and strings.  The result of the\n   concatenation is always an atom.\n\n   The use of this predicate is discouraged in favour of concat_string/2,\n   because the creation of new atoms involves entering them into a\n   dictionary whose garbage collection is relatively expensive.\n\nModes and Determinism\n   concat_atom(++, -) is det\n\nExceptions\n     4 --- List is not instantiated (non-coroutine mode only).\n     4 --- List contains free variables (non-coroutine mode only).\n     5 --- List is instantiated, but not to a list of atomic terms.\n     5 --- Dest is neither an atom nor a variable.\n\nExamples\n   \nSuccess:\n      concat_atom([abc,def],abcdef).\n\n      concat_atom([\"Str1\",\"Str2\"],X).\n    X = 'Str1Str2'.\n\n      concat_atom([the,man,\" is aged \",20],X).\n    X = 'theman is aged 20'.\n\n      concat_atom([1,2,3],X)\n    X = '123'.\n\nFail:\n      concat_atom([ab,bc],abc).\n\nError:\n      concat_atom(A,X).    (Error 4).\n      concat_atom([abc,D],X).  (Error 4).\n      concat_atom(art,X).      (Error 5).\n\nSee Also\n   concat_string / 2, concat_atoms / 3, atom_string / 2, join_string / 3"},"error/3":{"prefix":"error","body":"error(${1:EventId}, ${2:Culprit}, ${3:Module})$4\n$0","description":"error(++EventId, ?Culprit, +Module)\n\n   An error EventId is raised with Culprit and context module Module, and the corresponding error handler is executed\n\nArguments\n   EventId    Atom, integer or structure with functor default/1.\n   Culprit    Prolog term.\n   Module    Atom.\n\nType\n   Event Handling\n\nDescription\n   The event or error EventId with Culprit as its culprit goal is raised.\n   EventId is either an integer error number, or an atomic event name.\n   The error handler which is associated with EventId is invoked,\n   with its first argument set to EventId, its second argument to Culprit,\n   its third argument to Module, and its fourth argument to the context module\n   in which error/3 is invoked. If the handler has less than four arguments,\n   the extra information is lost.\n\n   This simulates an occurrence of the error EventId inside a call\n   to Culprit in Module.  The valid error numbers are those returned by\n   current_error/1.  Event names can be any atom as long as an event handler\n   has been defined for them.\n\n   If EventId is a structure with functor default/1, the structure argument\n   is taken as the error number and the default handler is executed, even\n   if the error handler has been redefined using set_event_handler/2.\n   This is useful for writing user error handlers.\n\n   If the event handler succeeds, possibly binding some variables\n   inside Culprit, then error/3 succeeds as well. If the handler fails\n   or calls exit_block/1, then so does error/3.\n\n   Not that when the error handler ignores the module (ie.  has arity less\n   than three), then error/2 and error/3 are equivalent.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the handler fails\n\nResatisfiable\n   Resatisfiable if the handler is resatisfiable\n\nExceptions\n     4 --- EventId is not instantiated.\n     5 --- EventId is not an error specification.\n     6 --- EventId is a number but not a valid error number.\n    32 --- No handler is associated to EventId\n\nExamples\n   \nSuccess:\n\n    ?- error(68, length(X, Y), lists).\n    calling an undefined procedure eclipse:length(X, Y) in module lists\n\n   % writing an alternative error handler for undefined predicates:\n    ?- arg(1,2).    % we want to change this\n    calling an undefined procedure arg(1, 2) in module eclipse\n\n    ?- [user].    % compile the new handler\n\n     undef_handler(_, Goal, _Context, Module) :-\n    functor(Goal, Name, BadArity),\n    (\n    current_predicate(Name/Arity)@Module\n    ;\n    current_built_in(Name/Arity)@Module\n    ),\n    !,\n    printf(\"%w does not exist, but there is %w\\n\",\n    [Name/BadArity, Name/Arity]),\n    fail.\n     undef_handler(Err, Goal, Context, Module) :-\n    error(default(Err), Goal, Context, Module).\n     user compiled 592 bytes in 0.02 seconds\n    yes.\n\n    ?- set_event_handler(68, undef_handler/4).\n    yes.\n\n    ?- arg(1,2).    % check if it works\n    arg / 2 does not exist, but there is arg / 3\n\n    no.\n\nError:\n      error(N,dummy(1),eclipse).    (Error 4).\n      error(5.0,dummy(1),eclipse).  (Error 5).\n      error(-2,dummy(1),eclipse).   (Error 6).\n      error(95,dummy(1),eclipse).   (Error 6).\n\nSee Also\n   error / 2, event / 1, current_error / 1, error_id / 2, get_event_handler / 3, reset_event_handler / 1, reset_error_handlers / 0, set_event_handler / 2"},"atom_string/2":{"prefix":"atom_string","body":"atom_string(${1:Atom}, ${2:String})$3\n$0","description":"atom_string(?Atom, ?String)\n\n   Conversion between an atom and a string.\n\nArguments\n   Atom    Atom or variable.\n   String    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   If Atom is instantiated, converts it to a string String.\n\n   If String is instantiated, converts it to an atom Atom.\n\nModes and Determinism\n   atom_string(+, -) is det\n   atom_string(-, +) is det\n\nExceptions\n     5 --- Atom is instantiated, but not to an atom.\n     5 --- String is instantiated, but not to a string.\n     4 --- Neither Atom nor String are instantiated (non-coroutine mode    only).\n\nExamples\n   \n   Success:\n   atom_string('Tom',\"Tom\").\n   atom_string(tom,X).    (gives X=\"tom\").\n   atom_string(X,\"4\").    (gives X='4').\n   Fail:\n   atom_string('jo',\"joe\").\n   Error:\n   atom_string(X,Y).    (Error 4).\n   atom_string(4,\"4\").    (Error 5).\n   atom_string(tom,'tom').    (Error 5).\n\nSee Also\n   append_strings / 3, integer_atom / 2, sprintf / 3, term_string / 2"},"concat_strings/3":{"prefix":"concat_strings","body":"concat_strings(${1:Src1}, ${2:Src2}, ${3:Dest})$4\n$0","description":"concat_strings(+Src1, +Src2, -Dest)\n\n   Succeeds if Dest is the concatenation of Src1 and Src2.\n\nArguments\n   Src1    String.\n   Src2    String.\n   Dest    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Dest is unified with the concatenation of Src1 and Src2.\n\nModes and Determinism\n   concat_strings(+, +, -) is det\n\nExceptions\n     4 --- Either (or both) of Src1 and Src2 is not instantiated    (non-coroutine mode only).\n     5 --- Either (or both) of Src1 and Src2 is instantiated, but not    to a string.\n     5 --- Dest is neither a string nor a variable.\n\nExamples\n   \nSuccess:\n  concat_strings(\"abc\",\"def\",X). (gives X=\"abcdef\").\n\n  [eclipse]: [user].\n   absolutename(File,Abs) :-\n    string_list(File,List),\n    arg(1,List,0'/) -> Abs = File;\n    (getcwd(Cwd),\n    concat_strings(Cwd,File,Abs)).\n   user compiled 256 bytes in 0.02 seconds\n  yes.\n  [eclipse]: absolutename(\"d.pl\",P), absolutename(\"/usr/bin\",F).\n  P = \"/home/lp/user/d.pl\"\n  F = \"/usr/bin\"\n  yes.\n\nFail:\n  concat_strings(\"ab\",\"bc\",\"abc\").\n\nError:\n  concat_strings(\"a\",X,\"ab\").    (Error 4).\n  concat_strings(\"big\",'gest',X).    (Error 5).\n\nSee Also\n   append_strings / 3, concat_atoms / 3, sprintf / 3"},"concat_string/2":{"prefix":"concat_string","body":"concat_string(${1:List}, ${2:Dest})$3\n$0","description":"concat_string(++List, -Dest)\n\n   Succeeds if Dest is the concatenation of the atomic terms contained in\nList.\n\nArguments\n   List    List of atomic terms.\n   Dest    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Dest is unified with the concatenation of the atomic terms contained in\n   List.  List may contain numbers, atoms and strings.  The result of the\n   concatenation is always a string.\n\nModes and Determinism\n   concat_string(++, -) is det\n\nExceptions\n     4 --- List is not instantiated (non-coroutine mode only).\n     4 --- List contains free variables (non-coroutine mode only).\n     5 --- List is instantiated, but not to a list of atomic terms.\n     5 --- Dest is neither an string nor a variable.\n\nExamples\n   \nSuccess:\n      concat_string([abc,def],\"abcdef\").\n\n      concat_string([\"Str1\",\"Str2\"],X).\n    X = \"Str1Str2\".\n\n      concat_string([the,man,\" is aged \",20],X).\n    X = \"theman is aged 20\".\n\n      concat_string([1,2,3],X).\n    X = \"123\".\n\nFail:\n      concat_string([ab,bc],\"abc\").\n\nError:\n      concat_string(A,X).    (Error 4).\n      concat_string([abc,D],X).  (Error 4).\n      concat_string(art,X).      (Error 5).\n\nSee Also\n   concat_atom / 2, concat_strings / 3, append_strings / 3, atom_string / 2, join_string / 3, split_string / 4, sprintf / 3"},"integer_atom/2":{"prefix":"integer_atom","body":"integer_atom(${1:Integer}, ${2:Atom})$3\n$0","description":"integer_atom(?Integer, ?Atom)\n\n   Conversion between an integer and an atom.\nIt is more efficient to use number_string/2 wherever possible.\n\nArguments\n   Integer    Integer or variable.\n   Atom    Atom or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   If Integer is instantiated, converts it to its associated atomic\n   representation Atom.\n\n   If Atom is instantiated, converts it to its integer form Integer.\n\n   Atom may contain only digits possibly preceded by a + or a -.\n\nModes and Determinism\n   integer_atom(+, -) is det\n   integer_atom(-, +) is semidet\n\nFail Conditions\n   Fails if Atom does not represent an integer\n\nExceptions\n     5 --- Integer is instantiated, but not to an integer.\n     5 --- Atom is instantiated, but not to an atom.\n     4 --- Both arguments are free variables (non-coroutine mode only).\n\nExamples\n   \n   Success:\n   integer_atom(1989,X).       (gives X = '1989').\n   integer_atom(X,'+12').      (gives X = 12).\n   integer_atom(-7,X).    (gives X = '-7').\n   integer_atom(X,'-7').       (gives X = -7).\n   integer_atom(N,'1234').     (gives N = 1234).\n   Fail:\n   integer_atom(I,'- 15').\n   integer_atom(I,' +15').\n   integer_atom(I,'2 ').\n   integer_atom(1234,'Abcd').\n   integer_atom(222,'123').\n   integer_atom(x,'+12').\n   Error:\n   integer_atom(A,B).    (Error 4).\n   integer_atom(124.5,X).      (Error 5).\n   integer_atom(N,1234).       (Error 5).\n\nSee Also\n   integer / 1, atom / 1, number_string / 2, sprintf / 3"},"join_string/3":{"prefix":"join_string","body":"join_string(${1:List}, ${2:Glue}, ${3:String})$4\n$0","description":"join_string(++List, +Glue, -String)\n\n   String is the string formed by concatenating the elements of List with\nan instance of Glue between each of them.\n\nArguments\n   List    List of atomic terms.\n   Glue    A string or atom.\n   String    A string or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   String is the string formed by concatenating the elements of List\n   with an instance of Glue between each of them.  List may contain\n   numbers, atoms and strings.  The result of the concatenation is\n   always a string.\n\n   Note that concat_string/2 can be defined as\n\n       concat_string(List, String) :-\n\t    join_string(List, \"\", String).\n\nModes and Determinism\n   join_string(++, +, -) is det\n\nExceptions\n     4 --- List is not instantiated (non-coroutine mode only).\n     4 --- List contains free variables (non-coroutine mode only).\n     5 --- List is instantiated, but not to a list of atomic terms.\n     5 --- String is neither an string nor a variable.\n     5 --- Glue is neither an string nor an atom.\n\nExamples\n   \nSuccess:\n    join_string([usr,\"local\",bin], \"/\", \"usr/local/bin\").\n    join_string([1,2,3], \" -> \", \"1 -> 2 -> 3\").\n\nError:\n    join_string(A,\"-\",X).    (Error 4).\n    join_string([abc,D],\",\",X).  (Error 4).\n    join_string(art,\",\",X).      (Error 5).\n    join_string([a,b],3,X).      (Error 5).\n\nSee Also\n   concat_string / 2, concat_strings / 3, append_strings / 3, atom_string / 2, split_string / 4, sprintf / 3"},"number_string/2":{"prefix":"number_string","body":"number_string(${1:Number}, ${2:String})$3\n$0","description":"number_string(?Number, ?String)\n\n   Conversion between any number and a string.\n\nArguments\n   Number    Number or variable.\n   String    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   If String is instantiated, its contents is interpreted as a number which\n   is in turn unified with Number.\n\n   If Number is instantiated and String is a variable, String is bound to\n   the textual representation of the number as writeq/1 would produce it.\n\n   If String does not represent a number, then number_string/2 fails.\n\nModes and Determinism\n   number_string(+, -) is det\n   number_string(-, +) is semidet\n\nFail Conditions\n   Fails if String does not represent a number\n\nExceptions\n     5 --- Number is instantiated, but not to an number.\n     5 --- String is instantiated, but not to a string.\n     4 --- Both arguments are free variables (non-coroutine mode only).\n\nExamples\n   \n   Success:\n   number_string(1989,X).       (gives X = \"1989\").\n   number_string(-7,X).    (gives X = \"-7\").\n   number_string(124.5,X).      (gives X = \"124.5\").\n   number_string(X,\"+12\").      (gives X = 12).\n   number_string(X,\"-7\").       (gives X = -7).\n   number_string(N,\"123.4\").     (gives N = 123.4).\n   number_string(3.0,\"3.0\").\n   number_string(3.0,\"+3.00\").\n   Fail:\n   number_string(N,\"- 15\").\n   number_string(N,\" +15\").\n   number_string(N,\"2 \").\n   number_string(N,\".5\").\n   number_string(N,\"Abcd\").\n   number_string(222,\"123\").\n   Error:\n   number_string(N,S).    (Error 4).\n   number_string(a,\"12\").       (Error 5).\n   number_string(N,1234).       (Error 5).\n\nSee Also\n   concat_string / 2, term_string / 2, atom_string / 2, number / 1, sprintf / 3, split_string / 4"},"split_string/4":{"prefix":"split_string","body":"split_string(${1:String}, ${2:SepChars}, ${3:PadChars}, ${4:SubStrings})$5\n$0","description":"split_string(+String, +SepChars, +PadChars, -SubStrings)\n\n   Decompose String into SubStrings according to separators SepChars and\npadding characters PadChars.\n\nArguments\n   String    A string.\n   SepChars    A string.\n   PadChars    A string.\n   SubStrings    A variable or list.\n\nType\n   Strings and Atoms\n\nDescription\n   The string String is decomposed into sub-strings which are returned\n   as a list of strings SubStrings.  Every character occurring in\n   SepChars is considered a separator, and every character occurring\n   in PadChars is considered a padding character.\n\n   The string String is split at the separators, and any padding\n   characters around the resulting sub-strings are removed. Neither\n   the separators nor the padding characters occur in SubStrings.\n\n   Characters that occur both in SepChars and PadChars are considered\n   separators, but such that a sequence of them is considered to be\n   only one separator. Moreover, when they occur at the beginning or\n   end of the string, they are ignored, ie. treated like padding.\n\n   The predicate can also be used to trim leading and trailing padding\n   from a string by giving an empty separator string.\n\nModes and Determinism\n   split_string(+, +, +, -) is det\n\nExceptions\n     4 --- String, SepChars or PadChars is not instantiated.\n     5 --- String, SepChars or PadChars is not a string.\n     5 --- List is neither an string nor a variable.\n\nExamples\n   \n     % split at every /\n     [eclipse]: split_string(\"/usr/local/eclipse\", \"/\", \"\", L).\n     L = [\"\", \"usr\", \"local\", \"eclipse\"]\n     yes.\n\n     % split at every sequence of /\n     [eclipse]: split_string(\"/usr/local//eclipse/\", \"/\", \"/\", L).\n     L = [\"usr\", \"local\", \"eclipse\"]\n     yes.\n\n     % split and strip padding\n     [eclipse 4]: split_string(\" comma, separated , data items \",\n    \",\", \" \\t\", L).\n     L = [\"comma\", \"separated\", \"data items\"]\n     yes.\n\n     % just strip padding\n     [eclipse]: split_string(\"   Hello world...\", \"\", \" .\", L).\n     L = [\"Hello world\"]\n     yes.\n\nSee Also\n   atom_string / 2, concat_string / 2, join_string / 3, number_string / 2, read_string / 3, read_string / 4, read_token / 2, read_token / 3, term_string / 2, library(regex)"},"string_list/2":{"prefix":"string_list","body":"string_list(${1:String}, ${2:List})$3\n$0","description":"string_list(?String, ?List)\n\n   List is a list whose elements are the integer codes of the bytes in the string\n\nArguments\n   String    String or variable.\n   List    List of integers (in the range 0 to 255) and/or variables,    or else a variable.\n\nType\n   Strings and Atoms\n\nDescription\n\n   This predicate performs conversion between a byte string and the\n   corresponding list of integers in the range 0..255.\n\n   If String is instantiated, unifies List with the list whose elements are\n   the integer codes for the bytes in the string.\n\n   If List is instantiated, unifies String with the string composed from\n   the bytes given by the list elements in range 0..255.\n\nModes and Determinism\n   string_list(+, -) is det\n   string_list(-, +) is det\n\nExceptions\n     5 --- String is neither a string nor a variable.\n     5 --- List is neither a list nor a variable.\n     6 --- One (or more) elements of List are not integers in the range    0 to 255.\n     4 --- Neither String or List are ground (non-coroutine mode only).\n\nExamples\n   \n   Success:\n   string_list(S,[65,98,99]).    (gives S=\"Abc\").\n   string_list(\"abc\",L).    (gives L=[97,98,99]).\n   string_list(\"abc\",[97,A,99]).       (gives A=98).\n   string_list(S,[127]).    (gives S=\"\\177\").\n   string_list(\"abc\",[97|A]).    (gives A=[98,99]).\n   Fail:\n   string_list(\"abc\",[98,99,100]).\n   Error:\n   string_list(S,[A|[128]]).    (Error 4).\n   string_list(S,[1|A]).    (Error 4).\n   string_list('string',L).    (Error 5).\n   string_list(S,\"list\").    (Error 5).\n   string_list('string',[128]).    (Error 5).\n   string_list(S,[\"B\"]).    (Error 5).\n   string_list(S,[256]).    (Error 6).\n\nSee Also\n   string_code / 3, string_list / 3, atom_string / 2, char_code / 2, term_string / 2, split_string / 4"},"string_code/3":{"prefix":"string_code","body":"string_code(${1:Index}, ${2:String}, ${3:Code})$4\n$0","description":"string_code(+Index, +String, -Code)\n\n   Succeeds if Code is the value of the Index'th byte in String\n\nArguments\n   Index    Integer between 1 and the length of String\n   String    String\n   Code    Variable or Integer\n\nType\n   Strings and Atoms\n\nDescription\n\tThis predicate extracts the Index'th byte from the given string String. \n\tBytes in the string are numbered from 1 (analogous to array indices in\n\tsubscript/3 and arg/3).\n    \n\tNote that (like all predicates that return a number as their last\n\targument), this predicate can be used as a function inside arithmetic\n\texpressions.\n    \n    For backward compatibility with earlier versions of ECLiPSe, the \n\targument order string_code(String,Index,Code) is also allowed.\n\nModes and Determinism\n   string_code(+, +, -) is det\n\nExceptions\n     5 --- Index is not an integer\n     5 --- String is not a string\n     5 --- Code is instantiated but not to an integer\n     6 --- Index is an integer less than 1 or greater than String's length\n     4 --- Either Index or String are uninstantated\n\nExamples\n   \n   string_code(1, \"abc\", 97).\t\t% succeeds\n   string_code(3, \"abc\", C).\t\t% gives C = 99\n\n   string_code(2, \"abc\", 100).\t\t% fails\n\n   string_code(_, \"abc\", C).\t\t% Error 4\n   string_code(1, _, C).\t\t% Error 4\n   string_code(1.5, \"abc\", C).\t\t% Error 5\n   string_code(1, abc, C).\t\t% Error 5\n   string_code(0, \"abc\", C).\t\t% Error 6\n   string_code(4, \"abc\", C).\t\t% Error 6\n\nSee Also\n   string_list / 2, char_code / 2"},"string_length/2":{"prefix":"string_length","body":"string_length(${1:String}, ${2:Length})$3\n$0","description":"string_length(+String, -Length)\n\n   Succeeds if Length is the length of the string String.\n\nArguments\n   String    String.\n   Length    Integer or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   The length of the string String is unified with Length.\n\n    Note that (like all predicates that return a number as their last\n    argument), this predicate can be used as a function inside arithmetic\n    expressions.\n\nModes and Determinism\n   string_length(+, -) is det\n\nExceptions\n     4 --- String is not instantiated (non-coroutine mode only).\n     5 --- String is instantiated, but not to a string.\n     5 --- Length is neither an integer nor a variable.\n\nExamples\n   \nSuccess:\n      string_length(\"Peter \",X).  (gives X=6).\n      string_length(\"Peter \",6).\n      string_length(\"401.35\",6).\n\nFail:\n      string_length(\"Peter\",6).\n\nError:\n      string_length(Str,Len).    (Error 4).\n      string_length(Str,6).    (Error 4).\n      string_length(\"small\",5.0).    (Error 5).\n      string_length(Str,instantiated).   (Error 5).\n      string_length(Str,46.2)    (Error 5).\n      string_length('this one',L).       (Error 5).\n\nSee Also\n   append_strings / 3, atom_length / 2, concat_strings / 3"},"substring/4":{"prefix":"substring","body":"substring(${1:String1}, ${2:Position}, ${3:Length}, ${4:String2})$5\n$0","description":"substring(+String1, ?Position, ?Length, ?String2)\n\n   Succeeds if String2 is the substring of String1 starting at position\nPosition and of length Length.\n\nArguments\n   String1    String.\n   Position    Integer (from 1 upwards) or variable.\n   Length    Integer (from 0 upwards) or variable.\n   String2    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Succeeds if String2 is a substring of String1 starting at position\n   Position and of length Length.\n\n   On backtracking, all such substrings are found.\n\n   The first character of a string is at position 1.\n\nNote\n   If String1 and String2 are instantiated, it is more efficient to use the\n   predicates substring/3 and/or string_length/2.\n\nModes and Determinism\n   substring(+, +, +, -) is semidet\n   substring(+, +, -, +) is semidet\n   substring(+, +, -, -) is nondet\n   substring(+, -, +, -) is nondet\n   substring(+, -, -, +) is nondet\n   substring(+, -, -, -) is multi\n\nFail Conditions\n   String1 does not have a substring at the required position and/or of the required length, or String2 does not occur within String1\n\nExceptions\n     5 --- String1 is instantiated, but not to a string.\n     5 --- String2 is neither a string nor a variable.\n     5 --- Either (or both) of Position or Length are neither integers    nor variables.\n     4 --- String1 is not instantiated.\n\nExamples\n   \nSuccess:\n  substring(\"abcabc\",3,1,\"c\").\n  substring(\"abcabc\",6,1,\"c\").\n  substring(\"abcabc\",P,1,\"c\"). (gives P=3; P=6).\n  substring(\"abcabc\",3,3,S).   (gives S=\"cab\").\n  substring(\"abc\",P,L,\"b\").    (gives P=2, L=1).\n\n  [eclipse]: substring(\"ab\",P,1,S).\n  P=1\n  S=\"a\"     More? (;)\n  P=2\n  S=\"b\"\n  yes.\n\n  [eclipse]: substring(\"ab\",1,L,S).\n  L=0\n  S=\"\"      More? (;)\n  L=1\n  S=\"a\"     More? (;)\n  L=2\n  S=\"ab\"\n  yes,\n\n  [eclipse]: substring(\"ab\",P,L,S), writeq((P,L,S)), nl, fail.\n  1 , 0 , \"\"    % on backtracking, returns all\n  1 , 1 , \"a\"    %   substrings of String1.\n  1 , 2 , \"ab\"\n  2 , 0 , \"\"\n  2 , 1 , \"b\"\n  3 , 0 , \"\"\n  no (more) solution.\n\nFail:\n  substring(\"joey\",P,L,\"joy\").\n  substring(\"joey\",P,2,\"joe\").\n\nError:\n  substring(S1,P,L,S2).    (Error 4).\n  substring(S1,1,2,\"bc\").    (Error 4).\n  substring(S1,1,2,'str').    (Error 4).\n  substring('string',2,3,S2).    (Error 5).\n  substring(\"string\",2,3,'str').       (Error 5).\n  substring(\"string\",0,L,S2).    (Error 6).\n  substring(\"string\",1,-1,S2).    (Error 6).\n\nSee Also\n   substring / 3, substring / 5, string_length / 2, split_string / 4"},"string_list/3":{"prefix":"string_list","body":"string_list(${1:String}, ${2:List}, ${3:Format})$4\n$0","description":"string_list(?String, ?List, +Format)\n\n   Conversion between string in different encodings and a character list\n\nArguments\n   String    String or variable.\n   List    A variable or a list of integers and/or variables.\n   Format    An atom.\n\nType\n   Strings and Atoms\n\nDescription\n   This predicate performs conversion between a string encoded in Format\n   and a list of the corresponding character representations.\n\n   If String is instantiated, it is must be a valid string in the encoding\n   format specified by Format.  It is then decoded and List is unified with\n   a list of the corresponding character representations.\n\n   If List is instantiated, it is must contain character representations\n   that are valid for the encoding format specified by Format.  These\n   characters are then encoded into a string which is unified with String.\n\n   Currently supported formats are:\n\nbytes or octet\n    Every byte in the string corresponds to a list integer in the range 0..255.\nchars\n    Every character in the string corresponds to a single-character atom\n    in the list.  This format assumes a default character encoding.\ncodes\n    Every character in the string corresponds to an integer character code\n    in the list.  This format assumes a default character encoding.\nutf8\n    The string is encoded in UTF-8 format and the list can contain integers\n    in the range 0..2^31-1.\n\n   Note that string_list/2 can be defined as:\n\n\tstring_list(S, L) :- string_list(S, L, bytes).\n\nModes and Determinism\n   string_list(+, -, +) is det\n   string_list(-, +, +) is det\n\nExceptions\n     4 --- Format is not instantiated.\n     4 --- Neither String nor List are ground.\n     5 --- String is neither a string nor a variable.\n     5 --- List is neither a list nor a variable.\n     5 --- Format is not an atom.\n     6 --- One (or more) elements of List are not of the type corresponding to Format.\n     6 --- Format is not a valid format specification.\n     6 --- One (or more) elements of List are not integers or atoms in the valid range for Format.\n\nExamples\n   \n    [eclipse 1]: string_list(S,[65,66,67],bytes).\n    S = \"ABC\"\n    yes.\n\n    [eclipse 2]: string_list(S, [65,66,67], utf8).\n    S = \"ABC\"\n    yes.\n\n    [eclipse 3]: string_list(S, [65, 0, 700, 2147483647], bytes).\n    out of range in string_list(S, [65, 0, 700, 2147483647])\n\n    [eclipse 4]: string_list(S, [65, 0, 700, 2147483647], utf8).\n    S = \"A\\000\\312\\274\\375\\277\\277\\277\\277\\277\"\n    yes.\n\nSee Also\n   string_list / 2, write / 2, read_string / 4"},"substring/3":{"prefix":"substring","body":"substring(${1:String1}, ${2:String2}, ${3:Position})$4\n$0","description":"substring(+String1, +String2, ?Position)\n\n   Succeeds if String2 is a substring of String1 beginning at position\nPosition.\n\nArguments\n   String1    String.\n   String2    String.\n   Position    Integer or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Used to test that String2 is a substring of String1 beginning at\n   position Position.  In this case, String1 and String2 are strings and\n   Position is an integer.\n\n   Also used to find the first position in String1 that its substring\n   String2 begins.  In this case, String1 and String2 are strings and\n   Position is a variable.\n\n   String positions must be positive and start at 1.\n\nModes and Determinism\n   substring(+, +, +) is semidet\n   substring(+, +, -) is semidet\n\nFail Conditions\n   Fails if String2 is not a substring of String1 beginning at position Position\n\nExceptions\n     4 --- Either String1 or String2 (or both) are not instantiated.\n     5 --- Either String1 or String2 (or both) are instantiated, but    not to strings.\n     5 --- Position is neither an integer nor a variable.\n     6 --- Position is not a positive integer.\n\nExamples\n   \nSuccess:\n      substring(\"str\",\"st\",1).\n      substring(\"abcabcabc\",\"bc\",X)     (gives X=2).\n      substring(\"abcabcabc\",\"bc\",8).\n      substring(\"abc\",\"\",X).    (gives X=1).\n      substring(\"abc\",\"\",2).\nFail:\n      substring(\"astring\",\"strg\",2).\n      substring(\"\",\"a\",X).\nError:\n      substring(S,\"str\",1).    (Error 4).\n      substring('str',S,1).    (Error 5).\n      substring(\"st\",\"s\",1.0).    (Error 5).\n      substring(\"ab\",\"a\",-2).    (Error 6).\n\nSee Also\n   substring / 5, split_string / 4"},"attach_suspensions/2":{"prefix":"attach_suspensions","body":"attach_suspensions(${1:Trigger}, ${2:Susps})$3\n$0","description":"attach_suspensions(+Trigger, ++Susps)\n\n   Insert the suspensions Susps into the suspension list of the symbolic\ntrigger Trigger.\n\nArguments\n   Trigger    An atom.\n   Susps    A suspension or list of suspensions.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This predicate is used to insert one or more suspensions into a\n   suspension list which is associated to the symbolic name Trigger.\n   This name can be an arbitrary atom.\n\n   The suspensions will be woken by a corresponding invocation of\n   schedule_suspensions/1.\n\nModes and Determinism\n   attach_suspensions(+, ++) is det\n\nExceptions\n     4 --- Susps or Trigger is not instantiated.\n     5 --- Susps is not a suspension or list.\n     5 --- Trigger is not an atom.\n\nExamples\n   \n\nSee Also\n   insert_suspension / 4, make_suspension / 3, suspend / 3, suspend / 4, schedule_suspensions / 1, demon / 1"},"substring/5":{"prefix":"substring","body":"substring(${1:String}, ${2:Before}, ${3:Length}, ${4:After}, ${5:SubString})$6\n$0","description":"substring(+String, ?Before, ?Length, ?After, ?SubString)\n\n   Succeeds if SubString is a substring of String, with \n    length Length, preceded by Before, and followed by After characters\n\nArguments\n   String    String.\n   Before    Integer (from 0 upwards) or variable.\n   Length    Integer (from 0 upwards) or variable.\n   After    Integer (from 0 upwards) or variable.\n   SubString    String or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Succeeds if String can be split into three substrings,\n    StringL, SubString and StringR, such that Before is\n    the length of StringL, Length is the length of SubString\n    and After is the length of StringR.\n\n   On backtracking, all such substrings are found.\n\n   Zero length substrings may be specified.\n\n   This predicate is very versatile and can be used to\n   \n   check for substrings\n   extract substrings\n   search for substrings\n   \n\nNote:\n   This predicate provides for strings the functionality that the ISO\n   sub_atom/5 predicate provides for atoms.\n\nModes and Determinism\n   substring(+, +, +, -, -) is semidet\n   substring(+, -, +, +, -) is semidet\n   substring(+, +, -, +, -) is semidet\n   substring(+, +, -, -, +) is semidet\n   substring(+, -, -, +, +) is semidet\n   substring(+, +, -, -, -) is nondet\n   substring(+, -, +, -, -) is nondet\n   substring(+, -, -, +, -) is nondet\n   substring(+, -, -, -, +) is nondet\n   substring(+, -, -, -, -) is multi\n\nFail Conditions\n   String cannot be split into substrings of the required lengths, or SubString does not occur within String\n\nExceptions\n     5 --- String is instantiated, but not to a string.\n     5 --- SubString is neither a string nor a variable.\n     5 --- Any of Before, Length or After are neither integers nor variables.\n     5 --- Any of Before, Length or After negative integers.\n     4 --- String is not instantiated.\n\nExamples\n   \nSuccess:\n  substring(\"abracadabra\",0,5,_,S2). (gives S2=\"abrac\").\n  substring(\"abracadabra\",_,5,0,S2). (gives S2=\"dabra\").\n  substring(\"abracadabra\",3,L,3,S2). (gives L=5, S2=\"acada\").\n  substring(\"abracadabra\",B,2,A,ab). (gives B=0, A=9; B=7, A=2).\n  substring(\"Banana\",3,2,_,S2).      (gives S2=\"an\").\n\n  [eclipse]: substring(\"ab\",B,1,A,S).\n  B=0\n  A=1\n  S=\"a\"     More? (;)\n  B=1\n  A=0\n  S=\"b\"\n  yes.\n\n  [eclipse]: substring(\"charity\",B,3,A,S2).\n  B=0\n  A=4\n  S2=\"cha\" More? (;)\n  B=1\n  A=3\n  S2=\"har\" More? (;)\n  B=2\n  A=2\n  S2=\"ari\" More? (;)\n  B=3\n  A=1\n  S2=\"rit\" More? (;)\n  B=4\n  A=0\n  S2=\"ity\"\n  yes.\n\n  [eclipse]: substring(\"abab\",B,L,A,S), writeq((B,L,A,S)), nl, fail.\n  0, 0, 4, \"\"    % on backtracking, returns all\n  0, 1, 3, \"a\"    %   substrings of String.\n  0, 2, 2, \"ab\"\n  0, 3, 1, \"aba\"\n  0, 4, 0, \"abab\"\n  1, 0, 3, \"\"\n  1, 1, 2, \"b\"\n  1, 2, 1, \"ba\"\n  1, 3, 0, \"bab\"\n  2, 0, 2, \"\"\n  2, 1, 1, \"a\"\n  2, 2, 0, \"ab\"\n  3, 0, 1, \"\"\n  3, 1, 0, \"b\"\n  4, 0, 0, \"\"\n  no (more) solution.\n\nFail:\n  substring(\"joey\",B,L,A,\"joy\").\n  substring(\"joey\",B,2,A\"joe\").\n\nError:\n  substring(S1,B,L,A,S2).    (Error 4).\n  substring(S1,1,2,3,\"bc\").    (Error 4).\n  substring(S1,1,2,3,'str').    (Error 4).\n  substring('string',2,3,1,S2).    (Error 5).\n  substring(\"string\",2,3,1,'str').     (Error 5).\n  substring(\"string\",a,3,1,S2).    (Error 5).\n  substring(\"string\",-1,L,A,S2).       (Error 6).\n\nSee Also\n   substring / 3, substring / 4, string_length / 2, split_string / 4"},"attached_suspensions/2":{"prefix":"attached_suspensions","body":"attached_suspensions(${1:Trigger}, ${2:SuspensionList})$3\n$0","description":"attached_suspensions(+Trigger, -SuspensionList)\n\n   Retrieves a list of all suspensions attached to the symbolic trigger Trigger.\n\nArguments\n   Trigger    An atom\n   SuspensionList      Variable or List.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n    Retrieves all suspensions (dead or live) attached to the trigger Trigger,\n    and returns them in SuspensionList.\n\n    Note that you can use sort/2 to eliminate duplicates, and\n    is_suspension/1 to filter out dead suspensions.\n\nModes and Determinism\n   attached_suspensions(+, -) is det\n\nExamples\n   \n?- suspend(true, 3, trigger(hello)), attached_suspensions(hello, S).\nS = ['SUSP-_207-susp']\nDelayed goals:\n    true\nYes (0.00s cpu)\n\nSee Also\n   suspensions / 1, suspensions / 2, subcall / 2, get_suspension_data / 3, sort / 2, is_suspension / 1"},"call_priority/2":{"prefix":"call_priority","body":"call_priority(${1:Goal}, ${2:Priority})$3\n$0","description":"call_priority(+Goal, +Priority)\n\n   Execute Goal with priority Priority.\n\nArguments\n   Goal    Atom or compound term.\n   Priority    A small integer.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   All goals in ECLiPSe execute under a certain priority. An execution\n   can only be interrupted by the waking of a goal with a higher\n   priority. Priorities are most relevant in data-driven algorithms,\n   to specify that certain goals must do their work before others\n   can meaningfully execute.\n\n   Priorities range from 1 (most urgent) to 12 (least urgent). The\n   toplevel goal of an execution always runs at the lowest priority (12).\n\n   call_priority/2 runs a goal at a given priority. If this priority\n   is higher than the one under which call_priority was invoked,\n   the goal executes immediately, but will be less interruptable\n   by woken goals. If the specified priority is lower, the execution\n   of goal will be effectively deferred until there are no more urgent\n   goal present.\n\n   Note that woken goals automatically execute under their associated\n   run_priority (which is a property of the predicate that is being invoked).\n   This is equivalent to a call_priority/2, therefore call_priority/2 is\n   usually not needed inside woken predicates.\n\n   Warning: Although it is possible to write programs that only work\n   correctly under a particular priority ordering, such practice is\n   strongly discouraged. Priorities should only affect efficiency,\n   never correctness.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal or Priority is not instantiated.\n     5 --- Goal is not an atom or a compound term, \t\tor Priority is not an integer.\n    24 --- Priority is not a number.\n\nExamples\n   \n    [eclipse 1]: [user].       \n     p :- call_priority(writeln(hello),8), writeln(world).\n\n    user       compiled traceable 136 bytes in 0.00 seconds\n    yes.\n    [eclipse 10]: call_priority(p,5).\n    world\n    hello\n    yes.\n    [eclipse 11]: call_priority(p,10).\n    hello\n    world\n    yes.\n    [eclipse 12]: call_priority(p,8).\n    hello\n    world\n    yes.\n\nSee Also\n   get_priority / 1, make_suspension / 3, suspend / 3, suspend / 4, set_suspension_data / 3"},"current_trigger/1":{"prefix":"current_trigger","body":"current_trigger(${1:Trigger})$2\n$0","description":"current_trigger(?Trigger)\n\n   Succeeds if Trigger is a currently defined symbolic trigger.\n\nArguments\n   Trigger    An atom or variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n\n    Succeeds if Trigger is a currently defined symbolic trigger for\n    suspensions (see trigger/1). If Trigger is a variable, the current\n    triggers will be enumerated one by one via backtracking.\n\nModes and Determinism\n   current_trigger(-) is nondet\n   current_trigger(+) is semidet\n\nFail Conditions\n   Trigger is not a current trigger.\n\nSee Also\n   trigger / 1"},"current_suspension/1":{"prefix":"current_suspension","body":"current_suspension(${1:Susp})$2\n$0","description":"current_suspension(?Susp)\n\n   Susp is a live (sleeping or scheduled) suspension.\n\nArguments\n   Susp    A variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for\n   execution, and finally executed.\n\n   current_suspension/1 nondeterministically enumerates all current\n   suspensions. They may be either sleeping or already scheduled\n   for execution. It does not return any dead suspensions.\n\n   Note: Please do not use this predicate if you need all suspensions.\n   Use suspensions/1 instead.\n\nModes and Determinism\n   current_suspension(-) is nondet\n   current_suspension(+) is semidet\n\nFail Conditions\n   Fail is there are no suspensions or if Susp is a dead suspension\n\nExamples\n   \n[eclipse 6]: suspend(writeln(a), 3, X->inst),\n    suspend(writeln(b), 5, Y->inst),\n    current_suspension(S),\n\tget_suspension_data(S, goal, G).\n\nX = X\nY = Y\nS = 'SUSP-_393-susp'\nG = writeln(b)\n\nDelayed goals:\n    writeln(a)\n    writeln(b)\nMore (0.00s cpu) ? ;\n\nX = X\nY = Y\nS = 'SUSP-_374-susp'\nG = writeln(a)\n\nDelayed goals:\n    writeln(a)\n    writeln(b)\nMore (0.00s cpu) ? ;\n\nNo (0.01s cpu)\n\nSee Also\n   delayed_goals / 1, make_suspension / 3, kill_suspension / 1, schedule_suspensions / 1, schedule_suspensions / 2, suspend / 3, suspend / 4, suspensions / 1, get_suspension_data / 3"},"delayed_goals/1":{"prefix":"delayed_goals","body":"delayed_goals(${1:GoalList})$2\n$0","description":"delayed_goals(-GoalList)\n\n   Succeeds if GoalList is the list of all goals currently delayed.\n\nArguments\n   GoalList    List, nil or variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Unifies GoalList with the list of all goals currently delayed.  If there\n   are no goals delayed, GoalList is unified with nil.  The order of goals\n   in the list is implementation-dependent.  Note that if GoalList is nil,\n   the system only checks if there are any delayed goals and it does not\n   actually construct the list.\n\nModes and Determinism\n   delayed_goals(-) is det\n\nExceptions\n     5 --- GoalList is instantiated but not to a list or nil.\n\nExamples\n   \nSuccess:\n    [eclipse]: X > 0, delayed_goals(L).\n\n    X = _d89\n    L = [_d89 > 0]\n\n    Delayed goals:\n    _d89 > 0\n    yes.\n    [eclipse]: X > 0, delayed_goals([1 > 0]).\n\n    X = 1\n    yes.\n\nFail:\n    X > 0, delayed_goals([]).\n\nError:\n    delayed_goals(X > 0).    (Error 5).\n    delayed_goals(0).    (Error 5).\n\nSee Also\n   delayed_goals / 2, delayed_goals_number / 2, subcall / 2"},"delayed_goals_number/2":{"prefix":"delayed_goals_number","body":"delayed_goals_number(${1:Var}, ${2:Number})$3\n$0","description":"delayed_goals_number(?Var, -Number)\n\n   Succeeds if Number is the number of goals delayed by the variable Var.\n\nArguments\n   Var    Any term.\n   Number    Integer or a variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Unifies Number with the number of goals delayed by the variable Var.  If\n   Var is instantiated, Number is unified with 1000000.  If Var is not\n   instantiated and there are no goals delayed by it, Number is unified\n   with 0.  This predicate does not construct the list of delayed goals and\n   hence it is faster than delayed_goals/2.  Its purpose is to give each\n   variable a weight corresponding to the number of constraints imposed on\n   the variable to be able to select the most constrained one.  It is\n   assumed that one million constraints cannot be placed on any variable.\n\nModes and Determinism\n   delayed_goals_number(?, -) is det\n\nExamples\n   \nSuccess:\n    % Make an intelligent permutation choosing\n    % the most constrained variable.\n    perm([], []).\n    perm([Var|List], Values) :-\n    delayed_goals_number(Var, C),\n    maxval(List, Var, C, Chosen, RestVar),\n    delete(Chosen, Values, RestVal),\n    perm(RestVar, RestVal).\n\n    maxval(L, Chosen, 1000000, Chosen, L) :- !.\n    maxval([], Chosen, _, Chosen, []).\n    maxval([X|L], SoFar, MaxVal, Chosen, [V|Rest]) :-\n    delayed_goals_number(X, C),\n    (C =< MaxVal -> V = X, Next = SoFar, Max = MaxVal ;\n    V = SoFar, Next = X, Max = C),\n    maxval(L, Next, Max, Chosen, Rest).\n    % the values are generated in the listed order\n    [eclipse]: perm([A, B, C], [1,2,3]).\n\n    A = 1\n    B = 2\n    C = 3     More? (;)\n    yes.\n\n    % B is more constrained than the others, and so\n    % its value will be generated first.\n    [eclipse]: B < 3, perm([A, B, C], [1,2,3]).\n\n    A = 2\n    B = 1\n    C = 3     More? (;)\n\nFail:\n    X > 0, delayed_goals_number(X, 0).\n\nSee Also\n   delayed_goals / 1, delayed_goals / 2, subcall / 2"},"delayed_goals/2":{"prefix":"delayed_goals","body":"delayed_goals(${1:Var}, ${2:GoalList})$3\n$0","description":"delayed_goals(?Var, -GoalList)\n\n   Succeeds if GoalList is the list of all goals delayed by the variable Var.\n\nArguments\n   Var    Any term.\n   GoalList    List or variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Unifies GoalList with the list of all goals delayed by the variable Var.\n   This list contains all goals that will be woken if the variable Var will\n   be instantiated.  If there are no such goals, e.g.  when Var is not a\n   variable, GoalList is unified with nil.\n\nModes and Determinism\n   delayed_goals(?, -) is det\n\nExamples\n   \nSuccess:\n    [eclipse]: X > 0, X < 5, delayed_goals(X, L).\n\n    X = _d103\n    L = [_d103 > 0, _d103 < 5]\n\n    Delayed goals:\n    _d103 > 0\n    _d103 < 5\n    yes.\n    [eclipse]: X > 0, X = 1, delayed_goals(X, L).\n\n    X = 1\n    L = []\n    yes.\nFail:\n    X > 0, delayed_goals(X, []).\n\nSee Also\n   delayed_goals / 1, delayed_goals_number / 2, subcall / 2"},"get_suspension_data/3":{"prefix":"get_suspension_data","body":"get_suspension_data(${1:Susp}, ${2:Name}, ${3:Value})$4\n$0","description":"get_suspension_data(?Susp, +Name, -Value)\n\n   Access properties of suspended goals.\n\nArguments\n   Susp    A suspension or variable.\n   Name    An atom.\n   Value    A variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This built-in is used to access the contents of the abstract suspension\n   data type. If applied to an already executed (dead) suspension it fails,\n   unless the state information is requested.\n\n   The accessible properties of a suspension are:\n\n    Name    Type    Value\n    -------------------------------------------------------------\n    goal    Term    Suspended goal\n    module    Atom    Context module\n    qualified_goal  Atom:Term   Lookup module and goal\n    priority    Integer     Waking priority\n    invoc    Integer     Invocation number (debugging)\n    state    Integer     0 (sleeping), 1 (scheduled), 2 (dead)\n\n   Note that a suspension is not a standard logical data structure and can\n   only be manipulated in a restricted way.  In particular, a suspension\n   cannot be printed (e.g. using writeq/1,2) and then read back, giving a\n   term identical to the one that was printed.\n\nModes and Determinism\n   get_suspension_data(?, +, -) is semidet\n\nFail Conditions\n   Fails if Susp is uninstantiated or if the suspension is already dead and Name is not 'state'\n\nExceptions\n     4 --- Name is not instantiated.\n     5 --- Susp is not a suspension.\n     5 --- Name is instantiated but not an atom.\n     6 --- Name is not the name of a suspension property.\n\nExamples\n   \n    [eclipse 4]: make_suspension(writeln(hello), 5, S),\n    get_suspension_data(S, priority, P),\n    get_suspension_data(S, goal, G),\n    get_suspension_data(S, module, M),\n    get_suspension_data(S, qualified_goal, QG),\n    get_suspension_data(S, invoc, I),\n    get_suspension_data(S, state, Z).\n\n    P = 5\n    G = writeln(hello)\n    M = eclipse\n    QG = eclipse : writeln(hello)\n    I = 0\n    S = 'SUSP-_162-susp'\n    Z = 0\n    Delayed goals:\n    writeln(hello)\n    yes.\n\n    [eclipse 2]: suspend(writeln(hello), 3, X->inst, S),\n    get_suspension_data(S, state, Z0),\n    call_priority((X=1,true,get_suspension_data(S, state, Z1)), 2),\n    get_suspension_data(S, state, Z2).\n    hello\n\n    Z0 = 0\n    X = 1\n    Z1 = 1\n    S = 'SUSP-_161-dead'\n    Z2 = 2\n    yes.\n\nSee Also\n   delayed_goals / 1, kill_suspension / 1, make_suspension / 3, get_priority / 1, call_priority / 2, suspend / 3, suspensions / 1, current_suspension / 1, set_suspension_data / 3"},"enter_suspension_list/3":{"prefix":"enter_suspension_list","body":"enter_suspension_list(${1:Position}, ${2:Attribute}, ${3:Susp})$4\n$0","description":"enter_suspension_list(+Position, +Attribute, +Susp)\n\n   Enter the suspension Susp into the suspension list at position Positiion within the structure Attribute.\n\nArguments\n   Position    Integer indicating the position of the suspension list.\n   Attribute    Compound term, typically a variable's attribute.\n   Susp    A suspension\n\nType\n   Advanced Control and Suspensions\n\nDescription\n\n   This predicate is used to add a suspension to a single suspension list.\n   The suspension list is expected in the Position'th argument of the\n   structure Attribute. This argument can be either an existing suspension\n   list, or a variable. If it is a variable, a new suspension list with\n   Susp will be created. \n\n   The functionality is similar to insert_suspension/3, but while\n   enter_suspension_list/3 enters only into a single suspension list,\n   insert_suspension/3 finds all variables in a term and inserts a\n   suspension into the attribute structures of all those variables.\n\n   Suspension lists should be regarded an opaque data structure and\n   only be accessed and manipulated by the set of primitives provided\n   for this purpose.\n\nModes and Determinism\n   enter_suspension_list(+, +, +) is det\n\nExceptions\n     4 --- Attribute, Susp or Position not instantiated.\n     5 --- Attribute is not a structure, or Susp not a suspension or Position is a non-integer number.\n     6 --- Attribute's arity is less than Position, or Position is zero or less.\n    24 --- Position is a non-number.\n   271 --- The suspension list in Position of Attribute is neither a list nor a free variable, or it contains an element which is not a suspension.\n\nExamples\n   \n[eclipse 1]: Att = att(_, hello), init_suspension_list(1, Att),\n    make_suspension(true, 3, S), enter_suspension_list(1, Att, S).\n\nAtt = att(['SUSP-_286-susp'], hello)\nS = 'SUSP-_286-susp'\n\nDelayed goals:\n    true\nYes (0.00s cpu)\n\nSee Also\n   insert_suspension / 3, insert_suspension / 4, schedule_suspensions / 2, init_suspension_list / 2"},"get_priority/1":{"prefix":"get_priority","body":"get_priority(${1:Priority})$2\n$0","description":"get_priority(-Priority)\n\n   Get the priority of the currently executing goal.\n\nArguments\n   Priority    A variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   All goals in ECLiPSe execute under a certain priority. An execution\n   can only be interrupted by the waking of a goal with a higher\n   priority. Priorities are most relevant in data-driven algorithms,\n   to specify that certain goals must do their work before others\n   can meaningfully execute.\n\n   Priorities range from 1 (most urgent) to 12 (least urgent). The\n   toplevel goal of an execution always runs at the lowest priority (12).\n\n   Warning: Although it is possible to write programs that only work\n   correctly under a particular priority ordering, such practice is\n   strongly discouraged. Priorities should only affect efficiency,\n   never correctness.\n\nModes and Determinism\n   get_priority(-) is det\n\nExceptions\n    24 --- Priority is neither variable nor number.\n\nExamples\n   \n    [eclipse 1]: get_priority(P).\n    P = 12\n    yes.\n\n    [eclipse 2]: [user].\n     p :- get_priority(P), writeln(prio=P).\n\n    user       compiled traceable 120 bytes in 0.00 seconds\n    yes.\n    [eclipse 3]: suspend(p, 5, X->inst), X=1.\n    prio = 5\n    X = 1\n    yes.\n\nSee Also\n   call_priority / 2, make_suspension / 3, suspend / 3, suspend / 4, set_suspension_data / 3"},"insert_suspension/3":{"prefix":"insert_suspension","body":"insert_suspension(${1:Term}, ${2:Susp}, ${3:Index})$4\n$0","description":"insert_suspension(?Term, +Susp, +Index)\n\n   Insert the suspension Susp into the Index'th suspension list of the current\nmodule's attribute for all attributed variables that occur in Term.\n\nArguments\n   Term    Any Prolog term.\n   Susp    A suspension.\n   Index    An integer.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This predicate is used to insert a suspension into a suspension list in\n   an attribute of one or more attributed variables.  Since Prolog does not allow to\n   insert new elements into a list in constant time, ECLiPSe provides this\n   predicate.  It finds all attributed variables occurring in the term Term and for\n   each of them, it locates the attribute which corresponds to the current\n   module.  This attribute must be a structure, otherwise an error is\n   raised, which means that the attribute has to be initialised before\n   calling insert_suspension/3.  The Index'th argument of the attribute\n   structure is interpreted as a suspension list and the suspension Susp is\n   inserted at the beginning of this list.  \n\nModes and Determinism\n   insert_suspension(?, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Susp or Index is not instantiated.\n     5 --- Susp is not a suspension.\n     5 --- Index is not an integer.\n     6 --- The attribute of a variable in Term is a structure whose arity is less than Index.\n   270 --- The current module has no declared variable attribute.\n   271 --- The attribute of a variable in Term is uninstantiated or it is not a structure.\n   271 --- The suspension list in the attribute of a variable in Term is neither a list nor a free variable, or it contains an element which is not a suspension.\n\nExamples\n   \n[eclipse 1]: meta_attribute(eclipse,[]).\nYes (0.01s cpu)\n\n[eclipse 2]: Att = att(_, hello), init_suspension_list(1, Att),\n    add_attribute(X, Att), make_suspension(true, 1, S),\n\tinsert_suspension(X, S, 1).\n\nAtt = att(['SUSP-_306-susp'], hello)\nX = X\nS = 'SUSP-_306-susp'\n\nDelayed goals:\n    true\nYes (0.00s cpu)\n\nSee Also\n   insert_suspension / 4, make_suspension / 3, meta_attribute / 2, enter_suspension_list / 3"},"init_suspension_list/2":{"prefix":"init_suspension_list","body":"init_suspension_list(${1:Position}, ${2:Attribute})$3\n$0","description":"init_suspension_list(+Position, +Attribute)\n\n   Initialise the argument position Position within the structure\nAttribute with an empty suspension list.\n\nArguments\n   Position    Integer indicating the position of the suspension list.\n   Attribute    Compound term, typically a variable's attribute.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This predicate is used to initialise a suspension list within\n   an attribute structure. Suspension lists should be regarded an\n   opaque data structure and only be accessed and manipulated\n   by the set of primitives provided for this purpose.\n\nModes and Determinism\n   init_suspension_list(+, +) is det\n\nExceptions\n     4 --- Position or Attribute is not instatiated.\n     5 --- Position is not an integer.\n     5 --- Attribute is not a structure.\n     6 --- Attribute does not have a Position'th argument.\n\nExamples\n   \n\nSee Also\n   insert_suspension / 3, insert_suspension / 4, schedule_suspensions / 2, merge_suspension_lists / 4, enter_suspension_list / 3"},"insert_suspension/4":{"prefix":"insert_suspension","body":"insert_suspension(${1:Term}, ${2:Susp}, ${3:Index}, ${4:Module})$5\n$0","description":"insert_suspension(?Term, +Susp, +Index, +Module)\n\n   Insert the suspension Susp into the Index'th suspension list of the\nattribute Module for all attributed variables that occur in Term.\n\nArguments\n   Term    Any Prolog term.\n   Susp    A suspension.\n   Index    An integer.\n   Module    An atom.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This predicate is used to insert a suspension into a suspension list in\n   an attribute of one or more attributed variables.  Since Prolog does not allow to\n   insert new elements into a list in constant time, ECLiPSe provides this\n   predicate.  It finds all attributed variables occurring in the term Term and for\n   each of them, it locates the attribute with the name Module.  This\n   attribute must be a structure, otherwise an error is raised, which means\n   that the attribute has to be initialised before calling\n   insert_suspension/3.  The Index'th argument of the attribute structure\n   is interpreted as a suspension list and the suspension Susp is inserted\n   at the beginning of this list.  \n\nModes and Determinism\n   insert_suspension(?, +, +, +) is det\n\nExceptions\n     4 --- Susp or Index is not instantiated.\n     5 --- Susp is not a suspension.\n     5 --- Index is not an integer.\n     6 --- The attribute of a variable in Term is a structure whose arity is less than Index.\n   270 --- The current module has no declared variable attribute.\n   271 --- The attribute of a variable in Term is uninstantiated or it is not a structure.\n   271 --- The suspension list in the attribute of a variable in Term is neither a list nor a free variable, or it contains an element which is not a suspension.\n\nExamples\n   \n[eclipse 1]: meta_attribute(myatt,[]).\nYes (0.01s cpu)\n\n[eclipse 2]: Att = att(_, hello), init_suspension_list(1, Att),\n    add_attribute(X, Att, myatt), make_suspension(true, 1, S),\n\tinsert_suspension(X, S, 1, myatt).\n\nAtt = att(['SUSP-_309-susp'], hello)\nX = X\nS = 'SUSP-_309-susp'\n\nDelayed goals:\n    true\nYes (0.00s cpu)\n\nSee Also\n   insert_suspension / 3, make_suspension / 3, meta_attribute / 2, enter_suspension_list / 3"},"kill_suspension/1":{"prefix":"kill_suspension","body":"kill_suspension(${1:Susp})$2\n$0","description":"kill_suspension(?Susp)\n\n   Kill the suspended goal represented by Susp, i.e. treat it as if it had\nbeen woken.\n\nArguments\n   Susp    A suspension or variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   The suspended goal represented by Susp is killed, and the suspension is\n   marked as now representing a woken goal.  If the suspension was already\n   marked as woken, kill_suspension/1 just succeeds. If called with a\n   variable, it succeeds as well which is useful when writing demon\n   predicates that might not have a suspension the first time they are\n   invoked.\n\n   Note that a suspension is not a standard Prolog data structure and can\n   only be manipulated in a restricted way.\n\nModes and Determinism\n   kill_suspension(?) is det\n\nExceptions\n     5 --- Susp is not a suspension.\n\nExamples\n   \n[eclipse 1]: suspend(writeln(hello), 3, X->inst, Susp),\n\tX=1.\t% wakes\nhello\n\nSusp = 'SUSP-_299-dead'\nX = 1\nYes (0.00s cpu)\n\n[eclipse 2]: suspend(writeln(hello), 3, X->inst, Susp),\n    kill_suspension(Susp),\n\tX=1.\t% no effect\n\nSusp = 'SUSP-_308-dead'\nX = 1\nYes (0.00s cpu)\n\nSee Also\n   demon / 1, make_suspension / 3, get_suspension_data / 3, attach_suspensions / 2, insert_suspension / 3, insert_suspension / 4"},"make_suspension/3":{"prefix":"make_suspension","body":"make_suspension(${1:Goal}, ${2:Prio}, ${3:Susp})$4\n$0","description":"make_suspension(+Goal, +Prio, -Susp)\n\n   Make Goal a suspended goal\n\nArguments\n   Goal    A Prolog Goal.\n   Prio    A small integer.\n   Susp    A variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   The goal Goal is made a suspended goal, i.e. it enters the suspended\n   part of the resolvent and shows up as a delayed goal.  When the debugger\n   is on, a DELAY port is generated.\n\n   A suspension can be in three states:\n\n\tState\t\tPrinted as\n\t---------------------------------\n\tsleeping\t'SUSP-_123-susp'\n\tscheduled\t'SUSP-_123-sched'\n\tdead\t\t'SUSP-_123-dead'\n\n   The Prio argument determines the priority with which the Goal will be\n   scheduled when woken. It can be a positive number between 1 and 12,\n   or zero, in which case the priority defaults to the priority setting\n   of the predicate which is called in Goal.\n\n   Note that a suspension is not a standard Prolog data structure and can\n   only be manipulated in a restricted way.  In particular, a suspension is\n   not an atom although it gets printed by default in the form\n   'SUSP-_123-susp'.   The only way to create a suspension is with\n   make_suspension/3,4, suspend/3,4 or by copying an existing suspension.\n   The contents of a suspension can only be retrieved using get_suspension_data/3.\n\nModes and Determinism\n   make_suspension(+, +, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is not a callable term.\n     5 --- Susp is not a variable.\n     5 --- Prio is not an integer.\n     6 --- Prio is not a valid priority.\n    60 --- Goal refers to an undefined precedure.\n\nExamples\n   \n[eclipse 1]: make_suspension(writeln(hello), 1, S), suspensions(Ss).\n\nS = 'SUSP-_264-susp'\nSs = ['SUSP-_264-susp']\n\nDelayed goals:\n\twriteln(hello)\nYes (0.00s cpu)\n\n[eclipse 2]: make_suspension(true, 3, S), is_suspension(S), type_of(S,T).\n\nS = 'SUSP-_272-susp'\nT = goal\n\nDelayed goals:\n    true\nYes (0.00s cpu)\n\nSee Also\n   suspend / 3, delayed_goals / 1, insert_suspension / 4, is_suspension / 1, kill_suspension / 1, schedule_suspensions / 1, schedule_suspensions / 2, get_suspension_data / 3, set_flag / 3, wake / 0"},"notify_constrained/1":{"prefix":"notify_constrained","body":"notify_constrained(${1:Var})$2\n$0","description":"notify_constrained(?Var)\n\n   Notify the system that the given variable was constrained\n\nArguments\n   Var    A variable or any term\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   When an extension package recognizes that new constraints have been\n   imposed on a particular attributed variable, it must notify the system\n   about it, so that other packages (e.g.  Propia) or system primitives\n   (e.g.  guards) can deliver proper results.\n   \n   The operational semantics is that the 'constrained' suspension list\n   of the given variable will be scheduled for waking.  After calling\n   notify_constrained/1 (and possibly after scheduling further suspension\n   lists in one go) a call to wake/0 must be made in order to actually\n   execute the scheduled suspensions.\n   \n   Although notify_constrained/1 can safely be called with a simple variable\n   or nonvariable argument, doing so has no effect and will simply succeed.\n   \n\nModes and Determinism\n   notify_constrained(?) is det\n\nSee Also\n   wake / 0"},"schedule_suspensions/1":{"prefix":"schedule_suspensions","body":"schedule_suspensions(${1:Trigger})$2\n$0","description":"schedule_suspensions(+Trigger)\n\n   Take the suspension list associated with the symbolic trigger\nTrigger and schedule them for execution.\n\nArguments\n   Trigger    An atom.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for execution,\n   and finally executed.\n\n   The task of schedule_suspensions/1 is to take suspensions from the\n   global suspension list associated to the symbolic name Trigger, and\n   schedule them for execution.  The suspensions are inserted into a\n   global priority list, according to their individual priority.  A\n   subsequent wake/0 will then actually execute them.\n\n   If no suspensions are associated to Trigger, schedule_suspensions/1\n   just succeeds and does nothing.\n\nModes and Determinism\n   schedule_suspensions(+) is det\n\nExamples\n   \n[eclipse 1]: suspend(writeln(world), 2, trigger(hello)),\n    schedule_suspensions(hello), wake.  \nworld\nyes.\n\nSee Also\n   demon / 1, insert_suspension / 3, insert_suspension / 4, make_suspension / 3, get_suspension_data / 3, attach_suspensions / 2, trigger / 1, wake / 0"},"merge_suspension_lists/4":{"prefix":"merge_suspension_lists","body":"merge_suspension_lists(${1:Pos1}, ${2:Attr1}, ${3:Pos2}, ${4:Attr2})$5\n$0","description":"merge_suspension_lists(+Pos1, +Attr1, +Pos2, +Attr2)\n\n   Destructively merge the suspension list on Pos1 in structure Attr1\ninto the suspension list on Pos2 in structure Attr2.\n\nArguments\n   Pos1    Integer indicating the position of the suspension list.\n   Attr1    Compound term, typically a variable's attribute.\n   Pos2    Integer indicating the position of the suspension list.\n   Attr2    Compound term, typically a variable's attribute.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This predicate is used to merge two suspension lists. The list\n   in Attr1 remains unaffected but the list in Attr2 is replaced\n   by the merge of the two lists.\n\n   Suspension lists should be regarded an opaque data structure and\n   only be accessed and manipulated by the set of primitives provided\n   for this purpose.\n\nModes and Determinism\n   merge_suspension_lists(+, +, +, +) is det\n\nExceptions\n     4 --- Pos1, Pos2, Attr1 or Attr2 is not instatiated.\n     5 --- Pos1 or Pos2 is not an integer.\n     5 --- Attr1 or Attr2 is not a structure or has no suspension list on the indicated argument position.\n     6 --- Attr1 or Attr2 does not have a Position'th argument.\n\nExamples\n   \n\nSee Also\n   insert_suspension / 3, insert_suspension / 4, schedule_suspensions / 2, init_suspension_list / 2, enter_suspension_list / 3"},"make_suspension/4":{"prefix":"make_suspension","body":"make_suspension(${1:Goal}, ${2:Prio}, ${3:Susp}, ${4:Module})$5\n$0","description":"make_suspension(+Goal, +Prio, -Susp, +Module)\n\n   Make Goal a suspended goal\n\nArguments\n   Goal    A Prolog Goal.\n   Prio    A small integer.\n   Susp    A variable.\n   Module    An atom.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n\n    This is equivalent to\n\n\tmake_suspension(Goal, Prio, Susp)@Module\n\n    which should be preferred.\n\nModes and Determinism\n   make_suspension(+, +, -, +) is det\n\nExceptions\n     4 --- Goal is not instantiated.\n     4 --- Module is not instantiated.\n     5 --- Goal is not a callable term.\n     5 --- Susp is not a variable.\n     5 --- Prio is not an integer.\n     5 --- Module is not an atom.\n     6 --- Prio is not a valid priority.\n    60 --- Goal refers to an undefined precedure.\n\nSee Also\n   make_suspension / 3"},"set_suspension_data/3":{"prefix":"set_suspension_data","body":"set_suspension_data(${1:Susp}, ${2:Name}, ${3:Value})$4\n$0","description":"set_suspension_data(+Susp, +Name, +Value)\n\n   Modify properties of suspended goals.\n\nArguments\n   Susp    A suspension or variable.\n   Name    An atom.\n   Value    An integer.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   This built-in is used to modify fields of the abstract suspension\n   data type.  The modifiable properties of a suspension are:\n\nName    Type    Value\n-------------------------------------------------------------\npriority    Integer     Waking priority\ninvoc       Integer     Invocation number (debugging)\n\n   All modifications are undone on backtracking. Changes to the priority\n   only have an effect the next time the suspension is scheduled\n   (ie changing the priority of an already scheduled suspension has\n   no effect unless it is a demon which can become suspended again).\n   If Susp is a variable or a dead suspension, this predicate\n   silently succeeds, doing nothing.\n\n   Note that a suspension is not a standard logical data structure and can\n   only be manipulated in a restricted way.  In particular, a suspension\n   cannot be printed (e.g. using writeq/1,2) and then read back, giving a\n   term identical to the one that was printed.\n\nModes and Determinism\n   set_suspension_data(+, +, +) is det\n\nExceptions\n     4 --- Name or Value is not instantiated.\n     5 --- Susp is instantiated, but not a suspension.\n     5 --- Name is instantiated but not an atom.\n     6 --- Name is not the name of a modifiable suspension property.\n\nExamples\n   \n    [eclipse 1]: make_suspension(writeln(hello),5,S),\n\t    set_suspension_data(S, priority, 2),\n\t    get_suspension_data(S, priority, P).\n\n    S = 'SUSP-_123-susp'\n    P = 2\n    Delayed goals:\n\t    writeln(hello)\n    yes.\n\n    :- demon d/2.\n    d(X, Susp) :-\n    ( var(S) ->    % initial suspend\n\t    suspend(d(X, Susp), 5, X->constrained, Susp)\n\t; finished(X) ->   % terminate\n\t    kill_suspension(Susp)\n\t; useful(X) ->     % raise priority\n\t    set_suspension_data(Susp, priority, 4)\n\t;    % lower priority\n\t    set_suspension_data(Susp, priority, 6)\n\t).\n\nSee Also\n   delayed_goals / 1, kill_suspension / 1, make_suspension / 3, get_suspension_data / 3, get_priority / 1, call_priority / 2, suspend / 3, suspensions / 1, current_suspension / 1, get_suspension_data / 3"},"schedule_suspensions/2":{"prefix":"schedule_suspensions","body":"schedule_suspensions(${1:Position}, ${2:Attribute})$3\n$0","description":"schedule_suspensions(+Position, +Attribute)\n\n   Take the suspension list on argument position Position within Attribute,\nand schedule them for execution.\n\nArguments\n   Position    Integer indicating the position of the suspension list.\n   Attribute    Compound term, typically a variable's attribute    with a suspension list in Position'th argument.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for execution,\n   and finally executed.\n\n   The task of schedule_suspensions/2 is to take suspensions\n   from a suspension list and schedule them for execution.\n   The suspensions are put into a global priority list, according\n   to their individual priority. A subsequent wake/0 will then\n   actually execute them.\n\n   As a side effect, the suspension list within Attribute is updated,\n   ie. suspensions which are no longer useful are removed destructively.\n\nModes and Determinism\n   schedule_suspensions(+, +) is det\n\nExceptions\n     4 --- Position or Attribute is not instatiated.\n     5 --- Position is not an integer.\n     5 --- Attribute is not a structure or it Position'th argument    is not a list of suspensions.\n     6 --- Attribute does not have a Position'th argument.\n\nExamples\n   \n[eclipse 1]: make_suspension(writeln(hello), 4, S),\n    make_suspension(writeln('hi there'), 2, T),\n\t     Attr = attr([S,T]),\n    schedule_suspensions(1, Attr),\n    wake.\nhi there\nhello\n\nS = 'SUSP-_306-dead'\nT = 'SUSP-_311-dead'\nAttr = attr([])\nyes.\n\n[eclipse 2]: [user].\n :- demon(d/0).\n d :- writeln(demon).\n\nuser       compiled traceable 68 bytes in 0.12 seconds\n\nyes.\n[eclipse 3]: make_suspension(d, 4, S), \n    make_suspension(writeln('hi there'), 2, T),\n\t     Attr = attr([S,T]),\n\t     schedule_suspensions(1,Attr),\n\t     wake.\nhi there\ndemon\n\nS = 'SUSP-_304-susp'\nT = 'SUSP-_309-dead'\nAttr = attr(['SUSP-_304-susp'])\n\nDelayed goals:\n    d\nyes.\n\nSee Also\n   demon / 1, insert_suspension / 3, insert_suspension / 4, make_suspension / 3, get_suspension_data / 3, wake / 0"},"suspend/4":{"prefix":"suspend","body":"suspend(${1:Goal}, ${2:Prio}, ${3:CondList}, ${4:Susp})$5\n$0","description":"suspend(+Goal, +Prio, +CondList, -Susp)\n\n   Suspend the Goal and wake it with priority Prio as soon as one of the\nconditions in CondList occurs.\n\nArguments\n   Goal    A callable term.\n   Prio    An integer.\n   CondList    A term of the form Vars->Cond or trigger(Atom) or a list of such terms.\n   Susp    A free variable used to return the created suspension.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   The specified goal Goal is suspended, subject to the given trigger\n   conditions and priority, as with suspend/3.  The only difference to\n   suspend/3 is that the Susp argument returns a handle for the created\n   suspension. This handle can, for example, be passed as an argument to\n   the suspended goal itself, which is useful for demon goals which need\n   to kill their own suspension under certain circumstances.\n\n   See suspend/3 for details of arguments and operation.\n\nModes and Determinism\n   suspend(+, +, +, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     6 --- CondList is ill-formed.\n\nExamples\n   \n[eclipse]: suspend(writeln(hello), 2, X->inst, Susp),\n    get_suspension_data(Susp, goal, Goal),\n    get_suspension_data(Susp, module, Module).\n\nX = X\nGoal = writeln(hello)\nSusp = 'SUSP-_321-susp'\nModule = eclipse\n\nDelayed goals:\n    writeln(hello)\nyes.\n\n[eclipse]: suspend(writeln(hello), 2, X->inst, Susp),\n    kill_suspension(Susp),     % killed before woken\n\tX=1.\n\nSusp = 'SUSP-_308-dead'\nX = 1\nyes.\n\n% A demon that wakes whenever X becomes more constrained\nreport(X) :-\n      suspend(report(X, Susp), 1, X->constrained, Susp).\n\n:- demon(report/2).\nreport(X, Susp) :-\n      ( var(X) ->\n    writeln(constrained(X))   % implicitly re-suspend\n      ;\n    writeln(instantiated(X)),\n    kill_suspension(Susp)     % remove from the resolvent\n      ).\n\nSee Also\n   demon / 1, make_suspension / 3, insert_suspension / 3, suspend / 3, attach_suspensions / 2"},"suspend/3":{"prefix":"suspend","body":"suspend(${1:Goal}, ${2:Prio}, ${3:CondList})$4\n$0","description":"suspend(+Goal, +Prio, +CondList)\n\n   Suspend the Goal and wake it with priority Prio as soon as one of the\nconditions in CondList occurs.\n\nArguments\n   Goal    A callable term.\n   Prio    An integer.\n   CondList    A term of the form Vars->Cond or trigger(Atom) or a list of such terms.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   The specified goal Goal is suspended (a suspension is created as with\n   make_suspension/3) and attached to the trigger conditions given in CondList.\n   When any of the trigger conditions arise in the future, the goal is\n   going to be woken up.\n\n   The Prio argument determines the priority with which the Goal will be\n   scheduled when woken. It can be a positive number between 1 and 12,\n   or zero, in which case the priority defaults to the priority setting\n   of the predicate which is called in Goal. (Note that this is the scheduling\n   priority which determines the order of execution; the priority under which\n   the woken goal is executed may be higher, and is determined by the\n   run_priority predicate property, see set_flag/3).\n\n   CondList is a list of terms (or a single term) of the form Vars->Cond\n   or trigger(Atom).  It specifies the conditions that will lead to the goal\n   being woken up. It is enough for one of the specified conditions to arise\n   in order for the goal to be woken.\n\n   Vars->Cond is used to specify trigger conditions on variables.\n   Vars is an arbitrary term, and the suspension will be attached to all\n   the variables that occur in Vars.  These trigger conditions correspond\n   to suspension lists inside of variables's attributes, and can be\n   written in a variety of forms:\n\n    Vars->SUSPLISTNAME    e.g. X->inst\n    Vars->ATTRNAME:SUSPLISTNAME       e.g. X->fd:min\n    Vars->ATTRNAME:ARGINDEX    e.g. X->fd:(min of fd)\n    Vars->ATTRNAME:ARGLIST    e.g. X->fd:[min,max]\n    Vars->LISTOFCONDS    e.g. X->[fd:min,inst]\n\n   There are 3 predefined suspension list names: 'inst' (for instantiation),\n   'bound' (instantiation, including aliasing to another variable) and\n   'constrained' (any constraining attribute modification).  These all\n   belong to an attribute called 'suspend'.  Others are defined by libaries,\n   and usually the attribute name is identical to the library name (e.g. fd).\n\n   A specification of the form trigger(Atom) states that the goal should\n   be woken by a symbolic trigger, ie.  by a matching invocation of the\n   built-in schedule_suspensions/1.  The name of the trigger can be an\n   arbitrary atom.\n\n   A variant suspend/4 of this predicate is available.  It returns a handle\n   for the created suspension, which is useful for suspending demons.\n\n   NOTE: it is possible to create a suspension that can never be woken,\n   e.g. by specifying a Vars-term without variables.\n\nModes and Determinism\n   suspend(+, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     6 --- CondList is ill-formed.\n\nExamples\n   \n[eclipse 1]: suspend(writeln(hello), 2, X->inst).\n\nX = X\n\nDelayed goals:\n    writeln(hello)\nyes.\n[eclipse 2]: suspend(writeln(hello), 2, X->inst),\n    writeln(one),\n    X=1,    % causes waking\n    writeln(two).\none\nhello\ntwo\n\nX = 1\nyes.\n[eclipse 3]: suspend(writeln(X), 2, [X,Y]->bound), X=Y.\nX\n\nX = X\nY = X\nyes.\n[eclipse 4]: suspend(writeln(world), 2, trigger(hello)), trigger(hello).\nworld\n\nyes.\n\nSee Also\n   suspend / 4, make_suspension / 3, insert_suspension / 3, attach_suspensions / 2, schedule_suspensions / 1, meta_attribute / 2, set_flag / 3"},"subcall/2":{"prefix":"subcall","body":"subcall(${1:Goal}, ${2:Delayed_goals})$3\n$0","description":"subcall(+Goal, -Delayed_goals)\n\n   Succeeds iff Goal succeeds and unifies Delayed_goals with a list of\nremaining delayed goals.\n\nArguments\n   Goal    Atom or compound term.\n   Delayed_goals       Variable or list.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Calls the goal Goal.  When Goal succeeds, Delayed_goals is unified with\n   a list of goals that were delayed, but not resumed during execution of\n   Goal.  These goals, together with the variable bindings in Goal, can be\n   regarded as a qualified answer to Goal.  I.e. Goal is true under the\n   condition that the conjunction of delayed goals is also true.\n\n   Note that, after exiting from subcall/2, the goals collected in\n   Delayed_goals do no longer exist as delayed goals.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Goal fails\n\nResatisfiable\n   Resatisfiable if Goal is resatisfiable\n\nExceptions\n     4 --- Goal is not instantiated.\n     5 --- Goal is neither an atom nor a compound term.\n    68 --- Goal is an undefined procedure.\n\nExamples\n   \nSuccess:\n    [eclipse]: X > 0, subcall(X < 5, DG).\n\n    X = X\n    DG = [X < 5]\n\n    Delayed goals:\n    X > 0\n    yes.\n    [eclipse]: subcall( (X > 0, Y > 0, X = 3) , DG).\n\n    Y = Y\n    X = 3\n    DG = [Y > 0]\n    yes.\n\nFail:\n    subcall(fail, _).\nError:\n    subcall(Var, D).    (Error 4).\n    subcall(3, D).    (Error 5).\n    subcall(foo(a), D).    (Error 68).\n\nSee Also\n   call / 1, @ / 2, : / 2, call_priority / 2"},"suspensions/1":{"prefix":"suspensions","body":"suspensions(${1:Susps})$2\n$0","description":"suspensions(-Susps)\n\n   Returns a list of all currently live (sleeping or scheduled) suspensions.\n\nArguments\n   Susps    A variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for execution,\n   and finally executed.\n\n   suspension/1 returns a list of all currently live suspensions.\n   They may be either sleeping or already scheduled for execution.\n   It does not return any dead suspensions.\n\n   Note: If you are looking for one particular suspension, consider\n   using current_suspension/1 instead.\n\nModes and Determinism\n   suspensions(-) is det\n\nExamples\n   \n    [eclipse 6]: suspend(writeln(a),3,X->inst),\n    suspend(writeln(b),5,Y->inst),\n    suspensions(S).\n\n    X = X\n    Y = Y\n    S = ['SUSP-_358-susp', 'SUSP-_376-susp']\n\n    Delayed goals:\n    writeln(a)\n    writeln(b)\n    yes.\n\nSee Also\n   current_suspension / 1, delayed_goals / 1, make_suspension / 3, kill_suspension / 1, schedule_suspensions / 1, schedule_suspensions / 2, suspend / 3, suspend / 4, get_suspension_data / 3"},"suspensions/2":{"prefix":"suspensions","body":"suspensions(${1:Var}, ${2:SuspensionList})$3\n$0","description":"suspensions(?Var, -SuspensionList)\n\n   Retrieves a list of all suspensions attached to the variable Var.\n\nArguments\n   Var    Any term.\n   SuspensionList      List or variable.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n    Retrieves all live suspensions attached to the variable Var, and\n    returns them in a duplicate-free list SuspensionList.\n\n    Note that this is a relatively expensive operation, involving collecting\n    all suspensions lists from the variable's attributes via their respective\n    suspensions-handlers, then removing duplicates and dead suspensions.\n\nModes and Determinism\n   suspensions(?, -) is det\n\nExamples\n   \n[eclipse 2]: suspend:(X>5), suspensions(X, S).\nX = X\nS = ['SUSP-_256-susp']\nDelayed goals:\n    suspend : (X > 5)\nyes.\n\n[eclipse 3]: suspensions(X, S).\nX = X\nS = []\nyes.\n\n[eclipse 4]: suspensions(12, S).\nS = []\nyes.\n\nSee Also\n   suspensions / 1, subcall / 2, get_suspension_data / 3"},"unschedule_suspension/1":{"prefix":"unschedule_suspension","body":"unschedule_suspension(${1:Susp})$2\n$0","description":"unschedule_suspension(+Susp)\n\n   Undo the scheduling of a suspension, preventing the delayed goal from actually being executed\n\nArguments\n   Susp    A suspension\n\nType\n   Advanced Control and Suspensions\n\nDescription\n\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for execution,\n   and finally executed.  This predicate affects suspensions that are in the\n   scheduled state, and causes them to pass into the executed state without\n   actually being executed.\n\n   Normally, scheduling a suspension leads to the execution of its associated\n   goal, which in turn leads to the suspension passing either into the dead\n   state (normal goals), or back into the suspended state (demons).\n\n   Under special circumstances, it may be known that exection of a\n   scheduled goal would not have any further effect, and in that case\n   unschedule_suspension/1 can be used to pretend that the execution\n   has already happened.\n\n   One example is a propagator for a global constraint, which touches the\n   variables it delays on, and thus wakes itself.  This self-waking is\n   redundant if it is known that the propagation algorithm computes all\n   consequences (i.e. a fixpoint) internally.  Self-waking can the be\n   prevented by calling unschedule_suspension/1 just before the propagator\n   terminates.\n\n   Another example is a binary constraint, implemented via two uni-directional\n   propagators:  the propagator for one direction may redundantly wake the\n   reverse propagator.  This can be prevented by unscheduling the respective\n   reverse propagator (whose suspension can be passed as an argument). Of\n   course the programmer has to be careful only to cancel truly redundant\n   execution.\n\n   This predicate is mainly useful in connection with demons: these go\n   back to suspended state if they were currently scheduled.  Non-demons\n   get killed if they were currently scheduled.  Suspensions that are\n   not currently scheduled (supendede or already dead) are unaffected.\n\nModes and Determinism\n   unschedule_suspension(+) is det\n\nExceptions\n     4 --- Susp is not instatiated.\n     5 --- Susp is not a suspension.\n\nExamples\n   \n:- demon prop/3.\nprop(X, Y, RevSusp) :-\n\twriteln(prop(X,Y)),\n\tunschedule_suspension(RevSusp).\n\t\n\n% Despite waking both goals, only the first one is executed:\n?- suspend(prop(X,Y,SB),0,X->inst,SF),\n   suspend(prop(Y,X,SF),0,Y->inst,SB),\n   [X,Y] = [1,2].\n\nprop(1, 2)\t% only forward demon wakes\n\n    X = 1\n    Y = 2\n    Delayed goals:\n\t    prop(1, 2, 'SUSP-_752-susp')\n\t    prop(2, 1, 'SUSP-_734-susp')\n    Yes (0.00s cpu)\n\n?- suspend(prop(X,Y,SB),0,X->inst,SF),\n   suspend(prop(Y,X,SF),0,Y->inst,SB),\n   [Y,X] = [2,1].\n\nprop(2, 1)\t% only backward demon wakes\n\n    X = 1\n    Y = 2\n    Delayed goals:\n\t    prop(1, 2, 'SUSP-_752-susp')\n\t    prop(2, 1, 'SUSP-_734-susp')\n    Yes (0.00s cpu)\n\nSee Also\n   demon / 1, make_suspension / 3, schedule_suspensions / 2, kill_suspension / 1, get_suspension_data / 3"},"wake/0":{"prefix":"wake","body":"wake","description":"wake\n\n   Execute all scheduled suspensions whose priorities are higher than the current\none.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages:  They are\n   created, attached to variables or symbolic triggers, later\n   scheduled for execution, and finally executed.\n\n   When a suspension is scheduled for execution, it gets inserted\n   into a global priority list where it is waiting for execution.\n   This global priority list is then processed explicitly by the\n   wake/0 predicate.  It will execute, in order of priority, all scheduled\n   suspensions that have priority higher than the current execution priority.\n   The woken goals themselves will be executed under their specific\n   run_priority, which may be higher than their scheduling priority.\n   \n   This separation of scheduling and execution enables the proper\n   handling of priorities:  Low priority suspensions are not\n   necessarily executed by the next wake/0, but possibly later\n   when the current priority has become low enough.\n\n   The separation also allows to schedule a batch of suspension lists\n   together before entering the priority-based execution scheme.\n\n   wake/0 should therefore be called in the following situations:\n    \n   1.  after new suspensions have been scheduled by one or several\n   calls to schedule_suspensions/1,2 or notify_constrained/1.\n\n   2.  whenever the current priority was lowered, since that may allow\n   further scheduled goals to be executed.\n\n   Note that wake/0 is implicitly invoked after every sequence of\n   meta_unify handlers and should thus not be called inside the handlers.\n\nFail Conditions\n   Fails if a woken goal fails\n\nResatisfiable\n   Resatisfiable if a woken goal is resatisfiable\n\nExamples\n   \n[eclipse 4]: make_suspension(write(a), 1, S),\n\tschedule_suspensions(1, attr([S])),\n\twake, write(b).\nab\nS = 'SUSP-_280-dead'\nyes.\n[eclipse 5]: make_suspension(write(a), 1, S),\n\tschedule_suspensions(1, attr([S])),\n\twrite(b), wake.\nba\nS = 'SUSP-_280-dead'\nyes.\n\nSee Also\n   make_suspension / 3, insert_suspension / 3, suspend / 3, suspend / 4, schedule_suspensions / 1, schedule_suspensions / 2, attach_suspensions / 2"},"trigger/1":{"prefix":"trigger","body":"trigger(${1:Trigger})$2\n$0","description":"trigger(+Trigger)\n\n   Wake the suspensions associated with the symbolic trigger Trigger\nuntil there are no more left.\n\nArguments\n   Trigger    An atom.\n\nType\n   Advanced Control and Suspensions\n\nDescription\n   Suspensions in ECLiPSe go through several stages: They are created,\n   attached to variables or symbolic triggers, later scheduled for execution,\n   and finally executed.\n\n   The task of trigger/1 is to take suspensions from the global suspension\n   list associated to the symbolic name Trigger and wake them.  The\n   suspensions are inserted into a global priority list, according to\n   their individual priority, and then executed. Trigger/1 includes a\n   call to wake/0 and is actually defined as\n   \n       trigger(Trigger) :-\n\t   schedule_suspensions(Trigger),\n\t   wake.\n   \n\n   If no suspensions are associated to Trigger, trigger/1\n   just succeeds and does nothing.\n\nFail Conditions\n   Fails if a woken goal fails\n\nExamples\n   \n[eclipse 1]: suspend(writeln(world), 2, trigger(hello)), trigger(hello).\nworld\nyes.\n\nSee Also\n   demon / 1, attach_suspensions / 2, make_suspension / 3, suspend / 3"},"current_macro/4":{"prefix":"current_macro","body":"current_macro(${1:TermClass}, ${2:TransPred}, ${3:Options}, ${4:Module})$5\n$0","description":"current_macro(-TermClass, -TransPred, -Options, -Module)\n\n   Succeeds if TermClass is a macro with the transformation predicate\nTransPred defined in module Module and flags Options.\n\nArguments\n   TermClass    Term in the form Atom/Integer or atom or variable.\n   TransPred    Term in the form Atom/Integer or variable.\n   Options    List or a variable.\n   Module    Atom or variable.\n\nType\n   Syntax Settings\n\nDescription\n   This predicate enumerates all visible macros and retrieves their\n   definition.  The arguments TransPred and Options correspond to the\n   arguments of macro/3 or portray/3.  Module is the definition module of\n   TransPred and it can be used for calling the TransPred explicitly (e.g.\n   using :/2).\n\nModes and Determinism\n   current_macro(-, -, -, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- TermClass not of form Atom/Integer.\n     5 --- TransPred not of form Atom/Integer.\n     5 --- Options not a list.\n\nExamples\n   \n[eclipse]: [user].    % define a macro\n tr_a(a(X), b(X,X)).\n :- local macro(a/1, tr_a/2, []).\n\nyes.\n[eclipse]: current_macro(F, T, O, M).  % list visible macros\n\nF = (-->) / 2    % predefined macro\nT = trdcg / 3\nO = [global, clause]\nM = macro     More? (;)\n\nF = (if) / 2    % predefined macro\nT = tr_if / 2\nO = [global, clause]\nM = coroutine     More? (;)\n\nF = a / 1    % our user defined macro\nT = tr_a / 2\nO = [local]\nM = eclipse     More? (;)\n\nF = no_macro_expansion / 1     % predefined macro\nT = trprotect / 2\nO = [global, protect_arg]\nM = macro     More? (;)\n\nno (more) solution.\n\nSee Also\n   macro / 3, portray / 3, erase_macro / 2"},"current_op/3":{"prefix":"current_op","body":"current_op(${1:Precedence}, ${2:Associativity}, ${3:Name})$4\n$0","description":"current_op(-Precedence, -Associativity, -Name)\n\n   Succeeds if Name is a visible operator with precedence Precedence and\nassociativity Associativity.\n\nArguments\n   Precedence    Integer or variable.\n   Associativity       Atom or variable.\n   Name    Atom or variable.\n\nType\n   Syntax Settings\n\nDescription\n   Used to check for the existence of a visible operator of precedence\n   Precedence with name Name and associativity Associativity.  Alternative\n   solutions are returned on backtracking.\n\n   Precedence is an integer in the range 1 to 1200.\n\n   Associativity is one of the atoms\n\n   xfx, xfy, yfx, fx, fy, xf, yf, fxx, fxy.\n\nModes and Determinism\n   current_op(-, -, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Precedence is not an integer.\n     5 --- Associativity is not one of the above atoms.\n     5 --- Name is instantiated but not to an atom.\n     6 --- Precedence is not in the range 0 to 1200.\n\nExamples\n   \nSuccess:\n   current_op(300, fx, *).\n\n   [eclipse]: current_op(P, A, +).\n   P = 500\n   A = fx     More? (;)\n   P = 500\n   A = yfx     More? (;)   % RETURN pressed\n   yes.\n\nFail:\n   current_op(10, fx, noop).\n\nError:\n   current_op(prec, fx, +).    (Error 5).\n   current_op(100, fff, +).    (Error 5).\n   current_op(100, fx, bad(op)).    (Error 5).\n   current_op(-1, fx, +).    (Error 6).\n\nSee Also\n   op / 3"},"erase_macro/2":{"prefix":"erase_macro","body":"erase_macro(${1:TransTerm}, ${2:Options})$3\n$0","description":"erase_macro(+TransTerm, ++Options)\n\n   Erases the macro definition for TransTerm done in the current module\n\nArguments\n   TransTerm    Term in the form Atom/Integer.\n   Options    Possibly empty list of option flags.\n\nType\n   Syntax Settings\n\nDescription\n   The macro defined for TransTerm and matching the specified Options\n   is erased.  If there was no matching macro definition, the predicate\n   silently succeeds. See macro/3 and portray/3 for the valid options.\n\nModes and Determinism\n   erase_macro(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- TransTerm is not instantiated or Options is not fully instantiated.\n     5 --- TransTerm not of form Atom/Integer or Options is not a list of atoms.\n     6 --- Options contains an element which is not a valid option.\n\nExamples\n   \n   Success:\n   erase_macro(a/1, [read]).\n   erase_macro(a/1, [write,goal]).\n   Error:\n   erase_macro(X, []).    (Error 4).\n   erase_macro(a, [write]).      (Error 5).\n   erase_macro(a/1, [hello]).    (Error 6).\n\nSee Also\n   current_macro / 4, macro / 3, portray / 3, phrase / 3"},"current_struct/2":{"prefix":"current_struct","body":"current_struct(${1:Name}, ${2:Struct})$3\n$0","description":"current_struct(?Name, -Struct)\n\n   Succeeds if Name is the name of a currently visible structure and Struct is its specification\n\nArguments\n   Name    Variable or atom\n   Struct    Variable or structure.\n\nType\n   Syntax Settings\n\nDescription\n\n\tUsed to retrieve the definition of a defined structure, or to\n\tenumerate all visible structure definitions.\n\t\n\tVisible structures are those which have either been declared locally,\n\texported, or which have been imported or reexported from another module.\n\t\n\nModes and Determinism\n   current_struct(+, -) is semidet\n   current_struct(-, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Name is not the name of a visible structure definition\n\nExceptions\n     5 --- Name is neither variable nor atom.\n     5 --- Struct is neither variable nor structure.\n\nExamples\n   \n    :- local struct(employee(name,age,salary)).\n\n    ?- current_struct(employee, Spec).\n    Spec = employee(name, age, salary)\n    yes.\n\n    ?- current_struct(Name, Spec).\n    Name = employee\n    Spec = employee(name, age, salary)\n    More (0.00s cpu) ? ;\n\n    Name = suspend\n    Spec = suspend(inst, constrained, bound)\n    More (0.00s cpu) ? ;\n\n    No (0.00s cpu)\n\n    ?- current_struct(book, Spec).\n    No (0.00s cpu)\n\nSee Also\n   local / 1, export / 1, struct / 1"},"get_chtab/2":{"prefix":"get_chtab","body":"get_chtab(${1:Char}, ${2:Class})$3\n$0","description":"get_chtab(+Char, -Class)\n\n   Succeeds if the lexical class of character Char is Class.\n\nArguments\n   Char    Integer in the range 0 to 255.\n   Class    Atom giving class name or variable.\n\nType\n   Syntax Settings\n\nDescription\n   Retrieves or checks the lexical class of a given character.\n\n   Class is unified with the current lexical character class of Char.\n\n   Char must be an integer in the range 0 to 255 (an escaped ASCII code is\n   also acceptable, eg 0'a = 98).\n\n   The following table lists the character classes and the corresponding\n   default characters:\n\n Class    Default member characters\n---------------------------------------------------------\n upper_case     all upper case letters\n underline      _\n lower_case     all lower case letters\n digit    digits\n blank_space    space, tab and nonprintable characters\n end_of_line    newline (NL)\n atom_quote     '\n string_quote   \"\n list_quote\n chars_quote\n radix\n ascii\n solo    ! ;\n special    ( [ { ) ] } , |\n line_comment   %\n escape    \\\n first_comment  /\n second_comment *\n symbol    # + - . : < = > ? @ ^ ` ~ & $\n terminator\n\nModes and Determinism\n   get_chtab(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Char in not instantiated.\n     5 --- Char is not an ASCII code.\n     6 --- Char is not in the range 0 to 255.\n\nExamples\n   \nSuccess:\n   [eclipse]: get_chtab(0'a,X).\n\n   X = lower_case\n   yes.\n   [eclipse]: get_chtab(60,X).\n\n   X = symbol\n   yes.\n   [eclipse]:\n\nFail:\n   get_chtab(98,symbol).\n   get_chtab(98,blah).\n\nError\n   get_chtab(X,lower_case).     (Error 4).\n   get_chtab(\"a\",X).    (Error 5).\n   get_chtab(-1,X).    (Error 6).\n\nSee Also\n   set_chtab / 2, read_token / 2, read_token / 3"},"set_chtab/2":{"prefix":"set_chtab","body":"set_chtab(${1:Char}, ${2:Class})$3\n$0","description":"set_chtab(+Char, +Class)\n\n   Sets the lexical class of character Char to class Class, this provides an\ninterface to ECLiPSe 's lexical analyser.\n\nArguments\n   Char    Integer in range 0 to 255.\n   Class    Atom indicating the character class.\n\nType\n   Syntax Settings\n\nDescription\n   Changes the lexical class of a given character.  This is especially\n   useful for implementing compatibility packages.  The possible character\n   classes which a character may have been given are shown below.\n\nNote\n   It is not recommended to change the class of the special characters,\n   since in some cases it might make it impossible to correctly parse\n   Prolog terms.\n\n   The following table lists the character classes and the default\n   corresponding characters:\n\n Class    Default member characters\n---------------------------------------------------------\n upper_case     all upper case letters\n underline      _\n lower_case     all lower case letters\n digit    digits\n blank_space    space, tab and nonprintable characters\n end_of_line    newline (NL)\n atom_quote     '\n string_quote   \"\n list_quote\n chars_quote\n radix\n ascii\n solo    ! ;\n special    ( [ { ) ] } , |\n line_comment   %\n escape    \\\n first_comment  /\n second_comment *\n symbol    # + - . : < = > ? @ ^ ` ~ & $\n terminator\n\nModes and Determinism\n   set_chtab(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Char and/or Class are not instantiated.\n     5 --- Char is not an integer in the range 0 to 255.\n     6 --- Class is not a valid lexical class.\n\nExamples\n   \nSuccess:\n   % The following example illustrates the use\n   % of set_chtab/2 to redefine the class of the\n   % dollar symbol.\n   %\n   [eclipse]: X = $a.\n    ^ (here?)\n   syntax error: postfix/infix operator expected\n   [eclipse]: set_chtab(0'$, lower_case).\n\n   yes.\n   [eclipse]: X = $a.\n\n   X = $a\n   yes.\n   [eclipse]:\n\nError:\n   set_chtab(\"a\",symbol).       (Error 5)\n   set_chtab(97,fred).    (Error 6)\n\nSee Also\n   local / 1, get_chtab / 2, read_token / 2, read_token / 3"},"macro/3":{"prefix":"local","body":"local","description":"local macro(++TermClass, ++TransPred, ++Options)\nexport macro(++TermClass, ++TransPred, ++Options)\n\n   Defines a macro transformation for the functor or type specified by TermClass.\n\nArguments\n   TermClass    Term in the form Atom, Atom/Integer or type(Type).\n   TransPred    Term in the form Atom/Integer.\n   Options    Possibly empty list of option flags.\n\nType\n   Syntax Settings\n\nDescription\n   This declaration is used to define a macro transformation on a class of\n   terms.  Macro transformations are performed when a term is read by one of\n   the predicates read/1,2, read_term/2,3, readvar/3 or read_annotated/2,3 \n   (unless the stream flag or global flag macro_expansion is switched off).\n\n   The TermClass specifies to which terms the transformation will be\n   applied:\n\n    Name/Arity\n\ttransform all terms with the specified functor\n    type(Type)\n\ttransform all terms of the specified type, where Type is one of\n\tcompound, string, integer, rational, float, breal, goal, atom, meta.\n\n   The +TransPred argument specifies the predicate that will perform the\n   transformation.  TransPred can be of either arity 2 or 3, and be in the \n   form:\n\n\ttrans_function(OldTerm, NewTerm [, Module]) :- ... .\n\n   or it can be source annotation aware, and be of arity 4 or 5, as follows:\n\n\ttrans_function(OldTerm, NewTerm, OldAnn, NewAnn [, Module]) :- ... .\n\n   At transformation time, the system will call TransPred in the module\n   where local macro/3 was invoked. The term to transform is\n   passed as the first argument, the second is a free variable which the\n   transformation should bind to the transformed term. In the case of the\n   source annotation aware version of TransPred, if the term was read in by\n   read_annotated/2,3, the annotated version of the term to transformed is\n   passed in the third argument, and the transformation should bind the\n   fourth argument to the annotated transformed term; otherwise, if no\n   source annotation information is available, the third argument is passed\n   in as a free variable, and the transformation should not bind the fourth\n   argument. In both TransPred cases, the optional last argument is the\n   module where the term was being read in.\n\n   Options is a list which may be empty or contain one of the following\n   type specification atoms:\n\n    term (default)\n\tTransform the term in all contexts (this is the default, and the\n\ttransformation is done in the parser, or explicitly via expand_macros/2)\n    clause\n\tTransform only if the term is a program clause, i.e. inside\n    compile/1, assert/1 etc, or explicitly via expand_clause/2.\n    goal (deprecated)\n\tTransform only if the term is a goal. This form is deprecated,\n\tplease use inline/2 to transform goals.\n\n   and possibly some of the following options:\n\n    protect_arg (optional)\n\tDisable transformation of subterms. If this option is used, the\n\ttransformation predicate itself should take care of transforming\n\tthose subterms that should be transformed (expand_macros/2).\n\tThis option is only useful for term-macros because only those\n\tperform automatic subterm transformation.\n    top_only (deprecated)\n\tConsider only the whole term, not subterms.\n\tThis option is deprecated, use clause and goal options instead.\n\n   The visibility of macros is controlled by the module system.\n   Transformations only take place when the macro declaration is\n   visible in the module where the term is read in.\n   The macro visibility is local or exported, depending on the declaration.\n\n   In rare cases it is necessary to suppress macro expansion explicitly.\n   The functor no_macro_expansion/1 can be wrapped around specific\n   instances of a term to prevent it from being transformed.\n   Macro expansion will then remove this wrapper so that the end\n   result is the untransformed term alone.\n\n   Term-transformations (but not clause/goal transformation) automatically\n   transform all subterms of a term in a bottom-up fashion. This means that\n   the transformation predicate will see a term with already transformed\n   subterms.\n\n   The source annotation aware transformation predicate is provided to\n   allow the user to detail how the subterms of the original term is mapped\n   to the transformed term. Without this extra information, the whole of\n   the transformed term is given the source information (source position,\n   source file etc.) of the original source term. This extra information is\n   useful when the subterms are goals, because without the extra\n   information, source tracing of these goals during debugging will not be\n   done.\n\nModes and Determinism\n   macro(++, ++, ++) is det\n\nExceptions\n     4 --- One or more arguments not instantiated.\n     5 --- TermClass not of form Atom, Atom/Integer or type(Type).\n     5 --- TransPred not of form Atom/Integer.\n     5 --- Options not a list or contains invalid flags.\n     6 --- Arity of TransPred is not 2 or 3.\n     6 --- Illegal flag in Options.\n   161 --- Transformation already defined in the current module for TermClass\n\nExamples\n   \n% The following example illustrates how a/1 may be\n% transformed into b/2 using the reader:\n\n   [eclipse]: [user].\n\n    trans_a(a(X),b(X,10)).\n\n    :- local macro(a/1,trans_a/2,[]).\n\n   yes.\n   [eclipse]: read(X).\n    a(fred).\n\n   X = b(fred, 10)\n   yes.\n\n% Example showing use of protect_arg:\n\n   [eclipse]: [user].\n\n    trb(X, newfunctor(Arg)) :- arg(1, X, Arg).\n    trd(d, newd).\n\n    :- local macro(b/1, trb/2, []),\n\t     macro(b_protect/1, trb/2, [protect_arg]),\n\t     macro(d/0, trd/2, []).\n\n   yes.\n   [eclipse]: read(X1),read(X2).\n    b(d).\n    b_protect(d).\n\n   X1 = newfunctor(newd)    % d is transformed\n   X2 = newfunctor(d)       % d is not transformed\n   yes.\n\n% Example showing use of type macros\n\n    [eclipse 1]: [user].\n\n     tr_int(0, 0).\n     tr_int(N, s(S)) :- N > 0, N1 is N-1, tr_int(N1, S).\n\n     :- local macro(type(integer), tr_int/2, []).\n\n    yes.\n    [eclipse 2]: read(X).\n    3.\n\n    X = s(s(s(0)))\n    yes.\n\n% Example showing use of annotation aware macro transformation\n\n    [eclipse 1]: [user].\n    trans_r(r(A,B), New, AnnR, AnnNew) :-\n    New = rr(B,A),\n    (nonvar(AnnR) ->\n    AnnR = annotated_term{term:RAnn},\n    RAnn = r(AnnA,AnnB),\n    NewRAnn = rr(AnnB,AnnA),\n    update_struct(annotated_term, [term:NewRAnn], AnnR, AnnNew)\n    ; \n    true\n    ).\n\n    :- local macro(r/2, trans_r/4,[]).\n    \n    yes.\n    [eclipse 2]: read(user,R).  \n    r(a,b).\n\n    R = rr(b, a)\n    yes.\n    [eclipse 3]: read_annotated(user,R,AR).      \n    r(a,b).\n\n    R = rr(b, a)\n    AR = annotated_term(rr(annotated_term(b, atom, user, 15, 362, 363), annotated_term(a, atom, user, 15, 360, 361)), compound, user, 15, 358, 360)\n    yes.\n\n% The previous example with non-annotation aware transformation:\n\n    [eclipse 1]: [user].\n    trans_r(r(A,B),rr(B,A)).\n    :- local macro(r/2, trans_r/  2,[]).\n\n    yes.\n    [eclipse 2]: read_annotated(user,R,AR).\n    r(a,b).\n\n    R = rr(b, a)\n    AR = annotated_term(rr(annotated_term(b, atom, user, 3, 61, 63), annotated_term(a, atom, user, 3, 61, 63)), compound, user, 3, 61, 63)\n    % all subterms have the same position information\n\nError:\n   local macro(X, trx/2, []).    (Error 4).\n   local macro(a/1, tra/2, [c]).    (Error 6).\n\nSee Also\n   portray / 3, expand_macros / 2, expand_clause / 2, current_macro / 4, erase_macro / 2, phrase / 3, inline / 2, read_annotated / 3"},"op/3":{"prefix":"op","body":"op(${1:Precedence}, ${2:Associativity}, ${3:Name})$4\n$0","description":"op(+Precedence, +Associativity, ++Name)\nlocal op(+Precedence, +Associativity, ++Name)\nexport op(+Precedence, +Associativity, ++Name)\n\n   Declare operator syntax.\n\nArguments\n   Precedence    Integer.\n   Associativity       Atom.\n   Name    Atom or List of atoms.\n\nType\n   Syntax Settings\n\nDescription\n   Declares Name as an operator of precedence Precedence and associativity\n   Associativity. Operators are purely a syntactic convenience: they allow\n   prefix-, infix- or postfix-syntax as an alternative to the canonical\n   functor-syntax for structures with one or two arguments. If used\n   carefully, they can contribute to making code more readable.\n\n   Precedence is an integer in the range 0 to 1200. An operator with a lower\n   precedence number binds its arguments more strongly than an operator with\n   higher precendence number.\n\n   The different classes of operators are distinguished through the\n   Associativity argument:\n\n    Operator class      Associativities\n    ---------------------------------------------------------------\n     prefix    fx, fy (unary) or fxx, fxy (binary)\n     infix    xfx, xfy, yfx\n     postfix    xf, yf\n\n   x represents an argument whose precedence must be lower than that of the\n   operator.  y represents an argument whose precedence must be lower or\n   equal to that of the operator.  y should be used if one wants to allow\n   chaining of operators.  The position of the y will determine the\n   grouping within a chain of operators. Examples:\n\n    Example declaration    will allow    to stand for\n    ---------------------------------------------------------------\n    :- op(500,xfx,in).    A in B    in(A,B)\n    :- op(500,xfy,in).    A in B in C    in(A,in(B,C))\n    :- op(500,yfx,in).    A in B in C    in(in(A,B),C)\n    :- op(500,fx ,pre).    pre A    pre(A)\n    :- op(500,fy ,pre).    pre pre A    pre(pre(A))\n    :- op(500, xf,post).       A post    post(A)\n    :- op(500, yf,post).       A post post    post(post(A))\n    :- op(500,fxx,bin).    bin A B    bin(A,B)\n    :- op(500,fxy,bin).    bin A bin B C       bin(A,bin(B,C))\n\n   Prefix, infix and postfix operators are independent of each other and\n   may coexist.  See the manual chapter on syntax about how ambiguities are\n   resolved in this case.\n\n   Operators can be local or exported, depending on the definition. The\n   default is local, i.e. the following declarations are equivalent:\n\n    :- op(500, xfy, before).\n    :- local op(500, xfy, before).\n\n   while\n\n    :- export op(500, xfy, before).\n\n   will export the operator to all modules that import the module containing\n   the declaration.  There are also a number of predefined global operators,\n   see the User Manual appendix for a complete list.\n\n   Name may be a single atom or a list of atoms, in which case each is\n   given the specified precedence and associativity.  A value of [] is\n   interpreted as the empty list.  To declare [] as an operator, use\n   e.g. op(500,fx,[[]]).\n\n   A precedence of 0 has a special meaning.  It erases a local operator\n   definition and/or hides a global operator of the same name and\n   associativity class.\n\nModes and Determinism\n   op(+, +, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Any of the input arguments is uninstantiated.\n     5 --- Precedence is not an integer.\n     5 --- Name is not an atom or list of atoms.\n     5 --- Associativity is not an atom.\n     6 --- Precedence is not in range 0 to 1200.\n     6 --- Associativity is not one of xf, xfx, fy, etc.\n\nExamples\n   \nSuccess:\n      [eclipse]: module(a).\n      [a]: current_op(X, Y, +).    % there are two global operators\n      X = 500\n      Y = yfx     More? (;)\n      X = 500\n      Y = fx     More? (;)\n      no (more) solution.\n      [a]: display(a+b*c).    % see how it is parsed\n      +(a, *(b, c))\n      yes.\n\n      [a]: op(100, xfy, +).    % define a local infix\n      yes.\n      [a]: display(a+b*c).    % parsed differently now!\n      *(+(a, b), c)\n      yes.\n\n      [a]: op(0, xfy, +).    % just hide the global infix\n      yes.\n      [a]: current_op(X, Y, +).\n      X = 500\n      Y = fx     More? (;)\n      no (more) solution.\n\nError:\n      op(X, fx, aaa).    (Error 4).\n      op(a, fx, aaa).    (Error 5).\n      op(100, xfx, 1).    (Error 5).\n      op(100, abc, fred).    (Error 6).\n      op(100, xfx, aaa),\n    op(100,xf,aaa).    (Error 43).\n\nSee Also\n   current_op / 3, local / 1, export / 1"},"portray/3":{"prefix":"local","body":"local","description":"local portray(++TermClass, ++TransPred, ++Options)\nexport portray(++TermClass, ++TransPred, ++Options)\n\n   Defines a portray transformation for the functor or type specified by TermClass.\n\nArguments\n   TermClass    Term in the form Atom, Atom/Integer or type(Type).\n   TransPred    Term in the form Atom/Integer.\n   Options    Possibly empty list of option flags.\n\nType\n   Syntax Settings\n\nDescription\n   This declaration is used to define a portray transformation on a class of\n   terms.  Portray transformations are performed when a term is written by\n   one of the predicates write/1,2, writeln/1,2, print/1,2, display/1,2,\n   printf/2,3 without the 'T' output option, or write_term/2,3 unless the\n   transform(false) option is used.  Alternatively, portray transformations\n   can be invoked explicitly via portray_term/3.\n\n   The TermClass specifies to which terms the transformation will be\n   applied:\n\n    Name/Arity\n\ttransform all terms with the specified functor\n    type(Type)\n\ttransform all terms of the specified type, where Type is one of\n\tcompound, string, integer, rational, float, breal, goal, atom, meta.\n\n   The +TransPred argument specifies the predicate that will perform the\n   transformation.  TransPred must be of arity 2 or 3 and be in the form:\n\n\ttrans_function(OldTerm, NewTerm [, Module]) :- ... .\n\n   At transformation time, the system will call TransPred in the module\n   where local portray/3 was invoked.  The term to transform is passed\n   as the first argument, the second is a free variable which the\n   transformation should bind to the transformed term, and the optional\n   third argument is the module where the term is going to be printed.\n\n   Options is a list which may be empty or contain one of the following\n   type specification atoms:\n\n    term (default)\n\tTransform all terms (this is the default)\n    clause\n\tTransform only if the term is printed as a program clause,\n\ti.e. by printf/2,3 with the 'C' output option, or write_term/2,3\n\twith the as(clause) option.\n    goal\n\tTransform only if the term is printed as a goal,\n\ti.e. by printf/2,3 with the 'G' output option, or write_term/2,3\n\twith the as(goal) option.\n\n   and possibly the following option:\n\n    protect_arg (optional)\n\tDisable transformation of subterms. If this option is used, the\n\ttransformation predicate itself should take care of transforming\n\tthose subterms that should be transformed (portray_term/3).\n\tThis option is only useful for term-transformation because only\n\tthose perform automatic subterm transformation.\n\n   The visibility of portray declarations is controlled by the module\n   system.  Transformations only take place when the portray\n   declarations is visible in the module where the term is being\n   printed.  The visibility is local or exported, depending on the\n   declaration.\n\n   Portray declarations are being treated as 'write'-macros in\n   current_macro/4 and erase_macro/2.\n\n   Term-transformations (but not clause/goal transformation) automatically\n   transform all subterms of a term in a top-down fashion. This means that\n   the transformation predicate will see a term with untransformed subterms.\n\nModes and Determinism\n   portray(++, ++, ++) is det\n\nExceptions\n     4 --- One or more arguments not instantiated.\n     5 --- TermClass not of form Atom, Atom/Integer or type(Type).\n     5 --- TransPred not of form Atom/Integer.\n     5 --- Options not a list or contains invalid flags.\n     6 --- Arity of TransPred is not 2 or 3.\n     6 --- Illegal flag in Options.\n   161 --- Transformation already defined in the current module for TermClass\n\nExamples\n   \n% Example showing use of write macros\n\n    [eclipse 1]: [user].\n\n     :- local portray(s/1, tr_s/2, []).\n     tr_s(0, 0).\n     tr_s(s(S), N) :- tr_s(S, N1), N is N1+1.\n\n    yes.\n    [eclipse 2]: write(s(s(s(0)))).\n    3\n    yes.\n\nError:\n   local portray(X, trx/2, []).    (Error 4).\n   local portray(a/1, tra/2, [c]).    (Error 6).\n\nSee Also\n   portray_term / 3, macro / 3, printf / 2, printf / 3, current_macro / 4, erase_macro / 2"},"struct/1":{"prefix":"local","body":"local","description":"local struct(++Prototype)\nexport struct(++Prototype)\n\n   Declare a structure according to Prototype.\n\nArguments\n   Prototype    A structure with ground arguments.\n\nType\n   Syntax Settings\n\nDescription\n   ECLiPSe structure notation provides a way to use structures with\n   field names rather than positional arguments.  Note that this is\n   not a new data type, just a new syntax for normal compound terms. \n   It is intended to make programs more readable and easier to modify,\n   without compromising efficiency (it is implemented by macro\n   expansion). \n\n   E.g. if a structure is declared by specifying the prototype\n\n\tbook(author, title, year, publisher)\n\n    then subsequently book/4-terms can be written as follows:\n\n\tbook{}\n\tbook{title:'tom sawyer'}\n\tbook{year:1886, title:'tom sawyer'}\n\n    which will be completely equivalent to the usual\n\n\tbook(_, _, _, _)\n\tbook(_, 'tom sawyer', _, _)\n\tbook(_, 'tom sawyer', 1886, _)\n\n    The advantage is that the order and position of the fields or the\n    arity of the whole structure do not have to be known and can be\n    changed by just changing the initial declaration.\n\n    The argument index of a field in a structure can be obtained using\n    a term of the form\n\n\tFieldName of StructName\n\n    so instead of arg(3,B,Y) one can write\n\n\targ(year of book, B, Y)\n\n    The arity of the structure can be obtained using a term of the\n    following form\n\n    property(arity) of StructName\n\n    instead of having to explicitly give the arity of the structure.  So, \n\n    property(arity) of book\n\n    would be equivalent to the integer 4.  Similarly, a Name/Arity\n    specification can be obtained by writing\n\n    property(functor) of StructName\n\n    so book/4 can alternatively be written as\n\n    property(functor) of book\n\n    Structures can also be declared to contain other structures, e.g.\n\n\t:- local struct(film(based_on:book,director,year)).\n\n    This allows the fields of book to be accessed as if they were\n    fields of film. Note that the declaration of the year-field in\n    the film-structure hides the year-field in the book structure.\n\nModes and Determinism\n   struct(++) is det\n\nExceptions\n     4 --- Struct is not ground.\n     5 --- Struct is neither variable nor structure.\n\nExamples\n   \n% A simple structure:\n\n    [eclipse 1]: local struct(person(name,address,age)).\n\n    yes.\n    [eclipse 2]: John = person{age:30, name:john},\n    John = person{age:A},\n    arg(name of person, John, N).\n\n    John = person(john, _146, 30)\n    A = 30\n    N = john\n    yes.\n\n    [eclipse 3]: N is (property(arity) of person) + 1.\n    N = 4\n    yes.\n\n    [eclipse 4]: PersonStructure = (property(functor) of person).\n    PersonStructure = person / 3\n    yes.\n\n% Example for structure inheritance:\n\n    [eclipse 4]: local struct(employee(p:person,salary)).\n\n    yes.\n    [eclipse 5]: Emp = employee{name:john,salary:2000}.\n\n    Emp = employee(person(john, _105, _106), 2000)\n    yes.\n    \n    [eclipse 6]: Emp = employee{name:john, salary:2000},\n    Emp = employee{p:Person, salary:S},\n    arg(name of employee, Emp, N).\n\n    Person = person(john, _169, _170)\n    S = 2000\n    Emp = employee(person(john, _169, _170), 2000)\n    N = john\n    yes.\n\n% Subscript syntax can be used with structures:\n\n    [eclipse 7]: Emp = employee{name:john, salary:2000},\n    Cost is 5 * Emp[salary of employee].\n\n     Cost = 10000\n     Emp = employee(person(john, _137, _138), 2000)\n     yes.\n\nSee Also\n   local / 1, export / 1, current_struct / 2, arg / 3, subscript / 3, update_struct / 4"},"compare/3":{"prefix":"compare","body":"compare(${1:Ordering}, ${2:Term1}, ${3:Term2})$4\n$0","description":"compare(-Ordering, ?Term1, ?Term2)\n\n   Succeeds if Ordering is a special atom which describes the ordering between\nTerm1 and Term2.\n\nArguments\n   Ordering    Unifiable to a special atom describing the ordering between    Term1 and Term2.\n   Term1    An arbitrary term.\n   Term2    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if Ordering is one of the special atoms ('<', '>' or '=')\n   describing the standard ordering between the terms Term1 and Term2:\n\n   Ordering is the atom '<' iff Term1 comes before Term2 in the standard\n   ordering.\n\n   Ordering is the atom '>' iff Term1 comes after Term2 in the standard\n   ordering.\n\n   Ordering is the atom '=' iff Term1 is identical to Term2.\n\n   The standard ordering of ECLiPSe terms is defined as the following\n   increasing order:\n\nvariables\n    (comparing two free variables yields an implementation-dependent\n    and not necessarily reproducible result).\n\nbounded reals\n    in ascending order (if bounds overlap, the order is by increasing lower\n    bounds, then increasing upper bounds; if both bounds are the same, the\n    two terms are considered equal).\n\nfloats\n    in ascending order, with negative zeros (-0.0) being different and\n    before positive zeros (0.0).\n\nrationals\n    in ascending order.\n\nintegers\n    in ascending order.\n\nstrings\n    lexicographical (ASCII) order\n\natoms\n    lexicographical (ASCII) order\n\ncompound terms\n    first by arity, then by functor name, then by the\n    arguments in left to right order.\n\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. when comparing numbers\n   of different types, the result is not necessarily their numerical order.\n\nModes and Determinism\n   compare(-, ?, ?) is det\n\nExamples\n   \n   Success:\n   compare(X, A, a), X = '<'.\n   compare(X, a, A), X = '>'.\n   compare('<', a(1,2), b(1,2)).\n   compare(X, 1, 1), X = '='.\n   compare(X, f(1), f(1)), X = '='.\n   compare('<', 3.0, 2).    % not arithmetic order!\n   compare('>', [a,b], [a|b]).\n   compare('>', [a,b], [a|X]).\n   Fail:\n   compare('<', atomb, atoma).\n   compare('=', 0, 1).\n   compare('>',1.0,1).\n\nSee Also\n   @> / 2, @< / 2, @=< / 2, @>= / 2"},"current_domain/3":{"prefix":"current_domain","body":"current_domain(${1:Name}, ${2:DefModule}, ${3:DomainDef})$4\n$0","description":"current_domain(?Name, -DefModule, -DomainDef)\n\n   Name is the name of a visible domain, defined by DomainDef in DefModule\n\nArguments\n   Name    Atom or variable\n   DefModule    Variable or atom (module)\n   DomainDef    Usually variable, will be bound to a ground structure\n\nType\n   Comparing and Sorting\n\nDescription\n\n\tUsed to look up a domain definition, or to enumerate all domain\n\tdefinitions visible in the caller module. Visible domain definitions\n\tare those which have been either declared locally, or exported,\n\tor which have been imported or reexported from another module.\n\t\n\tDefModule is the module where the domain was declared local or\n\texported. DomainDef is the structure which was specified in the\n\toriginal domain definition.\n\t\n\nModes and Determinism\n   current_domain(+, -, -) is semidet\n   current_domain(-, -, -) is nondet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   No visible domain name unifies with Name\n\nExamples\n   \n    :- local domain(colour(red,green,blue)).\n\n    :- export domain(vowel(a,e,i,o,u)).\n\n    :- local domain(abc(a,b,c)).\n    Domain value a not unique in module eclipse\n    out of range in local domain(abc(a, b, c))\n    Abort\n\n    ?- current_domain(Name, DefModule, Def).\n    Name = colour\n    DefModule = eclipse\n    Def = colour(red, green, blue)\n    More (0.00s cpu) ? ;\n\n    Name = vowel\n    DefModule = eclipse\n    Def = vowel(a, e, i, o, u)\n    More (0.00s cpu) ? ;\n\n    No (0.00s cpu)\n\n    ?- current_domain(vowel, DefModule, Def).\n    Name = vowel\n    DefModule = eclipse\n    Def = vowel(a, e, i, o, u)\n    Yes (0.00s cpu)\n\n    ?- current_domain(abc, DefModule, Def).\n    No (0.00s cpu)\n    \n\nSee Also\n   domain / 1, domain_index / 3"},"compare_instances/3":{"prefix":"compare_instances","body":"compare_instances(${1:Relationship}, ${2:Term1}, ${3:Term2})$4\n$0","description":"compare_instances(-Relationship, ?Term1, ?Term2)\n\n   Succeeds if Relationship is an atom describing the instance relationship\nbetween Term1 and Term2.\n\nArguments\n   Relationship    Variable or one of the atoms '<', '>', '='\n   Term1    An arbitrary term.\n   Term2    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if Relationship is unified with one of the three term\n   relationship symbols indicated by '<', '>', '=' where:\n\n   '<':  Term1 is an instance of Term2.\n\n   '>':  Term2 is an instance of Term1.\n\n   '=':  Term1 is variant of Term2.\n\n   For the definition of instance and variant refer to instance/2 and\n   variant/2, respectively.\n\nModes and Determinism\n   compare_instances(-, ?, ?) is det\n\nFail Conditions\n   Fails if none of the terms is an instance of the other\n\nExamples\n   \n   Success:\n   compare_instances(Rel,X,Y), Rel == '='.\n   compare_instances(=, [a,X], [a,Y]).\n   compare_instances(<, [a,b], [X,Y]).\n   compare_instances(<, [X], [X|Y]).\n   compare_instances(>, X, f(1,1)).\n   compare_instances(<, f(1,1), X).\n   Fail:\n   compare_instances(Rel, f(X), 1).\n   compare_instances(Rel, 1, f(X)).\n   compare_instances(<, X, a).\n\nSee Also\n   instance / 2, variant / 2"},"domain_index/3":{"prefix":"domain_index","body":"domain_index(${1:Value}, ${2:Domain}, ${3:Index})$4\n$0","description":"domain_index(+Value, -Domain, -Index)\n\n   Value is defined in Domain with positional number Index\n\nArguments\n   Value    Atomic term\n   Domain    Variable or structure of the form Module:DomainName\n   Index    Variable or integer starting from 1\n\nType\n   Comparing and Sorting\n\nDescription\n\n\tUsed to look up which domain a particular value belongs to, and\n\twhich numerical index it has within this domain. Only domain definitions\n\twhich are visible in the caller module are taken into account.\n\t\n\tDomain is returned as a pair DefinitionModule:DomainName which\n\tunabiguously identifies the domain definition that contains the value.\n\tIndex is unified with a natural number corresponding to the position\n\tof Value within that domain definition (starting from 1).\n\t\n\nModes and Determinism\n   domain_index(+, -, -) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The value does not occur in any of the visible domain definitions\n\nExceptions\n     4 --- Value is not instantiated\n     5 --- Value is not atomic\n\nExamples\n   \n    :- local domain(colour(red,green,blue)).\n\n    :- export domain(vowel(a,e,i,o,u)).\n\n    :- local domain(abc(a,b,c)).\n    Domain value a not unique in module eclipse\n    out of range in local domain(abc(a, b, c))\n    Abort\n\n    ?- domain_index(green, Domain, Index).\n    Domain = eclipse : colour\n    Index = 2\n    Yes (0.00s cpu)\n\n    ?- domain_index(a, Domain, Index).\n    Domain = eclipse : vowel\n    Index = 1\n    Yes (0.00s cpu)\n\n    ?- domain_index(b, Domain, Index).\n    No (0.00s cpu)\n\n    ?- domain_index(yellow, Domain, Index).\n    No (0.00s cpu)\n    \n\nSee Also\n   domain / 1, current_domain / 3"},"domain/1":{"prefix":"local","body":"local","description":"local domain(++Def)\nexport domain(++Def)\n\n   Define a domain (a set of symbols mapped to natural numbers)\n\nArguments\n   Def    A structure with atomic arguments.\n\nType\n   Comparing and Sorting\n\nDescription\n\n\tThis defines a domain. A domain definition is a ground structure\n\twith atomic arguments. The structure's functor name is taken as\n\tthe name of the domain. The domain name is used e.g. for declaring\n\tdomain variables in lib(ic_symbolic).\n\t\n\tThe structure's arguments are the domain values. A domain value\n\tcan be any atomic term (atom, string, number), but will usually\n\tbe an atom. Domains are ordered, and the argument order in the\n\tdefining structure implies the order of the domain values.\n\tThe domain values are mapped to natural numbers, with the first\n\targument being mapped to 1, the second to 2 and so on.\n\t\n\tAfter having been defined, the mapping can be looked up via the\n\tprimitives domain_index/3 and current_domain/3. Certain libraries\n\t(e.g. lib(ic_symbolic)) use the defined mapping internally.\n\t\n\tDomain definitions can be local or exported. The domain values of\n\tall visible domain definitions within a module must be mutually\n\texclusive, i.e. there must not be any ambiguity as to which domain\n\ta particular value belongs to. The system checks this condition\n\twhenever new domains are defined or imported.\n    \n\nModes and Determinism\n   domain(++) is det\n\nExceptions\n     4 --- Def is not ground\n     5 --- Def is neither variable nor structure\n     5 --- A domain value is not atomic\n     6 --- A domain value is not unique in this module\n    87 --- The domain name is already used locally\n    88 --- The domain name is already used and exported\n    89 --- The domain name is already used by an imported domain\n\nExamples\n   \n    :- local domain(colour(red,green,blue)).\n\n    :- export domain(vowel(a,e,i,o,u)).\n\n    :- local domain(abc(a,b,c)).\n    Domain value a not unique in module eclipse\n    out of range in local domain(abc(a, b, c))\n    Abort\n\n    ?- current_domain(Name, DefModule, Def).\n    Name = colour\n    DefModule = eclipse\n    Def = colour(red, green, blue)\n    More (0.00s cpu) ? ;\n\n    Name = vowel\n    DefModule = eclipse\n    Def = vowel(a, e, i, o, u)\n    More (0.00s cpu) ? ;\n\n    No (0.00s cpu)\n\n    ?- domain_index(blue, Domain, Index).\n    Domain = eclipse : colour\n    Index = 3\n    Yes (0.00s cpu)\n\n    ?- domain_index(o, Domain, Index).\n    Domain = eclipse : vowel\n    Index = 4\n    Yes (0.00s cpu)\n\n    ?- domain_index(yellow, Domain, Index).\n    No (0.00s cpu)\n\nSee Also\n   local / 1, export / 1, current_domain / 3, domain_index / 3, library(ic_symbolic)"},"merge/3":{"prefix":"merge","body":"merge(${1:List1}, ${2:List2}, ${3:List3})$4\n$0","description":"merge(+List1, +List2, -List3)\n\n   Succeeds if List3 is a merged list of List1 and List2.  If both lists are\nsorted, List3 will be sorted.\n\nArguments\n   List1    List.\n   List2    List.\n   List3    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Used to merge the sorted lists List1 and List2 to give the sorted list\n   List3.  merge(L1,L2,L3) is equivalent to merge(0,=<,L1,L2,L3).\n\n   For two lists [e1,e2,e3] and [f1,f2,f3], e1 is compared to f1.  The\n   lower (dictated by the standard ordering below) is put into List3, and\n   the process continued with the remaining input lists.  This process\n   continues until both lists are exhausted.\n\n   In particular, this will merge two sorted lists into a sorted list.\n\n   The sort is done according to the standard ordering of terms.\n   Duplicates are not removed.  See compare/3 for this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\n   merge(A, B, M) is equivalent to merge(0, =<, A, B, M).\n\nModes and Determinism\n   merge(+, +, -) is det\n\nExamples\n   \nSuccess:\n      merge([2,4,6],[1,3,5],L).\n    (gives L=[1,2,3,4,5,6]).\n      merge([f(1),f(7)],[f(8),f(10)],L).\n    (gives L=[f(1),f(7),f(8),f(10)]).\n      merge([f(5),f(8)],[f(1),f(2),f(2),f(5),f(8)],L).\n    (gives L=[f(1),f(2),f(2),f(5),f(5),f(8),f(8)]).\n      merge([a,w],[a,b,b,r,w],L).\n    (gives L=[a,a,b,b,r,w,w]).\n      merge([f(2),f(1)],[f(3),f(8)],L).\n    (gives L=[f(2),f(1),f(3),f(8)]).\n\nFail:\n      merge([2,4,6],[1,3,5],[1,2,3,4,5]).\n\nSee Also\n   compare / 3, merge / 5, msort / 2, number_merge / 3"},"keysort/2":{"prefix":"keysort","body":"keysort(${1:List1}, ${2:List2})$3\n$0","description":"keysort(+List1, -List2)\n\n   Succeeds if List2 is a sorted list version of List1, whose elements are of\nthe form Key-Value.  The sort is done according to the value of the key\nKey.\n\nArguments\n   List1    List of elements of the form Term-Term.\n   List2    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   The elements of List1 are of the form Key-Value, where Key and Value are\n   both arbitrary terms.\n\n   List1 is sorted according to the value of the key Key and the result is\n   unified with List2.  No sorting is carried out on Value.  The sort is\n   stable, i.e. the order of elements with the same key is preserved.\n\n   The sort is done according to the standard ordering of terms.\n   See compare/3 for this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\n   keysort(R, S) is equivalent to sort(1, =<, R, S).\n\nModes and Determinism\n   keysort(+, -) is det\n\nExceptions\n     4 --- List1 is not instantiated.\n     5 --- Either List1 or List2 is instantiated, but not to a list of    the form Term-Term.\n\nExamples\n   \nSuccess:\n      keysort([n-1,4-a],L).     (gives L = [4-a,n-1]]).\n      keysort([f(1)-a,[1]-w,7.2-b,\"k\"-e,n-q],L).\n    (gives L = [7.2-b,\"k\"-e,n-q,f(1)-a,[1]-w]).\n      keysort([f(1,2),g(1)],M). (gives M = [f(1,2),g(1)]).\n      keysort([g(1,2)-a, f(1,2)-a],M).\n    (gives M = [f(1,2)-a,g(1,2)-a]).\n      keysort([f(4,3)-a, f(3,4)-b],M).\n    (gives M = [f(3,4)-b,f(4,3)-a]).\n\nFail:\n      keysort([n-1,M-a],[n-1,M-a]).\n\nError:\n      keysort(L1,L2).    (Error 4).\n      keysort([n-1,m],L).    (Error 5).\n\nSee Also\n   compare / 3, merge / 3, merge / 5, msort / 2, sort / 4, number_sort / 4"},"instance/2":{"prefix":"instance","body":"instance(${1:Instance}, ${2:Term})$3\n$0","description":"instance(?Instance, ?Term)\n\n   Succeeds if Instance is an instance of Term.\n\nArguments\n   Instance    An arbitrary term.\n   Term    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if it is possible to find an instantiation of free variables in\n   Term such that Term and Instance are equal.  The result is undefined if\n   Term and Instance share variables.  Note that no unification actually\n   occurs.\n\n   Attributed variables are handled via the attribute's compare_instances\n   handler.  In particular, domain variables should be handled correctly.\n\nModes and Determinism\n   instance(?, ?) is semidet\n\nFail Conditions\n   Fails if Instance is not an instance of Term.\n\nExamples\n   \n   Success:\n   instance(atom,X).\n   instance(f(a,b),X).\n   instance(f(a,b),f(X,Y)).\n   instance(f(a,X),f(Y,X)).\n   instance(f(a,X),f(X,Y)).\n   instance(f(X,Y),f(Y,X)).\n   instance([a,b,c],[A,B,C]).\n   instance([a,f(1,b,X),Y|Z],T).\n   X::1..5, instance(3,X).\n   X::2..4, Y::1..5, instance(X,Y).\n\n   Fail:\n   instance(f(a,b),f(X,X)).\n   instance(X,a).\n   X::2..4, Y::1..5, instance(Y,X).\n\nSee Also\n   compare_instances / 3, prune_instances / 2, variant / 2"},"merge/5":{"prefix":"merge","body":"merge(${1:Key}, ${2:Order}, ${3:List1}, ${4:List2}, ${5:List3})$6\n$0","description":"merge(+Key, +Order, +List1, +List2, -List3)\n\n   Succeeds if List3 is a merged list of List1 and List2.  If both lists are\nsorted, List3 will be sorted.  The sort is done according to the Key and\nOrder specifications.\n\nArguments\n   Key    A non-negative integer or a list of positive integers.\n   Order    One of the atoms =<, >=, < or >.\n   List1    List.\n   List2    List.\n   List3    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Used to merge the sorted lists List1 and List2 to give the sorted list\n   List3.\n\n   If List1 and List2 are not lists of compound terms, use Key = 0.\n\n   If List1 and List2 are lists of compound terms, then the sort will be\n   according to the Keyth argument of the lists' elements.  If Key = 0,\n   then the sort is on the entire terms.\n\n   For two lists [e1,e2,e3] and [f1,f2,f3], e1 is compared to f1.  The\n   resulting element (dictated by Key, Order and the standard ordering\n   below, with ties being resolved in favour of the element from List1)\n   is put into List3, and the process continued with the remaining input\n   lists.  This process continues until both lists are exhausted.\n\n   In particular, this will merge two sorted lists into a sorted list.  The\n   merge is stable, i.e. the order of elements with the same key is preserved.\n   If List1 and List2 contain elements with identical keys, List1's elements\n   will occur first in List3.\n\n   In all cases where List1 and List2 are sorted, Order specifies whether\n   the lists are sorted into ascending (<, =<) or descending (>, >=) order\n   and whether duplicates are to be retained (=<, >=) or eliminated (<, >).\n   The way to remember the Order argument is that it is the relation which\n   holds between adjacent elements in the result.\n\n   The sort is done according to the standard ordering of terms.\n   See compare/3 for the definition of this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\nModes and Determinism\n   merge(+, +, +, +, -) is det\n\nExceptions\n     5 --- Key is greater than 0, and one of List1 and List2 does not    have all elements compound terms.\n     5 --- Key is not an integer or a list of integers.\n     6 --- One of the compound terms in List1 or List2 has not got as    many as Key arguments.\n\nExamples\n   \nSuccess:\n      merge(0,<,[2,4,6],[1,3,5],L).\n    (gives L=[1,2,3,4,5,6]).\n      merge(0,<,[f(1),f(7)],[f(8),f(10)],L).\n    (gives L=[f(1),f(7),f(8),f(10)]).\n      merge(0,<,[f(2),f(1)],[f(3),f(8)],L).\n    (gives L=[f(2),f(1),f(3),f(8)]).\n      merge(0,<,[f(2)],[f(6),f(1)],L).\n    (gives L=[f(2),f(6),f(1)]).\n      merge(0,>,[1,e,q],[Q,2,a],L).\n    (gives Q=_g60,L=[_g60,1,2,a,e,q]).\n      merge(0,>,[f(8),f(6)],[f(4),f(1)],L).\n    (gives L=[f(8),f(6),f(4),f(1)]).\n      merge(2,<,[f(2,1),f(6,4)],[f(6,3),f(8,6)],L).\n    (gives L=[f(2,1),f(6,3),f(6,4),f(8,6)]).\n      merge(2,<,[q(2,1),f(6,4)],[a(6,3),i(8,6)],L).\n    (gives L=[q(2,1),a(6,3),f(6,4),i(8,6)]).\n      merge(2,<,[f(a,b),f(c,a)],[f(k,a)],L).\n    (gives L=[f(k,a),f(a,b),f(c,a)).\n      merge(0,=<,[1,2],[3,4,4,5],L).\n    (gives L=[1,2,3,4,4,5]).\n      merge([2,1], =<, [f(1,a(1)), f(0,a(3))], [f(3,a(2)), f(1,a(4))], L).\n    (gives L=[f(1,a(1)), f(3,a(2)), f(0,a(3)), f(1,a(4))]).\nFail:\n      merge(0,<,[2,4,6],[1,3,5],[1,2,3,4,5]).\nError:\n      merge(1,<,[f(1,2),f],[f(3,4),h(1,2)],L). (Error 5).\n      merge(0.0,<,[f(1)],[f(2)],L).    (Error 5).\n      merge(2,<,[f(1,2)],[f(8)],L).    (Error 6).\n\nSee Also\n   merge / 3, compare / 3, number_merge / 5"},"msort/2":{"prefix":"msort","body":"msort(${1:List1}, ${2:List2})$3\n$0","description":"msort(+List1, -List2)\n\n   Succeeds if List2 has the same elements as List1 and is sorted.\n\nArguments\n   List1    List.\n   List2    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   List1 is sorted according to standard term ordering, (without\n   removing duplicates in the sense of ==/2) and unified with List2.\n\n   The sort is done according to the standard ordering of terms.\n   Duplicates are not removed.  See compare/3 for this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\nNote\n   msort(L1,L2) is equivalent to sort(0,=<,L1,L2).\n   msort(L1,L2) differs from sort(L1,L2) in that it keeps duplicates.\n\nModes and Determinism\n   msort(+, -) is det\n\nExceptions\n     4 --- List1 is not instantiated.\n     5 --- List1 is not a list.\n\nExamples\n   \nSuccess:\n      msort([3,2,1,2,3],[1,2,2,3,3]).\n      msort([2,4,6],L).    (gives L=[2,4,6]).\n      msort([2,4,6,1,7,3],L).   (gives L=[1,2,3,4,6,7]).\n\nFail:\n      msort([1,5,3,7],[1,3,7,5]).\n\nError:\n      msort(List1,List2).    (Error 4).\n      msort(\"[1]\",L).    (Error 5).\n\nSee Also\n   compare / 3, sort / 2, sort / 4, number_sort / 2"},"not_unify/2":{"prefix":"not_unify","body":"not_unify(${1:Term1}, ${2:Term2})$3\n$0","description":"not_unify(?Term1, ?Term2)\n\n   Succeeds if Term1 and Term2 are not unifiable.\n\nArguments\n   Term1    An arbitrary term.\n   Term2    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if Term1 and Term2 are not unifiable.  This predicate differs\n   from \\=/2 only if attributed variables are involved (e.g. with delayed goals or\n   constraints).  While \\=/2 does unification, waking of delayed goals and\n   full constraint propagation to determine unifiability, not_unify/2 uses\n   the test_unify-handler for this purpose.  not_unify/2 is therefore\n   likely to be cheaper, but possibly less precise (depending on the\n   test_unify-handler) than \\=/2.\n\nModes and Determinism\n   not_unify(?, ?) is semidet\n\nFail Conditions\n   Fails if Term1 and Term2 can be unified.\n\nExamples\n   \nSuccess:\n   not_unify(atom, neutron).\n   not_unify(1.0, 1).\nFail:\n   not_unify(X, Y).\n   not_unify(X, 1).\nNote the difference:\n   coroutine, X > 1, X \\= 1.\n       % succeeds because the delayed goal X>1 is\n       % taken into account\n   coroutine, X > 1, not_unify(X, 1).\n       % fails because the delayed goal X>1 is\n       % ignored by the test_unify handler\n\nSee Also\n   = / 2, \\= / 2, \\== / 2, meta_attribute / 2"},"number_merge/3":{"prefix":"number_merge","body":"number_merge(${1:List1}, ${2:List2}, ${3:List3})$4\n$0","description":"number_merge(+List1, +List2, -List3)\n\n   Succeeds if List3 is a merged list of List1 and List2.  If both lists are\nsorted, List3 will be sorted.\n\nArguments\n   List1    List of numeric terms.\n   List2    List of numeric terms.\n   List3    List of numeric terms or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Used to merge the sorted lists List1 and List2 to give the sorted list\n   List3.  number_merge(L1,L2,L3) is equivalent to number_merge(0,=<,L1,L2,L3).\n\n   For two lists [e1,e2,e3] and [f1,f2,f3], e1 is compared to f1.  The\n   lower (dictated by numerical ordering) is put into List3, and the\n   process continued with the remaining input lists.  This process\n   continues until both lists are exhausted.\n\n   In particular, this will merge two sorted lists into a sorted list.\n\n   The sort is done according to numerical ordering of terms as opposed to\n   merge/3 which uses the standard ordering of terms. Duplicates are\n   not removed. See number_sort/4 for a discussion of the differences\n   between numerical and standard ordering of numeric types.\n\n   number_merge(A, B, M) is equivalent to number_merge(0, =<, A, B, M).\n\nModes and Determinism\n   number_merge(+, +, -) is det\n\nExamples\n   \nSuccess:\n      number_merge([2,4,6],[1,3,5],L).\n    (gives L=[1,2,3,4,5,6]).\n      number_merge([f(1),f(7)],[f(8),f(10)],L).\n    (gives L=[f(1),f(7),f(8),f(10)]).\n      number_merge([f(5),f(8)],[f(1),f(2),f(2),f(5),f(8)],L).\n    (gives L=[f(1),f(2),f(2),f(5),f(5),f(8),f(8)]).\n      number_merge([a,w],[a,b,b,r,w],L).\n    (gives L=[a,a,b,b,r,w,w]).\n      number_merge([f(2),f(1)],[f(3),f(8)],L).\n    (gives L=[f(2),f(1),f(3),f(8)]).\n\nFail:\n      number_merge([2,4,6],[1,3,5],[1,2,3,4,5]).\n\nSee Also\n   merge / 3, merge / 5, number_merge / 5"},"number_sort/2":{"prefix":"number_sort","body":"number_sort(${1:List1}, ${2:List2})$3\n$0","description":"number_sort(+List1, -List2)\n\n   Succeeds if List2 is the numerically ordered version of List1.\n\nArguments\n   List1    List of numeric terms.\n   List2    List of numeric terms or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   List1 is sorted according to numerical ordering, and unified with List2.\n\n   The sort is done according to numerical ordering and duplicates are\n   retained as opposed to sort/2 which uses the standard ordering of\n   terms and removes duplicates. See number_sort/4 for a discussion of\n   the differences between numerical and standard ordering of numeric types.\n\nNote\n   number_sort(L1,L2) is equivalent to number_sort(0,=<,L1,L2).\n\nModes and Determinism\n   number_sort(+, -) is det\n\nExamples\n   \nSuccess:\n      sort([3,1,6,7,2],S).     (gives S=[1,2,3,6,7]).\n      sort([1,3,2,3,4,1],S).   (gives S=[1,1,2,3,3,4]).\nFail:\n      sort([2,1,3,4],[2,1,3,4]).\n\nSee Also\n   number_sort / 4, sort / 2, sort / 4"},"number_merge/5":{"prefix":"number_merge","body":"number_merge(${1:Key}, ${2:Order}, ${3:List1}, ${4:List2}, ${5:List3})$6\n$0","description":"number_merge(+Key, +Order, +List1, +List2, -List3)\n\n   Succeeds if List3 is a merged list of List1 and List2.  If both lists are\nsorted, List3 will be sorted.  The sort is done according to the Key and\nOrder specifications.\n\nArguments\n   Key    A non-negative integer or a list of positive integers.\n   Order    One of the atoms =<, >=, < or >.\n   List1    List.\n   List2    List.\n   List3    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Used to merge the sorted lists List1 and List2 to give the sorted list\n   List3.\n\n   If List1 and List2 are not lists of compound terms, use Key = 0.\n\n   If List1 and List2 are lists of compound terms, then the sort will be\n   according to the Keyth argument of the lists' elements. The Keyth\n   argument of the list elements must be a numeric term.\n\n   For two lists [e1,e2,e3] and [f1,f2,f3], e1 is compared to f1.  The\n   resulting element (dictated by Key, Order and numerical ordering,\n   with ties being resolved in favour of the element from List1)\n   is put into List3, and the process continued with the remaining input\n   lists.  This process continues until both lists are exhausted.\n\n   In particular, this will merge two sorted lists into a sorted list.  The\n   merge is stable, i.e. the order of elements with the same key is preserved.\n   If List1 and List2 contains elements with identical keys, List1's elements\n   will occur first in List3.\n\n   In all cases where List1 and List2 are sorted, Order specifies whether\n   the lists are sorted into ascending (<, =<) or descending (>, >=) order\n   and whether duplicates are to be retained (=<, >=) or eliminated (<, >).\n   The way to remember the Order argument is that it is the relation which\n   holds between adjacent elements in the result.\n\n   The sort is done according to numerical ordering of terms as opposed to\n   merge/5 which uses the standard ordering of terms. See\n   number_sort/4 for a discussion of the differences between numerical\n   and standard ordering of numeric types.\n\nModes and Determinism\n   number_merge(+, +, +, +, -) is det\n\nExceptions\n     5 --- Key is greater than 0, and one of List1 and List2 does not    have all elements compound terms.\n     5 --- Key is not an integer or a list of integers.\n     6 --- One of the compound terms in List1 or List2 has not got as    many as Key arguments.\n\nExamples\n   \nSuccess:\n      number_merge(0,<,[2,4,6],[1,3,5],L).\n    (gives L=[1,2,3,4,5,6]).\n      number_merge(1,>,[f(8),f(6)],[f(4),f(1)],L).\n    (gives L=[f(8),f(6),f(4),f(1)]).\n      number_merge(2,<,[f(2,1),f(6,4)],[f(6,3),f(8,6)],L).\n    (gives L=[f(2,1),f(6,3),f(6,4),f(8,6)]).\n      number_merge(2,<,[q(2,1),f(6,4)],[a(6,3),i(8,6)],L).\n    (gives L=[q(2,1),a(6,3),f(6,4),i(8,6)]).\n      number_merge(0,=<,[1,2],[3,4,4,5],L).\n    (gives L=[1,2,3,4,4,5]).\n      number_merge([2,1], =<, [f(1,a(1)), f(0,a(3))], [f(3,a(2)), f(1,a(4))], L).\n    (gives L=[f(1,a(1)), f(3,a(2)), f(0,a(3)), f(1,a(4))]).\nFail:\n      number_merge(0,<,[2,4,6],[1,3,5],[1,2,3,4,5]).\nError:\n      number_merge(0,>,[1],[Q,2],L).    (Error 4).\n      number_merge(1,<,[f(1,2),f],[f(3,4),h(1,2)],L). (Error 5).\n      number_merge(0.0,<,[f(1)],[f(2)],L).    (Error 5).\n      number_merge(0,<,[f(1),f(7)],[f(8),f(10)],L).   (Error 5).\n      number_merge(0,>,[1,e,q],[2],L).    (Error 5).\n      number_merge(2,<,[f(1,2)],[f(8)],L).    (Error 6).\n\nSee Also\n   merge / 3, merge / 5, number_merge / 3"},"number_sort/4":{"prefix":"number_sort","body":"number_sort(${1:Key}, ${2:Order}, ${3:Random}, ${4:Sorted})$5\n$0","description":"number_sort(+Key, +Order, +Random, -Sorted)\n\n   Succeeds if Sorted is the numerically sorted list\n\tversion of Random.  The sort is done according to the Key and\n\tOrder specifications.\n\nArguments\n   Key    A non-negative integer or a list of positive integers.\n   Order    One of the atoms <, =<, > or >=.\n   Random    List.\n   Sorted    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Sorts the list Random according to the Key and Order specifications,\n   and unifies Sorted with the result.  The sort is stable, i.e. the\n   order of elements with the same key is preserved.\n\n   If Random is not a list of compound terms, use Key = 0. The list\n   elements must be numerical terms.\n\n   If Random is a list of compound terms, then the sort will be according\n   to the Keyth argument of the list elements. The Keyth argument of each\n   list element must be a numeric term.\n\n   In all cases, Order specifies whether the list is sorted into ascending\n   (<, =<) or descending (>, >=) order and whether duplicates are to be\n   retained (=<, >=) or eliminated (<, >).  The way to remember the Order\n   argument is that it is the relation which holds between adjacent\n   elements in the result.\n\n   The sort is done according to numerical ordering as opposed to\n   sort/4 which uses the standard ordering of terms. See compare/3 for \n   this standard ordering. In particular for numeric terms of\n   different type, e.g. integers and floats, the numerical and\n   standard orderings differ: 1 < 2.0 but 2.0 @< 1. Additionally\n   the ordering of bounded reals differs. While the standard ordering\n   treats a bounded real as a compound term and orders them by lower\n   bound and then upper bound, numerical ordering treats them as true\n   intervals. As a consequence the order of overlapping intervals is\n   undefined: 1.0__1.1 @< 1.0__1.2 while no numerical order is\n   defined. In such cases an arithmetic exception is thrown. This can\n   have unexpected consequences: care must be taken when  sorting a\n   list containing both rationals and bounded reals. While integers\n   and floats are converted to zero-width intervals for the purposes\n   of comparison, rationals are converted to small intervals\n   guaranteed to contain the rational, e.g X is breal(1_1) gives\n   X=0.99999999999999989__1.0000000000000002 and thus no order is\n   defined between 1_1 and 1.0__1.0.\n\nModes and Determinism\n   number_sort(+, +, +, -) is det\n\nExceptions\n     4 --- One of List1 and List2 has an element whose Keyth argument is a variable\n     5 --- Key is greater than 0, and one of List1 and List2 has an element whose Keyth argument is a non-numeric term\n     5 --- Key is greater than 0, and one of List1 and List2 does not    have all elements compound terms.\n     5 --- Key is not an integer or a list of integers.\n     6 --- One of the compound terms in List1 or List2 has not got as    many as Key arguments.\n    20 --- One of List1 and List2 has elements whose numerical order is undefined.\n\nExamples\n   \nSuccess:\n      number_sort(0,<,[3,1,6,7,2],S).    (gives S=[1,2,3,6,7]).\n      number_sort(0,=<,[1,1.0,1_1,3,2,3,4,1],S).\n\t\t\t   (gives S=[1,1.0,1_1,1,2,3,3,4]).\n      number_sort(0,=<,[1,1.0,1.0__1.0,3,2,3,4,1],S).\n\t\t\t   (gives S=[1,1.0,1.0__1.0,1,2,3,3,4]).\n      number_sort(2,<,[f(a,3),h(b,1)],S).    (gives S=[h(2,1),f(1,3)]).\n      number_sort([2,1],=<,[f(3,a(2)),f(1,a(1)),f(0,a(3)),f(1,a(4))],S).\n    (gives S=[f(1,a(1)),f(3,a(2)),f(0,a(3)),f(1,a(4))]).\n\nFail:\n      number_sort(0,<,[2,1,3,4],[2,1,3,4]).\n\nError:\n      number_sort(0,>,[1,3,N],S).    (Error 4).\n      number_sort(0,>,[q,1,3,a,e],S).    (Error 5).\n      number_sort(1,<,[f(1),f(3),5],S).    (Error 5).\n      number_sort(1.0,<,[f(1),f(3),f(5)],S).   (Error 5).\n      number_sort(1,<,[f(a,3),h(b,1)],S).      (Error 5).\n      number_sort(2,<,[f(1,2),g(3,1),f(5)],S). (Error 6).\n      number_sort(0,<,[1,0.9__1.1],S).    (Error 20).\n      number_sort(0,=<,[1_1,1.0__1.0],S).      (Error 20).\n\nSee Also\n   compare / 3, number_sort / 2, sort / 2, sort / 4"},"prune_instances/2":{"prefix":"prune_instances","body":"prune_instances(${1:List}, ${2:PrunedList})$3\n$0","description":"prune_instances(+List, -PrunedList)\n\n   Succeeds if PrunedList is the smallest list that subsumes the list List.\n\nArguments\n   List    List of instantiated terms.\n   PrunedList    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Used to get the smallest list PrunedList whose elements subsume elements\n   of the list List.  List must not contain variables.  If List contains\n   elements which are variants of each other, then of these, PrunedList\n   will only contain the first element found.  If List contains element(s)\n   which are instances of another element, then of these, PrunedList will\n   only contain the latter.\n\n   Note that if List contains only ground terms, it cannot contain proper\n   instances or variants, but only duplicates.  Therefore, it is faster to\n   use a sorting predicate to prune it.\n\nModes and Determinism\n   prune_instances(+, -) is det\n\nExamples\n   \nSuccess:\n      prune_instances([5,2,3,5,4,2],L).\n    (gives L=[5,2,3,4]).\n      prune_instances([f(1,2),f(1,M),1],L).    % instance\n    (gives M=_g74,L=[f(1,_g74),1]).\n      prune_instances([f(1,2,3),f(1,M,3),f(1,2,N)],L).\n    (gives M=_g80,N=_g70, L=[f(1,_g80,3),f(1,2,_g70)]).\n      prune_instances([f(1,N),f(1,M),1],L).    % variants\n    (gives N=_g72,M=_g76, L=[f(1,_g72),1]).\n      prune_instances([f(1,X),f(1,2),g(1)],L).\n    (gives X=_g80; L=[f(1,_g80),g(1)]).\nFail:\n      prune_instances([1,2,3,1,4,2],[2,3,4]).\n\nSee Also\n   sort / 2, sort / 4"},"occurs/2":{"prefix":"occurs","body":"occurs(${1:Simple}, ${2:Term})$3\n$0","description":"occurs(?Simple, ?Term)\n\n   Succeeds if Simple is a variable or an atomic type that occurs in the term\nTerm.\n\nArguments\n   Simple    Variable or atomic type.\n   Term    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if Simple is a variable, an atom or a number occurring in the\n   term Term.\n\nModes and Determinism\n   occurs(?, ?) is semidet\n\nFail Conditions\n   Fails if Simple does not occur in the term Term.\n\nExceptions\n     5 --- If Simple is neither a variable, an atom nor a number.\n\nExamples\n   \n   Success:\n   occurs(a,a).\n   occurs(X,f(a,b,c,X)).\n   occurs(+,f(+,-)).\n   occurs(a,[b,c,a,g,a]).\n   occurs([ ],[a,b]).\n   occurs(1,[A|1]).\n   occurs(1.0,[1.0|B]).\n   Fail:\n   occurs(a,b).\n   occurs(X,f(Y,Z)).\n   occurs(X,Y).\n   occurs(1,\"2314\").\n   occurs([], [a,b|c]).\n   Error:\n   occurs(\"str\",f(\"str1\",\"str2\",\"str\")). (Error 5)\n   occurs([a],[a,b]).    (Error 5)\n   occurs(f(a,b),f(a,b)).    (Error 5)\n\nSee Also\n   instance / 2, variant / 2"},"term_hash/4":{"prefix":"term_hash","body":"term_hash(${1:Term}, ${2:Depth}, ${3:Range}, ${4:Hash})$5\n$0","description":"term_hash(?Term, +Depth, +Range, -Hash)\n\n   Computes a hash value for an arbitrary term\n\nArguments\n   Term    An arbitrary term\n   Depth    An integer\n   Range    An integer\n   Hash    A variable or an integer\n\nType\n   Comparing and Sorting\n\nDescription\n    This predicate attempts to computes a hash value for an arbitrary term.\n    The computed hash value lies between 0 and Range-1.\n\n    The Depth argument specifies the nesting depth of the term up to\n    which the term's components are taken into account for the\n    computation of the hash value.  More deeply nested parts of the\n    term will be ignored.  If the term contains uninstantiated parts in\n    the portion up to Depth, no reliable hash value can be computed\n    and the predicate succeeds, leaving Hash uninstantiated.  If Depth\n    is set to -1, the whole depth of the term will be used for computing\n    the hash value.  If Depth is set to 0, the hash value will be 0.\n    The main functor of a term is taken to be at depth 1, its arguments\n    at depth 2 etc.\n\nModes and Determinism\n   term_hash(?, +, +, -) is det\n\nExceptions\n     4 --- Depth or Range are not instantiated\n     5 --- Depth or Range are not integers\n\nExamples\n   \nSuccess:\n    [eclipse 1]: term_hash(hello, 1, 100, H).\n    H = 4\n    yes.\n\n    [eclipse 2]: term_hash(world, 1, 100, H).\n    H = 84\n    yes.\n\n    [eclipse 15]: term_hash(foo(bar,3,4.5), -1, 100, H).\n    H = 40\n    yes.\n\n    [eclipse 15]: term_hash(foo(bar,3,4.5), 1, 100, H).\n    H = 72\n    yes.\n\n    [eclipse 18]: term_hash(foo(X,3,4.5), 1, 100, H).\n    X = X\n    H = 72\n    yes.\n\n    [eclipse 19]: term_hash(foo(X,3,4.5), 2, 100, H).\n    X = X\n    H = H\n    yes.\n\nSee Also\n   hash : hash_create / 1, dim / 2"},"sort/2":{"prefix":"sort","body":"sort(${1:List1}, ${2:List2})$3\n$0","description":"sort(+List1, -List2)\n\n   Succeeds if List2 is the strictly ordered, no duplicates version of List1.\n\nArguments\n   List1    List.\n   List2    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   List1 is sorted strictly according to standard term ordering\n   (removing duplicates in the sense of ==/2), and unified with List2.\n\n   The sort is done according to the standard ordering of terms.\n   See compare/3 for this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\nNote\n   sort(L1,L2) is equivalent to sort(0,<,L1,L2).\n   sort(L1,L2) differs from msort(L1,L2) in that it removes duplicates.\n\nModes and Determinism\n   sort(+, -) is det\n\nExamples\n   \nSuccess:\n      sort([3,1,6,7,2],S).     (gives S=[1,2,3,6,7]).\n      sort([1,3,2,3,4,1],S).   (gives S=[1,2,3,4]).\n      sort([f(1,3),h(2,1)],S). (gives S=[f(1,3),h(2,1)]).\n      sort([\"b\",2.0,a(1),1,a],S).\n    (gives S=[2.0,1,\"b\",a,a(1)]).\nFail:\n      sort([2,1,3,4],[2,1,3,4]).\n\nSee Also\n   compare / 3, msort / 2, sort / 4, number_sort / 2"},"sort/4":{"prefix":"sort","body":"sort(${1:Key}, ${2:Order}, ${3:Random}, ${4:Sorted})$5\n$0","description":"sort(+Key, +Order, +Random, -Sorted)\n\n   Succeeds if Sorted is the sorted list version of Random.  The sort is done\naccording to the Key and Order specifications.\n\nArguments\n   Key    A non-negative integer or a list of positive integers.\n   Order    One of the atoms <, =<, > or >=.\n   Random    List.\n   Sorted    List or variable.\n\nType\n   Comparing and Sorting\n\nDescription\n   Sorts the list Random according to the Key and Order specifications, and\n   unifies Sorted with the result.  The sort is stable, i.e. the order of\n   elements with the same key is preserved.\n\n   If Random is not a list of compound terms, use Key = 0.\n\n   If Random is a list of compound terms, then the sort will be according\n   to the Keyth argument of the list elements.  If Key = 0, then the sort\n   is on the entire terms.\n\n   In all cases, Order specifies whether the list is sorted into ascending\n   (<, =<) or descending (>, >=) order and whether duplicates are to be\n   retained (=<, >=) or eliminated (<, >).  The way to remember the Order\n   argument is that it is the relation which holds between adjacent\n   elements in the result.\n\n   The sort is done according to the standard ordering of terms.\n   See compare/3 for the definition of this standard ordering.\n   Note in particular that numbers are first ordered by their type (integer,\n   float, etc) and only then by their magnitude, i.e. sorting numbers of\n   different types may not give the expected result.\n\nModes and Determinism\n   sort(+, +, +, -) is det\n\nExceptions\n     5 --- Key is greater than 0, and one of List1 and List2 does not    have all elements compound terms.\n     5 --- Key is not an integer or a list of integers.\n     6 --- One of the compound terms in List1 or List2 has not got as    many as Key arguments.\n\nExamples\n   \nSuccess:\n      sort(0,<,[3,1,6,7,2],S).     (gives S=[1,2,3,6,7]).\n      sort(0,>,[q,1,3,a,e,N],S).\n    (gives N=_g78,S=[q,e,a,3,1,_g78]).\n      sort(0,=<,[1,3,2,3,4,1],S).  (gives S=[1,1,2,3,3,4]).\n      sort(2,<,[f(1,3),h(2,1)],S). (gives S=[h(2,1),f(1,3)]).\n      sort(1,<,[f(1,3),h(2,1)],S). (gives S=[f(1,3),h(2,1)]).\n      sort([2,1],=<,[f(3,a(2)),f(1,a(1)),f(0,a(3)),f(1,a(4))],S).\n    (gives S=[f(1,a(1)),f(3,a(2)),f(0,a(3)),f(1,a(4))]).\n\nFail:\n      sort(0,<,[2,1,3,4],[2,1,3,4]).\n\nError:\n      sort(1,<,[f(1),f(3),5],S).    (Error 5).\n      sort(1.0,<,[f(1),f(3),f(5)],S).   (Error 5).\n      sort(2,<,[f(1,2),g(3,a),f(5)],S). (Error 6).\n\nSee Also\n   compare / 3, msort / 2, sort / 2, number_sort / 4"},"variant/2":{"prefix":"variant","body":"variant(${1:Term1}, ${2:Term2})$3\n$0","description":"variant(?Term1, ?Term2)\n\n   Succeeds if Term1 is a variant of Term2.\n\nArguments\n   Term1    An arbitrary term.\n   Term2    An arbitrary term.\n\nType\n   Comparing and Sorting\n\nDescription\n   Succeeds if the given terms are equal in the sense that all\n   ground instantiations in Term1 are also instantiations in Term2 and vice\n   versa.  The result is undefined if Term1 and Term2 share variables.  No\n   unification is performed.\n\n   Attributed variables are handled via the attribute's compare_instances\n   handler.  In particular, domain variables should be handled correctly.\n\nModes and Determinism\n   variant(?, ?) is semidet\n\nFail Conditions\n   Fails if Term1 is not a variant of Term2.\n\nExamples\n   \n   Success:\n   variant(1,1).\n   variant(X,Y).\n   variant(f(a,b),f(a,b)).\n   variant(f(a,X),f(a,Y)).\n   variant(f(X,Y),f(Y,X)).\n   variant([X,2], [Y,2]).\n   [X,Y]::2..4, variant(X,Y).\n\n   Fail:\n   variant(f(a,b),f(a,Y)).\n   variant(f(a,X),f(a,b)).\n   variant(f(X,Y),f(Z,Z)).\n   X::2..4, Y::1..5, variant(X,Y).\n\nSee Also\n   instance / 2, compare_instances / 3, prune_instances / 2"},"C/3":{"prefix":"C","body":"C(${1:Input}, ${2:Token}, ${3:Rest})$4\n$0","description":"C(?Input, ?Token, ?Rest)\n\n   Specifies how DCG grammar rules get a token from their input.\n\nArguments\n   Input    A List or a variable.\n   Token    A term or a variable.\n   Rest    A List or a variable.\n\nType\n   Term Manipulation\n\nDescription\n   This predicate is only useful in connection with definite clause grammar\n   rules (DCG). There is a global default definition of 'C'/3 which\n   consists of the single clause 'C'([Token|Rest], Token, Rest).  The Input\n   argument represents the parsing input before consuming Token and Rest is\n   the input after consuming Token.\n\n   DCGs normally operate on lists of tokens.  However, by redefining 'C'/3,\n   it is possible to let them manipulate other data structures.  The\n   example shows how to parse directly from an I/O stream.\n\nModes and Determinism\n   C(+, -, -) is semidet\n   C(-, +, +) is det\n\nFail Conditions\n   Fails if Input is not a non-empty list\n\nExamples\n   \n[eclipse 1]: [user].\n sentence --> noun, [is], adjective.\n noun --> [prolog] ; [lisp].\n adjective --> [boring] ; [great].\nuser       compiled traceable 560 bytes in 0.05 seconds\n\nyes.\n[eclipse 2]: phrase(sentence, [prolog,is,great], []).\n\nyes.\n[eclipse 3]: [user].\n:- local 'C'/3.       % to avoid a redefinition warning\n'C'(Stream-Pos0, Token, Stream-Pos1) :-\n    seek(Stream, Pos0),\n    read_string(Stream, \" \", _, TokenString),\n    atom_string(Token, TokenString),\n    at(Stream, Pos1).\nuser       compiled traceable 308 bytes in 0.00 seconds\n\nyes.\n[eclipse 4]: open(string(\"prolog is great\"), read, S),\n    phrase(sentence, S-0, S-End).\nS = 9\nEnd = 15     More? (;)\nyes.\n\nSee Also\n   phrase / 3"},"add_attribute/3":{"prefix":"add_attribute","body":"add_attribute(${1:Var}, ${2:Attribute}, ${3:AttrName})$4\n$0","description":"add_attribute(?Var, ?Attribute, +AttrName)\n\n   Add dynamically an attribute to a variable.\n\nArguments\n   Var    Any term.\n   Attribute    Any term.\n   AttrName    Integer or atom.\n\nType\n   Term Manipulation\n\nDescription\n   Adds an attribute with name AttrName and value Attribute to a variable.\n   There must have been a preceding attribute declaration (meta_attribute/2)\n   for AttrName.\n\n   If Var is a free variable, it will be turned into an attributed variable\n   with a single attribute Attribute whose name is AttrName.\n   If Var is already an attributed variable with other attributes,\n   then the new attribute will be added to it.\n\n   Otherwise, if the attribute slot for AttrName is already occupied, or\n   Var is already instantiated, then a new attributed variable with the\n   single attribute Attribute is created, and subsequently unified with Var.\n\n   If AttrName is an atom, the attribute corresponds to a previous\n   meta_attribute declaration.  If AttrName is an integer, it is directly\n   used as an attribute index slot (this is mainly used by the compiler to\n   resolve attribute references at compile time).\n\nModes and Determinism\n   add_attribute(?, ?, +) is semidet\n\nFail Conditions\n   Fails if Var is not a free variable and its unification with the new attributed variable fails\n\nExceptions\n   270 --- There is no attribute declared as AttrName.\n     6 --- AttrName is an integer, but not a valid attribute index\n\nExamples\n   \n[eclipse 6]: meta_attribute(extra, []).\n\nyes.\n[eclipse 3]: add_attribute(X, a, extra), printf(\"%QPMw\", X).\nX{suspend : _g270 , extra : a}\nX = X\nyes\n\nSee Also\n   meta_attribute / 2, add_attribute / 2"},"arg/3":{"prefix":"arg","body":"arg(${1:N}, ${2:Term}, ${3:Arg})$4\n$0","description":"arg(+N, +Term, -Arg)\n\n   Succeeds if Arg is the Nth argument of the compound term Term.\n\nArguments\n   N    Integer not greater than the arity of Term, or a list.\n   Term    Compound term.\n   Arg    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   If Term is a structure, unifies Arg with the Nth argument of a structure\n   Term.\n\n   If Term is a list (N must be either the integer 1 (for the head) or 2\n   (for the tail), unifies Arg with the head or tail of the list.  This is\n   a consequence of the fact that ./2 is the list functor and\n   .(a,.(b,.(c,[]))) is the same as [a,b,c].\n\n   If N is a list of integers and Term is a nested structure, then Arg\n   is the subterm of Term described by this list of integers.\n   E.g. arg([2,1,3], Term, Arg) is the same as arg(2, Term, T1),\n   arg(1, T1, T2), arg(3, T2, Arg).\n\nModes and Determinism\n   arg(+, +, -) is det\n\nExceptions\n     4 --- Either N or Term (or both) is not instantiated    (non-coroutine mode only).\n     5 --- N is instantiated, but not to an integer or list of integers.\n     5 --- Term is instantiated, but not to a compound term.\n     6 --- N is an integer less than 1 or greater than the arity of    Term.\n\nExamples\n   \nSuccess:\n      arg(2,foo(boo,moo),moo).\n      arg(2,.(a,b,c),b).\n      arg(2,.(a,b),b).\n      arg(2,term1(term2(a,b),c),c).\n      arg(2,f(a,f(a,b)),f(X,Y)).    (gives X=a; Y=b).\n      arg(2,[a,b,c],[b,c]).\n      arg(2,.(a,.(b,.(c,[]))),[b,c]).\n      arg(2,[1],[]).\n      arg([2,1], f(a,g(b,c)), X).       (gives X=b).\nFail:\n      arg(2,f(a,f(a,b)),f(X,X)).\nError:\n      arg(N,f(1,2),1).    (Error 4).\n      arg(N,[],X),    (Error 5).\n      arg(0,foo(boo,moo),moo). (Error 6).\n      arg(3,foo(boo,moo),moo). (Error 6).\n\nSee Also\n   arity / 2, functor / 3, =.. / 2, subscript / 3"},"add_attribute/2":{"prefix":"add_attribute","body":"add_attribute(${1:Var}, ${2:Attribute})$3\n$0","description":"add_attribute(?Var, ?Attribute)\n\n   Add dynamically an attribute to a variable\n\nArguments\n   Var    Any term.\n   Attribute    Any term.\n\nType\n   Term Manipulation\n\nDescription\n   Adds an attribute to a variable.  The attribute name is taken as the name\n   of the context module.  There must have been an attribute declaration\n   (meta_attribute/2) with the same name as the context module.\n\n   If Var is a free variable, it will be turned into an attributed variable\n   with a single attribute Attribute whose name is the name of the context\n   module.  If Var is already an attributed variable with other attributes,\n   then the new attribute will be added to it.\n\n   Otherwise, if the attribute slot is already occupied, or Var is already\n   instantiated, then a new attributed variable with the single attribute\n   Attribute is created, and subsequently unified with Var.\n\n   Use add_attribute/3 to add an explicitly named attribute.\n\nModes and Determinism\n   add_attribute(?, ?) is semidet\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if Var is not a free variable and its unification with the new attributed variable fails\n\nExceptions\n   270 --- There is no attribute declared in the context module.\n\nExamples\n   \n[eclipse 6]: meta_attribute(eclipse, []).\n\nyes.\n[eclipse 3]: add_attribute(X, a), printf(\"%QPMw\", X).\nX{suspend : _g270 , a}\nX = X\nyes\n\nSee Also\n   meta_attribute / 2, add_attribute / 3"},"array_list/2":{"prefix":"array_list","body":"array_list(${1:Array}, ${2:List})$3\n$0","description":"array_list(?Array, ?List)\n\n   Conversion between array and list\n\nArguments\n   Array    Array, i.e. structure with functor []/?, or variable\n   List    List, or variable\n\nType\n   Term Manipulation\n\nDescription\n   Converts lists to arrays and vice versa.  The behaviour is identical to\n\n    array_list(A, L) :- A =.. [[]|L].\n\n   except for error handling.\n\n   The elements in the Array and List are identical and in the same order.\n\nModes and Determinism\n   array_list(+, -) is det\n   array_list(-, +) is det\n\nExceptions\n     4 --- Both Array and List are variables (non-coroutining mode only)\n     5 --- Array is not an array, or List is not a list\n\nExamples\n   \n?- array_list([](a,b,c,d,e,f), L).\nL = [a,b,c,d,e,f]\n\n?- array_list(A, [a,b,c,d,e,f]),\nA = [](a,b,c,d,e,f)\n\n?- array_list([], L).\nL = []\n\n?- array_list(A, []),\nA = []\n\n?- array_list([]([](a,b),[](c,d)), L).\nL = [ [](a,b), [](c,d) ]\n\nSee Also\n   dim / 2, subscript / 3, array_concat / 3, is_array / 1, array_flat / 3, arg / 3"},"array_concat/3":{"prefix":"array_concat","body":"array_concat(${1:Front}, ${2:Back}, ${3:Concat})$4\n$0","description":"array_concat(+Front, +Back, -Concat)\n\n   Concatenate two arrays into one\n\nArguments\n   Front    Array, i.e. structure with functor []/M\n   Back    Array, i.e. structure with functor []/N\n   Concat    Variable or array with functor []/(M+N)\n\nType\n   Term Manipulation\n\nDescription\n   Succeeds if Concat is the concatenation of arrays Front and Back.\n\nModes and Determinism\n   array_concat(+, +, -) is det\n\nExceptions\n     4 --- Front or Back is a variable (non-coroutining mode only)\n     5 --- Front, Back or Concat are neither variables nor arrays\n\nExamples\n   \n?- array_concat([](a,b,c), [](d,e), L).\nL = [](a,b,c,d,e)\n\n?- array_concat([](a,b,c), [], L).\nL = [](a,b,c)\n\n?- array_concat([], [](d,e), L).\nL = [](d,e)\n\n?- array_concat([], [], L).\nL = []\n\n?- array_concat([]([](a,b),[](c)), [](d,[](e)), L).\nL = []([](a,b), [](c), d, [](e))\n\nSee Also\n   dim / 2, subscript / 3, array_list / 2, is_array / 1, array_flat / 3, arg / 3"},"array_flat/3":{"prefix":"array_flat","body":"array_flat(${1:N}, ${2:Array}, ${3:Flat})$4\n$0","description":"array_flat(+N, +Array, -Flat)\n\n   Flattens (reduces the number of dimensions) of a multi-dimensional array\n\nArguments\n   N    Integer\n   Array    Array, i.e. structure with functor []/?\n   Flat    Variable or array\n\nType\n   Term Manipulation\n\nDescription\n   Constructs an array Flat with the same elements, but N fewer dimensions\n   than Array.  The most common use is to create a flat, one-dimensional\n   array from a multi-dimensional one.  Note that multi-dimensional arrays\n   are in fact nested one-dimensional arrays.\n\n   N specifies how many levels are flattened:  a positive value N means\n   that a M-dimensional array will be reduced to a (M-N)-dimensional one,\n   e.g. a 2-D array gets reduced to a 1-D array.  When N is given as -1,\n   all array nesting is removed, and a 1-D array on the non-array elements\n   is produced.  In practice, it is however recommended to always use a\n   positive value for N, as this avoids ambiguities with respect to the\n   interpretation of subterm as nested array or array element.  With a\n   value of 0 the original array is returned unchanged.\n\n   The elements in the Flat array are in the same order as they would be\n   encountered in a depth-first left-to-right traversal of Array.\n\n   In the top N levels of Array, terms with functor []/M are interpreted\n   as arrays, in particular [] is interpreted as an empty array and thus\n   eliminated.\n\nModes and Determinism\n   array_flat(+, +, -) is det\n\nExceptions\n     4 --- N or Array is a variable\n     5 --- N is not an integer\n     5 --- Array is not an array\n     6 --- N is less than -1\n    24 --- N is not an integer, but possibly an arithmetic expression\n\nExamples\n   \n?- array_flat(0, []([](a,b,c),[](d,e,f)), A).      % no change\nA = []([](a, b, c), [](d, e, f))\n\n?- array_flat(1, []([](a,b,c),[](d,e,f)), A).      % 2-D to 1-D\nA = [](a, b, c, d, e, f)\n\n?- array_flat(2, []([](a,b,c),[](d,e,f)), A).      % still 2-D to 1-D\nA = [](a, b, c, d, e, f)\n\n?- dim(M, [2,2,2]), array_flat(2, M, A).    % 3-D to 1-D\nM = []([]([](_368,_369), [](_365,_366)), []([](_359,_360), [](_356,_357)))\nA = [](_368, _369, _365, _366, _359, _360, _356, _357)\n\n?- dim(M, [2,2,2]), array_flat(1, M, A).    % 3-D to 2-D\nM = []([]([](_368,_369), [](_365,_366)), []([](_359,_360), [](_356,_357)))\nA = []([](_368,_369), [](_365,_366), [](_359,_360), [](_356,_357))\n\n% mixed-dimensional 3-D to 2-D\n?- array_flat(1, [](a, [](b), []([](c)), [], d), A).\nA = [](a, b, [](c) ,d).\n\n?- array_flat(1, []([],[]), A).    % empty arrays\nA = []\n\nSee Also\n   dim / 2, subscript / 3, array_concat / 3, is_array / 1, array_list / 2, arg / 3"},"arity/2":{"prefix":"arity","body":"arity(${1:Term}, ${2:Arity})$3\n$0","description":"arity(+Term, -Arity)\n\n   Succeeds if Arity is the arity of Term.\n\nArguments\n   Term    Prolog term.\n   Arity    Variable or integer.\n\nType\n   Term Manipulation\n\nDescription\n\n    If Term is instantiated, its arity (number of arguments) is unified\n    with Arity.  For compound terms, this is the number of arguments,\n    for atomic terms it is 0.  As usual, non-empty lists are considered\n    compound terms with arity 2.\n\n    Note that (like all predicates that return a number as their last\n    argument), this predicate can be used as a function inside arithmetic\n    expressions, e.g.\n\n\t..., (I > arity(Term) -> writeln(error), fail ; arg(I, Term, Arg) ).\n\nModes and Determinism\n   arity(+, -) is det\n\nExceptions\n     4 --- Term is uninstantiated (non-coroutine mode only).\n\nExamples\n   \nSuccess:\n   arity(f(1,2),2).\n   arity(f(1,2),A).    (gives A=2).\n   arity([],A).    (gives A=0).\n   arity(\"s\",A).     (gives A=0).\n   arity(33,A).    (gives A=0).\n\nFail:\n   arity(f(1,2),3).\n   arity(\"compound(g)\",1).\n\nError:\n   arity(_,A).    (Error 4).\n\nSee Also\n   =.. / 2, arg / 3, functor / 3"},"bytes_to_term/2":{"prefix":"bytes_to_term","body":"bytes_to_term(${1:String}, ${2:Term})$3\n$0","description":"bytes_to_term(+String, -Term)\n\n   Converts String, which is supposed to be an encoding of a term, into Term.\n\nArguments\n   String    A string produced by term_to_bytes/2.\n   Term    A variable.\n\nType\n   Term Manipulation\n\nDescription\n   This predicate decodes strings produced by term_to_bytes/2 and\n   reconstructs the encoded term.  The string representation is\n   machine-independent, can be stored in files, sent over networks etc.\n   Note however that the string can contain arbitrary bytes,\n   including NUL and control characters.\n\n   The predicate attempts to reconstruct the term with all its attached\n   variable attributes and delayed goals. For this to be possible, the\n   variable attributes and the predicates corresponding to delayed goals\n   must all be defined in the environment where the term is reconstructed.\n\n   The term_to_bytes/bytes_to_term predicates differ from term_string/2\n   in that they do not create a human-readable representation, but are\n   significantly faster and convert the term with all its attributes.\n\nModes and Determinism\n   bytes_to_term(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- String is not a string.\n\nExamples\n   \n[eclipse]: term_to_bytes(s(X),String), bytes_to_term(String, Term).\nString = \"\\000\\000\\000\\b\\001\\002\\013\\001\\001s\\000\\377\\006\\376\\006\\001X\\000\"\nTerm = s(X)\nyes.\n\nSee Also\n   term_to_bytes / 2, copy_term / 2, copy_term / 3, writeq / 1, writeq / 2, write_canonical / 1, write_canonical / 2"},"char_code/2":{"prefix":"char_code","body":"char_code(${1:Char}, ${2:Code})$3\n$0","description":"char_code(?Char, ?Code)\n\n   Succeeds if Code is the numeric character code of the character Char.\n\nArguments\n   Char    One-character atom, string or variable.\n   Code    Integer or variable.\n\nType\n   Term Manipulation\n\nDescription\n   If Char is instantiated to a one-character atom or string,\n   Code is unified with the corresponding numeric character code,\n   depending on the character encoding in use.\n\n   If Code is instantiated to an integer, Char is unified with the\n   corresponding one-character atom.\n\nModes and Determinism\n   char_code(+, -) is det\n   char_code(-, +) is det\n\nExceptions\n     5 --- Char is instantiated, but not to a 1-character string or atom.\n     5 --- Code is instantiated, but not to an integer.\n     6 --- Code is instantiated to an integer outside the valid range for character codes.\n     4 --- Neither Char nor Code are instantiated (non-coroutine mode only).\n\nExamples\n   \n   Success:\n   char_code(b,98).\n   char_code(\"b\",98).\n   char_code(C,99).     (gives C=c).\n   char_code(a,I).      (gives I=97).\n   Fail:\n   char_code(a,98).\n   Error:\n   char_code(C,I).       (Error 4).\n   char_code(ab,I).      (Error 5).\n   char_code(7,I).       (Error 5).\n   char_code(C,-1).      (Error 6).\n\nSee Also\n   get_char / 1, get_char / 2, put_char / 1, put_char / 2, string_code / 3, string_list / 2, string_list / 3"},"copy_term/2":{"prefix":"copy_term","body":"copy_term(${1:OldTerm}, ${2:NewTerm})$3\n$0","description":"copy_term(?OldTerm, -NewTerm)\n\n   A copy of OldTerm with new variables is created and unified with NewTerm.\n\nArguments\n   OldTerm    Prolog term.\n   NewTerm    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   A copy of OldTerm is created, ie.  a term that is similar to OldTerm but\n   the free variables of OldTerm have been replaced by new variables which\n   do not occur elsewhere.  In other words, the new term is a most general\n   variant of the old one, in the sense of variant/2.\n\n   Attributed variables are treated like normal variables, except that their\n   attributes are copied as specified by the corresponding copy_term handler.\n   This would usually imply that properties of the variable which can be\n   interpreted as unary constraints (such as its domain) are copied, while\n   attributes that link the variable to other variables or objects are ignored.\n\n   If the term to be copied contains ground subterms (subterms without\n   variables), then these subterms are shared between the original and\n   the copy.  This optimization is only visible when using the nonlogical\n   setarg/3 primitive on such a subterm - the safest way to enforce\n   copying in such circumstances is to add a dummy variable argument.\n\n   Note that when the structure of the term to be copied is known, then\n   it is more efficient to use specialised unification code or a combination\n   of functor/3 and arg/3 to do the job.\n\nModes and Determinism\n   copy_term(?, -) is det\n\nExamples\n   \n   Success:\n   copy_term(a, C).    (gives C=a).\n   copy_term(s(X,a,Y,X), C). (gives C=s(_1, a, _2, _1)).\n   copy_term([X,2|Y], C).    (gives C=[_1, 2| _2]).\n   copy_term(X, C).\n   copy_term(X, s(1,2,3)).\n\n   X::5..8, copy_term(f(X), C).\t(gives C=f(_1{5..8})).\n\n   Fail:\n   copy_term(s(X,X), s(3,4)).\n\nSee Also\n   copy_term_vars / 3, copy_term / 3, variant / 2, functor / 3, term_variables / 2"},"copy_term_vars/3":{"prefix":"copy_term_vars","body":"copy_term_vars(${1:Vars}, ${2:OldTerm}, ${3:NewTerm})$4\n$0","description":"copy_term_vars(?Vars, ?OldTerm, -NewTerm)\n\n   NewTerm gets unified with a variant of OldTerm where all occurrences\nof variables in Vars are replaced by fresh variables.\n\nArguments\n   Vars    Prolog term, usually a variable or a list of variables.\n   OldTerm    Prolog term.\n   NewTerm    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   A copy of OldTerm is created, ie. a term that is similar to OldTerm but\n   all occurrences of the variables mentioned in Vars have been replaced\n   by new variables which do not occur elsewhere.\n\n   Attributed variables are treated like normal variables, except that their\n   attributes are copied as specified by the corresponding copy_term handler.\n   This would usually imply that properties of the variable which can be\n   interpreted as unary constraints (such as its domain) are copied, while\n   attributes that link the variable to other variables or objects are ignored.\n\n   Subterms that do not contain any of the variables to replace are\n   not physically copied.\n\n   Note that when the structure of the term to be copied is known, then\n   it is more efficient to use specialised unification code to do the job.\n\nModes and Determinism\n   copy_term_vars(?, ?, -) is det\n\nExamples\n      [eclipse]: Term=s(X,Y,Z), copy_term_vars(Y, Term, Copy).\n   X = _79\n   Z = _81\n   Y = _60\n   Term = s(_79, _60, _81)\n   Copy = s(_79, _120, _81)\n   yes.\n\nSee Also\n   copy_term / 2, copy_term / 3, variant / 2, functor / 3, term_variables / 2"},"copy_term/3":{"prefix":"copy_term","body":"copy_term(${1:OldTerm}, ${2:NewTerm}, ${3:AttrVars})$4\n$0","description":"copy_term(?OldTerm, -NewTerm, -AttrVars)\n\n   A copy of OldTerm with new variables is created and unified with NewTerm.\nAttrVars is a list mapping the attributed variables in OldTerm to the corresponding\nvariables in NewTerm.\n\nArguments\n   OldTerm    Prolog term.\n   NewTerm    Prolog term, normally a variable.\n   AttrVars    List of Pairs or a variable.\n\nType\n   Term Manipulation\n\nDescription\n   A copy of OldTerm is created, ie.  a term that is similar to OldTerm but\n   the free variables of OldTerm have been replaced by new variables which\n   do not occur elsewhere.  In other words, the new term is a most general\n   variant of the old one in the sense of variant/2.\n\n   This predicate is a more primitive version of copy_term/2 and does\n   not imply a particular handling of attributed variables. Instead it copies the\n   attributed variables as normal variables, and returns the AttrVars list as\n   a means to define the copying of attributed variables separately.  AttrVars is a\n   list of pairs [<attributed variable>|<variable>] which maps the\n   attributed variables in OldTerm to the corresponding fresh variables in\n   NewTerm.  By processing this list, the variables can be instantiated to\n   whatever the user defines as the copy of the attributed variable.\n\n   Note that copy_term/2 is implemented as\n\n    copy_term(X, Y) :-\n    copy_term(X, Y, Metas),\n    apply_copy_term_handlers(Metas).\n\nModes and Determinism\n   copy_term(?, -, -) is det\n\nExamples\n   \n[eclipse 1]: set_flag(output_mode, \"QPMV\").\n\nyes.\n[eclipse 3]: copy_term(s(a,X{a},Y, Z{b}), Copy, Metas).\n\nX = X_m234{a}\nY = Y_g224\nZ = Z_m212{b}\nCopy = s(a, _g282, Y_g288, _g292)\nMetas = [[Z_m212{b}|_g292], [X_m234{a}|_g282]]\nyes.\n\nSee Also\n   copy_term / 2, copy_term_vars / 3, variant / 2, term_variables / 2"},"get_var_bounds/3":{"prefix":"get_var_bounds","body":"get_var_bounds(${1:Var}, ${2:Lower}, ${3:Upper})$4\n$0","description":"get_var_bounds(?Var, -Lower, -Upper)\n\n   Retrieve bounds of a numeric variable in a generic way\n\nArguments\n   Var    Variable or number.\n   Lower    Float or variable.\n   Upper    Float or variable.\n\nType\n   Term Manipulation\n\nDescription\n    This predicate is intended to be used on attributed variables that\n    have a numeric domain.  The bound information is collected from the\n    variable's attributes via their get_bounds-handlers. If several\n    attributes contain bound information, the results are intersected\n    to produce the tightest bound information available. An empty bound\n    (Lower > Upper) can be returned.\n\n    The bounds are always returned as floating point numbers, regardless\n    of any integrality constraint on the variable.\n\nModes and Determinism\n   get_var_bounds(?, -, -) is det\n\nExceptions\n     5 --- Var is not a variable or number\n\nExamples\n   \n    [eclipse 1]: lib(fd), lib(ic).\n    yes.\n\n    [eclipse 2]: ic:(X::3.0..9.0), fd:(X::1..7), get_var_bounds(X,L,U).\n    X = X{ic : 3.0..9.0, fd:[1..7]}\n    L = 3.0\n    U = 7.0\n    Yes (0.00s cpu)\n\n    [eclipse 3]: get_var_bounds(X,L,U).\n    X = X\n    L = -1.0Inf\n    U = 1.0Inf\n    yes.\n\n    [eclipse 4]: get_var_bounds(5,L,U).\n    L = 5.0\n    U = 5.0\n    yes.\n\n    [eclipse 5]: get_var_bounds(a,L,U).\n    type error in get_var_bounds(a, L, U)\n\nSee Also\n   set_var_bounds / 3, get_bounds handler"},"functor/3":{"prefix":"functor","body":"functor(${1:Term}, ${2:Functor}, ${3:Arity})$4\n$0","description":"functor(?Term, ?Functor, ?Arity)\n\n   Succeeds if the compound term Term has functor Functor and arity Arity or\nif Term and Functor are atomic and equal, and Arity is 0.\n\nArguments\n   Term    Prolog term.\n   Functor    Atomic term or variable.\n   Arity    Positive integer or variable.\n\nType\n   Term Manipulation\n\nDescription\n   If Term is instantiated, its functor is unified with Functor and its\n   arity with Arity.\n\n   If Term is not instantiated, it is bound to a term with functor Functor\n   and arity Arity.\n\n   This predicate regards atomic terms (number, atom or string) as\n   terms with arity 0 and functor equal to the term.\n\n   To query only the arity of a term, arity/2 can be used instead of functor/3.\n\nModes and Determinism\n   functor(+, -, -) is det\n   functor(-, +, +) is det\n\nExceptions\n     4 --- Term and either (or both) of Functor and Arity are    uninstantiated (non-coroutine mode only).\n     5 --- Arity is neither a variable nor an integer.\n     5 --- Functor is neither a variable nor an atomic term.\n     6 --- Arity is a negative integer.\n\nExamples\n   \n   Success:\n   functor(f(1,2),f,2).\n   functor(f(1,2),F,A).  (gives F=f, A=2).\n   functor(T,f,3).       (gives T=f(_g50, _g52, _g54)).\n   functor(T,.,2).       (gives T=[_g48 | _g50]).\n   functor([],F,A).      (gives F=[], A=0).\n   functor(\"s\",F,A).     (gives F=\"s\", A=0).\n   Fail:\n   functor(f(1,2),f,3).\n   functor(\"compound(g)\",compound,1).\n   functor(f(1,2),\"f\",2).\n   Error:\n   functor(T,F,A).    (Error 4).\n   functor(\"f\",[f],X).    (Error 5).\n   functor(X,[a],Y).    (Error 5).\n   functor(f(1,2),f,-1).    (Error 6).\n\nSee Also\n   arity / 2, =.. / 2, arg / 3"},"dim/2":{"prefix":"dim","body":"dim(${1:Array}, ${2:Dimensions})$3\n$0","description":"dim(?Array, ?Dimensions)\n\n   Creates a multi-dimensional array or or computes the dimensions of an existing one\n\nArguments\n   Array    Variable or array.\n   Dimensions    Variable or list of integers.\n\nType\n   Term Manipulation\n\nDescription\n    Creates an array of arbitrary dimensions, or determines the dimensions\n    of an existing one.  Multi-dimensional arrays are represented in the\n    form of nested structures.\n\n    When creating an array of dimensions [D1,..,Dn], a nested structure\n    is created with the top-level term having the functor []/D1, its\n    arguments being structures with functor []/D2, and so on.\n    The functor [] is chosen to remind of arrays.\n\n    Empty arrays: the atom [] represents the empty array of any dimension.\n    This means that dimensions like [0], [3,0] and [3,0,4] all lead to\n    the creation of the empty array [].\n\n    When determining the dimensions of an existing array, this predicate\n    only considers the sub-arrays on index position 1.  It is therefore\n    not reliable for ragged arrays.\n\n    To get the size of one-dimensional arrays, it is more efficient to\n    use arity/2.\n\nModes and Determinism\n   dim(+, -) is det\n   dim(-, ++) is det\n\nExceptions\n     4 --- Both Array and Dimensions are not sufficiently instantiated.\n     5 --- Array is not an array (term with functor []/N).\n     5 --- Dimensions is not a list of integers.\n     6 --- An integer in Dimensions is negative.\n     6 --- Dimensions is the empty list.\n\nExamples\n   \n?- dim(M, [3,4]).\nM = []([](_131, _132, _133, _134),\n       [](_126, _127, _128, _129),\n       [](_121, _122, _123, _124))\nyes.\n\n?- dim(M, [3,4]), dim(M, L).\nM = []([](_131, _132, _133, _134),\n       [](_126, _127, _128, _129),\n       [](_121, _122, _123, _124))\nL = [3, 4]\nyes.\n\n?- dim(M, [0]).\nM = []\nyes.\n\n?- dim(A, []).\nout of range in dim(A, [])\n\nSee Also\n   arg / 3, arity / 2, subscript / 3, array_flat / 3, functor / 3"},"meta_attribute/2":{"prefix":"meta_attribute","body":"meta_attribute(${1:Name}, ${2:Handlers})$3\n$0","description":"meta_attribute(+Name, ++Handlers)\n\n   Declares the variable attribute Name with the corresponding handlers\n\nArguments\n   Name    Atom\n   Handlers    List or nil.\n\nType\n   Term Manipulation\n\nDescription\n\n   This predicate is used to declare a variable attribute and/or the\n   corresponding handlers.  The Name is usually the name of module where\n   this attribute is being defined and used.  The unqualified use of\n   attributed variables, i.e.  terms in the form Var{Attr} is allowed only in\n   modules which have a defined attribute name, otherwise the qualified\n   usage Var{Name:Attr} is required.\n\n   The Handlers argument specifies a list of handler predicates for several\n   built-in operations which require user-defined actions whenever an\n   attributed variable is encountered.  The list contains elements in the\n   form Operation:Pred, where Operation is the predefined name of the\n   built-in operation and Pred is the handler predicate specification.  The\n   handler definition module is assumed to be the module in which\n   meta_attribute/2 is being called; another module can be specified by\n   using the tool body predicate meta_attribute_body/3.  When true/0 is\n   specified as the handler or when no handler for a particular operation\n   is specified, this operation will ignore this extension.  If the\n   extension Name already exists, the specified handlers are updated, the\n   non-specified ones remain.\n\n   The call meta_attribute(Name, []) can be used as a preliminary\n   declaration of a particular attribute, e.g.  to compile a module part\n   before the actual declaration is called, or when processing separate\n   files that belong to a particular module.\n\n   The meta_attribute/2 predicate is sensitive to the flag debug_compile.\n   If it is on, the calls to the local handlers will be traceable (and\n   slower), if it is off, it will be the opposite.  All specified handlers\n   will be exported from their definition module.\n\nHandler Declarations\n   The predefined operations and the corresponding handler arguments are\n   the following:\n\nunify\n\n    Operation :   unification\n\n    Handler :   handler(+Term, ?Attribute [, ?SuspendAttribute])\n\n    Description :   The handler for the usual unification.  Term is the\n    term that was unified with the attributed variable, it is\n\teither a nonvariable or an attributed variable.  Attribute is\n\tthe contents of the attribute slot corresponding to the\n\textension.  Note that, at this point in execution, the orginal\n\tattributed variable no longer exists, because it has already\n\tbeen bound to Term.  The optional third argument is the\n\tsuspend-attribute of the former variable; it may be needed to\n\twake the variable's 'constrained' suspension list.\n\n\tThe handler's job is to determine whether the binding is\n\tallowed with respect to the attribute.  This could for example\n\tinvolve checking whether the bound term is in a domain\n\tdescribed by the attribute.  For variable-variable bindings,\n\ttypically the remaining attribute must be updated to reflect\n\tthe intersection of the two individual attributes.  In case of\n\tsuccess, suspension lists inside the attributes may need to be\n\tscheduled for waking.\n\n    If an attributed variable is unified with a standard variable, the\n    variable is bound to the attributed variable and no handlers are\n    invoked.  If an attributed variable is unified with another\n    attributed variable or a non-variable, the attributed variable is\n    bound (like a standard variable) to the other term and all handlers\n    for the unify operation are invoked.  Note that several attributed\n    variable bindings can occur e.g. during a head unification and also\n    during a single unification of compound terms.  The handlers are\n    only invoked at certain trigger points (usually before the next\n    regular predicate call).  Woken goals will start executing once\n\tall unify-handlers are done.\n\ntest_unify\n\n    Operation :   unification test\n\n    Handler :   handler(+Term, ?Attribute)\n\n    Description :   The handler for a unifiability test which is not\n    supposed to trigger constraints propagation.  It is used e.g.\n\tin the not_unify/2 predicate.  The handler arguments are\n\tequivalent to those of the unification handler, Term is the\n\tterm that was unified with the attributed variable, Attribute\n\tis the attribute of this extension.  The handler's job is to\n\tdetermine whether Attribute allows unification with Term (not\n\tconsidering effects of woken goals).  During the execution of\n\tthe handler the attributed variable may be bound to Term,\n\thowever when all local handlers succeed, all bindings are\n\tundone, and no waking occurs.\n\ncompare_instances\n\n    Operation :   instance and variant tests\n\n    Handler :   handler(-Res, ?TermL, ?TermR)\n\n    Description :   The handler for the variant/2, instance/2 and\n\tcompare_instances/3 instance-testing predicates.  The handler\n\targuments are similar to those of compare_instances/3. At least\n\tone of TermL or TermR will be an attributed variable whenever\n\tthe handler is invoked.  The handler should bind Res to < if\n\tthe attributes imply that TermL is a proper instance of TermR,\n\t> if TermR is a proper instance of TermL, and = if the two\n\tattributed variables are variants of each other (e.g. they have\n\tidentical domains).  If the terms are incomparable (not unifiable),\n\tthe handler must fail.  If the attribute being declared has no\n\tbearing on the instance-relationship, this handler should remain\n\tundefined.\n\ncopy_term\n\n    Operation :   copying an attributed variable\n\n    Handler :   handler(?AttrVar, ?Var)\n\n    Description :   The handler for the copy_term/2 predicate.  AttrVar is\n    the attributed variable encountered in the copied term, Var is\n    its corresponding variable in the copy.  All extension handlers\n    receive the same arguments.  This means that if the attributed\n    variable should be copied as an attributed variable, the\n    handler must check if Var is still a free variable or if it was\n    already bound to an attributed variable by a previous handler.\n\ndelayed_goals_number\n\n    Operation :   querying number of suspended goals of a variable\n\n    Handler :   handler(?AttrVar, -GoalsNumber)\n\n    Description :  The handler for the delayed_goals_number/2\n\tpredicate.  AttrVar is the attributed variable encountered in\n\tthe predicate.  The handler is supposed to return the number\n\tof all suspended goals in this attribute.\n\nget_bounds\n\n    Operation :   get information about numeric variable bounds\n\n    Handler :   handler(?AttrVar, -Lwb, -Upb)\n\n    Description :  The handler for the get_var_bounds/3 predicate. \n\tThe handler should only be defined if the attribute contains\n\tinformation about numeric bounds.  The handler is only invoked\n\tif the variable has the corresponding (non-empty) attribute. \n\tThe handler should bind Lwb and Upb to numbers (any numeric\n\ttype) reflecting the attribute's information about lower and\n\tupper bound of the variable, respectively.  If different\n\tattributes return different bounds information,\n\tget_var_bounds/3 will return the intersection of the bounds, even\n    if this is empty (Lwb > Upb).\n\nset_bounds\n\n    Operation :   impose new bounds on an attributed variable\n\n    Handler :   handler(?AttrVar, +Lwb, +Upb)\n\n    Description :  The handler for the set_var_bounds/3 predicate. \n\tThe handler should only be defined if the attribute can\n\tincorporate information about numeric variable bounds.  The\n\thandler is only invoked if the variable has the corresponding\n\t(non-empty) attribute.  Lwb and Upb are the numbers that were\n\tpassed to set_var_bounds/3, and the handler is expected to\n\tupdate its own bounds representation accordingly.\n\nsuspensions\n\n    Operation :   querying suspensions attached to a variable\n\n    Handler :   handler(?AttrVar, -ListOfSuspLists, -Tail)\n\n    Description :  The handler for the suspensions/2 predicate. \n\tAttrVar is an attributed variable.  The handler should bind\n\tListOfSuspLists to a list containing all the attribute's\n\tsuspension lists and ending with Tail.\n\nprint\n\n    Operation :   printing the attribute\n\n    Handler :   handler(?AttrVar, -Attribute)\n\n    Description : Printing the attribute in printf/2, 3 when the m option\n    is specified.  AttrVar is the attributed variable being printed,\n    Attribute is the term which will be printed as a value for this\n    attribute, qualified by the attribute name.  If no handler is\n    specified for an attribute, or the print handler fails, the\n    attribute will not be printed.  If there is only one attribute with\n    an associated print handler, the attribute value is not qualified\n    with the attribute name.\n\nThe following handlers are still supported for compatibility,\nbut their use is not recommended:\n\ndelayed_goals\n\n    Operation :   querying suspended goals of a variable (obsolete)\n\n    Handler :   handler(?AttrVar, ?Goals, -GoalsTail)\n\n    Description :   The handler for the delayed_goals/2 predicate.\n    AttrVar is the attributed variable encountered in the predicate.\n    The handler is supposed to create a difference list of all\n    goals in the suspended lists for this attribute. This handler\n\tshould not be used anymore, define a suspensions-handler instead.\n\npre_unify\n\n    Operation :   pre-unification notification (compatibility only)\n\n    Handler :   handler(?AttrVar, +Term [,-Goals])\n\n    Description :  The handler is invoked before unification.  The\n\tfirst argument is the attributed variable to be unified, the\n\tsecond argument is the term it is going to be unified with. \n\tThe optional third argument can be used to return goals that\n\twill be called after all pre-unify handlers for this variable\n\thave finished, and the variable has been bound.\n\tThe handlers itself should not bind any variables.\n\tIf multiple attributed variables were bound in a single\n\tunification, all these bindings are first undone, then the\n\thandlers are called and the variables re-bound one by one.\n\tThis handler is provided for compatibility with SICStus\n\tProlog and its use is not recommended. It can be used together\n\twith a unify handler, which is called afterwards.\n\nSuspension List Declaration\nThe following entry is used to declare the valid suspension lists that\nthe attribute defines:\n\nsuspension_lists\n\n    Operation : declare suspension list names\n\n    Handler :   list of name:indexlist\n\n    Description :   This specifies which attribute slots (arguments in the\n    attribute structure) are suspension lists, and how they are called.\n\tIt is possible to declare aliases, i.e. several names for the same\n\tsuspension list, or a common name for more than one suspension list.\n\tNote that in addition to this declaration, there must be an exported\n\tstruct-declaration with the same name as the attribute.  Using this,\n\tthe suspension_lists declarations can then be written as\n\tsusp_list_name:[(fieldname of attrname)]\n\nModes and Determinism\n   meta_attribute(+, ++) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- The arguments are not ground.\n     5 --- The first argument is not an atom or the second one is not a    list in the required format.\n     6 --- The specified operation is not implemented or the handler    arity is wrong.\n\nExamples\n   \n% Sample source directives\n\n:- meta_attribute(myattr, []).\n\n:- meta_attribute(thing, [unify:unify_things/3, print_things/2]).\n\n:- export struct(dom(values,min,max)).\n:- meta_attribute(dom, [\n\tunify:unify_doms/3,\n\tprint_doms/2,\n\tsuspension_lists:[\n\t\tmin:[(min of dom)],\n\t\tmax:[(max of dom)],\n\t\tboth:[(min of dom),(max of dom)]\n\t    ]\n    ]).\n\n% Example session\n\n?- writeq(X{a}).\nundefined variable attribute in add_attribute(X, a, eclipse)\nsyntax error : in source transformation\n| write(X{a}).\n|    ^ here\n\n?- meta_attribute(eclipse, []).\nyes.\n\n?- writeq(X{a}).\nX{suspend : _g386 , a}\nX = X\nyes.\n\nSee Also\n   not_unify / 2, instance / 2, variant / 2, compare_instances / 3, copy_term / 2, delayed_goals_number / 2, delayed_goals / 2, set_var_bounds / 3, get_var_bounds / 3, printf / 2, printf / 3, suspensions / 2, add_attribute / 2"},"meta_bind/2":{"prefix":"meta_bind","body":"meta_bind(${1:Meta}, ${2:Term})$3\n$0","description":"meta_bind(-Meta, ?Term)\n\n   The attributed variable Meta is bound to the term Term without triggering the\nmetaterm-unification event.\n\nArguments\n   Meta    An attributed variable.\n   Term    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   The attributed variable Meta is treated like a standard variable and bound to\n   Term.  The difference compared to using normal unification is that meta_bind/2\n   does not raise the meta-unification event, as is normally the case\n   whenever a attributed variable is bound.  An example of its use is in the handler\n   for the meta-unification event itself, e.g. when the attributed variable is to be\n   bound to a new one with a different attribute.\n\nModes and Determinism\n   meta_bind(-, ?) is det\n\nExceptions\n     4 --- Meta is a free variable.\n     5 --- Meta is instantiated.\n\nExamples\n   \n    [eclipse 2]: meta_bind(X{a}, 3).\n\n    X = 3\n    yes.\n\n    [eclipse 5]: [user].\n     change_attribute(X{_Old}, New) ?- meta_bind(X, _{New}).\n\n    yes.\n    [eclipse 6]: change_attribute(X{a}, b), printf(\"%Mw\", [X]).\n    X{b}\n\nError:\n    meta_bind(_, a).    (Error 4).\n    meta_bind(a, a).    (Error 5).\n\nSee Also\n   meta / 1"},"set_var_bounds/3":{"prefix":"set_var_bounds","body":"set_var_bounds(${1:Var}, ${2:Lower}, ${3:Upper})$4\n$0","description":"set_var_bounds(?Var, +Lower, +Upper)\n\n   Impose bounds on a numeric variable in a generic way\n\nArguments\n   Var    Variable or number.\n   Lower    A number.\n   Upper    A number.\n\nType\n   Term Manipulation\n\nDescription\n    This predicate is intended to be used on attributed variables that\n    have a numeric domain.  The bound information is distributed to the\n    variable's attributes via their set_bounds-handlers.  Only existing\n    attributes are involved, no new attributes are created!\n\n    The bounds can be given as any numeric type, the set_bounds handlers\n    are expected to interpret them appropriately.\n\nModes and Determinism\n   set_var_bounds(?, +, +) is semidet\n\nFail Conditions\n   Fails if imposing the bounds results in an empty domain\n\nExceptions\n     5 --- Var is not a variable or number\n\nExamples\n   \n    [eclipse 1]: lib(fd), lib(ic).\n    yes.\n\n    % update both attributes:\n    [eclipse 2]: ic:(X::3.0..9.0), fd:(X::1..7), set_var_bounds(X, 5, 6.5).\n    X = X{ic : 5.0..6.5, fd:[5, 6]}\n    yes.\n\n    % no attribute - no effect:\n    [eclipse 13]: set_var_bounds(X, 5, 6.5).\n    X = X\n    yes.\n\n    [eclipse 15]: set_var_bounds(0, 5, 6.5).\n    no (more) solution.\n\n    [eclipse 14]: set_var_bounds(a, 3,7).\n    type error in set_var_bounds(a, 3, 7)\n\nSee Also\n   get_var_bounds / 3, set_bounds handler"},"setarg/3":{"prefix":"setarg","body":"setarg(${1:N}, ${2:Term}, ${3:Arg})$4\n$0","description":"setarg(+N, +Term, ?Arg)\n\n   Destructively replaces the Nth argument of the compound term Term with the\nterm Arg.\n\nArguments\n   N    Integer not greater than the arity of Term, or a list\n of integers.\n   Term    Compound term or external data handle.\n   Arg    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   Destructively replaces the Nth argument of the compound term Term with\n   the term Arg.  The assignment is undone on backtracking.\n\n   The use of this built-in is strongly discouraged, due to its non-logical\n   behaviour!  It is provided only to enable the implementation of certain\n   low-level operations that could otherwise not be provided with the same\n   efficiency.  Surprising side effects can occur when you don't know\n   exactly what you are doing.  In particular, it must be assured by the\n   programmer that the old argument value is not needed any longer and that\n   the old argument was not aliased to some other location.  The old value\n   should also not be a variable.\n\n   If N is a list of integers and Term is a nested structure, then Arg\n   is the subterm of Term described by this list of integers.\n   E.g. setarg([2,1,3], Term, Arg) is the same as arg(2, Term, T1),\n   arg(1, T1, T2), setarg(3, T2, Arg).\n\nModes and Determinism\n   setarg(+, +, ?) is det\n\nExceptions\n     4 --- Either N or Term (or both) is not instantiated.\n     5 --- N is instantiated, but not to an integer.\n     5 --- Term is instantiated, but not to a compound term.\n     6 --- N is an integer less than 1 or greater than the arity of    Term.\n\nExamples\n   \nSuccess:\n      [eclipse]: T = s(a, b, c), setarg(2, T, hello).\n      T = s(a, hello, c)\n      yes.\n      [eclipse]: T = s(a, b, c), ( setarg(2, T, hello) ; true ).\n      T = s(a, hello, c)     More? (;)\n      T = s(a, b, c)\n      yes.\nUnpredictable result:\n    [eclipse 10]: S=s(A), T=t(A), setarg(1, T, b).\n    S = s(A)  or  S = s(b)\n    A = b     or  A = A\n    T = t(b)\n\nSee Also\n   arg / 3, xset / 3"},"subscript/3":{"prefix":"subscript","body":"subscript(${1:Term}, ${2:Subscript}, ${3:Elem})$4\n$0","description":"subscript(+Term, ++Subscript, -Elem)\n\n   Accesses the subterm Elem of Term, as specified by Subscript\n\nArguments\n   Term    Compound term (possibly nested), string, or external data handle.\n   Subscript    A list of integers, ranges or integer arithmetic expressions.\n   Elem    Prolog term.\n\nType\n   Term Manipulation\n\nDescription\n   If term is a compound term, e.g. a vector represented as a structure,\n   or a matrix represented as a structure of structures and so on, then\n   subscript/3 provides access to the term's components.\n   Subscript is a list of (sub)structure argument indices describing\n   which element to access.\n\n   The indices can be either an integer expression or a range in the form \n   Lower..Upper where Lower and Upper are integer expressions. The\n   expressions are evaluated and the corresponding components (or the\n   components in the range specified) accessed.\n\n   If Term is a string, Subscript must be a list of the form [Index], and\n   Elem is obtained via string_code(Index, Term, Elem).\n\n   If Term is an external data handle, Subscript must be a list of the form\n   [Index], and Elem is obtained via xget(Term, Index, Elem).\n\n   The main use for this predicate is to provide array syntax in arithmetic\n   expressions. Consider the arithmetic expression\n\n    X is Mat[I,J] + 1\n\n    which the ECLiPSe parser parses as\n\n    X is subscript(Mat,[I,J]) + 1\n\n    and the arithmetic evaluation mechanism turns that into\n\n    subscript(Mat,[I,J],T), +(T,1,X)\n\n    If Subscript contains a range of the form From..To, then\n    this results in the retrieval of a list of elements with\n    the indices from From to To.\n\n   NOTE: subscript/3 implements a superset of the functionality of arg/3.\n   So arg/3 is likely to be faster than subscript/3 in cases where they\n   implement the same functionality, i.e. structure argument lookup or\n   one/multi-dimensional array element lookup.\n\nModes and Determinism\n   subscript(+, ++, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- Term or Subscript are not sufficiently instantiated.\n     5 --- Term not compound or Subscript not integer list.\n     6 --- Subscript out of range.\n\nExamples\n   \n    [eclipse 6]: subscript(s(t(a,b),t(c,d),t(e,f)), [3,2], X).\n    X = f\n    yes.\n\n    [eclipse 11]: Vector = v(12,13,14,15), X is Vector[3].\n    X = 14\n    Vector = v(12, 13, 14, 15)\n    yes.\n\n    [eclipse 12]: Matrix = m(r(1,2,3),r(4,5,6),r(7,8,9)), X is Matrix[2,1].\n    X = 4\n    Matrix = m(r(1, 2, 3), r(4, 5, 6), r(7, 8, 9))\n    yes.\n\n    [eclipse 18]: Matrix = m(r(1,2,3),r(4,5,6),r(7,8,9)), Row is Matrix[2].\n    Row = r(4, 5, 6)\n    Matrix = m(r(1, 2, 3), r(4, 5, 6), r(7, 8, 9))\n    yes.\n\n    [eclipse 5]: Matrix = m(r(1,2,3),r(4,5,6),r(7,8,9)), \n    subscript(Matrix, [2,1..3], Row),\n    subscript(Matrix, [1..3,2], Col),\n    subscript(Matrix, [2..3,1..2], Sub).\n    Matrix = m(r(1, 2, 3), r(4, 5, 6), r(7, 8, 9))\n    Row = [4, 5, 6]\n    Col = [2, 5, 8]\n    Sub = [[4, 5], [7, 8]]\n    yes.\n\nSee Also\n   arg / 3, dim / 2, string_code / 3, xget / 3, array_flat / 3"},"term_string/2":{"prefix":"term_string","body":"term_string(${1:Term}, ${2:String})$3\n$0","description":"term_string(?Term, ?String)\n\n   Conversion between a Prolog term and a string.\n\nArguments\n   Term    Prolog term.\n   String    String or a variable.\n\nType\n   Term Manipulation\n\nDescription\n   If String is instantiated, its contents are parsed, and if the whole\n   string can be parsed as one Prolog term it is unified with Term.  If\n   String is not instantiated, Term is written into a string (using\n   writeq/2) and String is bound to it.\n\n   To change the way the term is converted into a string, e.g.  to include\n   attributed variable print handlers, it is possible to define it as follows:\n\nterm_to_string(T, S) :-\n    open(string(\"\"), write, Stream),\n    % use the flags which you want\n    printf(Stream, \"%mw\", [T]),\n    get_stream_info(Stream, name, S),\n    close(Stream).\n\nModes and Determinism\n   term_string(?, -) is det\n   term_string(-, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- String is instantiated, but not to a string.\n     7 --- String cannot be converted to a Prolog term.\n\nExamples\n   \nSuccess:\n      term_string(T, \"look\").      (gives T=look).\n      term_string(T, \"26.0\").      (gives T=26.0).\n      term_string(T, \"f(1,2).\").   (gives T=f(1,2)).\n      term_string(T, \"f(1,2)\").    (gives T=f(1,2)).\n      term_string(f(1,2),L).       (gives L=\"f(1, 2)\").\n      term_string(f(1,2),\"f(1, 2)\").\n      term_string(atom,S).    (gives S=\"atom\").\n      term_string(.(a,.(1,[])),S). (gives S=\"[a, 1]\").\n      term_string(2.60,\"2.6\").\n      term_string(2.6,\"2.60\").\n      term_string(T,S).    (gives T=_g94; S=\"_g94\").\n\nFail: term_string(2.6,\"2.5\").\n\nError:\n      term_string(T,atom).    (Error 5).\n      [eclipse]: term_string(T,\"F(1,2)\").  % String not a string\n      F(1,2)    % of a prolog term\n       ^ (here?)\n      syntax error: unexpected token\n      string contains unexpected characters in term_string(T, \"F(1,2)\")\n\nSee Also\n   integer_atom / 2, number_string / 2, string_list / 2, split_string / 4"},"term_to_bytes/2":{"prefix":"term_to_bytes","body":"term_to_bytes(${1:Term}, ${2:String})$3\n$0","description":"term_to_bytes(?Term, -String)\n\n   String is a ground encoding of Term, suitable for writing to a file,\ntransmitting over a network etc.\n\nArguments\n   Term    Prolog term.\n   String    A variable.\n\nType\n   Term Manipulation\n\nDescription\n   This predicate produces a string which contains an encoded representation\n   of the term Term. This representation is machine-independent, can be stored\n   in files, sent over networks etc. Note however that the string can contain\n   arbitrary bytes, including NUL and control characters.\n\n   The predicate attempts to convert the term with all its attached\n   variable attributes and delayed goals. If this is not wanted,\n   you can strip those by first copying the term using copy_term/2 or\n   copy_term/3.\n\n   The term_to_bytes/bytes_to_term predicates differ from term_string/2\n   in that they do not create a human-readable representation, but are\n   significantly faster and convert the term with all its attributes.\n\nModes and Determinism\n   term_to_bytes(?, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- String is neither variable nor string.\n\nExamples\n   \n[eclipse]: term_to_bytes(s(X),String), bytes_to_term(String, Term).\nString = \"\\000\\000\\000\\b\\001\\002\\013\\001\\001s\\000\\377\\006\\376\\006\\001X\\000\"\nTerm = s(X)\nyes.\n\nSee Also\n   bytes_to_term / 2, copy_term / 2, copy_term / 3, writeq / 1, writeq / 2, write_canonical / 1, write_canonical / 2"},"term_variables/2":{"prefix":"term_variables","body":"term_variables(${1:Term}, ${2:VarList})$3\n$0","description":"term_variables(?Term, -VarList)\n\n   Succeeds if VarList is the list of all variables in Term.\n\nArguments\n   Term    Prolog term.\n   VarList    List or variable.\n\nType\n   Term Manipulation\n\nDescription\n   This predicate collects all the variables inside Term into the list\n   VarList.  Every variable occurs only once in VarList, even if it occurs\n   several times in Term.  The order of the variables in the list is not\n   specified.  As usual, attributed variables are also considered variables.\n\nModes and Determinism\n   term_variables(?, -) is det\n\nExceptions\n     5 --- VarList instantiated but not to a list.\n\nExamples\n   \nSuccess:\n    term_variables(atom, []).\n    term_variables(Term, L).       % gives L = [Term]\n    term_variables(f(a,B,c), L).   % gives L = [B]\n    term_variables([X,Y,Z], L).    % gives L = [Z,Y,X]\n    term_variables([X,Y,X], L).    % gives L = [Y,X]\n    term_variables(s(X{a}), L).    % gives L = [X{a}]\n\nFail:\n    term_variables(f(a,B,c), []).\n\nSee Also\n   nonground / 1, nonground / 2, nonground / 3, nonvar / 1, var / 1"},"acyclic_term/1":{"prefix":"acyclic_term","body":"acyclic_term(${1:Term})$2\n$0","description":"acyclic_term(?Term)\n\n   Succeeds if Term is acyclic (finite)\n\nArguments\n   Term    Arbitrary term\n\nType\n   Type Testing\n\nDescription\n\tUsed to test whether Term is acyclic (a finite tree).\n\tFails if Term is cyclic (an infinite, rational tree).\n\nModes and Determinism\n   acyclic_term(?) is semidet\n\nFail Conditions\n   Fails if Term is cyclic\n\nExamples\n   \n    ?- X = f(f(a)), acyclic_term(X).\n    X = f(f(a))\n    Yes (0.00s cpu)\n\n    ?- X = f(X), acyclic_term(X).\n    No (0.00s cpu)\n\n    % could be used to simulate occurs check\n    unify_with_occurs_check(X, X) :- acyclic_term(X).\n\nSee Also"},"update_struct/4":{"prefix":"update_struct","body":"update_struct(${1:StructName}, ${2:FieldList}, ${3:OldStruct}, ${4:NewStruct})$5\n$0","description":"update_struct(+StructName, +FieldList, ?OldStruct, ?NewStruct)\n\n   NewStruct is the same as OldStruct except that the fields in FieldList have been replaced\n\nArguments\n   StructName    An atom (the structure name)\n   FieldList    A list of name:Value structures, or one such structure\n   OldStruct    Structure or variable\n   NewStruct    Variable or structure\n\nType\n   Term Manipulation\n\nDescription\n\tThis predicate is only useful together with structure declarations.\n\tIts purpose is to allow updating a structure's fields (by creating\n\ta new, updated structure) without having to know all the fields of\n\tthe structure, or its arity.\n\n\tupdate_struct/4 creates a new structure NewStruct which is identical\n\tto another structure OldStruct, except that the fields listed\n\tin FieldList contain the values in FieldList, while all fields not\n\tmentioned in FieldList retain the same values in OldStruct and\n\tNewStruct.\n\n\tupdate_struct/4 is usually expanded at compile time into two\n\tsimple, efficient unifications (see example).\n\nModes and Determinism\n   update_struct(+, +, +, -) is det\n   update_struct(+, +, -, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StructName or FieldList is a variable\n     4 --- A member of FieldList (or its tail) is insufficiently instantiated\n     5 --- StructName is not an atom, or FieldList is not a proper list\n     5 --- An Element of FieldList is not an atom:term structure\n     6 --- StructName is not the name of a declared, visible structure\n     6 --- A field name in FieldList is not a field of the structure denoted by StructName\n\nExamples\n   \n    ?- local struct(person(name,address,age,salary)).\n    yes.\n\n    ?- Old = person{name:john,salary:4000,address:here,age:30},\n       update_struct(person, [salary:5000,address:there], Old, New).\n\n    Old = person(john, here, 30, 4000)\n    New = person(john, there, 30, 5000)\n    yes.\n\n    ?- update_struct(person, [salary:5000], Old, New).\n\n    Old = person(_244, _245, _246, _247)\n    New = person(_244, _245, _246, 5000)\n    yes.\n\n    % Compilation: The code\n\n    set_salary(Old, New, NewSalary) :-\n    \tupdate_struct(person, [salary:NewSalary], Old, New).\n\n    % is compiled into\n\n    set_salary(Old, New, NewSalary) :-\n\tOld = person(X1, X2, X3, _),\n\tNew = person(X1, X2, X3, NewSalary).\n\nSee Also\n   struct / 1, = / 2"},"breal/1":{"prefix":"breal","body":"breal(${1:Breal})$2\n$0","description":"breal(?Breal)\n\n   Succeeds if Breal is a bounded real number.\n\nArguments\n   Breal    A term.\n\nType\n   Type Testing\n\nDescription\n\tUsed to test whether a term is a bounded real number.\n\tA bounded real (breal) is conceptually a real number, and it\n\tis represented by a lower and upper bound in floating point\n\tformat.\n\nModes and Determinism\n   breal(?) is semidet\n\nFail Conditions\n   Fails if Breal is not a bounded real number\n\nExamples\n   \nSuccess:\n    ?- breal(0.99__1.01).\n    Yes (0.00s cpu)\n\n    ?- X is breal(pi), breal(X).\n    X = 3.1415926535897927__3.1415926535897936\n    Yes (0.00s cpu)\n\nFail:\n    ?- breal(1.0).\n    No (0.00s cpu)\n\n    ?- breal(1).\n    No (0.00s cpu)\n\n    ?- breal(\"hello\").\n    No (0.00s cpu)\n\nSee Also\n   atomic / 1, integer / 1, number / 1, float / 1, real / 1, rational / 1, breal / 2"},"atomic/1":{"prefix":"atomic","body":"atomic(${1:Term})$2\n$0","description":"atomic(?Term)\n\n   Succeeds if Term is an atom, a number, or a string.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n\n\tUsed to test whether Term is an atomic term.\n\tThis is the negation of compound/1.\n\nModes and Determinism\n   atomic(?) is semidet\n\nFail Conditions\n   Fails if Term is not an atom, a number or a string\n\nExamples\n   \nSuccess:\n    atomic(atom).\n    atomic(1.4).\n    atomic(3).\n    atomic(\"Hello world\").\n    atomic([]).\n\nFail:\n    atomic([1,3,3,6]).\n    atomic(this(is,a,structure)).\n    atomic(X).\n\nSee Also\n   atom / 1, compound / 1, is_list / 1, is_array / 1, var / 1"},"atom/1":{"prefix":"atom","body":"atom(${1:Atom})$2\n$0","description":"atom(?Atom)\n\n   Succeeds if Atom is a Prolog atom.\n\nArguments\n   Atom    Prolog term.\n\nType\n   Type Testing\n\nDescription\n\n    Used to test whether Atom is an atom.\n    Note that this includes the empty list [].\n\nModes and Determinism\n   atom(?) is semidet\n\nFail Conditions\n   Fails if Atom is not an atom\n\nExamples\n   \nSuccess:\n    atom(atom).\n    atom('Anything').\n    atom(*).\n    atom([]).\n    atom(#).\n    atom($).\n    atom(/).\n    atom(\\).\n\nFail:\n    atom(1).\n    atom(this(is,a,structure)).\n    atom(X).\n\nSee Also\n   var / 1, is_list / 1, is_array / 1, callable / 1, type_of / 2"},"compound/1":{"prefix":"compound","body":"compound(${1:Term})$2\n$0","description":"compound(?Term)\n\n   Succeeds if Term is of type compound, i.e.  a structure or a list.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\nUsed to test whether Term is a compound term.\n\tCompound terms have an arity greater than zero.\n\tThis test is the negation of atomic/1.\n\nModes and Determinism\n   compound(?) is semidet\n\nFail Conditions\n   Fails if Term is not a compound term\n\nExamples\n   \n   Success:\n   compound(f(1,2)).\n   compound(f(_,_)).\n   compound([1,2,3]).\n   compound(.(1,2)).\n   compound(f/1).\n   compound(1+2).\n   compound(1+2).\n   Fail:\n   compound(\"f(1,2)\").\n   compound(Term).\n   compound(atom).\n\nSee Also\n   atom / 1, atomic / 1, callable / 1, is_list / 1, is_array / 1, var / 1"},"callable/1":{"prefix":"callable","body":"callable(${1:Term})$2\n$0","description":"callable(?Term)\n\n   Succeeds if Term is callable, i.e. of type atom or compound.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n\nUsed to test whether Term is a 'callable' term, i.e. whether it\nis an atom or compound term, and could therefore be used as a goal.\nNote that this is a purely syntactic check which does not say\nanything about the existence of a corresponding predicate.\n\nThis predicate is equivalent to\n\n    callable(X) :- atom(X).\n    callable(X) :- compound(X).\n\nNote that it also succeeds for lists.\n\nModes and Determinism\n   callable(?) is semidet\n\nFail Conditions\n   Fails if Term is not an atom or a compound term\n\nExamples\n   \nSuccess:\n   callable(true).\n   callable(hello(\"world\",42)).\n   callable(f(1,2)).\n   callable([1,2,3]).\n   callable(.(1,2)).\n   callable(foo).\n   callable([]).\n\nFail:\n   callable(\"f(1,2)\").\n   callable(_).\n   callable(42).\n   make_suspension(true,0,S), callable(S).\n\nSee Also\n   atom / 1, compound / 1, is_list / 1, is_array / 1, var / 1"},"current_functor/1":{"prefix":"current_functor","body":"current_functor(${1:PredSpec})$2\n$0","description":"current_functor(?PredSpec)\n\n   Succeeds if PredSpec is a functor known to the system.\n\nArguments\n   PredSpec    Functor in the form Name/Arity or variable.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether PredSpec is a functor known to the system or to\n   return all functors defined.\n\n   Note that PredSpec is specified in the format Name/Arity and may be\n   specified with Name as an atom or variable and/or Arity as an integer or\n   variable.\n\nModes and Determinism\n   current_functor(++) is semidet\n   current_functor(-) is multi\n\nFail Conditions\n   Fails if PredSpec is not a currently known functor\n\nExceptions\n     5 --- PredSpec is instantiated but not in the format Atom /    Integer\n\nExamples\n   \nSuccess:\n   current_functor(findall/N).\n   current_functor(N/4).\n   current_functor((',')/2).\n\n   [eclipse]: current_functor(X).\n\n   X = '' / 0     More? (;)\n\n   X = findall / 0     More? (;)\n\n   X = findall / 3     More? (;)\n\n   X = at_eof_handler / 0     More? (;)    % RETURN pressed\n   yes.\n   [eclipse]:\n\nFail:\n   current_functor(myfunctor/100).\n\nError:\n   current_functor(abc)    Error 5.\n   current_functor(man(1)).       Error 5.\n\nSee Also\n   atom / 1, current_atom / 1, current_op / 3"},"current_atom/1":{"prefix":"current_atom","body":"current_atom(${1:Atom})$2\n$0","description":"current_atom(?Atom)\n\n   Succeeds if Atom is an atom in the system.\n\nArguments\n   Atom    Atom or variable.\n\nType\n   Type Testing\n\nDescription\n   Used to return all currently defined atoms.\n\n   Note that once an atom name is specified for the first time it is\n   automatically made known to the system, so calls to current_atom/1 with\n   any atom as an argument will always succeed.\n\nModes and Determinism\n   current_atom(+) is det\n   current_atom(-) is multi\n\nExceptions\n     5 --- Atom is not instantiated to an atom.\n\nExamples\n   \nSuccess:\n   current_atom(eclipse).\n   current_atom(anything).\n   current_atom('My atom').\n\n   [eclipse]: current_atom(X).\n\n   X = []    More? (;)    % RETURN pressed\n   yes.\n   [eclipse]:\n\nError:\n   current_atom(1).    Error 5.\n   current_atom(man(1)).      Error 5.\n\nSee Also\n   atom / 1, current_functor / 1"},"float/1":{"prefix":"float","body":"float(${1:Real})$2\n$0","description":"float(?Real)\n\n   Succeeds if Real is a floating point number.\n\nArguments\n   Real    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Real is a floating point number.\n\nModes and Determinism\n   float(?) is semidet\n\nFail Conditions\n   Fails if Real is not a floating point number\n\nExamples\n   \n   Success:\n   float(1.0).\n   float(3e27).\n   Fail:\n   float(1).\n   float('1.0').\n   float(X).\n\nSee Also\n   atomic / 1, integer / 1, number / 1, rational / 1, breal / 1, real / 1"},"free/1":{"prefix":"free","body":"free(${1:Var})$2\n$0","description":"free(?Var)\n\n   Succeeds if Var is a free variable, not an attributed one.\n\nArguments\n   Var    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Var is a free variable.  free/1 is like var/1 but\n   does not succeed for attributed variables.\n\n   CAUTION: is it usually a mistake to distinguish between free and attributed\n   variables, because variables can have several unrelated attributes (for\n   example, some attributes are only for debugging purposes and should not\n   affect the program behaviour at all). Correct code should check for the\n   presence or absence of a particular attribute, and only use the free/1\n   test as a shortcut for detecting the absence of any attribute, e.g.\n\n    add_my_attribute_if_needed(X) :-\n    free(X),\n    % X has no attributes at all: add my one\n    add_attribute(X, my_attribute).\n    add_my_attribute_if_needed(X{my_attr:Attr}) ?-\n    ( var(Attr) ->\n    % X has attributes, but not my one: add it\n    add_attribute(X, my_attribute)\n    ;\n    % X already has my attribute: do nothing\n    true\n    ).\n\nModes and Determinism\n   free(?) is semidet\n\nFail Conditions\n   Fails if Var is instantiated or an attributed variable\n\nExamples\n   \nSuccess:\n      free(X).\n      free(_abc).\n      free(_).\n\nFail:\n      free(X{a}).\n      suspend:(X>0), free(X).\n      var(atom).\n      var('Abc').\n\nSee Also\n   nonground / 1, nonvar / 1, meta / 1, type_of / 2, var / 1"},"integer/1":{"prefix":"integer","body":"integer(${1:Integer})$2\n$0","description":"integer(?Integer)\n\n   Succeeds if Integer is an integer number.\n\nArguments\n   Integer    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Integer is of type integer.\n\nModes and Determinism\n   integer(?) is semidet\n\nFail Conditions\n   Fails if Integer is not an integer number\n\nExamples\n   \n   Success:\n   integer(10).\n   integer(-40).\n   Fail:\n   integer(3.14).\n   integer('4').\n   integer(Integer).\n\nSee Also\n   integer_atom / 2, number / 1, float / 1, real / 1, rational / 1, breal / 1"},"ground/1":{"prefix":"ground","body":"ground(${1:Term})$2\n$0","description":"ground(?Term)\n\n   Succeeds if Term is ground.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n\n\tUsed to test whether Term is ground, i.e. contains no variables.\n\tThis is the negation of nonground/1.\n\nModes and Determinism\n   ground(?) is semidet\n\nFail Conditions\n   Fails if Term is not ground\n\nExamples\n   \n   Success:\n   ground(atom).\n   ground(likes(mouse,cheese)).\n   Fail:\n   ground(VarTerm).\n   ground(f(a,B,c)).\n   ground([x,y|Z]).\n\nSee Also\n   nonvar / 1, nonground / 1, nonground / 2, nonground / 3, type_of / 2, var / 1"},"get_var_info/3":{"prefix":"get_var_info","body":"get_var_info(${1:Var}, ${2:InfoName}, ${3:Value})$4\n$0","description":"get_var_info(?Var, ?InfoName, -Value)\n\n   Succeeds if Var is an uninstantiated variable, InfoName is a valid\ninformation name and the information value Value unifies with the value of\nthe information.\n\nArguments\n   Var    Prolog Term, usually a variable.\n   InfoName    Atom or variable.\n   Value    Atom or variable.\n\nType\n   Type Testing\n\nDescription\n   This predicate is used to test the type of a free variable or to get its\n   source name (when available).\n\n   The possible values for InfoName are type or name.\n\n   If InfoName unifies with name, the predicate will succeed if the source\n   name of the free variable Var is available and unifies with Value.\n\n   If InfoName unifies with type, the predicate will succeed if Value\n   unifies with the type of the variable Var.\n\n   The possible types are:\n\n    meta      an attributed variable (metaterm)\n    free      a free variable\n\nModes and Determinism\n   get_var_info(?, +, -) is semidet\n   get_var_info(?, -, -) is semidet\n\nFail Conditions\n   Fails if Var is not a variable\n\nExceptions\n     5 --- InfoName or Value is neither an atom nor a variable.\n     6 --- InfoName is not an information name.\n\nExamples\n   \nSuccess:\n      ?- suspend:(Var1 > Var2), get_var_info(Var1, Info, Value).\n      Var2 = Var2\n      Var1 = Var1\n      Info = name\n      Value = 'Var1'\n      Delayed goals:\n       Var1 > Var2     More? (;)\n\n      Var2 = Var2\n      Var1 = Var1\n      Info = type\n      Value = meta\n\n      Delayed goals:\n       Var1 > Var2\n      yes.\n\n      ?- get_var_info(Var1, type, Type).\n      Var1 = Var1\n      Type = free\n      yes.\n\n      ?- set_flag(variable_names,off).\n      yes.\n\n      ?- get_var_info(Var1, name, Name).\n      no (more) solution.\n\nFail:\n      get_var_info(atom, name, Name).\n      set_flag(variable_names, off),\n    get_var_info(X, name, Name).\n\nError:\n      get_var_info(X, not_an_info, Y).    (Error 6)\n      get_var_info(X, type, 123).    (Error 5)\n\nSee Also\n   set_flag / 2, type_of / 2, var / 1"},"is_event/1":{"prefix":"is_event","body":"is_event(${1:Term})$2\n$0","description":"is_event(?Term)\n\n   Succeeds if Term is an event name or handle\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is either an event name (an atom) or an event\n   handle (a special kind of handle as created by event_create/3).\n\nModes and Determinism\n   is_event(?) is semidet\n\nFail Conditions\n   Fails if Term is neither an atom nor an event handle\n\nExamples\n   \n\n    ?- is_event(my_event).\n    Yes (0.00s cpu)\n\n    ?- event_create(true, [], E), is_event(E).\n    E = 'EVENT'(16'edc90b18)\n    Yes (0.00s cpu)\n\n    ?- bag_create(B), is_event(B).\n    No (0.00s cpu)\n\n    ?- is_event(_).\n    No (0.00s cpu)\n\n    ?- is_event(42).\n    No (0.00s cpu)\n\nSee Also\n   event / 1, atom / 1, is_handle / 1, event_create / 3, type_of / 2"},"is_array/1":{"prefix":"is_array","body":"is_array(${1:Term})$2\n$0","description":"is_array(?Term)\n\n   Succeeds if Term is an array.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is an array, i.e. a term with functor []/N.\n   Could be defined as:\n\n\tis_array(X) :- nonvar(X), functor(X, [], _).\n\n   Note that this includes the empty array [].\n\nModes and Determinism\n   is_array(?) is semidet\n\nFail Conditions\n   Fails if Term is not an array\n\nExamples\n   \n    ?- is_array([]).\n    Yes (0.00s cpu)\n\n    ?- is_array([](1,2,3)).\n    Yes (0.00s cpu)\n\n    ?- is_array([1,2,3]).\n    No (0.00s cpu)\n\n    ?- is_array(f(1,2)).\n    No (0.00s cpu)\n\n    ?- is_array(foo).\n    No (0.00s cpu)\n\n    ?- is_array(_).\n    No (0.00s cpu)\n\nSee Also\n   atom / 1, callable / 1, compound / 1, is_list / 1, ground / 1"},"is_handle/1":{"prefix":"is_handle","body":"is_handle(${1:Term})$2\n$0","description":"is_handle(?Term)\n\n   Succeeds if Term is an external data handle.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is a handle for external data.\n   Such handles can be created by external predicates using the\n   ECLiPSe C or C++ API.\n\nModes and Determinism\n   is_handle(?) is semidet\n\nFail Conditions\n   Fails if Term is not an external data handle\n\nExamples\n   \n\n    ?- bag_create(B), is_handle(B).\n    B = 'BAG'(16'edc90b18)\n    Yes (0.00s cpu)\n\n    ?- is_handle(_).\n    No (0.00s cpu)\n\n    ?- is_handle(42).\n    No (0.00s cpu)\n\nSee Also\n   is_event / 1, type_of / 2, xget / 3, xset / 3"},"is_list/1":{"prefix":"is_list","body":"is_list(${1:Term})$2\n$0","description":"is_list(?Term)\n\n   Succeeds if Term is a proper list.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is a proper list, i.e. either the empty list,\n   of a list element whose tail is itself a proper list.  The predicate\n   could be recursively defined as:\n\n\tis_list(X) :- var(X), !, fail.\n\tis_list([_|Xs]) :- is_list(Xs).\n\tis_list([]).\n\n   The complexity of this operation is linear in the length of the list.\n\nModes and Determinism\n   is_list(?) is semidet\n\nFail Conditions\n   Fails if Term is not a proper list\n\nExamples\n   \n    ?- is_list([]).\n    Yes (0.00s cpu)\n\n    ?- is_list([1,2,3]).\n    Yes (0.00s cpu)\n\n    ?- is_list([1,2|3]).   % illegal tail\n    No (0.00s cpu)\n\n    ?- is_list([1,2|_]).   % open-ended list\n    No (0.00s cpu)\n\n    ?- is_list(list).\n    No (0.00s cpu)\n\n    ?- is_list(42).\n    No (0.00s cpu)\n\n    ?- is_list(X).\n    No (0.00s cpu)\n\nSee Also\n   atom / 1, callable / 1, compound / 1, is_array / 1, ground / 1"},"is_suspension/1":{"prefix":"is_suspension","body":"is_suspension(${1:Term})$2\n$0","description":"is_suspension(?Term)\n\n   Succeeds if Term is a sleeping suspension.\n\nArguments\n   Term    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is a sleeping suspension, i.e.  a suspension\n   that has not yet been executed.  type_of/2 can be used to test for a\n   sleeping or executed suspension.\n\nModes and Determinism\n   is_suspension(?) is semidet\n\nFail Conditions\n   Fails if Term is not a sleeping suspension\n\nExamples\n   \nSuccess:\n      make_suspension(true, 2, S), is_suspension(S).\n\nFail:\n      is_suspension(X).\n\n      is_suspension(a).\n\n      make_suspension(true, 2, S), schedule_suspensions(1, s(S)),\n      wake, is_suspension(S).\n\nSee Also\n   type_of / 2, make_suspension / 3, schedule_suspensions / 2, suspensions / 1, suspensions / 2"},"nonground/3":{"prefix":"nonground","body":"nonground(${1:N}, ${2:Term}, ${3:VarList})$4\n$0","description":"nonground(+N, ?Term, -VarList)\n\n   Succeeds if Term contains at least N different variables, and returns N of\nthem in the list VarList.\n\nArguments\n   N    Integer.\n   Term    Prolog term.\n   VarList    List or variable.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term contains at least N different variables.  The\n   argument VarList is unified with a list of exactly N of those variables.\n   If Term contains more than N variables, it is not further specified\n   which ones will be in the list and in which order.  As usual, attributed\n   variables are also considered variables.\n\n   Note that this predicate is a generalisation of nonground/1 and\n   nonground/2 which could be written as:\n\n    nonground(Term) :- nonground(1, Term, _).\n    nonground(Term, Var) :- nonground(1, Term, [Var]).\n\nModes and Determinism\n   nonground(+, ?, -) is semidet\n\nFail Conditions\n   Fails if Term contains less than N variables\n\nExceptions\n     4 --- N is not instantiated.\n     5 --- VarList instantiated but not to a list.\n     6 --- N is not positive.\n\nExamples\n   \nSuccess:\n    nonground(1, Term, L).       % gives L = [Term]\n    nonground(1, f(a,B,c), L).   % gives L = [B]\n    nonground(2, [X,Y,Z], L).    % gives L = [Y,X]\n    nonground(2, [X,Y,Z], L).    % gives L = [Y,X]\n    nonground(1, s(X{a}), L).    % gives L = [X{a}]\n\nFail:\n    nonground(1, atom, L).\n    nonground(2, f(a,B,c), L).\n    nonground(2, [X,X,X], L).\n\nSee Also\n   nonground / 1, nonground / 2, nonvar / 1, var / 1"},"nonground/1":{"prefix":"nonground","body":"nonground(${1:VarTerm})$2\n$0","description":"nonground(?VarTerm)\n\n   Succeeds if VarTerm is not ground.\n\nArguments\n   VarTerm    Prolog term.\n\nType\n   Type Testing\n\nDescription\n\n    Used to test whether VarTerm is not ground i.e. whether it is itself a\n    variable, or it has at least one subterm that is a uninstantiated variable.\n    This is the negation of ground/1.\n\nModes and Determinism\n   nonground(?) is semidet\n\nFail Conditions\n   Fails if VarTerm is ground\n\nExamples\n   \n   Success:\n   nonground(VarTerm).\n   nonground(f(a,B,c)).\n   nonground([x,y|Z]).\n   Fail:\n   nonground(atom).\n   nonground(likes(man,woman)).\n\nSee Also\n   nonvar / 1, ground / 1, nonground / 2, nonground / 3, type_of / 2, var / 1"},"nonground/2":{"prefix":"nonground","body":"nonground(${1:Term}, ${2:Variable})$3\n$0","description":"nonground(?Term, -Variable)\n\n   Succeeds if Term is not a ground term and binds Variable to one of the\nvariables inside Term.\n\nArguments\n   Term    Prolog term.\n   Variable    A variable.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Term is not ground i.e. whether it contains at\n   least one uninstantiated variable.  The argument Variable is unified with one of\n   the variables inside Term, i.e. with one of the responsibles for its\n   non-groundness.  When Term contains several variables, it is not\n   specified which one will be returned as Variable.  As usual, attributed\n   variables are also considered variables.\n\nModes and Determinism\n   nonground(?, -) is semidet\n\nFail Conditions\n   Fails if Term is ground\n\nExamples\n   \nSuccess:\n    nonground(Term, V).       % unifies V with Term\n    nonground(f(a,B,c), V).   % unifies V with B\n    nonground([x,Y|Z], V).    % unifies V with Y or Z\n    nonground(s(X{a}), V).    % unifies V with X{a}\n\nFail:\n    nonground(atom, V).\n    nonground(likes(man, woman), V).\n\nSee Also\n   nonground / 1, nonground / 3, nonvar / 1, var / 1"},"meta/1":{"prefix":"meta","body":"meta(${1:Var})$2\n$0","description":"meta(?Var)\n\n   Succeeds if Var is an attributed variable.\n\nArguments\n   Var    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Var is an attributed variable.\n\n   CAUTION: this test only detects the presence of any attribute, which is\n   usually not what is required. It is more common to check for the presence\n   of a particular attribute by using a matching clause of the form:\n\n    has_my_attribute(_{my_attr:Attr}) ?-\n    \tnonvar(Attr).\n\nModes and Determinism\n   meta(?) is semidet\n\nFail Conditions\n   Fails if Var is not an attributed variable\n\nExamples\n   \nSuccess:\n      meta(X{a}).\n      suspend:(X>0), meta(X).\n\nFail:\n      meta(atom).\n      meta(X).\n\nSee Also\n   free / 1, type_of / 2, var / 1"},"nonvar/1":{"prefix":"nonvar","body":"nonvar(${1:Term})$2\n$0","description":"nonvar(?Term)\n\n   Succeeds if Term is instantiated.\n\nArguments\n   Term    Any Prolog term.\n\nType\n   Type Testing\n\nDescription\n\n    Used to test whether Term is instantiated.  This is the negation of var/1,\n    i.e. it succeeds if Term is not an uninstantiated variable.\n    Note that it also succeeds if Term is a partially instantiated term,\n    i.e. a compound term with at least one uninstantiated subterm.\n\nModes and Determinism\n   nonvar(?) is semidet\n\nFail Conditions\n   Fails if Term is not instantiated\n\nExamples\n   \n   Success:\n   nonvar(atom).\n   nonvar(33).\n   nonvar(foo(3)).\n   nonvar(foo(_)).\n   nonvar([_|_]).\n   Fail:\n   nonvar(Var).\n\nSee Also\n   nonground / 1, type_of / 2, var / 1"},"number/1":{"prefix":"number","body":"number(${1:Number})$2\n$0","description":"number(?Number)\n\n   Succeeds if Number is a number.\n\nArguments\n   Number    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Number is a number.  number/1 could be defined as\n\n   number(X) :- integer(X).\n   number(X) :- rational(X).\n   number(X) :- float(X).\n   number(X) :- breal(X).\n\nModes and Determinism\n   number(?) is semidet\n\nFail Conditions\n   Fails if Number is not a number\n\nExamples\n   \n   Success:\n   number(10).\n   number(-21.0).\n   number(1_3).\n   number(3e27).\n   Fail:\n   number(pi).\n   number(e).\n   number('-21.0').\n   number(X).\n   number(fred).\n\nSee Also\n   atomic / 1, integer / 1, breal / 1, rational / 1, float / 1, real / 1"},"rational/1":{"prefix":"rational","body":"rational(${1:Rational})$2\n$0","description":"rational(?Rational)\n\n   Succeeds if Rational is a rational number.\n\nArguments\n   Rational    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Rational is a rational number.\n\nModes and Determinism\n   rational(?) is semidet\n\nFail Conditions\n   Fails if Rational is not a rational number\n\nExamples\n   \n   Success:\n   rational(1_3).\n   set_flag(prefer_rationals, on), X is 1/3, rational(X).\n   Fail:\n   rational(1).\n   rational(1.0).\n   rational('1.0').\n   rational(a).\n   rational(X).\n\nSee Also\n   atomic / 1, integer / 1, number / 1, float / 1, real / 1, breal / 1"},"string/1":{"prefix":"string","body":"string(${1:String})$2\n$0","description":"string(?String)\n\n   Succeeds if String is a string.\n\nArguments\n   String    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether String is a string.\n\nModes and Determinism\n   string(?) is semidet\n\nFail Conditions\n   Fails if String is not a string\n\nExamples\n   \n   Success:\n   string(\"astring\").\n   Fail:\n   string('astring').\n   string(X).\n\nSee Also\n   atom / 1, atomic / 1, var / 1"},"real/1":{"prefix":"real","body":"real(${1:Real})$2\n$0","description":"real(?Real)\n\n   Succeeds if Real is a real (float or breal) number.\n\nArguments\n   Real    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Real is a real number, i.e.\n\teither a floating point number (float) or a bounded real number\n\t(breal). It could be defined as:\n\n   real(X) :- float(X).\n   real(X) :- breal(X).\n\nModes and Determinism\n   real(?) is semidet\n\nFail Conditions\n   Fails if Real is not a real number\n\nExamples\n   \n   Success:\n   real(1.0).\n   real(0.99__1.01).\n   real(3e27).\n   real(1e300__1.0Inf).\n   Fail:\n   real(1).\n   real('1.0').\n   real(X).\n\nSee Also\n   atomic / 1, float / 1, integer / 1, number / 1, rational / 1, breal / 1"},"type_of/2":{"prefix":"type_of","body":"type_of(${1:Term}, ${2:Type})$3\n$0","description":"type_of(?Term, -Type)\n\n   Succeeds if Type is the data type of the term Term.\n\nArguments\n   Term    Prolog term.\n   Type    Atom or variable.\n\nType\n   Type Testing\n\nDescription\n   The type of the term Term is unified with Type.\n\n   The types are atoms from the set: string, atom, var, integer, rational,\n   float, breal, compound, handle, goal.\n\nModes and Determinism\n   type_of(?, -) is det\n\nExceptions\n     5 --- Type is instantiated, but not to an atom.\n\nExamples\n   \nSuccess:\n      type_of(X,T).    (gives T=var).\n      type_of([1,2],T).     (gives T=compound).\n      type_of([],atom).\n      type_of(#,atom).\n      type_of($,atom).\n      type_of(*,atom).\n      type_of(/,atom).\n      type_of(\\,atom).\n      type_of(\"a\",string).\n      type_of(1,integer).\n      type_of(123456789012345,integer).\n      type_of(1_3,rational).\n      type_of(1.0,float).\n      type_of(0.99__1.01,breal).\n      type_of(a(b),compound).\n      bag_create(B), type_of(B, handle).\n      record(k, a), recorded(k, _, R), type_of(R, handle).\n      make_suspension(true,3,S), type_of(S, goal).\nFail:\n      type_of(2.0,integer).\n      type_of(2.0,float).\nError:\n      type_of(2,\"atom\").  (Error 5).\n\nSee Also\n   atom / 1, callable / 1, compound / 1, free / 1, integer / 1, meta / 1, number / 1, nonground / 1, breal / 1, rational / 1, float / 1, float / 1, real / 1, string / 1, var / 1"},"var/1":{"prefix":"var","body":"var(${1:Var})$2\n$0","description":"var(?Var)\n\n   Succeeds if Var is a variable or an attributed variable.\n\nArguments\n   Var    Prolog term.\n\nType\n   Type Testing\n\nDescription\n   Used to test whether Var is a variable or an attributed variable.  The\n   difference between var/1 and free/1 is that var/1 succeeds on attributed\n   variables as well.\n\n   var/1 could be defined as\n\n    var(X) :- free(X).\n    var(X) :- meta(X).\n\nModes and Determinism\n   var(?) is semidet\n\nFail Conditions\n   Fails if Var is instantiated\n\nExamples\n   \nSuccess:\n      var(X).\n      var(_abc).\n      var(_).\n      var(X{a}).\n      suspend:(X>0), var(X).\n\nFail:\n      var(atom).\n      var('Abc').\n\nSee Also\n   free / 1, meta / 1, nonground / 1, nonvar / 1, type_of / 2"},"concat_atoms/3":{"prefix":"concat_atoms","body":"concat_atoms(${1:Src1}, ${2:Src2}, ${3:Dest})$4\n$0","description":"concat_atoms(+Src1, +Src2, -Dest)\n\n   Succeeds if Dest is the concatenation of Src1 and Src2.\nIt is more efficient to use concat_strings/3 whenever possible.\n\nArguments\n   Src1    Atom.\n   Src2    Atom.\n   Dest    Atom or variable.\n\nType\n   Strings and Atoms\n\nDescription\n   Dest is unified with the concatenation of Src1 and Src2.\n   The use of this predicate is discouraged in favour of concat_strings/3,\n   because the creation of new atoms involves entering them into a\n   dictionary whose garbage collection is relatively expensive.\n\nModes and Determinism\n   concat_atoms(+, +, -) is det\n\nExceptions\n     4 --- Either (or both) of Src1 and Src2 is not instantiated    (non-coroutine mode only).\n     5 --- Either (or both) of Src1 and Src2 is instantiated, but not    to an atom.\n     5 --- Dest is neither an atom nor a variable.\n\nExamples\n   \nSuccess:\n      concat_atoms(abc,def,abcdef).\n\n      [eclipse]: [user].\n       filename(File,Full) :-\n    name(File,L),\n    member(0'.,L) -> Full = File ;\n    concat_atoms(File,'.pl',Full).\n       user compiled 208 bytes in 0.00 seconds\n      yes.\n      [eclipse]: filename(a,P), filename('b.pl',F).\n      P = 'a.pl'\n      F = 'b.pl'\n      yes.\n\nFail:\n      concat_atoms(ab,bc,abc).\n\nError:\n      concat_atoms(art,X,artpaul).      (Error 4).\n      concat_atoms(art,\"paul\",X).       (Error 5).\n\nSee Also\n   concat_strings / 3, append_strings / 3, atom_string / 2"},"stored_keys/2":{"prefix":"stored_keys","body":"stored_keys(${1:StoreHandle}, ${2:Keys})$3\n$0","description":"stored_keys(+StoreHandle, -Keys)\n\n   Retrieve all keys stored in a store object\n\nArguments\n   StoreHandle    A store handle or store name\n   Keys    A variable or list\n\nType\n   Non-logical Variables, Arrays, Bags, Shelves and Stores\n\nDescription\n\tThis retrieves a list of all keys under which entries are stored\n\tin the given store object. If the store is empty, the empty list\n\tis returned.\n\n\tThe order of the keys in the returned list is undefined.\n\n\tThe complexity of this operation is linear in the size of all keys,\n\tsince they need to be copied.\n\n\tNote: If StoreHandle is not a handle, then it must be an atom or a\n\tcompound term, and the store is identified by this term's toplevel\n\tfunctor together with the context module.\n    \n\nModes and Determinism\n   stored_keys(+, -) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- StoreHandle is uninstantiated\n     5 --- StoreHandle is neither atom nor compound term nor store handle\n    45 --- StoreHandle is not the name of a store\n\nExamples\n   \n\n    ?- store_create(Handle),\n       store_set(Handle, tom, 12345),\n       store_set(Handle, name(dick,tracy), phone(42376,home)),\n       store_set(Handle, numbers:prime, [2,3,5,7|_More]),\n       stored_keys(Handle, Keys).\n\n    Handle = 'STORE'(16'003130e8)\n    Keys = [numbers:prime, tom, name(dick, tracy)]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   store / 1, local / 1, store_erase / 1, store_set / 3, store_contains / 2, store_get / 3, store_delete / 2, stored_keys_and_values / 2, store_create / 1, store_count / 2"},"apply:apply/2":{"prefix":"apply","body":"apply(${1:Term}, ${2:Args})$3\n$0","description":"apply(?Term, ?Args)\n\n   The apply/2 higher-order predicate\n\nArguments\n   Term    An atom or compound term\n   Args    A list of arbitrary terms\n\nType\n   library(apply)\n\nDescription\n\n    Invokes a goal that is formed by appending the elements of the\n    list Args as additional arguments to Term.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    % The following three examples all invoke the goal plus(1,2,X):\n\n    ?- apply(plus, [1,2,X]).\n    X = 3\n\n    ?- apply(plus(1), [2,X]).\n    X = 3\n\n    ?- apply(plus(1,2), [X]).\n    X = 3\n\n    % Error:\n\n    ?- apply(plus(1),[2]).\n    calling an undefined procedure plus(1, 2) in module eclipse\n    Abort"},"apply_macros:apply_macros_desc":{"prefix":"lib","body":"lib(${1:apply_macros})$2\n$0","description":"lib(apply_macros)\n\n    Note that this library is largely superseded by the do-loop construct!\n    \n    A collection of utilities to apply a predicate to\n    all elements of a list resp. all subterm of a term.\n    To avoid performance degradation due to apply/2,\n    they are implemented as macros, i.e. they are specialized\n    into auxiliary predicates without metacalls, and the\n    calls are translated into calls of the auxiliary predicates."},"apply_macros:appnodes/2":{"prefix":"appnodes","body":"appnodes(${1:Pred}, ${2:Term})$3\n$0","description":"appnodes(+Pred, +Term)\n\n   Call Pred on all Subterms of Term (depth-first and left-to-right order)\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"apply_macros:checklist/2":{"prefix":"checklist","body":"checklist(${1:Pred}, ${2:List})$3\n$0","description":"checklist(+Pred, +List)\n\n   Apply a predicate to all list elements\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   checklist(<(0), [1,2,3])."},"apply_macros:fromto/4":{"prefix":"fromto","body":"fromto(${1:From}, ${2:To}, ${3:Step}, ${4:Pred})$5\n$0","description":"fromto(+From, +To, +Step, +Pred)\n\n   Call Pred with the numbers From..To in increments of Step\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"apply_macros:mapargs/3":{"prefix":"mapargs","body":"mapargs(${1:Pred}, ${2:TermIn}, ${3:TermOut})$4\n$0","description":"mapargs(+Pred, +TermIn, ?TermOut)\n\n   Create new term by applying a predicate to all arguments\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   mapargs(atom_string, s(a,b,c), s(\"a\",\"b\",\"c\"))."},"apply_macros:maplist/3":{"prefix":"maplist","body":"maplist(${1:Pred}, ${2:ListIn}, ${3:ListOut})$4\n$0","description":"maplist(+Pred, +ListIn, ?ListOut)\n\n   Create new list by applying a predicate to all list elements\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   maplist(times(3), [1,2,3,4], [3,6,9,12])."},"apply_macros:mapstream/3":{"prefix":"mapstream","body":"mapstream(${1:Pred}, ${2:ListIn}, ${3:ListOut})$4\n$0","description":"mapstream(+Pred, ?ListIn, ?ListOut)\n\n   Like maplist/3, but delays if ListIn is not complete\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"apply_macros:selectlist/3":{"prefix":"selectlist","body":"selectlist(${1:Pred}, ${2:ListIn}, ${3:ListOut})$4\n$0","description":"selectlist(+Pred, +ListIn, ?ListOut)\n\n   Creates output list of all list elements that pass a given test\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   selectlist(<(0), [1,0,-2,3], [1,3])."},"apply_macros:sumargs/4":{"prefix":"sumargs","body":"sumargs(${1:Pred}, ${2:Term}, ${3:AccIn}, ${4:AccOut})$5\n$0","description":"sumargs(+Pred, +Term, ?AccIn, ?AccOut)\n\n   Call Pred on all arguments of Term and collect a result in Accumulator\n\nType\n   library(apply_macros)\n\nDescription\nThe traversal order is unspecified!\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"apply_macros:sumlist/4":{"prefix":"sumlist","body":"sumlist(${1:Pred}, ${2:List}, ${3:AccIn}, ${4:AccOut})$5\n$0","description":"sumlist(+Pred, +List, ?AccIn, ?AccOut)\n\n   Call Pred on all element of List and collect a result in Accumulator\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n\tsumlist(plus, [1,2,3,4], 1, 10).\n\tsumlist(times, [1,2,3,4], 1, 24)."},"apply_macros:sumnodes/4":{"prefix":"sumnodes","body":"sumnodes(${1:Pred}, ${2:Term}, ${3:AccIn}, ${4:AccOut})$5\n$0","description":"sumnodes(+Pred, +Term, ?AccIn, ?AccOut)\n\n   Call Pred on all Subterms of Term and collect a result in Accumulator\n\nType\n   library(apply_macros)\n\nDescription\nThe traversal is depth-first and left-to-right\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n\tsumnodes(vars, s(1,t(X,2),[Y]), [], [X,Y]).\n\twhere\n\t    vars(X, Vars, [X|Vars]) :- var(X), !.\n\t    vars(_, Vars, Vars).\n\n\tor even more elegant using grammar rules:\n\n\tsumnodes(vars, s(1,t(X,2),[Y]), [X,Y], []).\n\twhere\n\t    vars(X) --> {var(X)} -> [X];[]."},"asm:asm/2":{"prefix":"asm","body":"asm(${1:PredSpec}, ${2:WAMCode})$3\n$0","description":"asm(+PredSpec, +WAMCode)\n\n   Assemble the WAM instructions WAMCode into ECLiPSe as predicate PredSpec. \n\nArguments\n   +PredSpec    Atom/Integer.\n   +WAMCode    A list of WAM instructions in the right format.\n\nType\n   library(asm)\n\nDescription\n   Assembles the WAM instruction WAMCode into the current ECLiPSe session\n   as the predicate PredSpec. The WAM code is in the form of a list, with\n   each element representing one WAM instruction. The format of the WAMCode\n   is the same as that generated by disasm/2,3. Thus the predicate can be\n   used to load a predicate previously dissasembled by disasm/2,3 without\n   having to compile the source Prolog form of the predicate.\n\n   If PredSpec is an existing defined predicate, the older definition will\n   be replaced. If WAMCode is not in the correct format, an exception will\n   be generated and the predicate PredSpec would not be redefined. \n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- PredSpec is not in correct form.\n     6 --- WAMCode is not in correct form.  \n\nSee Also\n   asm / 3, disasm / 2, disasm / 3, pasm / 4"},"asm:asm/3":{"prefix":"asm","body":"asm(${1:PredSpec}, ${2:WAMCode}, ${3:Flags})$4\n$0","description":"asm(+PredSpec, +WAMCode, +Flags)\n\n   Assemble the WAM instructions WAMCode into ECLiPSe in module Module as\npredicate PredSpec.  \n\nArguments\n   +PredSpec    Atom/Integer.\n   +WAMCode    A list of WAM instructions in the right format.\n   +Flags    An integer.\n\nType\n   library(asm)\n\nDescription\n   Assembles the WAM instruction WAMCode into the current ECLiPSe session\n   in an existing module Module as the predicate PredSpec. The WAM code is\n   in the form of a list, with each element representing one WAM\n   instruction. The format of the WAMCode is the same as that generated by\n   disasm/2,3. Thus the predicate can be used to load a predicate\n   previously dissasembled by disasm/2,3 without having to compile the\n   source Prolog form of the predicate.\n\n   If PredSpec is an existing defined predicate, the older definition will\n   be replaced. If WAMCode is not in the correct format, an exception will\n   be generated and the predicate PredSpec would not be redefined. \n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- PredSpec or Module is not in correct form.\n     6 --- WAMCode is not in correct form.  \n    80 --- Module is not an existing module.\n\nSee Also\n   asm / 2, disasm / 2, disasm / 3, pasm / 4"},"asm:asm_desc":{"prefix":"lib","body":"lib(${1:asm})$2\n$0","description":"lib(asm)\n\n       The asm library provide tools for assembling and disassembling the WAM\n    code representation of predicates to and from memory. It also allows\n    the formatted printing of the WAM code. This library is used by the\n    fcompile library to generate the object code, which is a form of the\n    WAM code that can be read back in and assembled into the predicates."},"asm:disasm/2":{"prefix":"disasm","body":"disasm(${1:PredSpec}, ${2:WAMCode})$3\n$0","description":"disasm(+PredSpec, ?WAMCode)\n\n   Disassemble an existing predicate PredSpec in the current module to its WAM\nabstract machine representation WAMCode.\n\nArguments\n   +PredSpec    Atom/Integer.\n   ?WAMCode    Variable or a list of WAM instructions in the right format.\n\nType\n   library(asm)\n\nDescription\n   Unifies WAMCode with the WAM instructions representing the abstract\n   machine code for the predicate specified by PredSpec (in Name/Arity\n   form). The WAM code is in the form of a list, with each element\n   representing one WAM instruction. The format of the WAMCode is the same\n   as that used by asm/2,3 and pasm/4 to assemble a predicate. Thus, the\n   WAM code generated by disasm/2,3 can be used to load the predicate into\n   ECLiPSe without having to compile the source Prolog form. \n\n   The library asm must be loaded to use diasm/2.\n\n   Currently asm/2 cannot disassemble dynamic predicates.\n\nFail Conditions\n      Fails if WAMCode is initially instantiated and does not unify with the WAM code generated by asm/1 for the predicate, or if PredSpec is dynamic.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- PredSpec is not in correct form.\n    60 --- PredSpec does not exist in current module.\n\nExamples\n   \n   for fruit/1 defined by:\n\n      fruit(orange).\n\n   ?- disasm(fruit / 1, W).\n   W = [get_atom(a(1), orange), retd, code_end]\n\nSee Also\n   disasm / 3, asm / 2, asm / 3, pasm / 4, wam / 1"},"asm:disasm/3":{"prefix":"disasm","body":"disasm(${1:PredSpec}, ${2:WAMCode}, ${3:Module})$4\n$0","description":"disasm(+PredSpec, ?WAMCode, +Module)\n\n   Disassemble an existing predicate PredSpec in the module Module to its WAM\nabstract machine representation WAMCode.\n\nArguments\n   +PredSpec    Atom/Integer.\n   ?WAMCode    Variable or a list of WAM instructions in the right format.\n   +Module    Atom\n\nType\n   library(asm)\n\nDescription\n   Unifies WAMCode with the WAM instructions representing the abstract\n   machine code for the predicate specified by PredSpec (in Name/Arity\n   form) in module Module. The WAM code is in the form of a list, with each\n   element representing one WAM instruction. The format of the WAMCode is\n   the same as that used by asm/2,3 and pasm/4 to assemble a\n   predicate. Thus, the WAM code generated by disasm/2,3 can be used to\n   load the predicate into ECLiPSe without having to compile the source\n   Prolog form.\n\n   The library asm must be loaded to use diasm/3.\n\n   Currently disasm/3 cannot disassemble dynamic predicates.\n\n   If PredSpec is dynamic.\n\nFail Conditions\n      Fails if WAMCode is initially instantiated and does not unify with the WAM code generated by asm/1 for the predicate, or if PredSpec is dynamic.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- PredSpec or Module not in correct form.\n    60 --- PredSpec does not exist in module Module.\n    80 --- Module is not an existing module.\n\nSee Also\n   disasm / 2, asm / 2, asm / 3, pasm / 4, wam / 1"},"asm:pasm/4":{"prefix":"pasm","body":"pasm(${1:WAMCode}, ${2:Size}, ${3:BTPos}, ${4:Object})$5\n$0","description":"pasm(+WAMCode, -Size, -BTPos, -Object)\n\n   Partially assemble WAMCode into an object format.\n\nArguments\n   WAMCode    A list of WAM instructions in the right format.\n   Size    Variable or integer\n   BTPos    Variable or integer\n   Object    A list of object words in the right format.\n\nType\n   library(asm)\n\nDescription\n   Partially assemble the WAM instructions given WAMCode without loading it\n   into the current session. Instead, an object format is generated. This\n   object format can be loaded into an ECLiPSe session using the low level\n   built-in store_pred/9. fcompile/1,2 uses this predicate to generate the\n   object code for predicates. BTPos is the offset in words to the break/\n   port table, which are the addresses to the positions in the code for the \n   predicate where a breakpoint can be set (body goals which are tracable).\n\n   The partially assembled code consists of Object, which is a typed\n   representation of the words that need to be stored into memory; and\n   Size, the size in words that this object code will occupy in memory.\n\nModes and Determinism\n   pasm(+, -, -, -) is semidet\n\nFail Conditions\n      If WAMCode is not in correct format.\n\nResatisfiable\n      No.\n\nSee Also\n   asm / 2, asm / 3, disasm / 2, disasm / 3, sicstus : fcompile / 1, fcompile : fcompile / 1, fcompile : fcompile / 2, portable_object_code / 1"},"asm:portable_object_code/1":{"prefix":"portable_object_code","body":"portable_object_code(${1:Object})$2\n$0","description":"portable_object_code(++Object)\n\n   Check whether abstract machine code is 32/64 bit portable\n\nArguments\n   Object    A list of object words, as produced by pasm/4.\n\nType\n   library(asm)\n\nDescription\n   This check can be run on the output of pasm/4.\n   \n   ECLiPSe runtime engines on 32/64 bit hardware use different abstract\n   machine instructions when processing integers that are between 32 and\n   64 bits in size.  Code (and .eco files) that contain such instructions\n   cannot be used on a runtime with different word-size from where it was\n   assembled.  This predicate prints warnings and fails if the given code\n   contains such constructs.\n\nModes and Determinism\n   portable_object_code(++) is semidet\n\nFail Conditions\n   If Object is not portable between 32/64 bit.\n\nSee Also\n   pasm / 4"},"asm:wam/1":{"prefix":"wam","body":"wam(${1:PredSpec})$2\n$0","description":"wam(+PredSpec)\n\n   Prints the formatted WAM code for predicate PredSpec.\n\nArguments\n   +PredSpec    Atom, or Atom/Integer\n\nType\n   library(asm)\n\nDescription\n   Prints the WAM instructions representing the predicate specified by\n   PredSpec from the current module in a formatted form. Requires the \n   library asm to be loaded.\n\n   If PredSpec is an atom (i.e. no arity is given), then a predicate with\n   that name is printed, and if there are more than one predicate defined\n   (i.e. same name but different arities), then these different predicates\n   will be printed by backtracking.\n\n   This predicate is intended as a replacement for the lower level als/1,\n   which performs the same function. The differences are that the abstract\n   instruction names are printed in a more human oriented form (rather than\n   the internal names used by ECLiPSe), and labels and their references are\n   printed symbolically. Note that the predicate is implemented via the\n   disasm/3 predicate of the library, and hence the same restrictions\n   applies: it cannot be used to print the code for dynamic predicates.\n\nFail Conditions\n      If PredSpec is a dynamic predicate.\n\nResatisfiable\n      Yes.\n\nExceptions\n     5 --- PredSpec not in correct form.\n    60 --- PredSpec not defined in the current module.\n\nSee Also\n   disasm / 2, disasm / 3, wam / 2, als / 1"},"asm:wam/2":{"prefix":"wam","body":"wam(${1:PredSpec}, ${2:Module})$3\n$0","description":"wam(+PredSpec, +Module)\n\n   Prints the formatted WAM code for predicate PredSpec from module Module.\n\nArguments\n   +PredSpec    Atom, or Atom/Integer\n   +Module    Atom.\n\nType\n   library(asm)\n\nDescription\n   Prints the WAM instructions representing the predicate specified by\n   PredSpec in a formatted form. Requires the library asm to be loaded.\n\n   If PredSpec is an atom (i.e. no arity is given), then a predicate with\n   that name is printed, and if there are more than one predicate defined\n   (i.e. same name but different arities), then these different predicates\n   will be printed by backtracking.\n\n   This predicate is intended as a replacement for the lower level als/1,\n   which performs the same function. The differences are that the abstract\n   instruction names are printed in a more human oriented form (rather than\n   the internal names used by ECLiPSe), and labels and their references are\n   printed symbolically. Note that the predicate is implemented via the\n   disasm/3 predicate of the library, and hence the same restrictions\n   applies: it cannot be used to print the code for dynamic predicates.\n\nFail Conditions\n      If PredSpec is a dynamic predicate.\n\nResatisfiable\n      Yes.\n\nExceptions\n     5 --- PredSpec or Module not in correct form.\n    60 --- PredSpec not defined in module Module.\n    80 --- Module is not an existing module.\n\nSee Also\n   disasm / 2, disasm / 3, wam / 1, als / 1"},"atts:atts_desc":{"prefix":"lib","body":"lib(${1:atts})$2\n$0","description":"lib(atts)\n\n    Implements SICStus-Prolog compatible attributes on variables, via\n    mapping to native ECLiPSe attributes (one ECLiPSe attribute for\n    each module that defines SICStus attributes).\n\n    Implements the predicates\n\n    get_atts(-Var, ?AccessSpec)\n\tgetting attributes\n    put_atts(-Var, +AccessSpec)\n\tsetting attributes\n\n    and allows the user definition of the hook predicates\n\n    verify_attributes(-Var, +Value, -Goals)\n\tpre-unification hook, called as ECLiPSe's pre_unify handler\n    attribute_goal(-Var, -Goal)\n\tallows to define an interpretation of the attribute as goal.\n\tIf defined, it is also used as the print-handler for attributes.\n\n    ECLiPSe's toplevel makes no attempts to invoke any hooks."},"bfs:bfs_branch/1":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:bfs_branch(+Branch)\n\n   Post a branching constraint to the bfs instance BfsInstance.\n\nArguments\n   Branch    Prolog term\n\nType\n   library(bfs)\n\nDescription\n\n   Post a new branching constraint Branch to the bfs instance\n   BfsInstance. The constraint will be used to create a new child node\n   of the current open node in the search tree for BfsInstance.\n   Branch may be any prolog term, but clearly should be an\n   appropriate constraint for the node relaxation solver associated with\n   BfsInstance. \n\nSee Also\n   solver_setup / 2, solver_setup / 3, get / 2"},"bfs:bfs_desc":{"prefix":"lib","body":"lib(${1:bfs})$2\n$0","description":"lib(bfs)\n\n   This library lets you use customisable branch-and-bound search. It\n   is primarily intended for use with the colgen library in implementing\n   branch-and-price algorithms, but can be used with arbitrary\n   user-defined node solution, separation and selection goals.\n   When application specific methods are not required for node\n   separation and/or selection the use of built-in depth-first\n   and best-first node selection, and branching on most fractional\n   variable or generalised upper bound constraint may be specified.\n   When the relaxed problem to be solved at a node involves an eplex\n   instance branching may additionally be specified by built-in\n   objective coefficient, estimate- or lower-bounding based methods,\n   and best-estimate node selection may be used."},"bfs:bfs_instance/1":{"prefix":"bfs_instance","body":"bfs_instance(${1:BfsInstance})$2\n$0","description":"bfs_instance(++BfsInstance)\n\n   Initialises the bfs instance BfsInstance.\n\nArguments\n   BfsInstance    Bfs instance name (atom)\n\nType\n   library(bfs)\n\nDescription\n  \n  Initialises the bfs instance BfsInstance. A bfs instance is an\n  instance of the best first search solver, with which node\n  relaxation and separation solvers can be associated and used to\n  optimise the problem constraints posted to the relaxed node solver\n  with respect to its objective using a specified node ordering scheme.\n  In particular best-first and best-estimate search schemes are\n  supported and application-specific schemes may be easily defined by\n  the user.\n  \n  If BfsInstance is not an already existing bfs instance, a new bfs\n  instance will be created and initialised. If it is an existing bfs\n  instance, and it is not currently being used (having no associated\n  solvers), it is effectively reinitialised. Otherwise, the predicate\n  aborts with an error. Note that a bfs instance is a module, and each\n  bfs instance can be associated with at most one relaxation and one\n  separation solver at any time and vice versa.\n  \n  \n\nSee Also\n   integers / 1, bfs_branch / 1, node_info / 5, solver_setup / 2, solver_setup / 3, solve / 1, get / 2, var_get / 3, statistics / 0"},"bfs:get/2":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:get(++What, -Value)\n\n   Obtain information for the problem associated with BfsInstance.\n\nArguments\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(bfs)\n\nDescription\n\n   Retrieve information about the problem associated with the bfs\n   instance BfsInstance. What can take one of the following values:\n\n    frac_vars\n    Returns the list of variables declared as integer for\n    BfsInstance which have fractional solution values in the current node\n    of the search tree.\n\n    branches\n    Returns the branching decisions taken from the root to the\n    current node of the search tree.\n\n    data\n    Returns the user-defined data associated with the instance.\n\n    node_count\n    Returns the total number of nodes in the search tree.\n\nExceptions\n     6 --- What is not a valid value."},"bfs:integers/1":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:integers(+Ints)\n\n   Declare Ints as integers in BfsInstance.\n\nArguments\n   Ints    A variable or list of variables\n\nType\n   library(bfs)\n\nDescription\n\n   The variable or list of variables Ints will be considered integers\n   when solving the problem associated with BfsInstance. Note that\n   this does not mean that they will be treated as integers by the\n   specified node relaxation solver, rather that they will be considered\n   as candidates for branching decisions in nodes where their solution\n   value is not integral (to within a tolerance parameter set in the\n   options list of BfsInstance:solver_setup/3). The predefined\n   node separation schemes will branch on these variables. User-defined\n   node separation predicates may access the fractional variables\n   at the current node via a call to BfsInstance:get/2\n\nSee Also\n   solver_setup / 3, get / 2"},"bfs:node_cost/1":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:node_cost(+Val)\n\n   Set solution cost for the problem at a node.\n\nArguments\n   Val    Solution cost for problem (number)\n\nType\n   library(bfs)\n\nDescription\n\n   Set the solution cost for the problem at the current open node of\n   the search tree associated with the bfs instance BfsInstance."},"bfs:node_info/5":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:node_info(+Var, ?Lo, ?Hi, ?Val, ?RC)\n\n   Get or set node bounds and solution information for an individual solver problem variable Var.\n\nArguments\n   Var    A solver problem variable for solver the associated with BfsInstance\n   Lo    Lower bound for Var (number)\n   Hi    Upper bound for Var (number)\n   Val    Solution value for Var (number)\n   RC    Reduced cost for Var (number)\n\nType\n   library(bfs)\n\nDescription\n\n   Retrieve or update bounds and solution information for an\n   individual solver problem variable Var for the current open node of\n   the search tree associated with the bfs instance BfsInstance. If Var\n   was not already a problem variable for BfsInstance it will now be\n   considered one. If reduced costs are available in problems\n   involving eplex instances supplying these to the bfs solver can lead\n   to improved pruning."},"bfs:solve/1":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:solve(-Cost)\n\n   Optimise the problem associated with BfsInstance.\n\nArguments\n   Cost    The optimal solution cost of the problem associated with BfsInstance\n\nType\n   library(bfs)\n\nDescription\n\n   A solver setup with solver_setup/2 or solver_setup/3 is triggered\n   using this predicate.\n\n   The node relaxation and separation solvers are applied to the next\n   selected node of the problem represented by Handle repeatedly until\n   no more open nodes remain. The criteria for node selection order\n   depends on the options given to solver_setup/2,3.  solve/1 fails if\n   there is no solution or succeeds if an optimal solution is found,\n   returning the solution's cost in Cost.  After a success, various\n   solution information and statistics can be retrieved using get/2,\n   var_get/3 and statistics/0.\n\nFail Conditions\n   No solution exists satisfying the global feasibility conditions.\n\nSee Also\n   solver_setup / 2, solver_setup / 3, get / 2, var_get / 3, statistics / 0"},"bfs:solver_setup/2":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:solver_setup(+OptSense, +Solver)\n\n   Setup a bfs solver tree for bfs instance BfsInstance.\n\nArguments\n   OptSense    Optimisation direction: min or max\n   Solver    Node relaxation solver\n\nType\n   library(bfs)\n\nDescription\n\n  Setup a new solver tree for the bfs instance BfsInstance. The tree\n  will be associated with BfsInstance; BfsInstance must not already\n  have a solver tree associated with it. Once the solver tree is setup,\n  it can be optimised via solve/1.\n\n  This is a simplified version of solver_setup/3, it is equivalent to\n  calling solver_setup/3 with the following default options:\n\n       solver_setup(OptSense, Solver, [])\n\nSee Also\n   integers / 1, bfs_branch / 1, node_info / 5, solver_setup / 3, solve / 1, get / 2, var_get / 3, statistics / 0"},"bfs:solver_setup/3":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:solver_setup(+OptSense, +Solver, ++ListOfOptions)\n\n   Setup a bfs solver tree for bfs instance BfsInstance.\n\nArguments\n   OptSense    Optimisation direction: min or max\n   Solver    Node relaxation solver\n   ListOfOptions       List of solver options\n\nType\n   library(bfs)\n\nDescription\n\n  Setup a new solver tree for the bfs instance BfsInstance. The tree\n  will be associated with BfsInstance; BfsInstance must not already\n  have a solver tree associated with it. Once the solver tree is setup,\n  it can be optimised via solve/1. This predicate allow various\n  options to be specified when setting up the  solver state via\n  ListOfOptions.\n\n  OptSense is the optimisation direction. Note that this\n  is assumed to be the same as the sense of optimisation used in\n  Solver. It is the user's responsibility to ensure \n  that this is in fact the case. OptSense is used internally\n  for bound updates and pruning, and for node ordering with the built-in\n  best-first and best-estimate node selection methods.\n\n  Solver is the node relaxed problem solver. It is either a\n  user-defined predicate or an eplex instance or handle, for which a\n  built-in node relaxation solver is available.\n\nListOfOptions are:\n\nseparation(+Separation)\n    Use the specified method to separate the current node.\n    Separation is either a user-defined predicate, or one of\n    the atoms fracvar, enhanced, strong, deg_est\n    corresponding to the built-in separation methods. Note that the\n    methods enhanced, strong, deg_est are only available when\n    the node relaxation solver involves an eplex instance.\n    Separation defaults to fracvar.\n\nnode_select(+Select)\n    Use the specified method (depth_first, best_first,\n    best_estimate) to select the next open node for solution and\n    separation. Select defaults to best_first.\n\nalpha(?AlphaMin, ?AlphaMax)\n    When using estimate- or lower-bounding based dichotomic node\n    separation methods the overall value assigned to branching on a\n    particular variable or constraint is calculated as a weighted sum\n    of the estimates obtained for the two branches it would produce.\n    AlphaMin is the weighting given to the minimum of the two estimates\n    and AlphaMax to the maximum. AlphaMin and AlphaMax\n    are numbers and default to 2 and 1 respectively.\n\nbeta(?BetaConst, ?BetaPC, ?BetaLB)\n    When using estimate- or lower-bounding based node separation\n    methods with a problem involving an eplex instance the estimate\n    assigned to each branch produced by branching on a particular\n    variable or constraint is calculated as a weighted sum  of the\n    pseudo-cost estimate and the lower bound. BetaPC is the weighting\n    given to the pseudo-cost estimate and BetaLB to the lower bound.\n    BetaConst is a constant offset only used when linear regression is\n    employed to update these values during search. BetaConst,\n    BetaPC, BetaLB are numbers and default to 0, 1,\n    1 respectively.\n\npseudo_cost(?PCInit, ?PCUpdate, ?PCRatio)\n    \n    When using estimate-based dichotomic node separation methods\n    with a problem involving an eplex instance up and down pseudo-costs\n    are assigned to each variable and generalised upper bound constraint \n    branch-point representing the estimated degradation in objective\n    cost per unit change in variable or constraint value incurred on\n    that branch.\n    PCInit specifies the method used to initialise these\n    values when a variable or constraint branch-point is first considered\n    for branching:\n    \n    average : the pseudocosts are initialised to the average\n    of the observed changes in cost of all up or down branches in the\n    search tree.\n    cost : variable pseudocosts are initialised to the\n    objective cost coefficient of the variable, constraint branch-point\n    pseudocosts to the average of the cost coefficients of variables\n    involved.\n    calculated : the pseudocosts are initialised to a\n    value calculated by performing a number of external solver iterations\n    equal to (PCRatio * #iterations in root node)/(2* #fractional\n    vars in root node).\n    \n    The default is calculated.\n    PCUpdate is an atom specifying the method used to\n    update these values throughout the search tree once the variable\n    or constraint has been branched on:\n    \n    average : the pseudocosts are updated to the average\n    of the observed changes in cost of all up or down branches in the\n    search tree for that variable or constraint. \n    first : the pseudocosts are fixed to the observed\n    change in cost at the first up or down branch in the search tree for\n    that variable or constraint.\n    last : the pseudocosts are fixed to the observed\n    change in cost at the last up or down branch in the search tree for\n    that variable or constraint.\n    \n    The default is average.\n    PCRatio is a float between 0 and 1 and is used in\n    calculating the number of external solver iterations to perform\n    when explicitly calculating initial pseudo-cost estimates; the\n    default value is 0.05. Setting small ratios will result in faster\n    node separation, but the initial estimates for variables and\n    constraints on which the branching decisions are taken will be less\n    accurate. Setting larger values will result in more work being performed\n    in node separation and better estimates for the branching\n    decisions. The optimum value will be problem specific, although in \n    general the overhead of performing a total number of iterations\n    more than a small ratio of the root node iterations will outweigh the\n    benefit obtained.\n\nlower_bound(+Limit)\n    When using lower-bounding based node separation methods with a\n    problem involving an eplex instance, specify how many external solver\n    iterations should be performed to calculate the lower bound.\n    Limit is an integer and defaults to 1. Setting small\n    values of iterations will result in faster node separation, but the\n    lower bounds on which the branching decisions are taken will be less\n    tight. Setting larger values will result in more work being performed\n    in node separation and tighter lower bounds for the branching\n    decisions. The optimum value will be problem specific, although in\n    general the overhead of performing more than a few iterations will\n    outweigh the benefit obtained.\n\nint_tolerance(+IntTol)\n    Specify how far from integrality an integer variable's node\n    solution can fall before it is considered for separation by the\n    built-in separation methods. IntTol is a float and\n    defaults to 0.00001.  \n\ninfo_messages(+OnOff)\n    Specify whether information messages should be output at\n    various points during solution. This option is most useful for\n    debugging purposes. OnOff is one of the atoms on or\n    off, the default is off.\n\nSee Also\n   integers / 1, bfs_branch / 1, node_info / 5, solver_setup / 2, solve / 1, get / 2, var_get / 3, statistics / 0"},"bfs:statistics/0":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:statistics\n\n   Display search tree statistics for bfs instance BfsInstance.\n\nType\n   library(bfs)\n\nDescription\n\n  Display statistics for the search tree associated with the bfs\n  instance BfsInstance: total number of nodes created, total search\n  time, number of nodes solved, node solution time, number of nodes\n  separated, node separation time, total number of global feasible\n  solutions found, first and optimal global solution solution time.\n\nSee Also\n   solver_setup / 2, solver_setup / 3, solve / 1"},"bfs:var_get/3":{"prefix":"BfsInstance","body":"BfsInstance","description":"BfsInstance:var_get(+Var, ++What, -Value)\n\n   Obtain information for an individual solver problem variable Var.\n\nArguments\n   Var    A solver problem variable for the solver associated with BfsInstance\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(bfs)\n\nDescription\n\n   Retrieve information about solver results related to a particular\n   variable, for the bfs instance BfsInstance. Fails if Var is not a\n   problem variable for BfsInstance. What can take one of the following\n   values: \n\n    optimal_val\n    Returns the floating-point solution for variable Var.\n\n    node_val\n    Returns the floating-point solution for variable Var for the\n    current node in the search tree of this instance.\n\n    type\n    Returns the type real or integer of Var in this instance.\n\nExceptions\n     6 --- What is not a valid value."},"branch_and_bound:bb_cost/2":{"prefix":"bb_cost","body":"bb_cost(${1:Handle}, ${2:Cost})$3\n$0","description":"bb_cost(++Handle, -Cost)\n\n   Low-level primitive for building branch-and-bound-style search procedures\n\nType\n   library(branch_and_bound)\n\nSee Also\n   bb_probe / 7"},"branch_and_bound:bb_finish/1":{"prefix":"bb_finish","body":"bb_finish(${1:Handle})$2\n$0","description":"bb_finish(++Handle)\n\n   Low-level primitive for building branch-and-bound-style search procedures\n\nType\n   library(branch_and_bound)\n\nSee Also\n   bb_probe / 7"},"branch_and_bound:bb_init/2":{"prefix":"bb_init","body":"bb_init(${1:ExtremeCost}, ${2:Handle})$3\n$0","description":"bb_init(++ExtremeCost, -Handle)\n\n   Low-level primitive for building branch-and-bound-style search procedures\n\nType\n   library(branch_and_bound)\n\nSee Also\n   bb_probe / 7"},"branch_and_bound:bb_min/3":{"prefix":"bb_min","body":"bb_min(${1:Goal}, ${2:Cost}, ${3:Options})$4\n$0","description":"bb_min(+Goal, ?Cost, ?Options)\n\n   Find a minimal solution using the branch-and-bound method\n\nArguments\n   Goal    The (nondeterministic) search goal\n   Cost    A (usually numeric domain) variable representing the cost\n   Options    A bb_options structure or variable\n\nType\n   library(branch_and_bound)\n\nDescription\n\tA solution of the goal Goal is found that minimizes\n\tthe value of Cost.  Cost should be a\n\tvariable that is affected, and eventually instantiated, by\n\tGoal.  Usually, Goal is the search procedure\n\tof a constraint problem and Cost is the variable\n\trepresenting the cost.  The solution is found using the branch\n\tand bound method:  as soon as a solution is found, it gets\n\tremembered and the search is continued or restarted with an\n\tadditional constraint on the Cost variable which\n\trequires the next solution to be better than the previous one. \n\tIterating this process yields an optimal solution in the end.\n\t\n\tThe possible options are\n\t\n\tstrategy:\n\t    \n\t    continue (default)\n\t    \tafter finding a solution, continue search with the newly\n\t\tfound bound imposed on Cost\n\t    restart\n\t    \tafter finding a solution, restart the whole search with\n\t\tthe newly found bound imposed on Cost\n\t    step\n\t    \ta synonym for 'restart'\n\t    dichotomic\n\t    \tafter finding a solution, split the remaining cost range\n\t\tand restart search to find a solution in the lower sub-range.\n\t\tIf that fails, assume the upper sub-range as the remaining\n\t\tcost range and split again.\n\t    \n\t    The new bound or the split point, respectively, are computed\n\t    from the current best solution, while taking into account the\n\t    parameters delta and factor.\n\t    \n\tfrom:\n\t    number - an initial lower bound for the cost (default -1.0Inf)\n\n\tto:\n\t    number - an initial upper bound for the cost (default +1.0Inf)\n\n\tdelta:\t\n\t    number - minimal absolute improvement required for each step\n\t    (default 1.0), applies to all strategies\n\n\tfactor:\n\t    number - minimal improvement ratio (with respect to the lower\n\t    cost bound) for strategies 'continue' and 'restart' (default 1.0),\n\t    or split factor for strategy 'dichotomic' (default 0.5)\n\n\ttimeout:\n\t    number - maximum seconds of cpu time to spend (default: no limit)\n\n\treport_success:\n\t    GoalPrefix - an atom (predicate name) or structure (goal prefix),\n\t    specifying a goal to be invoked whenever the branch-and-bound\n\t    process finds a better solution.  The invoked goal is constructed\n\t    by adding three arguments (Cost, Handle, Module) to GoalPrefix.\n\t    Cost is a float number representing the cost of the solution found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    The default handler prints a message.\n\n\treport_failure:\n\t    GoalPrefix - an atom (predicate name) or structure (goal prefix),\n\t    specifying a goal to be invoked whenever the branch-and-bound\n\t    process cannot find a solution in a cost range.  The invoked goal\n\t    is constructed by adding three arguments (Cost, Handle, Module) to\n\t    GoalPrefix.  Cost is a From..To structure representing the range\n\t    of cost in which no solution could be found, Handle is a handle\n\t    as accepted by bb_cost/2 or bb_solution/2, and Module is the\n\t    context module of the minimisation.\n\t    The default handler prints a message.\n\n\treport_timeout:\n\t    GoalPrefix - an atom (predicate name) or structure (goal prefix),\n\t    specifying a goal to be invoked when the branch-and-bound\n\t    process times out.  The invoked goal is constructed\n\t    by adding three arguments (Cost, Handle, Module) to GoalPrefix.\n\t    Cost is a float number representing the cost of the best solution\n\t    found, Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    The default handler prints a message.\n\t\n\tThe default options can be selected by passing a free variable as\n\tthe Options-argument. To specify other options, pass a bb_options-\n\tstructure in struct-syntax, e.g.\n\t\n\tbb_options{strategy:dichotomic, timeout:60}\n\t\n\tIn order to maximize instead of minimizing, introduce a negated\n\tcost variable in your model and minimize that instead.\n\t\n\tNote: the report_success, report_failure and report_timeout options\n\talso accept Name/Arity specifications with maximum arity 3 for the\n\thandler goals (the three optional arguments being Cost, Handle,\n\tand Module).  Therefore, the simplest way to disable a handler\n\tcompletely is to set it to true/0.\n\t\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n?- bb_min(member(X,[9,6,8,4,7,2,4,7]), X, O).\nFound a solution with cost 9\nFound a solution with cost 6\nFound a solution with cost 4\nFound a solution with cost 2\nFound no solution with cost -1.0Inf .. 1\nX = 2\nO = bb_options(continue, -1.0Inf, 1.0Inf, 1, 1, 0, 0, _, _)\nyes.\n\n[eclipse 6]: bb_min(member(X,[9,6,8,4,7,2,4,7]), X, bb_options{delta:4}).\nFound a solution with cost 9\nFound a solution with cost 4\nFound no solution with cost -1.0Inf .. 0\nX = 4\nyes.\n\n[eclipse 10]: bb_min(member(X,[99,60,80,40,70,30,70]), X,\n\tbb_options{strategy:dichotomic, from:0}).\nFound a solution with cost 99\nFound a solution with cost 40\nFound no solution with cost 0.0 .. 20.0\nFound a solution with cost 30\nFound no solution with cost 20.0 .. 25.0\nFound no solution with cost 25.0 .. 27.5\nFound no solution with cost 27.5 .. 28.75\nFound no solution with cost 28.75 .. 29.0\n\nX = 30\nyes.\n\nSee Also\n   bb_min / 6"},"branch_and_bound:bb_min/6":{"prefix":"bb_min","body":"bb_min(${1:Goal}, ${2:Cost}, ${3:Template}, ${4:Solution}, ${5:Optimum}, ${6:Options})$7\n$0","description":"bb_min(+Goal, ?Cost, ?Template, ?Solution, ?Optimum, ?Options)\n\n   Find a minimal solution using the branch-and-bound method\n\nArguments\n   Goal    The (nondeterministic) search goal\n   Cost    A (usually numeric domain) variable representing the cost\n   Template    A term containing all or some problem variables\n   Solution    A term which will be unified with the optimized Template\n   Optimum    A variable which will be set to the optimum value of Cost\n   Options    A bb_options structure or variable\n\nType\n   library(branch_and_bound)\n\nDescription\n\tA solution of the goal Goal is found that minimizes\n\tthe value of Cost.  Cost should be a\n\tvariable that is affected, and eventually instantiated, by\n\tGoal.  Usually, Goal is the search procedure\n\tof a constraint problem and Cost is the variable\n\trepresenting the cost.  The solution is found using the branch\n\tand bound method:  as soon as a solution is found, it gets\n\tremembered and the search is continued or restarted with an\n\tadditional constraint on the Cost variable which\n\trequires the next solution to be better than the previous one. \n\tIterating this process yields an optimal solution in the end.\n\t\n\tThe possible options are\n\t\n\tstrategy:\n\t    \n\t    continue (default)\n\t    \tafter finding a solution, continue search with the newly\n\t\tfound bound imposed on Cost\n\t    restart\n\t    \tafter finding a solution, restart the whole search with\n\t\tthe newly found bound imposed on Cost\n\t    step\n\t    \ta synonym for 'restart'\n\t    dichotomic\n\t    \tafter finding a solution, split the remaining cost range\n\t\tand restart search to find a solution in the lower sub-range.\n\t\tIf that fails, assume the upper sub-range as the remaining\n\t\tcost range and split again.\n\t    \n\t    The new bound or the split point, respectively, are computed\n\t    from the current best solution, while taking into account the\n\t    parameters delta and factor.\n\t    \n\tfrom:\n\t    number - an initial lower bound for the cost (default -1.0Inf)\n\n\tto:\n\t    number - an initial upper bound for the cost (default +1.0Inf)\n\n\tdelta:\t\n\t    number - minimal absolute improvement required for each step\n\t    (default 1.0), applies to all strategies\n\n\tfactor:\n\t    number - minimal improvement ratio (with respect to the lower\n\t    cost bound) for strategies 'continue' and 'restart' (default 1.0),\n\t    or split factor for strategy 'dichotomic' (default 0.5)\n\n\ttimeout:\n\t    number - maximum seconds of cpu time to spend (default: no limit)\n\n\treport_success:\n\t    GoalPrefix - an atom (predicate name) or structure (goal prefix),\n\t    specifying a goal to be invoked whenever the branch-and-bound\n\t    process finds a better solution.  The invoked goal is constructed\n\t    by adding three arguments (Cost, Handle, Module) to GoalPrefix.\n\t    Cost is a float number representing the cost of the solution found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    The default handler prints a message.\n\n\treport_failure:\n\t    GoalPrefix - an atom (predicate name) or structure (goal prefix),\n\t    specifying a goal to be invoked whenever the branch-and-bound\n\t    process cannot find a solution in a cost range.  The invoked goal\n\t    is constructed by adding three arguments (Cost, Handle, Module) to\n\t    GoalPrefix.  Cost is a From..To structure representing the range\n\t    of cost in which no solution could be found, Handle is a handle\n\t    as accepted by bb_cost/2 or bb_solution/2, and Module is the\n\t    context module of the minimisation.\n\t    The default handler prints a message.\n\t\n\tThe default options can be selected by passing a free variable as\n\tthe Options-argument. To specify other options, pass a bb_options-\n\tstructure in struct-syntax, e.g.\n\t\n\tbb_options{strategy:dichotomic, timeout:60}\n\t\n\tIn order to maximize instead of minimizing, introduce a negated\n\tcost variable in your model and minimize that instead.\n\t\n\tUnlike bb_min/3, bb_min/6 does not affect Goal or Cost after\n\tthe optimum has been found. Instead, the optimum cost value is returned\n\tin Optimum, and the Solution argument gets unified with an instance of\n\tTemplate where the variables have the values that correspond to the\n\toptimal solution. Note that bb_min/3 is actually based on bb_min/6\n\tand can be defined as:\n\t\n\tbb_min(Goal, Cost, Options) :-\n\t    bb_min(Goal, Cost, Goal, Goal, Cost, Options).\n\t\n\t\n\tCompatibility note: For backward compatibility, the report_success and\n\treport_failure options also accept Name/Arity specifications with\n\tmaximum arity 3 for the handler goals. The three optional arguments\n\tare then Cost, Handle, and Module.\n\t\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   bb_min / 3"},"branch_and_bound:bb_probe/7":{"prefix":"bb_probe","body":"bb_probe(${1:From}, ${2:To}, ${3:Goal}, ${4:Template}, ${5:Cost}, ${6:Handle}, ${7:Module})$8\n$0","description":"bb_probe(++From, ++To, +Goal, ?Template, ?Cost, ++Handle, ++Module)\n\n   Low-level primitive for building branch-and-bound-style search procedures\n\nType\n   library(branch_and_bound)\n\nDescription\n\n\tbb_probe tries to find a solution for Goal in the range From..To.\n\tIf there is a solution, its Template and Cost are stored in Handle,\n\tthe computation is undone, and bb_probe succeeds.\n\tIf there is no solution, Handle is not changed and bb_probe fails.\n\tThe primitive set_var_bounds/3 is used to impose cost bounds\n\tduring the search process in a generic way.\n\nExamples\n   % a simple branch-and-bound procedure\nmy_minimize(Goal, Cost, Solution, OptCost, Module) :-\n\tbb_init(1000000, Handle),\n\t(\n\t    bb_delta(0, 1000000, Goal, Cost, Handle, Module)\n\t;\n\t    bb_solution(Handle, Solution),\n\t    bb_cost(Handle, OptCost)\n\t),\n\tbb_finish(Handle).\n\nbb_delta(From, To, Goal, Cost, Handle, Module) :-\n\tbb_probe(From, To, Goal, Goal, Cost, Handle, Module),\n\tNewTo is bb_cost(Handle) - 1,\n\tbb_delta(From, NewTo, Goal, Cost, Handle, Module).\n    \n\nSee Also\n   bb_init / 2, bb_cost / 2, bb_solution / 2, bb_finish / 1, bb_min / 3, bb_min / 6, set_var_bounds / 3"},"branch_and_bound:bb_solution/2":{"prefix":"bb_solution","body":"bb_solution(${1:Handle}, ${2:Solution})$3\n$0","description":"bb_solution(++Handle, -Solution)\n\n   Low-level primitive for building branch-and-bound-style search procedures\n\nType\n   library(branch_and_bound)\n\nSee Also\n   bb_probe / 7"},"branch_and_bound:branch_and_bound_desc":{"prefix":"lib","body":"lib(${1:branch_and_bound})$2\n$0","description":"lib(branch_and_bound)\n\n\tThis is a solver-independent library implementing branch-and-bound\n\tprimitives. It can be used with any nondeterministic search routine\n\tthat instantiates a cost variable when a solution is found. The cost\n\tvariable can be an arbitrary numerical domain variable or even a\n\tsimple domain-less variable.\n\t\n\tThe main predicates are bb_min/3, bb_min/6 and, as a shorthand,\n\tminimize/2.\n\t\n\tNote on the treatment of bounded reals: The library allows the cost\n\tto be instantiated to a number of type breal. This is useful e.g.\n\twhen using lib(ic) to solve problems with continuous variables.\n\tWhen the variable domains have been narrowed sufficiently, the\n\tproblem variables (in particular the cost variable) should be\n\tinstantiated to a bounded real, e.g. using the following idiom:\n\t\n\t\tX is breal_from_bounds(get_min(X),get_max(X))\n\t\n\tBounded reals contain some uncertainty about their true value. If\n\tthis uncertainty is too large, the branch-and-bound procedure may\n\tnot be able to compare the quality of two solutions. In this case,\n\ta warning is issued and the search terminated prematurely.  The\n\tproblem can be solved by increasing the delta-parameter, or by\n\tlocating the cost value more precisely."},"branch_and_bound:minimize/2":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:Cost})$3\n$0","description":"minimize(+Goal, ?Cost)\n\n   Find a minimal solution using the branch-and-bound method\n\nType\n   library(branch_and_bound)\n\nDescription\nThis is a shorthand for\n    \t\n\tbb_min(+Goal, ?Cost, _DefaultOptions)\n\t\n\tSee bb_min/3 for details.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   bb_min / 3"},"calendar:calendar_desc":{"prefix":"lib","body":"lib(${1:calendar})$2\n$0","description":"lib(calendar)\n\n\tJulian Dates (JD) and Modified Julian Dates (MJD) are a\n\tconsecutive day numbering scheme widely used in astronomy,\n\tspace travel etc. It is defined for a long period from\n\t12 noon, 1 Jan 4713 BC  to  12 noon, 1 Jan 3268 AD.\n\t\n\tHere we use MJDs as the central representation (JDs are a bit\n\tawkward because they change at noon and are very large numbers).\n\t\n\tNote that you can use fractional MJDs to denote the time of day.\n\tThe time is then defined to be Universal Time (UT, formerly GMT).\n\tThat means that every day has a unique integer number,\n\tor every time point has a unique float representation!\n\t(Using double floats, the resolution is better than 10\n\tmicroseconds until the year 2576, and better than 100\n\tmicroseconds until the year 24826).\n\t\n\tDifferences between times are obviously trivial to compute,\n\tand so are weekdays (by simple mod(7) operation).\n\t\n\tThe code is valid for dates starting from\n\t\t 1 Mar 0004 = MJD -677422 = JD 1722578.5\n\t\n\tThe relationship between JD and MJD is simply\n\tMJD = JD-2400000.5, ie MJD 0 = 17 Nov 1858."},"calendar:date_to_mjd/2":{"prefix":"date_to_mjd","body":"date_to_mjd(${1:DMY}, ${2:MJD})$3\n$0","description":"date_to_mjd(++DMY, ?MJD)\n\n   Convert a date in day/month/year form to an MJD day number\n\nArguments\n   DMY    A structure of the form D/M/Y where D,M and Y are integers\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nSee Also\n   mjd_to_date / 2"},"calendar:dwy_to_mjd/2":{"prefix":"dwy_to_mjd","body":"dwy_to_mjd(${1:DWY}, ${2:MJD})$3\n$0","description":"dwy_to_mjd(++DWY, ?MJD)\n\n   Convert a DayOfWeek/WeekOfYear/Year representation to MJD\n\nArguments\n   DWY    structure of the form Day/Week/Year\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nDescription\nConvert a DayOfWeek/WeekOfYear/Year representation to MJD,\n    \twhere DayOfWeek is the day number within the week (1 for monday up to\n\t7 for sunday), and WeekOfYear is the week number within the year\n\t(starting with 1 for the week that contains January 1st)"},"calendar:dwy_to_mjd/3":{"prefix":"dwy_to_mjd","body":"dwy_to_mjd(${1:DWY}, ${2:FirstWeekday}, ${3:MJD})$4\n$0","description":"dwy_to_mjd(++DWY, ++FirstWeekday, ?MJD)\n\n   Convert a DayOfWeek/WeekOfYear/Year representation to MJD\n\nArguments\n   DWY    Structure of the form Day/Week/Year\n   FirstWeekday    Atom (monday,tuesday,etc)\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nDescription\nas dwy_to_mjd/2, but allows to choose a different starting day for weeks, specified as atom monday, tuesday etc"},"calendar:dy_to_mjd/2":{"prefix":"dy_to_mjd","body":"dy_to_mjd(${1:DY}, ${2:MJD})$3\n$0","description":"dy_to_mjd(++DY, ?MJD)\n\n   Convert a DayOfYear/Year representation to MJD\n\nArguments\n   DY    structure of the form DayOfYear/Year\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nDescription\nConvert a DayOfYear/Year representation to MJD, where DayOfYear is the relative day number starting with 1 on every January 1st"},"calendar:jd_to_mjd/2":{"prefix":"jd_to_mjd","body":"jd_to_mjd(${1:JD}, ${2:MJD})$3\n$0","description":"jd_to_mjd(++JD, ?MJD)\n\n   Convert Julian Dates (JD) to Modified Julian Dates (MJD)\n\nArguments\n   JD    Integer or float\n   MJD    Variable or float\n\nType\n   library(calendar)\n\nDescription\nConvert Julian Dates (JD) to Modified Julian Dates (MJD). The relationship is simply MJD = JD-2400000.5"},"calendar:mjd_now/1":{"prefix":"mjd_now","body":"mjd_now(${1:MJD})$2\n$0","description":"mjd_now(?MJD)\n\n   Returns the current date/time as (float) MJD\n\nArguments\n   MJD    Variable or float\n\nType\n   library(calendar)"},"calendar:mjd_to_date/2":{"prefix":"mjd_to_date","body":"mjd_to_date(${1:MJD}, ${2:DMY})$3\n$0","description":"mjd_to_date(++MJD, ?DMY)\n\n   Converts an MJD day number into the corresponding Day/Month/Year\n\nArguments\n   MJD    Integer or float\n   DMY    Variable or structure\n\nType\n   library(calendar)\n\nSee Also\n   date_to_mjd / 2"},"calendar:mjd_to_dwy/2":{"prefix":"mjd_to_dwy","body":"mjd_to_dwy(${1:MJD}, ${2:DWY})$3\n$0","description":"mjd_to_dwy(++MJD, ?DWY)\n\n   Convert an MJD to a DayOfWeek/WeekOfYear/Year representation\n\nArguments\n   MJD    Integer or float\n   DWY    Variable or structure of the form Day/Week/Year\n\nType\n   library(calendar)\n\nDescription\nConvert MJDs to a DayOfWeek/WeekOfYear/Year representation,\n    \twhere DayOfWeek is the day number within the week (1 for monday up to\n\t7 for sunday), and WeekOfYear is the week number within the year\n\t(starting with 1 for the week that contains January 1st)"},"calendar:mjd_to_dwy/3":{"prefix":"mjd_to_dwy","body":"mjd_to_dwy(${1:MJD}, ${2:FirstWeekday}, ${3:DWY})$4\n$0","description":"mjd_to_dwy(++MJD, ++FirstWeekday, ?DWY)\n\n   Convert an MJD to a DayOfWeek/WeekOfYear/Year representation\n\nArguments\n   MJD    Integer or float\n   FirstWeekday    Atom (monday,tuesday,etc)\n   DWY    Structure of the form Day/Week/Year\n\nType\n   library(calendar)\n\nDescription\nas mjd_to_dwy/2, but allows to choose a different starting day for weeks, specified as atom monday, tuesday etc"},"calendar:mjd_to_dy/2":{"prefix":"mjd_to_dy","body":"mjd_to_dy(${1:MJD}, ${2:DY})$3\n$0","description":"mjd_to_dy(++MJD, ?DY)\n\n   Convert an MJD to a DayOfYear/Year representation\n\nArguments\n   MJD    Integer or float\n   DY    Variable or structure of the form DayOfYear/Year\n\nType\n   library(calendar)\n\nDescription\nConvert MJD to a DayOfYear/Year representation, where DayOfYear is the relative day number starting with 1 on every January 1st"},"calendar:mjd_to_jd/2":{"prefix":"mjd_to_jd","body":"mjd_to_jd(${1:MJD}, ${2:JD})$3\n$0","description":"mjd_to_jd(++MJD, ?JD)\n\n   Convert Modified Julian Dates (MJD) to Julian Dates (JD)\n\nArguments\n   MJD    Integer or float\n   JD    Variable or float\n\nType\n   library(calendar)\n\nDescription\nConvert Modified Julian Dates (MJD) to Julian Dates (JD). The relationship is simply JD = MJD+2400000.5"},"calendar:mjd_to_time/2":{"prefix":"mjd_to_time","body":"mjd_to_time(${1:MJD}, ${2:HMS})$3\n$0","description":"mjd_to_time(++MJD, ?HMS)\n\n   Extracts the time in H:M:S form from a float MJD\n\nArguments\n   MJD    Integer or float\n   HMS    Variable or structure\n\nType\n   library(calendar)\n\nDescription\nreturns the time of day (UTC/GMT) corresponding to the given MJD as Hour:Minute:Seconds structure, where Hour and Minute are integers and Seconds is a float"},"calendar:mjd_to_unix/2":{"prefix":"mjd_to_unix","body":"mjd_to_unix(${1:MJD}, ${2:UnixTime})$3\n$0","description":"mjd_to_unix(++MJD, ?UnixTime)\n\n   Convert an MJD to the UNIX time representation\n\nArguments\n   MJD    Integer or float\n   UnixTime    Variable or integer\n\nType\n   library(calendar)"},"calendar:mjd_to_weekday/2":{"prefix":"mjd_to_weekday","body":"mjd_to_weekday(${1:MJD}, ${2:DayName})$3\n$0","description":"mjd_to_weekday(++MJD, ?DayName)\n\n   returns the weekday of the specified MJD as atom monday, tuesday etc\n\nArguments\n   MJD    Integer or float\n   DayName    Variable or atom\n\nType\n   library(calendar)"},"calendar:mjd_to_ymd/2":{"prefix":"mjd_to_ymd","body":"mjd_to_ymd(${1:MJD}, ${2:YMD})$3\n$0","description":"mjd_to_ymd(++MJD, ?YMD)\n\n   Converts an MJD day number into the corresponding ISO8601 Year-Month-Day form\n\nArguments\n   MJD    Integer or float\n   YMD    Variable or structure\n\nType\n   library(calendar)\n\nSee Also\n   ymd_to_mjd / 2"},"calendar:mjd_to_ywd/2":{"prefix":"mjd_to_ywd","body":"mjd_to_ywd(${1:MJD}, ${2:YWD})$3\n$0","description":"mjd_to_ywd(++MJD, ?YWD)\n\n   Convert an MJD to ISO8601 Year-Week-Day representation\n\nArguments\n   MJD    Integer or float\n   YWD    Variable or structure of the form Year-Week-Day\n\nType\n   library(calendar)\n\nDescription\nConvert MJDs to a Year-WeekOfYear-DayOfWeek representation\n\taccording to ISO 8601, where DayOfWeek is the day number within the\n\tweek (1 for monday up to 7 for sunday), and WeekOfYear is the ISO8601\n\tweek number (where week 1 is the week containing January 4th).\n\tNote that January 1 to 3 may belong to the previous year."},"calendar:time_to_mjd/2":{"prefix":"time_to_mjd","body":"time_to_mjd(${1:HMS}, ${2:MJD})$3\n$0","description":"time_to_mjd(++HMS, ?MJD)\n\n   Convert the time in H:M:S form to a float MJD <1.0\n\nArguments\n   HMS    A structure of the form H:M:S or H:M, where H and M are integers and S is a float\n   MJD    Variable or float\n\nType\n   library(calendar)\n\nDescription\nReturns a float MJD <1.0 encoding the time of day (UTC/GMT). This can be added to an integral day number to obtain a full MJD."},"calendar:unix_to_mjd/2":{"prefix":"unix_to_mjd","body":"unix_to_mjd(${1:UnixTime}, ${2:MJD})$3\n$0","description":"unix_to_mjd(++UnixTime, ?MJD)\n\n   Convert the UNIX time representation into a (float) MJD\n\nArguments\n   UnixTime    Integer or float (seconds since 1 Jan 1970)\n   MJD    Variable or float\n\nType\n   library(calendar)"},"calendar:ymd_to_mjd/2":{"prefix":"ymd_to_mjd","body":"ymd_to_mjd(${1:YMD}, ${2:MJD})$3\n$0","description":"ymd_to_mjd(++YMD, ?MJD)\n\n   Convert a date in ISO8601 Year-Month-Day form to an MJD day number\n\nArguments\n   YMD    A structure of the form Y-M-D where D,M and Y are integers\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nSee Also\n   mjd_to_ymd / 2"},"calendar:ywd_to_mjd/2":{"prefix":"ywd_to_mjd","body":"ywd_to_mjd(${1:DWY}, ${2:MJD})$3\n$0","description":"ywd_to_mjd(++DWY, ?MJD)\n\n   Convert an ISO8601 Year-Week-Day representation to MJD\n\nArguments\n   DWY    structure of the form Year-Week-Day\n   MJD    Variable or integer\n\nType\n   library(calendar)\n\nDescription\nConvert a Year-WeekOfYear-DayOfWeek representation to MJD,\n    \twhere DayOfWeek is the day number within the week (1 for monday\n\tup to 7 for sunday), and WeekOfYear is the ISO8601 week number\n\t(where week 1 is the week containing January 4th). Note that\n\tJanuary 1 to 3 may belong to the previous year."},"cgi:get_error_output/1":{"prefix":"get_error_output","body":"get_error_output(${1:Message})$2\n$0","description":"get_error_output(-Message)\n\n   Retrieve error messages explaining failure of posted_params/1\n\nType\n   library(cgi)\n\nSee Also\n   posted_params / 1"},"cgi:get_param_value/3":{"prefix":"get_param_value","body":"get_param_value(${1:NameValuePairs}, ${2:Name}, ${3:Value})$4\n$0","description":"get_param_value(+NameValuePairs, +Name, ?Value)\n\n   Look up the value of a posted parameter\n\nType\n   library(cgi)\n\nDescription\nLook up the value of a posted parameter. Returns an empty string\n    if there is no parameter with the given name. Name must be an atom.\n\nSee Also\n   posted_params / 1, substitute_placeholders / 3"},"cgi:posted_params/1":{"prefix":"posted_params","body":"posted_params(${1:NameValuePairs})$2\n$0","description":"posted_params(-NameValuePairs)\n\n   Returns the parameters posted to the CGI script\n\nType\n   library(cgi)\n\nDescription\nReturns a list of Name=Value pairs, where Name is an atom\n    and Value is a string, representing the information that was posted to\n    the CGI script. Both POST and GET methods are supported.\n    \n    If there is a problem, the predicate fails. In that case, the caller should\n    retrieve an error message using get_error_output/1 and present it to the\n    user, e.g. by embedding it into the generated html page.\n    \n\nFail Conditions\n   There was a problem obtaining the parameters from the environment\n\nSee Also\n   get_param_value / 3, substitute_placeholders / 3, get_error_output / 1"},"cgi:substitute_placeholders/3":{"prefix":"substitute_placeholders","body":"substitute_placeholders(${1:PageTemplate}, ${2:NameValuePairs}, ${3:Page})$4\n$0","description":"substitute_placeholders(+PageTemplate, +NameValuePairs, -Page)\n\n   Substitute placeholders in a html source with a value string\n\nType\n   library(cgi)\n\nDescription\nTakes a string (usually a html-source) with embedded\n    placeholders and replaces the placeholders by their value according\n    to the NameValuePairs argument. The syntax for placeholders is their\n    name enclosed in ^ (up arrow) characters.\n\nSee Also\n   posted_params / 1, get_param_value / 3"},"changeset:monitor_changes/6":{"prefix":"monitor_changes","body":"monitor_changes(${1:Vars}, ${2:Templates}, ${3:Prio}, ${4:CondList}, ${5:AttrMod}, ${6:ChangeStream})$7\n$0","description":"monitor_changes(+Vars, +Templates, +Prio, +CondList, +AttrMod, -ChangeStream)\n\n   Monitor variables for modifications\n\nArguments\n   Vars    A list containing variables\n   Templates    A list of terms corresponding to the variables\n   Prio    Priority for the monitoring demons\n   CondList    Suspension list spec\n   AttrMod    Suspension list attribute module\n   ChangeStream    A lazy list of lists of changes\n\nType\n   library(changeset)\n\nDescription\n\n    Like monitor_changes_arr/5, but (instead of array indices) the\n    ChangeStream contains the elements of the Templates-list that\n    correspond to the modified variables, thus allowing arbitrary\n    information to be conveyed to the code that processes the changes.\n    \n    [eclipse 10]: X1::1..9, X2::1..8,\n\t    monitor_changes([X1,X2],[info(1,X1),info(2,X2)], 8,\n\t\t\t    [min of fd, max of fd], fd, Stream),\n\t    X1 #> X2, X2 #>= 5.\n\n    Stream = [[info(1, X1{[6..9]})], [info(2, X2{[5..8]}), info(1, X1)]|More]\n    X1 = X1{[6..9]}\n    X2 = X2{[5..8]}"},"changeset:monitor_changes_arr/5":{"prefix":"monitor_changes_arr","body":"monitor_changes_arr(${1:VarArr}, ${2:Prio}, ${3:CondList}, ${4:AttrMod}, ${5:ChangeStream})$6\n$0","description":"monitor_changes_arr(+VarArr, +Prio, +CondList, +AttrMod, -ChangeStream)\n\n   Monitor variables for modifications\n\nArguments\n   VarArr    A structure containing variables\n   Prio    Priority for the monitoring demons\n   CondList    Suspension list spec\n   AttrMod    Suspension list attribute module\n   ChangeStream    A lazy list of lists of changes\n\nType\n   library(changeset)\n\nDescription\n\n    This predicate monitors an array of variables for certain\n    modifications, and creates a continuous stream of lists of indices of\n    modified variables, e.g.\n    \n\tmonitor_changes_arr(VarArr, 8, [min of fd, max of fd], fd, Stream)\n    \n    will monitor the variables in VarArr for modifications of their min/max\n    fd-attributes. The monitor will run with a priority of 8 to 9.\n    All variable modifications that occur between two wakings of the\n    monitor will be detected by the monitor. It will then create a list\n    of indices of the modified variables, and append this list to\n    ChangeStream.\n    \n\t[eclipse 4]: X1::1..9, X2::1..8,\n\t\tmonitor_changes_arr(v(X1,X2), 8,\n\t\t\t\t    [min of fd, max of fd], fd, Changes),\n\t\tX1 #> X2, X2 #>= 5.\n\n\tChanges = [[1], [2, 1]|More]\n\tX1 = X1{[6..9]}\n\tX2 = X2{[5..8]}\n    \n    What happened here is that the first constraint X1 #> X2 caused X1 to\n    change its lower bound, therefore [1] was appended to the Changes list.\n    Then X2 #>= 5 raised the lower bound of X2 and (because X1 #> X2)\n    the lower bound of X1, therefore both variable indices [1,2] were\n    appended to the Changes list.\n    \n    The priority of the monitor should be set up such that is is lower than\n    the priority of the propagation constraints. In that case, the lists\n    that get appended to ChangeStream represent exactly the set of variables\n    (without duplicates) that were modified by one propagation sequence.\n    \n    Note that the ChangeStream can be used to trigger actions whenever\n    new changes get appended, for example:\n    \n\tdelay report_changes(X) if var(X).\n\treport_changes([]).\n\treport_changes([X|T]) :-\n\t\tprintf(\"The following variables changed: %Mw%n%b\", [X]),\n\t\treport_changes(T).\n\n\t[eclipse 11]: X1::1..9, X2::1..8,\n\t\tmonitor_changes_arr(v(X1,X2), 8,\n\t\t\t\t\t[min of fd, max of fd], fd, Changes),\n\t\treport_changes(Changes),\n\t\tX1 #> X2, X2 #>= 5.\n\tThe following variables changed: [1]\n\tThe following variables changed: [2, 1]\n\t..."},"chr:chr/1":{"prefix":"chr","body":"chr(${1:File})$2\n$0","description":"chr(+File)\n\n   Compile File.chr into a .pl file and load the pl file.\n\nArguments\n   +File    A file name (with extension chr).\n\nType\n   library(chr)\n\nDescription\n   Compile File.chr containing constraint handling rules into a .pl file\n   and load the pl file.  Note that even if the file cannot be opened by\n   UNIX (Error 170), a nonempty .pl file will be produced and loaded (with\n   no effect).\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- File is not an atom or string.\n   170 --- UNIX cannot open the file.\n\nExamples\n      Success:\n[eclipse]: chr(minmax).\nminmax.chr compiled traceable 106874 bytes in 3.37 seconds\nminmax.pl  compiled traceable 124980 bytes in 1.83 seconds\nyes.\n\nSee Also\n   chr2pl / 1"},"chr:chr2pl/1":{"prefix":"chr2pl","body":"chr2pl(${1:File})$2\n$0","description":"chr2pl(+File)\n\n   Compile File.chr into a .pl file.\n\nArguments\n   +File    A file name (with extension chr).\n\nType\n   library(chr)\n\nDescription\n   Compile File.chr containing constraint handling rules into a .pl file.\n   Note that even if the file cannot be opened by UNIX (Error 170), a\n   nonempty .pl file will be produced.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     5 --- File is not an atom or string.\n   170 --- UNIX cannot open the file.\n\nExamples\n      Success:\n[eclipse]: chr(minmax).\nminmax.chr compiled traceable 106874 bytes in 3.37 seconds\nyes.\n\nSee Also\n   chr / 1"},"chr:chr_get_constraint/1":{"prefix":"chr_get_constraint","body":"chr_get_constraint(${1:Constraint})$2\n$0","description":"chr_get_constraint(?Constraint)\n\n   Remove a constraint unifying with Constraint from the constraint store.\n\nArguments\n   ?Constraint    A constraint (callable term) defined by constraint handling    rules.\n\nType\n   library(chr)\n\nDescription\n   Removes a constraint unifying with Constraint from the constraint store.\n   Note that if the unification with Constraint binds variables occurring\n   also in other constraints in the constraint store, these constraints may\n   be simplified (see last examples).  Thus it is recommended to use either\n   a free variable or a term with variable arguments for Constraint.  Used\n   by advanced constraint handling rules users to manipulate themselves the\n   constraints defined by constraint handling rules.\n\nFail Conditions\n      Fails if there is no constraint (defined by constraint handling rules)\n   in the constraint store that unifies with Constraint.\n\nResatisfiable\n      Yes.\n\nExamples\n      Example using the constraint handler for Booleans  bool.chr:\n[eclipse]: chr_get_constraint(C).\nno (more) solution.\n\n[eclipse]: and(X,Y,Z), or(X,Y,Z).\n\nConstraints:\n(1) X_g745 * Y_g777 = Z_g809 % pretty print of and/3 constraint\n(2) X_g745 + Y_g777 = Z_g809 % pretty print of or/3 constraint\n\nyes.\n\n[eclipse]: and(X,Y,Z), or(X,Y,Z), chr_get_constraint(C).\n\nC = X * Y = Z\n\nConstraints:\n(2) X_g765 + Y_g797 = Z_g829\n     More? (;)\n\nC = X + Y = Z\n\nConstraints:\n(1) X_g765 * Y_g797 = Z_g829\n     More? (;)\nno (more) solution.\n\n[eclipse]: and(X,Y,Z), or(X,Y,Z), chr_get_constraint(and(1,A,B)).\n% or/3 - constraint is solved when X is bound to 1\nX = 1\nY = A\nZ = 1\nA = A\nB = 1\n\n[eclipse]: and(X,Y,Z), or(X,Y,Z), chr_get_constraint(and(1,1,0)).\nno (more) solution. % or/3 - constraint fails\n\n[eclipse]: and(X,Y,Z), chr_get_constraint(and(1,1,0)).\n\nX = 1\nY = 1\nZ = 0\n\n   The predicate chr_labeling/0 can be defined as:\nlabeling :-\n   chr_get_constraint(C),\n   chr_label_with(C),\n   !,\n   chr_resolve(C),\n   labeling.\n\nlabeling.\n\nSee Also\n   chr_labeling / 0, chr_label_with / 1, chr_resolve / 1, chr_get_constraint / 1, chr_get_constraint / 2"},"chr:chr_get_constraint/2":{"prefix":"chr_get_constraint","body":"chr_get_constraint(${1:Variable}, ${2:Constraint})$3\n$0","description":"chr_get_constraint(Variable,?Constraint)\n\n   Remove a constraint in which the variable Variable occurs and which unifies\nwith Constraint from the constraint store.\n\nArguments\n   Variable    A free variable.\n   ?Constraint    A constraint (callable term) defined by constraint handling    rules.\n\nType\n   library(chr)\n\nDescription\n   Removes a constraint in which the variable Variable occurs and which\n   unifies with Constraint from the constraint store.  Note that if the\n   unification with Constraint binds variables occurring also in other\n   constraints in the constraint store, these constraints may be simplified\n   (see last examples).  Thus it is recommended to use either a free\n   variable or a term with variable arguments for Constraint.  Used by\n   advanced constraint handling rules users to manipulate themselves the\n   constraints defined by constraint handling rules.  See also\n   chr_get_constraint/1 for more examples.\n\nFail Conditions\n      Fails if Variable is not a free variable or if there is no constraint\n   (defined by constraint handling rules) in the constraint store that\n   unifies with Constraint and in which the variable Variable occurs.\n\nResatisfiable\n      Yes.\n\nExamples\n      Example using the constraint handler for Booleans  bool.chr:\n[eclipse]: and(X,Y,Z), or(A,B,C), chr_get_constraint(Y,Cstr).\n\nX = X\nZ = Z\nA = A\nB = B\nY = Y\nCstr = X * Y = Z\n\nConstraints:\n(2) A + B = C   % pretty print for or/3 - constraint\n\n     More? (;)\n\nno (more) solution.\n\n   The following predicate labeling(+Varlist) labels the variables in the\n   list Varlist:\nlabeling([X|VL]) :-\n   var(X),\n   chr_get_constraint(X,C),\n   chr_label_with(C),\n   !,\n   chr_resolve(C),\n   labeling([X|VL]).\n\nlabeling([X|VL]) :-\n   labeling(VL).\n\nlabeling([]).\n\nSee Also\n   chr_labeling / 0, chr_label_with / 1, chr_resolve / 1, chr_get_constraint / 2"},"chr:chr_label_with/1":{"prefix":"chr_label_with","body":"chr_label_with(${1:Constraint})$2\n$0","description":"chr_label_with(+Constraint)\n\n   Checks the label_with declarations of Constraint.\n\nArguments\n   +Constraint    A chr constraint.\n\nType\n   library(chr)\n\nDescription\n   Checks the label_with declarations of Constraint.  Used by advanced\n   constraint handling rules users to write their own labeling procedure\n   for the constraints defined by constraint handling rules.\n\nFail Conditions\n      Fails if Constraint is a variable or if Constraint does not have a\n   label_with declaration or if the guard of all unifying label_with\n   declarations fail.\n\nResatisfiable\n      Yes.\n\nExamples\n      Given the following  label_with declaration (from the example\n   constraint handler in file  time-pc.chr:\nlabel_with path(N, X, Y, L, T, I) if N>1.\n\n[eclipse]: chr_label_with(path(N,X,Y,L,T,I)).\nno (more) solution.\n\n[eclipse]: chr_label_with(path(1,X,Y,L,T,I)).\nno (more) solution.\n\n[eclipse]: chr_label_with(path(2,X,Y,L,T,I)).\nX = X\nY = Y\nL = L\nT = T\nI = I     More? (;)\nno (more) solution.\n\nSee Also\n   chr_labeling / 0, chr_resolve / 1, chr_get_constraint / 1, chr_get_constraint / 2"},"chr:chr_labeling/0":{"prefix":"chr_labeling","body":"chr_labeling","description":"chr_labeling\n\n   Activates the built-in labeling feature for constraint handling rules.\n\nArguments\n\nType\n   library(chr)\n\nDescription\n   The constraint handling rule run-time system provides built-in labeling\n   user-defined constraints.  The built-in labeling is invoked by calling\n   the built-in predicate chr_labeling/0.  Once called, whenever no more\n   constraint handling is possible, the built-in labeling will choose a\n   constraint goal whose label_with declaration is satisfied for labeling.\n   It will introduce choices using the clauses of the constraint.\n\nFail Conditions\n      None, only on backtracking.\n\nResatisfiable\n      Yes.\n\nExamples\n   \n   A query without and with built-in labeling:\n[eclipse]: minimum(X,Y,Z), maximum(X,Y,W), Z neq W.\n\nX = _g357\nY = _g389\nZ = _g421\nW = _g1227\n\nConstraints:\n(1) minimum(_g357, _g389, _g421)\n(2) _g421 leq _g357\n(3) _g421 leq _g389\n(4) maximum(_g357, _g389, _g1227)\n(5) _g357 leq _g1227\n(7) _g389 leq _g1227\n(10) _g421 lss _g1227\n\nyes.\n\n[eclipse]: minimum(X,Y,Z), maximum(X,Y,W),\n    Z neq W, chr_labeling.\n\nX = Z = _g363\nY = W = _g395\n\nConstraints:\n(10) _g363 lss _g395\n\n     More? (;)\n\nX = W = _g363\nY = Z = _g395\n\nConstraints:\n(17) _g395 lss _g363\nyes.\n\nSee Also\n   chr_label_with / 1, chr_resolve / 1, chr_get_constraint / 1, chr_get_constraint / 2"},"chr:chr_notrace/0":{"prefix":"chr_notrace","body":"chr_notrace","description":"chr_notrace\n\n   Deactivates the standard or Opium debugger extension for constraint\nhandling rules.\n\nArguments\n\nType\n   library(chr)\n\nDescription\n   The query chr_trace.  deactivates the standard or opium debugger.  In\n   case of the Opium debugger, its window remains until quited.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExamples\n      Success:\n[eclipse]: chr_notrace.\nyes.\nDebugger switched off\n\nSee Also\n   chr_opium / 0, chr_trace / 0"},"chr:chr_opium/0":{"prefix":"chr_opium","body":"chr_opium","description":"chr_opium\n\n   Activates the Opium debugger and shows constraint handling.\n\nArguments\n\nType\n   library(chr)\n\nDescription\n   In order to use the Opium debugger, the debug_compile flag must have\n   been on (default) during compilation (chr to pl) and loading of the\n   produced ECLiPSe  code.  The query chr_opium.  opens an Opium window in\n   which the ECLiPSe  code will be traced.  The library chr_opium will be\n   automatically loaded.  Note that the Opium debugger for constraint\n   handling rules works with X graphic interface.  The OPIUM_WINDOW\n   environment variable must thus be set.  An Opium execution can be\n   aborted using the a.  command in Opium.\n\n   Both debuggers display user-defined constraints and application of\n   constraint handling rules.  In the Opium debugger, this information\n   corresponds to additional ports of the debugger.  The additional ports\n   are:\n\n  * add:  A new constraint is added to the constraint store.\n\n  * already_in:  A constraint to be added was already present.\n\n   The ports related to application of rules are:\n\n  * try_rule:  A rule is tried.\n\n  * delay_rule:  The last tried rule cannot fire because the guard did not\n    succeed.\n\n  * fire_rule:  The last tried rule fires.\n\n   The ports related to labeling are:\n  * try_label:  A label_with declaration is checked.\n\n  * delay_label:  The last label_with declaration delays because the guard\n    did not succeed.\n\n  * fire_label:  The last tried label_with declaration succeeds, so the\n    clauses of the associated constraint will be used for built-in\n    labeling.\n\n   When displayed, each constraint is labeled with a unique integer\n   identifier.  Each rule is labeled with its name as given in the chr\n   source using the @ operator.  If a rule does not have a name, it is\n   displayed together with a unique integer identifier.\n\n   See the extension manual chapter on constraint handling rules for more\n   information on the Opium scenario used for debugging.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   chr_trace / 0, chr_notrace / 0"},"chr:chr_resolve/1":{"prefix":"chr_resolve","body":"chr_resolve(${1:Constraint})$2\n$0","description":"chr_resolve(+Constraint)\n\n   Uses the Prolog clauses to solve a constraint Constraint.\n\nArguments\n   +Constraint    A constraint (callable term) defined by constraint handling    rules.\n\nType\n   library(chr)\n\nDescription\n   Uses the Prolog clauses to solve a constraint Constraint.  Used by\n   advanced constraint handling rules users to program labeling procedures\n   for the constraints defined by constraint handling rules.\n\nFail Conditions\n      Fails if there are no Prolog clauses for the constraint or if the bodies\n   of all clauses fail.\n\nResatisfiable\n      Yes.\n\nExceptions\n     4 --- Constraint is a free variable.\n     6 --- Constraint is term which is not a constraint (defined by    constraint handling rules).\n\nExamples\n      Example using the constraint handler for Booleans in file  bool.chr:\n[eclipse]: chr_resolve(X).\ninstantiation fault in is_predicate(_g671 / _g639)\n\n[eclipse]: chr_resolve(and(X,Y)).\nout of range in chr_resolve(and(X,Y))\n\n[eclipse]: chr_resolve(and(X,Y,Z)).\n\nX = 0\nY = Y\nZ = 0     More? (;)\n\nX = 1\nY = Z\nZ = Z\nyes.\n\n[eclipse]: chr_resolve(and(a,b,c)).\nno (more) solution.\n\n   The predicate chr_labeling/0 can be defined as:\nlabeling :-\n   chr_get_constraint(C),\n   chr_label_with(C),\n   !,\n   chr_resolve(C),\n   labeling.\n\nlabeling.\n\nSee Also\n   chr_labeling / 0, chr_label_with / 1, chr_get_constraint / 1, chr_get_constraint / 2"},"chr:chr_trace/0":{"prefix":"chr_trace","body":"chr_trace","description":"chr_trace\n\n   Activates the standard debugger and shows constraint handling.\n\nArguments\n\nType\n   library(chr)\n\nDescription\n   In order to use the standard debugger, the debug_compile must have been\n   on (default) during compilation (chr to pl) and loading of the produced\n   ECLiPSe  code.  The query chr_trace.  activates the standard debugger\n   showing more information about the handling of constraints.  In the\n   standard debugger, user-defined constraints are treated as predicates\n   and the information about application of constraint handling rules is\n   displayed without stopping.  The additional information displayed is:\n\n  * add:  A new constraint is added to the constraint store.\n\n  * already_in:  A constraint to be added was already present.\n\n   The ports related to application of rules are:\n\n  * try_rule:  A rule is tried.\n\n  * delay_rule:  The last tried rule cannot fire because the guard did not\n    succeed.\n\n  * fire_rule:  The last tried rule fires.\n\n   The ports related to labeling are:\n  * try_label:  A label_with declaration is checked.\n\n  * delay_label:  The last label_with declaration delays because the guard\n    did not succeed.\n\n  * fire_label:  The last tried label_with declaration succeeds, so the\n    clauses of the associated constraint will be used for built-in\n    labeling.\n\n   When displayed, each constraint is labeled with a unique integer\n   identifier.  Each rule is labeled with its name as given in the chr\n   source using the @ operator.  If a rule does not have a name, it is\n   displayed together with a unique integer identifier.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExamples\n      Success:\n[eclipse]: chr_trace.\nyes.\nDebugger switched on - creep mode\n[eclipse]: notrace.     % trace only constraints\nDebugger switched off\nyes.\n[eclipse]: minimum(X,Y,Z), maximum(X,Y,Z).\n% trace edited to show only firing rules\n\nADD (1) minimum(X, Y, Z)\nTRY (1) minimum(_g218, _g220, _g222) with propagation\nRULE 'propagation' FIRED\n\n ADD (2) leq(_g665, _g601)\n\n ADD (3) leq(_g665, Var)\n\nADD (4) maximum(_g601, Var, _g665)\nTRY (4) maximum(_g601, Var, _g665) with propagation\nRULE 'propagation' FIRED\n\n ADD (5) leq(_g601, _g665)\n TRY (5) leq(_g601, _g665) (2) leq(_g665, _g601) with antisymmetry\n RULE 'antisymmetry' FIRED\n\nTRY (4) maximum(_g601, Var, _g601) with max_eq\nRULE 'max_eq' FIRED\n\n ADD (6) leq(Var, _g601)\n TRY (3) leq(_g601, Var) (6) leq(Var, _g601) with antisymmetry\n RULE 'antisymmetry' FIRED\n\nTRY (1) minimum(_g601, _g601, _g601) with min_eq\nRULE 'min_eq' FIRED\n\n ADD (7) leq(_g601, _g601)\n TRY (7) leq(_g601, _g601) with reflexivity\n RULE 'reflexivity' FIRED\n\nX = Y = Z = _g558\nyes.\n\nSee Also\n   chr_opium / 0, chr_notrace / 0"},"cio:cio_desc":{"prefix":"lib","body":"lib(${1:cio})$2\n$0","description":"lib(cio)\n\n    This library provides C-Prolog compatible I/O predicates. It is included\n    in the C-Prolog compatibility package, but can be used independently.\n    The predicates change ECLiPSe's input or output stream, respectively."},"colgen:SE/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:(?X $= ?Y)\n\n   Constrains X to be equal to Y.\n\nArguments\n   X    Partial linear expression\n   Y    Partial linear expression\n\nType\n   library(colgen)\n\nDescription\n    \n    Logically: Constrains X to be less than or equal to Y.  X and Y\n    are partial linear expressions. Partial linear expressions may\n    contain terms of the form implicit_sum(+Var) in addition\n    to any terms allowed within a standard linear\n    expression. Variables occurring inside implicit_sum/1\n    terms are taken to be subproblem variables whose instantiation\n    will correspond to the coefficient of a generated master problem\n    variable in this constraint. Operationally, the constraint gets\n    delayed until the external solver state for ColgenInstance is\n    invoked.\n    \n \n\nSee Also\n   $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2, var_get / 3"},"colgen:SEL/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:(?X $=< ?Y)\n\n   Constrains X to be less than or equal to Y.\n\nArguments\n   X    Partial linear expression\n   Y    Partial linear expression\n\nType\n   library(colgen)\n\nDescription\n    \n    Logically: Constrains X to be less than or equal to Y.  X and Y\n    are partial linear expressions. Partial linear expressions may\n    contain terms of the form implicit_sum(+Var) in addition\n    to any terms allowed within a standard linear\n    expression. Variables occurring inside implicit_sum/1\n    terms are taken to be subproblem variables whose instantiation\n    will correspond to the coefficient of a generated master problem\n    variable in this constraint. Operationally, the constraint gets\n    delayed until the external solver state for ColgenInstance is\n    invoked.\n    \n \n\nSee Also\n   $= / 2, $>= / 2, =:= / 2, =< / 2, >= / 2, var_get / 3"},"colgen:SGE/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:(?X $>= ?Y)\n\n   Constrains X to be greater than or equal to Y.\n\nArguments\n   X    Partial linear expression\n   Y    Partial linear expression\n\nType\n   library(colgen)\n\nDescription\n    \n    Logically: Constrains X to be greater than or equal to Y. X and Y\n    are partial linear expressions. Partial linear expressions may\n    contain terms of the form implicit_sum(+Var) in addition\n    to any terms allowed within a standard linear\n    expression. Variables occurring inside implicit_sum/1\n    terms are taken to be subproblem variables whose instantiation\n    will correspond to the coefficient of a generated master problem\n    variable in this constraint. Operationally, the constraint gets\n    delayed until the external solver state for ColgenInstance is\n    invoked.\n    \n \n\nSee Also\n   $= / 2, $=< / 2, =:= / 2, =< / 2, >= / 2, var_get / 3"},"colgen:cg_subproblem_solution/1":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:cg_subproblem_solution(++Value)\n\n   Posts new subproblem solution(s) to the colgen instance ColgenInstance.\n\nArguments\n   Value    Subproblem solution (sp_sol structure) or list of subproblem solutions\n\nType\n   library(colgen)\n\nDescription\n  \n  Post subproblem solution(s) corresponding to a column of coefficients\n  for a new master problem variable to the colgen instance\n  ColgenInstance. The argument must be a sp_sol\n  structure or list of such structures:\n \n      sp_sol(cost, coeff_vars, aux)\n \n  where cost is the master problem cost function coefficient\n  of the solution, coeff_vars is a list of Id-Val\n  pairs corresponding to the subproblem variable solution values and\n  identifier of the constraint in which it occurred as an implicit sum\n  term for those subproblem variables with a non-zero solution\n  value. aux should contain any problem specific information\n  which is of interest that is not represented uniquely by the cost\n  and objective coefficients."},"colgen:colgen_desc":{"prefix":"lib","body":"lib(${1:colgen})$2\n$0","description":"lib(colgen)\n\n   This library lets you use hybrid column generation. Partial linear\n   constraints are posted to a solver and further variables added to\n   them during search as they become profitable. The generated\n   variables will have a column of coefficients in the constraints of\n   the colgen instance associated with them corresponding to\n   particular instantiations of the variables of a subproblem. The\n   predicate to find profitable subproblem variable instantiations is\n   supplied by the user. When a user-defined branching predicate is\n   provided, the library can also be used for hybrid branch-and-price.\n\n   The library uses the eplex library to solve LP master\n   problems, from which dual values are used to create cost functions\n   for the user-defined subproblem. Solution of master and subproblems\n   will iterate until no further subproblem solutions are posted to\n   the colgen instance."},"colgen:colgen_instance/1":{"prefix":"colgen_instance","body":"colgen_instance(${1:ColgenInstance})$2\n$0","description":"colgen_instance(++ColgenInstance)\n\n   Initialises the colgen instance ColgenInstance.\n\nArguments\n   ColgenInstance      Colgen instance name (atom)\n\nType\n   library(colgen)\n\nDescription\n  \n  Initialises the colgen instance ColgenInstance. A colgen instance is an\n  instance of the colgen solver, to which colgen partial linear arithmetic\n  constraints can be posted, and to which an external LP solver can be\n  associated and used to optimise the posted constraints with respect\n  to some objective.\n  \n  If ColgenInstance is not an already existing colgen instance, a new colgen\n  instance will be created and initialised. If it is an existing colgen\n  instance, and it is not currently being used (having no outstanding posted\n  constraints and no associated solver), it is effectively reinitialised.\n  Otherwise, the predicate aborts with an error. Note that a colgen instance\n  is a module, and each colgen instance can be associated with at most one\n  solver at any time and vice versa.\n  \n  \n\nSee Also\n   >= / 2, =:= / 2, =< / 2, $>= / 2, $= / 2, $=< / 2, var_get / 3"},"colgen:get/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:get(++What, -Value)\n\n   Obtain global problem information.\n\nArguments\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(colgen)\n\nDescription\n\n   Retrieve information about solver constraints and results, for the\n   colgen instance ColgenInstance. What can take one of the following values:\n\n    dual(+Id)\n      Returns the floating-point value of the\n      current dual value for the constraint having identifier Id. See\n      also sp_obj below.\n\n    sp_obj(+Id)\n      Returns the sub problem objective terms currently associated\n      associated with the constraint having identifier Id. This will\n      be a term Val*Var where Val is the current dual value\n      for the constraint as also returned by\n      ColgenInstance:get(dual(Id), Val) and Var is the\n      subproblem variable in the implicit sum term of the\n      constraint. It is the users responsibility to get all relevant\n      terms of the current cost function and ensure that subproblem\n      solutions posted to the colgen instance have a non-negative\n      cost.\n\n    vars\n      Returns a list of all variables currently\n      associated with the colgen instance ColgenInstance.\n\n    non_zero_vars\n      Returns a list of all variables currently associated with\n      the colgen instance ColgenInstance that have a non-zero\n      optimal solution. This may be more efficient than retrieving all\n      problem variables after solution, since very many variables can\n      be generated and most will have a zero value in the optimal\n      solution.\n\n    frac_vars\n      Returns a list of all variables currently associated with\n      the colgen instance ColgenInstance that have a\n      fractional optimal solution. This is intended for use primarily\n      in user-defined problem branching predicates.\n\n    column_count\n      Number of generated columns.\n\n    obj_val\n      Current objective value.\n\n    unsatisfiable_cstrs\n\n    satisfiable_cstrs\n\n    generated_non_zero_vars\n\n    non_zero_vars\n\n    vars\n\n    sep_goal\n      Separation goal.\n\n    sp_solver\n      Subproblem solver goal.\n\n    stab_coeff/bound_minus/plus(Ident)\n      Stabilisation parameters per constraint."},"colgen:identified_constraint/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:identified_constraint(+Cstr, ?Id)\n\n   Post an identified constraint to the colgen instance ColgenInstance.\n\nArguments\n   Cstr    colgen constraint\n\nType\n   library(colgen)\n\nDescription\n  \n  Post a constraint to the colgen instance ColgenInstance\n  which will be associated with the identifier Id. The\n  constraint Cstr must be a valid colgen constraint of type\n  >=/2,=:=/2,==/2,$=/2,$=. If Id is\n  uninstantiated it will be unified with the external solver row\n  number of the constraint when this is set up. The identifier can\n  later be used to retrieve the dual value or subproblem cost function\n  term associated with the constraint.\n   \n\nSee Also\n   >= / 2, =:= / 2, =< / 2, $>= / 2, $= / 2, $=< / 2, get / 2"},"colgen:minimize/3":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:minimize(+SolveSubProblem, +Obj, -ObjVal)\n\n   Minimizes the problem associated with the colgen instance ColgenInstance.\n\nArguments\n   SolveSubProblem     Subproblem solution predicate\n   Obj    The objective function to minimize\n   ObjVal    The optimal solution cost\n\nType\n   library(colgen)\n\nDescription\n  \n  Minimize the partial linear expression Obj for the problem\n  associated with the colgen instance ColgenInstance, using\n  the user-defined predicate SolveSubProblem to provide\n  profitable variables during solution. The optimal solution cost is\n  unified with ObjVal.\n  \n  The first argument of the subproblem solution predicate must be a\n  subproblem structure, as specified in solver_setup/3.\n  \n  \n\nSee Also\n   solver_setup / 3"},"colgen:set/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:set(+What,++Value)\n\n   Set parameters for column generation instance.\n\nArguments\n   What    Parameter name\n   Value    Parameter value\n\nType\n   library(colgen)\n\nDescription\n    \n    Set parameters for the give column generation instance:\n    \n\ndisallow (off|lp|clp)\n    policy for active preventions of duplicate columns.\nint_tolerance (1e-5|float)\n    tolerance for optimality.\nbasis_perturbation (off|on)\n    should we try and perturb the external solver basis when we appear\n    to be at optimal and external solver returns same basis after adding\n    columns  ('off' - no, 'on' - temporarily set the external solver\n    to always perturb)\ninfo_messages (off|on)\n    print messages while solving.\non_degeneracy (stop|continue)\n    should we halt when we find degeneracy (default 'stop'), or\n    continue and let the subproblem solver deal with it ('continue').\nstabilisation (off|on()|stab_pred())\n    the policy to perform basis stabilisation:\n    \n    off\n\tno stabilisation is performed.\n    on(BoundIter, BoundUpdate, CoeffIter, CoeffUpdate)\n\tthen the default policy is used with var bounds/coefficients\n\tupdated by BoundUpdate/CoeffUpdate after BoundIter/CoeffIter\n\titerations respectively.\n    stab_pred(UpdatePred, StoppingPred)\n\ta user defined policy is employed and UpdatePred/ StoppingPred\n\tshould be predicates that perform the updates and test for\n\tstopping conditions.\n    \nstab_coeff/bound_minus/plus(Ident)\n    parameters for stabilisation, per constraint.\n\n \n\nSee Also\n   get / 2, solver_setup / 3"},"colgen:solver_setup/2":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:solver_setup(+SolveSubProblem, +Obj)\n\n   Define subproblem and objective for ColgenInstance.\n\nArguments\n   SolveSubProblem     Subproblem solution predicate\n   Obj    The objective function to minimize\n\nType\n   library(colgen)\n\nDescription\n    Equivalent to solver_setup/3 with default options.\n    \n\nSee Also\n   solver_setup / 3"},"colgen:solver_setup/3":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:solver_setup(+SolveSubProblem, +Obj, +Options)\n\n   Define subproblem, objective and options for ColgenInstance.\n\nArguments\n   SolveSubProblem     Subproblem solution predicate\n   Obj    The objective function to minimize\n   Options    A list of options\n\nType\n   library(colgen)\n\nDescription\n  \n  Define the partial linear expression Obj as the objective to\n  minimize for the problem associated with the colgen instance\n  ColgenInstance.  It will typically contain implicit_sum terms.\n  \n  Associate the user-defined predicate SolveSubProblem to provide\n  profitable variables during the solution process.\n  \n  The first argument of the subproblem solution predicate must be a\n  subproblem structure:\n \n      sp_prob(master_pool, cutoff, cost, coeff_vars, aux, ...)\n \n  where and master_pool will be unified with the colgen\n  instance ColgenInstance so that solutions can be posted to\n  it from within the solution predicate, cutoff is a minimum\n  acceptable value for the cost of subproblem solutions that will be\n  updated before calling the predicate, cost is the variable\n  occurring in the implicit sum term of obj (if any)\n  representing the contribution of new subproblem solutions to the\n  master problem solution cost, coeff_vars is a list of all\n  subproblem variables occurring in the implicit sum terms of master\n  problem constraints.\n  \n  \n  The following options are accepted:\n    \n    separate(+SeparationGoal)\n\ta user-specified separation goal (XXX).\n    node_select(+Val)\n\tnode selection criterion passed to bfs instance\n\t(best_first|depth_first|best_estimate).\n    eplex_option(+EplexOption)\n\tOption to be passed to the associated eplex solver instance.\n    disallow(+Policy)\n\tpolicy for active prevention of duplicate columns (off|lp|clp).\n    int_tolerance(+Tol)\n\ttolerance for optimality (1e-5|float).\n    basis_perturbation(+OffOn)\n\tshould we try and perturb the external solver basis when we appear\n\tto be at optimal and external solver returns same basis after adding\n\tcolumns  ('off' - no, 'on' - temporarily set the external solver\n\tto always perturb)\n    info_messages(+OffOn)\n\tprint messages while solving.\n    on_degeneracy(+Action)\n\tshould we halt when we find degeneracy (default 'stop'), or\n\tcontinue and let the subproblem solver deal with it ('continue').\n    stabilisation(+Policy)\n\tthe policy to perform basis stabilisation:\n\t\n\toff\n\t    no stabilisation is performed.\n\ton(BoundIter, BoundUpdate, CoeffIter, CoeffUpdate)\n\t    then the default policy is used with var bounds/coefficients\n\t    updated by BoundUpdate/CoeffUpdate after BoundIter/CoeffIter\n\t    iterations respectively.\n\tstab_pred(UpdatePred, StoppingPred)\n\t    a user defined policy is employed and UpdatePred/ StoppingPred\n\t    should be predicates that perform the updates and test for\n\t    stopping conditions.\n\t\n    \n  \n  \n\nSee Also\n   set / 2"},"colgen:var_get/3":{"prefix":"ColgenInstance","body":"ColgenInstance","description":"ColgenInstance:var_get(+Var, ++What, -Value)\n\n   Obtain information for an individual solver problem variable Var.\n\nArguments\n   Var    A solver problem variable for the solver associated with ColgenInstance\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(colgen)\n\nDescription\n\n   Retrieve information about solver constraints and results related to a\n   particular variable, for the colgen instance ColgenInstance.\n   What can take one of the following values:\n\n    mp_val\n    Returns the floating-point solution for variable Var.\n\n    cost\n    Returns the master problem objective coefficient\n    associated with the variable Var.\n\n    coeffs\n    Returns a list of Id-Val pairs representing the constraint\n    identifiers and coefficient values for the master problem\n    constraints in which the coefficient is non-zero associated\n    with the variable Var.\n\n    aux\n    Returns the auxiliary information associated with the\n    variable Var. The intended use is for subproblem information\n    not represented in the master problem constraint coefficients."},"config_opts:config_opts_desc":{"prefix":"lib","body":"lib(${1:config_opts})$2\n$0","description":"lib(config_opts)\n\n   This library provides a centralised mechanism for managing configuration\n   options for other libraries and applications.  Such options range from\n   turning logging on and off and specifying what statistics to collect and\n   print, to which redundant constraints and search strategies to use.\n\n   A software component registers the fact that it supports an option by\n   calling register_option/3.  An option's value can then be set and\n   retrieved through set_option/2 and get_option/2, respectively.  And any\n   party wishing to be notified when an option's value changes can achieve\n   this by calling request_notification/2.\n\n   The values and associated parameters of configuration options are\n   persistent across backtracking.  Values are copied when set and\n   retrieved, which means that any non-ground values will contain fresh\n   copies of variables when retrieved rather than the original ones.\n\n   Note that at the moment configuration option settings are global, which\n   makes them unsuitable for some purposes (e.g. any library that might be\n   used by more than one component of a software system if those components\n   may wish to use different settings for that library).  We hope to address\n   this issue in a future version of this library, probably by allowing the\n   use of handles to manage multiple sets of options.\n\n   This library is still experimental and is expected to evolve.  Feedback,\n   suggestions, problem reports, etc. welcome."},"config_opts:get_all_options/1":{"prefix":"get_all_options","body":"get_all_options(${1:OptionList})$2\n$0","description":"get_all_options(?OptionList)\n\n   Retrieves the current values of all options\n\nArguments\n   OptionList    List of (Module:Name)-Value terms\n\nType\n   library(config_opts)\n\nDescription\n   This predicate retrieves the current values of all options, returning a\n   list of terms of the form (Module:Name)-Value, where Name is the name of\n   the option, Module is the module that defined (registered) it, and Value\n   is the current value of the option.\n\n   The values are copied during retrieval, which means that if they are\n   non-ground then they will contain fresh copies of variables rather than\n   the original ones (or sharing with other retrieved copies).\n\nSee Also\n   register_option / 3, set_option / 2, get_option / 2"},"config_opts:get_option/2":{"prefix":"get_option","body":"get_option(${1:Name}, ${2:Value})$3\n$0","description":"get_option(++Name, ?Value)\n\n   Retrieves the current value of an option\n\nArguments\n   Name    Name of the option\n   Value    Value to be given to the option\n\nType\n   library(config_opts)\n\nDescription\n   This predicate retrieves the current value Value of the option with name\n   Name.  The option must have already been registered with\n   register_option/3.\n\n   Value is copied during retrieval, which means that if it is non-ground\n   then it will contain fresh copies of variables rather than the original\n   ones (or sharing with other retrieved copies).\n\nSee Also\n   register_option / 3, set_option / 2"},"config_opts:register_option/3":{"prefix":"register_option","body":"register_option(${1:Name}, ${2:InitialValue}, ${3:Options})$4\n$0","description":"register_option(++Name, ?InitialValue, +Options)\n\n   Register an option\n\nArguments\n   Name    Name of the option (any ground term)\n   InitialValue    Initial value to be given to option\n   Options    List of options related to this option\n\nType\n   library(config_opts)\n\nDescription\n   This predicate sets up an option with name Name and initial value\n   InitialValue.  Name must be ground; InitialValue can be any term but\n   should normally be ground, since it will be copied when stored and\n   retrieved, which means that any retrieved non-ground value will contain\n   fresh copies of variables rather than the original ones.\n\n   Options must be a list.  The following terms may appear in this list:\n   \n   validation_pred(Pred/Arity)\n       Pred is used to validate any value to be assigned to the option.\n       This can be used to ensure that only legal values are assigned to the\n       option.  Arity must be either 1 or 2, corresponding to the arity of\n       the predicate to be called: if Arity is 1 then Pred(NewValue) is\n       called, if Arity is 2 then Pred(Name, NewValue) is called; Name is\n       the name of the option and NewValue is the value to be validated.  If\n       the call to Pred succeeds then the value is assigned to the option;\n       if it fails the value is not assigned.  Any choice points left by the\n       call to Pred are pruned upon success.\n\n       Only one validation predicate may be defined for any option; if more\n       are specified then each replaces the one before it.\n\n   notify_pred(Pred)\n       Specifies that Pred(Name, OldValue, NewValue) should be called\n       whenever the value of the option Name is changed.  OldValue is the\n       old value of the option that has just been replaced and NewValue is\n       the new value that has just been assigned.  Pred should not modify\n       OldValue or NewValue in any way, as this may interfere with other\n       notification predicates.  Note that any choice points left by the\n       call to Pred are pruned upon success.\n\n       See also request_notification/2.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   set_option / 2, get_option / 2, get_all_options / 1, request_notification / 2"},"config_opts:request_notification/2":{"prefix":"request_notification","body":"request_notification(${1:Name}, ${2:Pred})$3\n$0","description":"request_notification(++Name, ++Pred)\n\n   Requests that a predicate be called when an option changes\n\nArguments\n   Name    Name of the option\n   Pred    Predicate to call\n\nType\n   library(config_opts)\n\nDescription\n   Specifies that Pred(Name, OldValue, NewValue) should be called whenever\n   the value of the option Name is changed.  OldValue is the old value of\n   the option that has just been replaced and NewValue is the new value that\n   has just been assigned.  Pred should not modify OldValue or NewValue in\n   any way, as this may interfere with other notification predicates.  Note\n   also that any choice points left by the call to Pred are pruned upon\n   success.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   register_option / 3, set_option / 2"},"config_opts:set_option/2":{"prefix":"set_option","body":"set_option(${1:Name}, ${2:Value})$3\n$0","description":"set_option(++Name, ?Value)\n\n   Gives a new value to an option\n\nArguments\n   Name    Name of the option\n   Value    Value to be given to the option\n\nType\n   library(config_opts)\n\nDescription\n   This predicate gives a new value Value to the option with name Name.  The\n   option must have already been registered with register_option/3.  If the\n   option has an associated validation predicate (see register_option/3),\n   then this is called before the option is given the new value, and if the\n   validation predicate fails the value is not assigned and set_option/2\n   fails.\n\n   If the new value is successfully set, then any notification predicates\n   associated with the option (see request_notification/2 and\n   register_option/3) are called.\n\n   The value set is persistent across backtracking.  Value is copied during\n   setting, which means that if it is non-ground then it will contain fresh\n   copies of variables rather than the original ones when retrieved later.\n\nSee Also\n   register_option / 3, get_option / 2, request_notification / 2"},"conjunto_fd_sets:conjunto_fd_sets_desc":{"prefix":"lib","body":"lib(${1:conjunto_fd_sets})$2\n$0","description":"lib(conjunto_fd_sets)\n\n    This is a wrapper for library(fd_sets) to make it more backward\n    compatible with its predecessor, the set solver library(conjunto).\n    Supported are:\n    \n    the curly-bracket syntax for sets (input only)\n    the backquote-syntax for several constraints (`<>,`<,`::,`=)\n    refine/1\n    \n    Not supported are:\n    \n    non-integer set elements\n    el_weight/2, sum_weight/2 (but see fd_sets:weight/2)\n    max_weight/2 (but see fd_sets:insetdomain/4)"},"conjunto_fd_sets:refine/1":{"prefix":"refine","body":"refine(${1:Set})$2\n$0","description":"refine(?Set)\n\n   Instantiate Set to a possible value\n\nType\n   library(conjunto_fd_sets)\n\nDescription\n\n    Instantiate Set to a possible value. The predicate backtracks over\n    all possible set instantiations. refine/1 is a special instance of\n    the more general insetdomain/4 predicate, and is defined as\n\n    refine(Set) :-\n    \tinsetdomain(Set, any, small_first, in_notin).\n\nResatisfiable\n   yes\n\nSee Also\n   ic_hybrid_sets : insetdomain / 4, ic_sets : insetdomain / 4, fd_sets : insetdomain / 4"},"conjunto:all_disjoint/1":{"prefix":"all_disjoint","body":"all_disjoint(${1:Lsets})$2\n$0","description":"all_disjoint(?Lsets)\n\n   Lsets is a list of set domain variables which are constrained to be\npairwise disjoint.\n\nArguments\n   ?Lsets    List of set domain variables.\n\nType\n   library(conjunto)\n\nDescription\n   Lsets is a list of set domain variables which are constrained to be\n   pairwise disjoint.  Once the unconsistent domain bounds have been\n   updated.  The predicate is a programming abstraction standing for\n   conjunction of disjointness constraints.  The generated disjointness\n   constraints are delayed.  They are activated each time a lower bound of\n   one set domain involed is modified.\n\nFail Conditions\n      Fails if some elements of Lsets are not set variables or if all the set\n   variables can not be pairwise disjoint.\n\nResatisfiable\n      No.\n\nExamples\n   \nS `:: {}.. {1,3,5}, S1 `:: {1} .. {1,3,4}, S2 `::{3,4}..{3,4,5},\nall_disjoint([S,S1,S2]).\n\nS = S{{} .. {5}}\nS1 = {1}\nS2 = S2{{3, 4} .. {3, 4, 5}}\n\nDelayed goals:\n    S{{} .. {5}} dis_s S2{{3, 4} .. {3, 4, 5}}\nyes.\n\nSee Also\n   `:: / 2, `<> / 2, `= / 2, all_union / 2"},"conjunto:all_union/2":{"prefix":"all_union","body":"all_union(${1:Lsets}, ${2:Svar})$3\n$0","description":"all_union(?Lsets, ?Svar)\n\n   Lsets is a list of set domain variables whose union is the set term Svar.\n\nArguments\n   ?Lsets    A list of set domain variables.\n   ?Svar    A free variable or a set variable.\n\nType\n   library(conjunto)\n\nDescription\n   Svar is the union of all the set variables appearing in Lsets.  If Svar\n   is a free variable, it becomes a set variable and its attached domain is\n   defined from the union of the domains or known sets appearing in Lsets.\n\nFail Conditions\n      Fails if some elements of Lsets are not set variables and if Svar can\n   not be the union of the Lsets elements.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 13]: S `:: {}.. {1,2,3,5}, S1 `:: {1} .. {1,2,3,4},\nall_union([S, S1],{1,2,3,4,5}).\n\nS = S{{5} .. {1, 2, 3, 5}}\nS1 = S1{{1, 4} .. {1, 2, 3, 4}}\n\nDelayed goals:\n    ground_union(S{{5} .. {1, 2, 3, 5}},\nS1{{1, 4} .. {1, 2, 3, 4}}, {1, 2, 3, 4, 5})\nyes.\n\nSee Also\n   `:: / 2, `= / 2, `<> / 2, all_disjoint / 1"},"conjunto:el_weight/2":{"prefix":"el_weight","body":"el_weight(${1:Var}, ${2:Wvar})$3\n$0","description":"el_weight(+Var, ?Wvar)\n\n   Var is an element of type e(Val,Weight) from a weighted domain.  Wvar is a\nfree variable unifying with the weight Weight of Var.\n\nArguments\n   +Var    A weighted element.\n   ?Wvar    Term unifying with an integer.\n\nType\n   library(conjunto)\n\nDescription\n   Unifyes the weight of the term Var which should be of the form\n   e(Val,Weight) with Wvar.  This predicate is convenient to select\n   elements for the labeling of weighted sets.\n\nFail Conditions\n      Fails if Var is not of the form e(Val,Weight) or if Wvar is not\n   unifyable with the weight.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 12]: E = e(1,2), el_weight(E, W).\n\nE = e(1, 2)\nW = 2\nyes.\n\nSee Also\n   max_weight / 2, `:: / 2"},"conjunto:glb/2":{"prefix":"glb","body":"glb(${1:S}, ${2:Glb})$3\n$0","description":"glb(?S, ?Glb)\n\n   S is a set domain variable and Glb is the lower bound of its domain.\n\nArguments\n   ?S    A set domain variable.\n   ?Glb    A free variable or a ground set.\n\nType\n   library(conjunto)\n\nDescription\n   Glb is the ground set corresponding to the lower bound of the domain of\n   S. If Glb is a free variable, it is instanciated to the lower bound of\n   the domain of S. If it is a ground set, it should be equal to the lower\n   bound of the domain of S, otherwise it fails.\n\nFail Conditions\n      Fails if S is not a set domain variable or if Glb is a ground set not\n   equal to the lower bound of S domain.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 9]: S `:: {}.. {1,2,3,5}, glb(S,Glb).\n\nS = S{{} .. {1, 2, 3}}\nGlb = {}\nyes.\n\nSee Also\n   `:: / 2, lub / 2, set_range / 3"},"conjunto:list2set/2":{"prefix":"list2set","body":"list2set(${1:List}, ${2:Svar})$3\n$0","description":"list2set(+List, ?Svar)\n\n   Transforms a ground list List into a ground set Svar.\n\nArguments\n   +List    A ground list.\n   ?Svar    A free variable or a ground set.\n\nType\n   library(conjunto)\n\nDescription\n   This predicate forces Svar to be the ground set associated with the\n   ground list List.  Svar can be a free variable or a ground set.\n\nFail Conditions\n      Fails if List is not ground or if Svar is ground and different from the\n   computed set.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 5]: L = [1,3,2,6,4], list2set(L, S).\n\nL = [1, 3, 2, 6, 4]\nS = {1, 2, 3, 4, 6}\nyes.\n\nSee Also\n   set2list / 2"},"conjunto:lub/2":{"prefix":"lub","body":"lub(${1:S}, ${2:Lub})$3\n$0","description":"lub(?S, ?Lub)\n\n   S is a set domain variable and Lub is the lower bound of its domain.\n\nArguments\n   ?S    A set domain variable.\n   ?Lub    A free variable or a ground set.\n\nType\n   library(conjunto)\n\nDescription\n   Lub is the ground set corresponding to the upper bound of the domain of\n   S. If Lub is a free variable, it is instanciated to the upper bound of\n   the domain of S. If it is a ground set, it should be equal to the upper\n   bound of the domain of S, otherwise it fails.\n\nFail Conditions\n      Fails if S is not a set domain variable or if Lub is a ground set not\n   equal to the upper bound of S domain.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 9]: S `:: {}.. {1,2,3,5}, lub(S,Lub).\n\nS = S{{} .. {1, 2, 3}}\nLub = {1, 2, 3}\nyes.\n\nSee Also\n   `:: / 2, glb / 2, set_range / 3"},"conjunto:max_weight/2":{"prefix":"max_weight","body":"max_weight(${1:Svar}, ${2:Var})$3\n$0","description":"max_weight(?Svar, ?Var)\n\n   Svar is a weighted set domain variable whose maximal possible weight\nattached to an element is Var.\n\nArguments\n   ?Svar    A weighted set domain variable or a weighted set.\n   ?Var    Term unifying with a term of the form e(_,_).\n\nType\n   library(conjunto)\n\nDescription\n   If Svar is a weighted set domain variable, it returns the element of its\n   domain which belongs to the set resulting from the difference of the\n   upper bound and the lower bound and which has the greatest weight.  If\n   Svar is a ground set, it just returns the element with the geratest\n   weight.\n\nFail Conditions\n      Fails if Svar is not a weighted set term, or if Var can not be unified\n   with the extracted element.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 4]: S `:: {e(a,10), e(b,15)} ..{e(a,10), e(b,15),\n e(c,20)},  max_weight(S,W).\n\nS = S{{e(a, 10), e(b, 15)} .. {e(a, 10), e(b, 15), e(c, 20)}}\nW = e(c, 20)\nyes.\n\nSee Also\n   `:: / 2"},"conjunto:modify_bound/3":{"prefix":"modify_bound","body":"modify_bound(${1:Flag}, ${2:Svar}, ${3:Var})$4\n$0","description":"modify_bound(+Flag, ?Svar, +Var)\n\n   Flag is a flag which takes its value in fglb, lubg.  It indicates the bound\nof the set domain variable Svar which should be updated and take the value\nVar which is ground.\n\nArguments\n   +Flag    A ground value from fglb, lubg.\n   ?Svar    A set domain variable.\n   +Var    A ground set.\n\nType\n   library(conjunto)\n\nDescription\n   Flag is a flag which should take the value glb or lub, otherwise it\n   fails.  If Svar is a ground set, it succeeds if we have Var equals to\n   Svar.  If Svar is a set domain variable, its new lower or upper bound\n   will be updated and take the value Var.  For monotonicity reasons, set\n   domains can only get reduced.  So a new upper bound has to be contained\n   in the old one and a new lower bound has to contain the old one.\n   otherwise it fails.\n\nFail Conditions\n      Fails if Svar is ground and different from Var or if the new upper bound\n   is not contained in the old one or the new lower bound does not contain\n   the old one.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 9]: S `:: {1,2}..{1,2,3,4,6}, modify_bound(glb, S, {1,2,3}).\n\nS = S{{1, 2, 3} .. {1, 2, 3, 4, 6}}\nyes.\n\nSee Also\n   `:: / 2, glb / 2, lub / 2, set_range / 3"},"conjunto:refine/1":{"prefix":"refine","body":"refine(${1:Svar})$2\n$0","description":"refine(?Svar)\n\n   Instanciate Svar to a value in its set domain.\n\nArguments\n   ?Svar    A set domain variable or a ground set.\n\nType\n   library(conjunto)\n\nDescription\n   If Svar is a set domain variable, it labels Svar to its first possible\n   value (which satisfies the constraints) by taking the largest possible\n   set of elements chosen from the smallest one to the biggest one.  If\n   there are several possible instances of Svar, it creates choice points.\n   It backtracks on the element taken.  If Svar is a ground set, nothing\n   happens.  Otherwise it fails.  If List is a possible list of set domain\n   variables occuring in the program, the simplest labeling procedure is:\n\n    labelings([]).\n    labelings([S | List]) :-\n    refine(S),\n    labelings(List).\n\nFail Conditions\n      Fails if Svar is not a set domain variable or ground set.\n\nResatisfiable\n      On the taken elements.\n\nExamples\n   \n[eclipse 21]: S `:: {} ..{1,2,5,3,8}, refine(S).\n\nS = {1, 2, 3, 5, 8}     More? (;)\nyes\n\nSee Also\n   `:: / 2"},"conjunto:set/1":{"prefix":"set","body":"set(${1:SVar})$2\n$0","description":"set(?SVar)\n\n   Succeeds if SVar is a ground set (not a set domain)\n\nArguments\n   ?SVar    A Prolog term.\n\nType\n   library(conjunto)\n\nDescription\n   This predicate is used to test if a term is a ground set, that is a set\n   variable where the domain is reduced to a singleton or a set of ground\n   values defined with the symbols fg.\n\nFail Conditions\n      Fails if SVar is not a ground set.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 3]: S = {a,{f(a,g),3},c}, set(S).\n\nS = {a,{f(a,g),3},c}\nyes.\n\nSee Also\n   `:: / 2, glb / 2, lub / 2, set_range / 3"},"conjunto:set2list/2":{"prefix":"set2list","body":"set2list(${1:Svar}, ${2:List})$3\n$0","description":"set2list(+Svar, ?List)\n\n   Transforms a ground set Svar into a list of ordered elements List.\n\nArguments\n   +Svar    A ground set.\n   ?List    Term unifying with a list of ground values.\n\nType\n   library(conjunto)\n\nDescription\n   This predicate forces List to be the list of ordered elements associated\n   to the ground set Svar.  List can be a free variable or a ground term.\n   This predicate is convenient when iterations over set elements are\n   required.\n\nFail Conditions\n      Fails if Svar is not ground or if List is ground and different from the\n   computed list.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 3]: S = {1,4,2,6,2,7}, set2list(S, L).\n\nS = {1, 2, 4, 6, 7}\nL = [1, 2, 4, 6, 7]\nyes.\n\nSee Also\n   list2set / 2"},"conjunto:set_range/3":{"prefix":"set_range","body":"set_range(${1:Svar}, ${2:Glb}, ${3:Lub})$4\n$0","description":"set_range(?Svar, ?Glb, ?Lub)\n\n   Svar is a set domain variable and Glb and Lub are the respective lower\nbound and upper bound of its domain.\n\nArguments\n   ?Svar    A set domain variable.\n   ?Glb    A free variable or a ground set.\n   ?Lub    A free variable or a ground set.\n\nType\n   library(conjunto)\n\nDescription\n   This predicate computes the lower bound Glb and the upper bound Lub of\n   the domain attached to the set variable Svar.  If Glb and/or Lub are\n   ground, they should be equal to the respective bounds of the domain,\n   otherwise it fails.\n\nFail Conditions\n      Fails if Svar is not a set domain variable or if one of the terms glb,\n   Lub, can not be unified with the respective bounds of the domain of\n   Svar.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- Var is not a domain variable.\n\nExamples\n   \n[eclipse 7]: S `:: {} .. {1,2,3}, set_range(S, Glb, Lub).\n\nS = S{{} .. {1, 2, 3}}\nGlb = {}\nLub = {1, 2, 3}\nyes.\n\nSee Also\n   `:: / 2, glb / 2, lub / 2"},"conjunto:sum_weight/2":{"prefix":"sum_weight","body":"sum_weight(${1:Svar}, ${2:Var})$3\n$0","description":"sum_weight(?Svar, ?Var)\n\n   Svar is a weighted set domain variable or a weighted ground set and Var a\nfree variable or a domain variable or an integer which represents the\nweight of Svar.\n\nArguments\n   ?Svar    A weighted set domain variable or a weighted ground set.\n   ?Var    Term unifying with a domain variable or an integer.\n\nType\n   library(conjunto)\n\nDescription\n   Svar is a weighted set domain variable or ground set.  Var is the weight\n   of Svar.  If Var is a free variable, this constraint is a mean to access\n   a set weight and attach it to Var.  If not, the weight of Svar is\n   constrained to be equal to Var.  The constraint is delayed and activated\n   each time a modification occurs in the domain of Svar or Var.\n   Convenient when dealing with packing problems.\n\nFail Conditions\n      Fails if Svar is not a weighted set term or if Var can not represent the\n   weight of Svar.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse 4]: S `:: {e(a,10), e(b,15)} ..{e(a,10), e(b,15),\n    e(c,20)}, sum_weight(S, W).\n\nS = S{{e(a, 10), e(b, 15)} .. {e(a, 10), e(b, 15), e(c, 20)}}\nW = W{[25..45]}\n\nDelayed goals:\n    weight_s(S{{e(a, 10), e(b, 15)} .. {e(a, 10),\n    e(b, 15), e(c, 20)}}, W{[25..45]})\nyes.\n\nSee Also\n   `:: / 2"},"constraint_pools:collect_all_pool_constraints/2":{"prefix":"collect_all_pool_constraints","body":"collect_all_pool_constraints(${1:Pool}, ${2:Constraints})$3\n$0","description":"collect_all_pool_constraints(+Pool, -Constraints)\n\n   Collect all currently stored constraints in Pool\n\nArguments\n   Pool    Atom\n   Constraints    Variable, returns list of callable terms\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Constraints is unified with a list of all currently stored constraints\n    in Pool, regardless of their type.  An empty list is returned if the\n    pool was already empty.  The pool store is emptied completely.\n    This modification is backtrackable.\n    \n\nSee Also\n   pool_is_empty / 1, get_all_pool_constraints / 2, collect_typed_pool_constraints / 3"},"constraint_pools:collect_typed_pool_constraints/3":{"prefix":"collect_typed_pool_constraints","body":"collect_typed_pool_constraints(${1:Pool}, ${2:Type}, ${3:Constraints})$4\n$0","description":"collect_typed_pool_constraints(+Pool, +Type, -Constraints)\n\n   Collect all currently stored constraints of type Type in Pool\n\nArguments\n   Pool    Atom\n   Type    Integer\n   Constraints    Variable, returns list of callable terms\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Constraints is unified with a list of all currently stored\n    constraints of type Type in Pool.  An empty list is returned if\n    the pool was already empty for this type.  The pool store for type\n    Type is emptied.  This modification is backtrackable.\n    \n\nSee Also\n   pool_is_empty / 1, get_typed_pool_constraints / 3, collect_all_pool_constraints / 2"},"constraint_pools:constraint_pools_desc":{"prefix":"lib","body":"lib(${1:constraint_pools})$2\n$0","description":"lib(constraint_pools)\n\n    This library contains support for constraint pools. Constraint\n    pools are a way to have several instances of a constraint solver.\n\n    A constraint pool is an Eclipse module. It exports a number of\n    predicates (often constraint predicates) which are specified when\n    the pool is created. The constraint pool does not implement these\n    predicates (constraints) itself, but simply forwards every predicate\n    call, or stores the calls, annotated with the pool name."},"constraint_pools:create_constraint_pool/3":{"prefix":"create_constraint_pool","body":"create_constraint_pool(${1:PoolName}, ${2:NTypes}, ${3:SpecList})$4\n$0","description":"create_constraint_pool(+PoolName, +NTypes, ++SpecList)\n\n   Create a \"constraint pool\" module\n\nArguments\n   PoolName    Atom - the name of the pool to create\n   NTypes    Integer - the number of constraint types\n   SpecList    List of terms of the form Atom/Integer->Spec\n\nType\n   library(constraint_pools)\n\nDescription\n\n\tCreate a special type of module, called a \"constraint pool\".\n\n\tThe module will contain:\n\t\n\tsimple definitions for the predicates listed in SpecList.\n\t    These definitions will just store or forward every call.\n\ta logical store which can be used to store and retrieve\n\t    constraints, indexed by pool name and type. NTypes is the number\n\t    of different constraint types that this pool will support.\n\ta logical store for one additional data item, for example\n\t    a solver handle.\n\t\n\n\tThe possible specifications in SpecList are:\n\t\n\tN/A -> store_as(Type)\n\t    will generate a definition for the predicate N/A such that every\n\t    call to N/A will be stored in the pool for the given Type.\n\t    \n\tN/A -> ImplN/ImplA\n\t    will generate a definition for the predicate N/A such that every\n\t    call to N/A gets augmented with an additional argument (the pool\n\t    name), and mapped into a call to the implementation predicate\n\t    ImplN/ImplA. The implementation predicate must be visible from\n\t    where create_constraint_pool/3 is invoked.  The implementation\n\t    predicate's arity ImplA must be one higher than the the arity A\n\t    of the newly defined predicate.\n\t    \n\t\n\n\tSince a pool is a module, the pool name should normally not refer\n\tto an existing module. If it does, the existing module gets augmented\n\twith the pool predicates and pool stores.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n       % We assume the implementation predicate:\n    d(Data, Pool) :- writeln(d(Data, Pool)).\n\n    % Create the pool:\n    ?- create_constraint_pool(pool, 1, [c/2->store_as(1),d/1->d/2]).\n    Yes (0.00s cpu)\n\n    % Call the just created pool constraint d/1,\n    % which leads to d/2 being invoked:\n    ?- pool:d(hello).\n    d(hello, pool)\n    Yes (0.00s cpu)\n\n    % Call the just created pool constraint c/2,\n    % which will be stored. Then retrieve the store:\n    ?- pool:c(a,b), collect_all_pool_constraints(pool, C).\n    C = [c(a, b)]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   is_constraint_pool / 1, pool_is_empty / 1, post_typed_pool_constraint / 3, collect_typed_pool_constraints / 3, collect_all_pool_constraints / 2, set_pool_item / 2, get_pool_item / 2"},"constraint_pools:get_all_pool_constraints/2":{"prefix":"get_all_pool_constraints","body":"get_all_pool_constraints(${1:Pool}, ${2:Constraints})$3\n$0","description":"get_all_pool_constraints(+Pool, -Constraints)\n\n   Get all currently stored constraints Pool\n\nArguments\n   Pool    Atom\n   Constraints    Variable, returns list of callable terms\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Constraints is unified with a list of all currently stored constraints\n    in Pool, regardless of their type. The pool itself is not changed.\n    An empty list is returned if the pool is empty.\n    \n\nSee Also\n   collect_all_pool_constraints / 2, get_typed_pool_constraints / 3"},"constraint_pools:get_pool_item/2":{"prefix":"get_pool_item","body":"get_pool_item(${1:Pool}, ${2:Item})$3\n$0","description":"get_pool_item(+Pool, -Item)\n\n   Associate a term Item with the pool Pool\n\nArguments\n   Pool    Atom\n   Item    Variable, returns term\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Retrieve the 'pool item', i.e. the term associated with the\n    pool using set_pool_item/2. This could for example be a solver\n    handle.  The pool is not modified.\n    \n\nSee Also\n   create_constraint_pool / 3, set_pool_item / 2"},"constraint_pools:get_typed_pool_constraints/3":{"prefix":"get_typed_pool_constraints","body":"get_typed_pool_constraints(${1:Pool}, ${2:Type}, ${3:Constraints})$4\n$0","description":"get_typed_pool_constraints(+Pool, +Type, -Constraints)\n\n   Get all currently stored constraints of type Type in Pool\n\nArguments\n   Pool    Atom\n   Type    Integer\n   Constraints    Variable, returns list of callable terms\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Constraints is unified with a list of all currently stored constraints\n    of type Type in Pool. The pool itself is not changed.\n    An empty list is returned if the pool is empty for this type.\n    \n\nSee Also\n   collect_typed_pool_constraints / 3, get_all_pool_constraints / 2"},"constraint_pools:is_constraint_pool/1":{"prefix":"is_constraint_pool","body":"is_constraint_pool(${1:Pool})$2\n$0","description":"is_constraint_pool(+Pool)\n\n   Check whether Pool is a constraint pool\n\nArguments\n   Pool    Atom\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Succeeds of Pool is a constraint pool that has been created earlier\n    using create_constraint_pool/3.\n    \n\nExamples\n       \n\nSee Also\n   create_constraint_pool / 3"},"constraint_pools:pool_is_empty/1":{"prefix":"pool_is_empty","body":"pool_is_empty(${1:Pool})$2\n$0","description":"pool_is_empty(+Pool)\n\n   Check whether Pool is an empty constraint pool\n\nArguments\n   Pool    Atom\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Succeeds of Pool is an empty constraint pool, i.e. has no constraints\n    stored.\n    \n\nExamples\n       \n\nSee Also\n   create_constraint_pool / 3, post_typed_pool_constraint / 3, collect_typed_pool_constraints / 3, collect_all_pool_constraints / 2, set_typed_pool_constraints / 3, get_all_pool_constraints / 2"},"constraint_pools:post_typed_pool_constraint/3":{"prefix":"post_typed_pool_constraint","body":"post_typed_pool_constraint(${1:Pool}, ${2:Type}, ${3:Constraint})$4\n$0","description":"post_typed_pool_constraint(+Pool, +Type, +Constraint)\n\n   Stores the term Constraint in Pool's constraint store as type Type\n\nArguments\n   Pool    Atom\n   Type    Integer\n   Constraint    Callable Term\n\nType\n   library(constraint_pools)\n\nDescription\n\n    Stores the term Constraint in Pool's constraint store as type Type.\n    Constraint is not interpreted in any way, it is just stored in order\n    to be retrieved later using one of the retrieval predicates.\n    \n\nExamples\n       ?- create_constraint_pool(p, 3, []).\n    Yes (0.09s cpu)\n\n    ?- post_typed_pool_constraint(p, 1, foo(one)),\n\t    post_typed_pool_constraint(p, 2, bar(two)),\n\t    post_typed_pool_constraint(p, 1, baz(three)),\n\t    get_typed_pool_constraints(p, 1, C1),\n\t    get_typed_pool_constraints(p, 2, C2).\n\t    get_typed_pool_constraints(p, 3, C3).\n\n    C1 = [baz(three), foo(one)]\n    C2 = [bar(two)]\n    C3 = []\n    Yes (0.00s cpu)\n    \n\nSee Also\n   collect_typed_pool_constraints / 3, collect_all_pool_constraints / 2, set_typed_pool_constraints / 3, get_all_pool_constraints / 2"},"constraint_pools:set_pool_item/2":{"prefix":"set_pool_item","body":"set_pool_item(${1:Pool}, ${2:Item})$3\n$0","description":"set_pool_item(+Pool, +Item)\n\n   Associate a term Item with the pool Pool\n\nArguments\n   Pool    Atom\n   Item    Arbitrary term\n\nType\n   library(constraint_pools)\n\nDescription\n\n    An arbitrary term (for example a solver handle) is associated with the\n    pool Pool, in order to be retrieved later using get_pool_item/2.\n    The modification to the pool is backtrackable.\n    \n\nExamples\n       ?- create_constraint_pool(p, 0, []).\n    Yes (0.08s cpu)\n\n    ?- set_pool_item(p, sample_item), get_pool_item(p,X).\n    X = sample_item\n    Yes (0.00s cpu)\n    \n\nSee Also\n   create_constraint_pool / 3, get_pool_item / 2"},"constraint_pools:set_typed_pool_constraints/3":{"prefix":"set_typed_pool_constraints","body":"set_typed_pool_constraints(${1:Pool}, ${2:Type}, ${3:Constraints})$4\n$0","description":"set_typed_pool_constraints(+Pool, +Type, +Constraints)\n\n   Replace the stored constraints for type Type\n\nArguments\n   Pool    Atom\n   Type    Integer\n   Constraints    List of callable Terms\n\nType\n   library(constraint_pools)\n\nDescription\n\n    The constraint store of pool Pool for type Type is forgotten and\n    replaced with the list of constraints Constraints.  This\n    modification is backtrackable.\n    \n\nExamples\n       \n\nSee Also\n   collect_typed_pool_constraints / 3, get_typed_pool_constraints / 3"},"coverage:ccompile/1":{"prefix":"ccompile","body":"ccompile(${1:File})$2\n$0","description":"ccompile(+File)\n\n   Compile a file, inserting code coverage counters\n\nArguments\n   File    Atom or string\n\nType\n   library(coverage)\n\nDescription\n\n    This is a variant of the ECLiPSe compiler that inserts code coverage\n    counters into the compiled code. This code can then be run, and the\n    results analysed by printing them using coverage:result/1.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ccompile / 2, library(coverage), result / 1, result / 2"},"coverage:ccompile/2":{"prefix":"ccompile","body":"ccompile(${1:File}, ${2:OptionList})$3\n$0","description":"ccompile(+File, +OptionList)\n\n   Compile a file, inserting code coverage counters\n\nArguments\n   File    Atom or string\n   OptionList    List of Name:Value pairs\n\nType\n   library(coverage)\n\nDescription\n\n    This is a variant of the ECLiPSe compiler that inserts code coverage\n    counters into the compiled code. This code can then be run, and the\n    results analysed by printing them using coverage:result/1.\n\n    Options to modify the behaviour of the code coverage library are:\n\n    exit_counters (default:on)\n    \tSetting this to 'off' will suppress coverage counters at the end of\n\tconjunctions (comma-sequences of subgoals).\n    blocks_only (default:off)\n    \tSetting this to 'on' will leave only coverage counters at the\n\tbeginning and at the end of conjunctions (comma-sequences of\n\tsubgoals) and suppress all others.\n    macro_expansion (default:off)\n\tThis options affects only the printing of the result (html) file.\n\tBy default, read-macros are not expanded in this output.  In rare\n\tcases, where macro expansion would affect the placement of coverage\n\tcounter positions, it may be necessary to set this option to 'on'\n\tin order to display the counter values at the correct positions\n\tin the code.\n    goal_expansion (default:on)\n    \tSetting this to 'off' will suppress goal expansion (inlining)\n\tduring compilation. This may be necessary when the processed\n\tcode contains predicates that get executed at compile time.\n    verbose (default:off)\n    \tIf set to 'on', the coverage preprocessor will print predicate\n\tnames as they are processed (to log_output).\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ccompile / 1, library(coverage), result / 1, result / 2"},"coverage:coverage_desc":{"prefix":"lib","body":"lib(${1:coverage})$2\n$0","description":"lib(coverage)\n\n\tThis is a tool for obtaining code coverage information, i.e.\n\tinformation about which points in the code were executed how\n\toften during a particular run of the program.\n\n\tThe usage is as follows:\n\t\n\tLoad the coverage library\n\t\n\t?- lib(coverage).\n\t\n\tCompile your program with the coverage compiler\n\t\n\t?- coverage:ccompile(my_program).\n\t\n\tRun the query which you want to examine\n\t\n\t?- my_query(X,Y,Z).\n\t\n\tGenerate an html file containing the results. E.g. the following\n\twill create the result file coverage/my_program.html:\n\t\n\t?- coverage:result(my_program).\n\t\n\tView the result file using any browser. The result file\n\tcontains a pretty-printed form of the source, annotated with\n\tthe values of the code coverage counters.\n\t\n\n\tBy default, code coverage counters are inserted before and after\n\tevery subgoal in the code. For instance, in the clause\n\n\tp :- q, r, s.\n\n\tfour counters would be inserted: before the call to q, between\n\tq and r, between r and s, and after s:\n\n\tp :- point(1), q, point(2), r, point(3), s, point(4).\n\n\tThis is the most precise form provided. The counter values do not\n\tonly show whether all code points were reached, they also show whether\n\tsubgoals ever failed or aborted (in that case the counter before\n\ta subgoal will have a higher value than the counter after it).\n\tFor example, the result of running the above code may look like:\n\n\tp :-  43  q,  25  r,  25  s  0 .\n\n\twhich would indicate that q was called 43 times, but succeeded\n\tonly 25 times, r was called 25 times and succeeded always, and\n\ts was called 25 times and never succeeded.  Coverage counts of\n\tzero are displayed in red because they indicate unreached code.\n\n\tIf one is only interested in knowing whether all code was covered,\n\tit is not necessary to have all these counters. point(1) and point(4)\n\tare enough to know whether q, r and s were successfully executed.\n\tThe option blocks_only implements this: counters only\n\tget inserted at the beginning and at the end of conjunctions\n\t(comma-separated goal sequences), i.e. in the example:\n\n\tp :- point(1), q, r, s, point(4).\n\n\tFor big programs, the presence of counters at the end of\n\tclauses can cause problems because they prevent tail-recursion\n\toptimization and may lead to stack overflows.  If that should\n\tbe the case, exit-counters can be disabled by setting the\n\texit_counters option to off, leading to the following\n\tincomplete instrumentation:\n\n\tp :- point(1), q, point(2), r, point(3), s.\n\n\tNote on the analysis of large, structured applications: \n\tLarger applications often consist of several modules which get\n\tcompiled implicitly through use_module/1 directives.  In this\n\tcase, the module(s) that one wants to compile in coverage mode\n\tcan be either compiled with ccompile/1 in advance (before\n\tloading the main application module), or afterwards (in which\n\tcase ccompile/1 will replace the previously compiled normal\n\tcode with coverage-code).\n\n\tLimitation: The current implementation cannot deal with multiple\n\t(non-module) files that are ccompiled into the same module."},"coverage:reset_counters/0":{"prefix":"reset_counters","body":"reset_counters","description":"reset_counters\n\n   Reset all the coverage counters to zero\n\nArguments\n\nType\n   library(coverage)\n\nDescription\n\n    The system maintains code coverage counters for all code compiled\n    with coverage:ccompile/1. These counters get incremented when this\n    code is run, and get reset implicitly when the results are output\n    using coverage:result/1.\n    \n\nSee Also\n   ccompile / 1, result / 1"},"coverage:result/0":{"prefix":"result","body":"result","description":"result\n\n   Pretty-print all files with code coverage results\n\nArguments\n\nType\n   library(coverage)\n\nDescription\n\n    This will pretty-print all source files that have been previously\n    compiled with ccompile/1,2. For details see result/1.\n\n    \n\nSee Also\n   result / 1, result / 2, library(coverage), library(pretty_printer), ccompile / 1"},"coverage:result/1":{"prefix":"result","body":"result(${1:File})$2\n$0","description":"result(+File)\n\n   Pretty-print a file, including any code coverage results\n\nArguments\n   File    Atom or string\n\nType\n   library(coverage)\n\nDescription\n\n    This will pretty-print the given source file, annotated with the\n    values of code coverage counters. The resulting .html file will be\n    placed in a sub-directory called 'coverage', relative to File.\n    See result/2 for options to modify the output.\n\n    This predicate only makes sense if File has previously been compiled\n    in coverage mode (using coverage:ccompile/1,2), and the code has been\n    run in order to obtain values for the coverage counters.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   result / 2, library(coverage), library(pretty_printer), ccompile / 1"},"coverage:result/2":{"prefix":"result","body":"result(${1:File}, ${2:OptionList})$3\n$0","description":"result(+File, +OptionList)\n\n   Pretty-print a file, including any code coverage results\n\nArguments\n   File    Atom or string\n   OptionList    List of Name:Value pairs\n\nType\n   library(coverage)\n\nDescription\n\n    This will pretty-print the given source file, annotated with the\n    values of code coverage counters. By default, the resulting .html\n    file will be placed in a sub-directory called 'coverage', relative\n    to File.\n\n    OptionList is a list of options identical to the one accepted by\n    pretty_print/2 in the library(pretty_printer), and can be used to\n    modify the output style and the location of the output file.\n\n    This predicate only makes sense if File has previously been compiled\n    in coverage mode (using coverage:ccompile/1,2), and the code has been\n    run in order to obtain values for the coverage counters.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   result / 1, pretty_printer : pretty_print / 2, ccompile / 1, library(coverage), library(pretty_printer)"},"cprolog:cprolog_desc":{"prefix":"lib","body":"lib(${1:cprolog})$2\n$0","description":"lib(cprolog)\n\n    One of the requirements during the development of ECLiPSe has been the\n    aim of minimising the work required to port traditional Prolog\n    programs to ECLiPSe.  A de-facto standard for many years was the\n    C-Prolog dialect, often referred to as Edinburgh Prolog.  Therefore,\n    many of the non standard predicates in C-Prolog have also been\n    included in ECLiPSe.  It is of course impossible to achieve total\n    compatibility between the two systems.  To assist in making the\n    changes necessary to run a C-Prolog program on the current version of\n    ECLiPSe, we describve here the predicates available in the\n    C-Prolog compatibility library and summarise the principal\n    differences between ECLiPSe Prolog and C-Prolog. \n    \n    Most of the C-Prolog predicates are also ECLiPSe built-in predicates\n    and so they can be always accessed. \n    \n    Please note that this text does not detail the functionality of\n    C-Prolog, refer to the C-Prolog documentation for this information. \n    \n    The effect of the compatibility library is local to the module where\n    it is loaded. For maximum compatibility, a C-Prolog program should\n    be wrapped in a separate module starting with a directive like\n    \n    :- module(mymodule, [], cprolog).\n    \n    In this case, Eclipse-specific language constructs will not be available.\n    \n    If the compatibility package is loaded into a standard module, e.g. like\n    \n    :- module(mymixedmdule).\n    :- use_module(library(cprolog)).\n    \n    then C-Prolog and Eclipse language features can be used together. \n    However, ambiguities must be resolved explicitly and confusion may\n    arise from the different meaning of quotes in Eclipse vs C-Prolog.\n    \n    Note that the C-Prolog compatibility package includes the cio\n    library (for see/1, seeing/1, seen/0, skip/1, tab/1, tell/1, telling/1,\n    told/0).\n    \n    The following C-Prolog predicates are not available in ECLiPSe, or\n    the corresponding predicates have a different semantics: \n    \n    assert/2, asserta/2, assertz/2, clause/3 \n\tECLiPSe does not support database references for clauses. \n    expand_term/2 \n\tThis is not supported.  ECLiPSe provides the macro facility\n\t    for transforming input terms (see chapter 13). \n    'LC'/0, 'NOLC'/0 \n\tThese are not supported in ECLiPSe. \n    \n    \n    The following differences remain even with the compatibility package: \n    \n    Database References \n\tECLiPSe provides database references only for terms in the indexed database, not for program clauses. \n    Numbers \n\tC-Prolog has a tendency to \"prefer\" integers over real\n\tnumbers.  For instance, under C-Prolog when the call X is\n\t4.0/2.0 is made, X is instantiated to an integer.  This\n\tbehaviour does not occur in ECLiPSe.  The order of integers\n\tand reals in the standard order is different. \n    Operators \n\tIn C-Prolog there is a bug regarding the operator not -- it\n\tbinds closer than its precedence declaration. \n    Strings \n\tStrings are simulated in C-Prolog by lists.  Under C-Prolog\n\tmode, ECLiPSe provides this functionality -- double-quoted\n\tstrings are parsed as lists of integers.  This can cause\n\tconfusion when pure ECLiPSe predicates are used in C-Prolog\n\tmode, e.g.  substring/3 will not accept double-quoted items,\n\tsince they are lists, not ECLiPSe strings.  The built-in\n\tstring_list/2 converts between both representations. \n    consult/1, reconsult/1 \n\tThese are implemented by simply calling the ECLiPSe predicate\n\tcompile/1.  By default all compiled procedures are static. \n\tProcedures on which assert/1 etc.  will be applied, have to be\n\tdeclared as dynamic using dynamic/1.  The notation [-File] for\n\treconsult/1 is not supported. \n    get/1\n\tThis is similar to the ECLiPSe predicate get/1, but\n\tcontrol characters and blank spaces are skipped. \n    put/1\n\tThis is similar to the ECLiPSe predicate put/1, but it\n\tfirst applies arithmetic evaluation to its argument. \n    heapused/1\n\tNeeded for evaluating heapused in arithmetic expressions. \n\tIt returns the sum of code heap and general heap usage. \n    instance/2\n\tNote that this compatibility predicate redefines the\n\tECLiPSe builtin of the same name but different meaning (which\n\tis no longer available in C-Prolog mode).  It is implemented\n\tusing the ECLiPSe predicate referenced_record/2. \n    log/2, log10/2\n\tThese are not predicates in C-Prolog (arithmetic\n\tfunctors), but in ECLiPSe they are needed for evaluating log/1\n\tand log10/1 in arithmetic expressions. \n    ttyput/1\n    \tcorresponds to the DEC-10 Prolog predicate \n    \n    The list below describes the syntax differences between ECLiPSe\n    and C-Prolog.  The following C-Prolog properties are simulated by\n    the compatibility package: \n    \n\tsingle (resp. double) quote must be doubled between single (resp. double) quotes. \n\t$ is a normal character. \n\tthe symbol | is not an atom. \n    \n    The following properties of original C-Prolog are not simulated by\n    the compatibility package: \n    \n\ta clause can not be ended by end of file. \n\tbased integers are not accepted. \n\tcomments are not a delimiter (just ignored). \n\t{} is not an atom. \n\t[] can not be a functor."},"csv:csv_read/3":{"prefix":"csv_read","body":"csv_read(${1:File}, ${2:Rows}, ${3:Options})$4\n$0","description":"csv_read(+File, -Rows, +Options)\n\n   Read a file containing comma separated values (csv format)\n\nArguments\n   File    File name (string or atom)\n   Rows    List of lists (output)\n   Options    List of options\n\nType\n   library(csv)\n\nDescription\n\n    Reads a file containing comma separated values, and returns the\n    file content as a list.  The file may have an optional .csv suffix.\n    \n    The result list contains one element for each record in the file.\n    Each list element is itself a list, representing a data record.\n    The data elements are either numbers (if they can be interpreted\n    as numbers by ECLiPSe's number_string/2 predicate), or otherwise\n    strings.\n    \n    No options are currently supported.\n    \n    \n\nModes and Determinism\n   csv_read(+, -, +) is det\n\nSee Also\n   number_string / 2, csv_read_row / 2"},"csv:csv_read_row/2":{"prefix":"csv_read_row","body":"csv_read_row(${1:Stream}, ${2:RowList})$3\n$0","description":"csv_read_row(+Stream, -RowList)\n\n   Read one row of comma separated values (approximate)\n\nArguments\n   Stream    Stream name or handle\n   RowList    List of numbers and strings, or 'end_of_file' (output)\n\nType\n   library(csv)\n\nDescription\n\n    Reads one row of comma separated values from Stream, and returns\n    the result as a list.  On end of file, returns the atom 'end_of_file'.\n    \n    The result list contains one element for each field in the record.\n    The data elements are either numbers (if they can be interpreted\n    as numbers by ECLiPSe's number_string/2 predicate), or otherwise\n    strings.\n    \n    Shortcomings: as oppsed to csv_read/3, this predicate here uses the\n    ECLiPSe parser to read rows, and does not implement the cvs format\n    fully.  E.g. empty fields are not handled and yield a syntax error.\n    \n    \n\nModes and Determinism\n   csv_read_row(+, -) is det\n\nSee Also\n   number_string / 2, csv_read / 3"},"cumulative:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (fd variables or integers)\n   Durations    Collection of duration for tasks (fd variables or integers)\n   Resources    Collection of resource uages by tasks (fd variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(cumulative)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of finite\n   domain variable or integers.  ResourceLimit is an integer.  The\n   declarative meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n   The (ic/fd)_edge_finder and (ic/fd)_edge_finder3 libraries implementation\n   of this predicate can provide stronger propagations.\n\nSee Also\n   profile / 4, lists : collection_to_list / 2, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"cumulative:cumulative_desc":{"prefix":"lib","body":"lib(${1:cumulative})$2\n$0","description":"lib(cumulative)\n\n       This library implements the cumulative scheduling constraint for the\n    FD solver.  It provides weaker propagation than the two edge finder\n    libraries: edge_finder and edge_finder3."},"cumulative:profile/4":{"prefix":"profile","body":"profile(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Profile})$5\n$0","description":"profile(+StartTimes, +Durations, +Resources, ?Profile)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (fd variables or integers)\n   Durations    Collection of duration for tasks (fd variables or integers)\n   Resources    Collection of resource usages by tasks (fd variables or integers)\n   Profile    List of resource usage at the start of each task\n\nType\n   library(cumulative)\n\nDescription\n\n   StartTimes, Durations and Resources are collections (a la\n   collection_to_list/2) of equal size N of finite domain variable or\n   integers, with the same meaning as in cumulative/4.\n   Profile is unified with a list of length N of finite domain variables or\n   integers indicating the level of resource usage at the starting point of\n   each task.\n\nSee Also\n   cumulative / 4, lists : collection_to_list / 2"},"daVinci:daVinci_begin/0":{"prefix":"daVinci_begin","body":"daVinci_begin","description":"daVinci_begin\n\n   Start the connection to daVinci and begin the transfer of a new graph\n\nArguments\n\nType\n   library(daVinci)\n\nDescription\n\nThis commands opens the connection to the daVinci system if not\nalready open and starts the information about a new graph.  This\npredicate should be called once for each graph to be transmitted.  \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExamples\n   \n:-use_module(daVinci).\n\ntop:-\n\tdaVinci_begin,\n\tdaVinci_node(1),\n\tdaVinci_node(2,'a bigger label'),\n\tdaVinci_node(aa),\n\n\tdaVinci_edge(1,1,2),\n\tdaVinci_edge(2,2,2),\n\tdaVinci_edge(3,2,aa),\n\n\tdaVinci_node_attribute(1,'COLOR','red'),\n\tdaVinci_node_attribute(2,'COLOR','dodgerblue'),\n\n\tdaVinci_node_attribute(2,'FONTSTYLE','italic'),\n\tdaVinci_edge_attribute(3,'EDGECOLOR','blue'),\n\tdaVinci_edge_attribute(3,'EDGEPATTERN','dashed'),\n\tdaVinci_node(4),\n\tdaVinci_edge(4,2,4),\n\tdaVinci_edge(5,4,2),\n\tdaVinci_end.\n\nSee Also\n   daVinci_end / 0"},"daVinci:daVinci_desc":{"prefix":"lib","body":"lib(${1:daVinci})$2\n$0","description":"lib(daVinci)\n\nThis library provides a simple interface to the daVinci graph drawing\ntool.  It allows to specify a graph with nodes, edges and their\nattributes, and draws the graph inside the daVinci tool.  The\ninterface does not allow callbacks back from the daVinci system, nor\ndoes it handle the customisation of the daVinci interface that is\npossible. The daVinci system is a graph drawing tool developed at\nthe University of Bremen in Germany and is freely available for\nnon-profit and internal use.  Please download the software from their\nWEB site daVinci\nHome page and register with the developers.  We do not provide the\nexecutable as part of this library. The communication between\nEclipse and daVinci is handled by a socket interface, where we\nexchange text messages terminated by a line-feed.  In order to gain a\nbit of flexibility in the interface, we use two string streams to\nbuffer information about edges and attributes.  The three streams used\nfor communication are called daVinciOut, daVinciEdge and\ndaVinciAttribute.  If the stream daVinciOut exists, we assume that the\ndaVinci server is running and that we can send information to it.  If\nthe stream does not exist, then we open the daVinci program in server\nmode and connect the stream to the socket connection on the port\n2542."},"daVinci:daVinci_draw_graph/1":{"prefix":"daVinci_draw_graph","body":"daVinci_draw_graph(${1:Graph})$2\n$0","description":"daVinci_draw_graph(+Graph)\n\n   Draw a graph in lib(graph_algorithms) format\n\nArguments\n   Graph    a graph description\n\nType\n   library(daVinci)\n\nDescription\n\nThis predicate takes a graph in the format defined by the\nlibrary lib(graph_algorithms), and draws it.\n\nExamples\n   \n:- lib(graph_algorithms).\n:- lib(daVinci).\n\ntop :-\n\tmake_random_graph(10,20,true,true,true,Graph),\n\tdaVinci_draw_graph(Graph)."},"daVinci:daVinci_edge/3":{"prefix":"daVinci_edge","body":"daVinci_edge(${1:Name}, ${2:Node1}, ${3:Node2})$4\n$0","description":"daVinci_edge(?Name, ?Node1, ?Node2)\n\n   This command adds an edge between two nodes in the graph.\n\nArguments\n   Name    a Prolog term \n   Node1    a Prolog term \n   Node2    a Prolog term \n\nType\n   library(daVinci)\n\nDescription\n\nThis command adds an edge between two nodes in the graph.  The edge is\nfrom Node1 to Node2.  Both nodes must exist in the final graph, but do\nnot need to be defined before the edge is entered.  Each edge must\nhave a unique name, typically a number or an atom.  Names for nodes\nand edges do not have to be disjoint.   \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExamples\n    see daVinci_begin/0 \n\nSee Also\n   daVinci_edge_attribute / 3"},"daVinci:daVinci_edge_attribute/3":{"prefix":"daVinci_edge_attribute","body":"daVinci_edge_attribute(${1:Name}, ${2:Type}, ${3:Value})$4\n$0","description":"daVinci_edge_attribute(?Name, ++Type, ++Value)\n\n   Set an attribute for an edge in the graph\n\nArguments\n   Name    a Prolog term\n   Type    an atom\n   Value    an atom\n\nType\n   library(daVinci)\n\nDescription\n\nThis predicate is used to set some attribute of an edge in the graph. \nFor a list of all possible attributes and their values, please refer\nto the daVinci documentation\nReference\nManual.  Typical attributes are 'EDGECOLOR' or 'EDGEPATTERN' to\nset the appearance of the edge.  Note that it is currently not\npossible in daVinci to specify labels for the edges.   \n\nFail Conditions\n   \n\nResatisfiable\n   yes\n\nExamples\n    see daVinci_begin/0 \n\nSee Also\n   daVinci_edge / 3"},"daVinci:daVinci_end/0":{"prefix":"daVinci_end","body":"daVinci_end","description":"daVinci_end\n\n   This commands ends the information about a graph and calls daVinci to draw it.\n\nArguments\n\nType\n   library(daVinci)\n\nDescription\n\nThis commands is called once when all information about a graph have\nbeen transmitted.  It sends the graph description to the daVinci tool\nand causes it to bbe drawn.  After this command, the next daVinci\ncommand should be daVinci_begin/0 to begin the information about the\nnext graph.   \n\nFail Conditions\n   fails if the stream daVinciEdge does not exist\n\nResatisfiable\n   no\n\nExamples\n   \nsee daVinci_begin/0\n\nSee Also\n   daVinci_begin / 0"},"daVinci:daVinci_exit/0":{"prefix":"daVinci_exit","body":"daVinci_exit","description":"daVinci_exit\n\n   This commands closes the connection and exits daVinci.\n\nArguments\n\nType\n   library(daVinci)\n\nSee Also\n   daVinci_begin / 0"},"daVinci:daVinci_node/1":{"prefix":"daVinci_node","body":"daVinci_node(${1:Node})$2\n$0","description":"daVinci_node(?Node)\n\n   Define one node for the graph. The label of the node is equal to its name.\n\nArguments\n   Node    a Prolog term, normally a number or an atom\n\nType\n   library(daVinci)\n\nDescription\n\nThis command defines one node for the graph.  The label of the node is\nequal to the name of the node.  Often, the name is a number or an\natom, but it can be any Prolog structure.  The node name must be\nunique, and should not contain backslash, tilde or double quote\ncharacters. \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExamples\n   \nsee daVinci_begin/0\n\nSee Also\n   daVinci_node / 2, daVinci_node_attribute / 3"},"daVinci:daVinci_node/2":{"prefix":"daVinci_node","body":"daVinci_node(${1:Node}, ${2:Info})$3\n$0","description":"daVinci_node(?Node, ?Info)\n\n   Defines a node in the graph. The label of the node can be different from the name.\n\nArguments\n   Node    a Prolog term, often a number or an atom\n   Info    a Prolog term\n\nType\n   library(daVinci)\n\nDescription\n\nThis command defines one node for the graph.  The label of the node is\ngiven as the second argument, and can be different from the name. \nBoth arguments can be arbitrary Prolog terms, but the name often is a\nnumber of an atom.  The name of each node must be unique, and should\nnot contain backslash, tilde or double quote characters.   \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExamples\n   \nsee daVinci_begin/0\n\nSee Also\n   daVinci_node / 1, daVinci_node_attribute / 3"},"daVinci:daVinci_node_attribute/3":{"prefix":"daVinci_node_attribute","body":"daVinci_node_attribute(${1:Name}, ${2:Type}, ${3:Value})$4\n$0","description":"daVinci_node_attribute(?Name, ++Type, ++Value)\n\n   Set an attribute for a node in the graph\n\nArguments\n   Name    a Prolog Term\n   Type    an atom\n   Value    an atom \n\nType\n   library(daVinci)\n\nDescription\n\nThis predicate is used to set an attribute of a node in the graph. \nFor a list of all possible attributes and their values, please refer\nto the daVinci documentation Reference\nManual.  Typical attributes are 'COLOR','FONTSYTLE','BORDER' to\nset the appearance of the node, and 'OBJECT' to change the label\ndisplayed in the node.   \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExamples\n   \nsee daVinci_begin/0\n\nSee Also\n   daVinci_node / 1, daVinci_node / 2"},"dbi:cursor_N_execute/4":{"prefix":"cursor_N_execute","body":"cursor_N_execute(${1:Cursor}, ${2:Executed}, ${3:TupleList}, ${4:RestTupleList})$5\n$0","description":"cursor_N_execute(++Cursor, -Executed, +TupleList, -RestTupleList)\n\n   Executes the parametrised prepared SQL statement represented by Cursor, once for each tuple in TupleList.\n\nArguments\n   Cursor    A cursor handle\n   Executed    Number of times the SQL statement was executed.\n   TupleList    A difference list (together with RestTupleList) of tuples of parameter values matching the template for this cursor\n   RestTupleList       Tail of tuple difference list\n\nType\n   library(dbi)\n\nDescription\n\n Executes the parameterised prepared SQL statement represented by Cursor,\n previously prepared by session_sql_prepare/4 or session_sql_prepare_query/5.\n The predicate executes a number of tuples from TupleList, taking the\n tuples in order from the start of the list, leaving the unprocessed tuples\n in RestTupleList. The number of tuple processed is unified with Executed.\n Any results produced when executing a tuple is discarded when the next\n tuple is processed.\n\n The number of tuples processed per call is determined by the library. \n This freedom allows the  predicate to process a multiple number of tuples\n in the most efficient way for the DBMS.\n\n Each tuple is a structure whose name and arity match the parameter\n template when Cursor was prepared, and the arguments give the values for\n the parameters for this execution, and must be compatible with the type\n specified by the template, except that an argument can be an\n uninstantiated variable, to denote a NULL value for the corresponding\n parameter.\n\n MySQL specific note: MySQL does not support the execution of multiple\n tuples in one go, so for MySQL, this predicate is essentially equivalent\n to executing cursor_next_execute/1 multiple times.\n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Type mismatch between parameter template specification for Cursor and actual tuple data\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_bad_template --- ParamTemplate not specified when Cursor was created\n\nExamples\n   \n  transfer_(Session, Amount, FromAccount, ToAccount) :-\n      SQL = \"update accounts set balance = balance + ?    where id = ?\",\n      Deduct is - Amount,\n      session_sql_prepare(Session,incbal(1.0,12),SQL,Update),\n      Updates = [incbal(Deduct,FromAccount),incbal(Amount,ToAccount)],\n      % execute both updates with one call to cursor_N_execute/4\n      cursor_N_execute(Update,_,Updates,[]).\n\nSee Also\n   cursor_next_execute / 2, cursor_N_execute / 4, session_sql_prepare / 4, session_sql_prepare_query / 5"},"dbi:cursor_N_tuples/4":{"prefix":"cursor_N_tuples","body":"cursor_N_tuples(${1:Cursor}, ${2:Retrieved}, ${3:ResultTuples}, ${4:RestResultTuples})$5\n$0","description":"cursor_N_tuples(++Cursor, -Retrieved, -ResultTuples, -RestResultTuples)\n\n   Retrieve  result tuples from the SQL query in the difference list ResultTuples and RestResultTuples.\n\nArguments\n   Cursor    A cursor handle\n   Retrieved    Number of result tuples retrieved\n   ResultTuples    Returned difference list (with RestResultTuples) of result tuples\n   RestResultTuples    Tail of returned result tuples\n\nType\n   library(dbi)\n\nDescription\n\n This is similar to cursor_all_tuples/4 except it works on difference list.\n It is designed to efficiently retrieve a buffer full of tuples for DBMS\n that support the retrieval of multiple tuples in its API. Otherwise, all\n the remaining tuples are retrieved one by one and the ResultTuples list\n constructed. Retrieved is unified with the number of retrieved result\n tuples. If no tuples match the query, Retrieved will be 0. Each element\n of the list is a single result tuple. Cursor is a cursor previously\n created with session_sql_query/4 or session_sql_prepare_query/5. Each\n tuple in ResultTuples is a structure with the same name and arity as\n defined by the tuple template when the cursor was created. The predicate\n converts the result to the type specified in the template, except that\n NULL values are returned as variables.\n\n If the SQL query have not yet been executed, and it contains no\n parameters, then the SQL query will first be executed before retrieving\n the results.\n\n MySQL specific note: MySQL does not support the retrieval of multiple\n tuples in one go, so for MySQL, this predicate is essentially equivalent\n to retrieving the results one by one.\n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Unable to convert tuple result to ECLiPSe type\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_error --- Error from DBMS while fetching result\n   dbi_not_query --- The SQL associated with Cursor is not a query and so cannot return results.\n\nSee Also\n   session_sql_query / 4, session_sql_prepare_query / 5, cursor_next_tuple / 2, cursor_all_tuples / 2"},"dbi:cursor_all_execute/2":{"prefix":"cursor_all_execute","body":"cursor_all_execute(${1:Cursor}, ${2:TupleList})$3\n$0","description":"cursor_all_execute(++Cursor, +TupleList)\n\n   Executes the parametrised prepared SQL statement represented by Cursor, once for each tuple in TupleList.\n\nArguments\n   Cursor    A cursor handle\n   TupleList    A list of tuples of parameter values matching the template for this cursor\n\nType\n   library(dbi)\n\nDescription\n\n Executes the parameterised prepared SQL statement represented by Cursor,\n previously prepared by session_sql_prepare/4 or session_sql_prepare_query/5.\n The statement is executed once for each tuple in TupleList, with the \n parameter values supplied by that tuple. The tuples are executed in the\n order they are in TupleList, and any results produced are discarded when\n the next tuple is executed.\n\n Each tuple is a structure whose name and arity match the parameter\n template when Cursor was prepared, and the arguments give the values for\n the parameters for this execution, and must be compatible with the type\n specified by the template, except that an argument can be an\n uninstantiated variable, to denote a NULL value for the corresponding\n parameter.\n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Type mismatch between parameter template specification for Cursor and actual tuple data\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_bad_template --- ParamTemplate not specified when Cursor was created\n\nSee Also\n   cursor_next_execute / 2, cursor_N_execute / 4, session_sql_prepare / 4, session_sql_prepare_query / 5"},"dbi:cursor_all_tuples/2":{"prefix":"cursor_all_tuples","body":"cursor_all_tuples(${1:Cursor}, ${2:ResultTuples})$3\n$0","description":"cursor_all_tuples(++Cursor, -ResultTuples)\n\n   Retrieve all remaining result tuples from the SQL query in ResultTuples\n\nArguments\n   Cursor    A cursor handle\n   ResultTuples    Returned list of result tuples\n\nType\n   library(dbi)\n\nDescription\n\n Retrieve the all remaining result tuples from the SQL query represented by\n Cursor, and unify them with ResultTuples list. Each element of the list is\n a single result tuple. Cursor is a cursor previously created with\n session_sql_query/4 or session_sql_prepare_query/5. Each tuple in\n ResultTuples is a structure with the same name and arity as defined by the\n tuple template when the cursor was created. The predicate converts the\n result to the type specified in the template, except that NULL values are\n returned as variables.\n\n If the SQL query have not yet been executed, and it contains no\n parameters, then the SQL query will first be executed before retrieving\n the results.\n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Unable to convert tuple result to ECLiPSe type\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_error --- Error from DBMS while fetching result\n   dbi_not_query --- The SQL associated with Cursor is not a query and so cannot return results.\n\nSee Also\n   session_sql_query / 4, session_sql_prepare_query / 5, cursor_next_tuple / 2, cursor_N_tuples / 4"},"dbi:cursor_close/1":{"prefix":"cursor_close","body":"cursor_close(${1:Cursor})$2\n$0","description":"cursor_close(++Cursor)\n\n   Close the cursor associated with Cursor\n\nArguments\n   Cursor    A cursor handle\n\nType\n   library(dbi)\n\nDescription\n\n Closes a cursor explicitly, and frees the resources associated with the\n cursor. It takes effect immediately.\n\n It is recommended that the user close all cursors before explicitly\n closing a session. Cursors that remain open after a session is closed\n cannot be used, but may still be using resources.\n\n Cursors are automatically closed if the program backtracks or aborts back\n beyond where they were created.\n\nExceptions\n     5 --- Cursor is not a cursor handle.\n\nSee Also\n   session_close / 1, session_sql_prepare / 4, session_sql_query / 4, session_sql_prepare_query / 5"},"dbi:cursor_next_execute/2":{"prefix":"cursor_next_execute","body":"cursor_next_execute(${1:Cursor}, ${2:Tuple})$3\n$0","description":"cursor_next_execute(++Cursor, +Tuple)\n\n   Executes the parametrised prepared SQL statement represented by Cursor.\n\nArguments\n   Cursor    A cursor handle\n   Tuple    A tuple of parameter values matching the template for this cursor (structure)\n\nType\n   library(dbi)\n\nDescription\n\n Executes the parameterised prepared SQL statement represented by Cursor,\n previously prepared by session_sql_prepare/4 or session_sql_prepare_query/5.\n The parameter values for this execution is supplied by Tuple.\n\n Tuple is a structure whose name and arity match the parameter template\n when Cursor was prepared, and the arguments give the values for the\n parameters for this execution, and must be compatible with the type\n specified by the template, except that an argument can be an\n uninstantiated variable, to denote a NULL value for the corresponding\n parameter.\n\n If the SQL statement is a query, then it should be prepared as a\n query using session_sql_prepare_query/5, and results can be obtained from\n the query by the cursor_*_tuple family of predicates. A dbi_bad_template\n error would be raised if the query was prepared with session_sql_prepared/4,\n because no result tuple template was specified.\n\n This predicate is called with default options for the cursor, i.e. it is\n equivalent to calling cursor_next_execute/3 with an empty Options list.\n \n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Type mismatch between parameter template specification for Cursor and actual tuple data\n   dbi_buffer_over --- Parameter value(s) too big for the buffer\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_bad_template --- ParamTemplate not specified when Cursor was created\n   dbi_bad_cursor --- The Cursor is not in a state to execute a query (e.g. it was cancelled)\n\nExamples\n   \n  % note '?' in SQL in the syntax MySQL uses for placeholders. This may be\n  % different in other DBMS\n  transfer_(Session, Amount, FromAccount, ToAccount) :-\n      SQL = \"update accounts set balance = balance + ? \\\n    where id = ?\",\n      Deduct is - Amount,\n      % incbal(1.0,12) is the parameter template\n      session_sql_prepare(Session,incbal(1.0,12),SQL,Update),\n      cursor_next_execute(Update,incbal(Deduct,FromAccount)),\n      cursor_next_execute(Update,incbal(Amount,ToAccount)).\n\nSee Also\n   cursor_next_execute / 3, cursor_all_execute / 2, cursor_N_execute / 4, session_sql_prepare / 4, session_sql_prepare_query / 5"},"dbi:cursor_next_execute/3":{"prefix":"cursor_next_execute","body":"cursor_next_execute(${1:Cursor}, ${2:Tuple}, ${3:Options})$4\n$0","description":"cursor_next_execute(++Cursor, +Tuple, ++Options)\n\n   Executes the parametrised prepared SQL statement represented by Cursor, with options Options.\n\nArguments\n   Cursor    A cursor handle\n   Tuple    A tuple of parameter values matching the template for this cursor (structure)\n   Options    Options (list of Option:Value pairs or nil)\n\nType\n   library(dbi)\n\nDescription\n\n Executes the parameterised prepared SQL statement represented by Cursor,\n previously prepared by session_sql_prepare/4 or session_sql_prepare_query/5.\n The parameter values for this execution is supplied by Tuple. Options is \n a (possibly empty) list of Option:Value pairs, specifying \n DBMS-specific options for the cursor.\n\n Tuple is a structure whose name and arity match the parameter template\n when Cursor was prepared, and the arguments give the values for the\n parameters for this execution, and must be compatible with the type\n specified by the template, except that an argument can be an\n uninstantiated variable, to denote a NULL value for the corresponding\n parameter.\n\n If the SQL statement is a query, and was prepared as a query using\n session_sql_prepare_query/5, results can be obtained from the query by\n the cursor_*_tuple family of predicates.\n\n MySQL specific:\n\n Options is used to specify the type of cursor used. Currently this only\n applies to cursors for SQL queries. The options are:\n\nbuffering\nSpecifies where the result set of a SQL query is buffered. Value can be\n either client (the default) or server. By default, the\n whole of the result set for a query is copied to the client (i.e. the\n ECLiPSe process running lib(dbi)) after the SQL query is executed. The \n alternative is to leave the result set on the DBMS server, and only get\n the result tuples from the server one by one (with e.g. cursor_next_tuple/2).\n \n The default buffering is on the client side, because this is the default\n of the MySQL C API, and in addition, it imposes certain restrictions on\n how the result tuples can be retrieved. However, as the whole result set\n is retreived, this can impose significant memory overheads if there are\n many tuples in the result set.\n \ntype\nSpecifies the type of cursor, and is only meaningful if the buffering\n option is set to server. Value can be either no_cursor (the\n default) or read_only.  These correspond to the MySQL statement \n attribute STMT_ATTR_CURSOR_TYPE of CURSOR_TYPE_NO_CURSOR and \n CURSOR_TYPE_READ_ONLY respectively (See the MySQL manual for details).\n\n Only one active cursor of type no_cursor is allowed per session, and this\n active cursor must be closed before another query can be issued to the\n DBMS server. read_only cursor does not have this restriction, and several\n such cursors can be active at the same time. \n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Type mismatch between parameter template specification for Cursor and actual tuple data\n     6 --- Invalid option specification in Options\n   dbi_buffer_over --- Parameter value(s) too big for the buffer\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_bad_template --- ParamTemplate not specified when Cursor was created\n   dbi_bad_cursor --- The Cursor is not in a state to execute a query (e.g. it was cancelled)\n\nSee Also\n   cursor_next_execute / 2, cursor_all_execute / 2, cursor_N_execute / 4, session_sql_prepare / 4, session_sql_prepare_query / 5"},"dbi:cursor_next_tuple/2":{"prefix":"cursor_next_tuple","body":"cursor_next_tuple(${1:Cursor}, ${2:ResultTuple})$3\n$0","description":"cursor_next_tuple(++Cursor, -ResultTuple)\n\n   Retrieve the next result tuple from the SQL query in ResultTuple\n\nArguments\n   Cursor    A cursor handle\n   ResultTuple    Returned result tuple\n\nType\n   library(dbi)\n\nDescription\n\n Retrieve the next result tuple from the SQL query represented by Cursor,\n and unify it with ResultTuple. Cursor is a cursor previously created with\n session_sql_query/4 or session_sql_prepare_query/5. ResultTuple is a\n structure with the same name and arity as defined by the tuple template\n when the cursor was created. The predicate converts the result to the type\n specified in the template, except that NULL values are returned as\n variables.\n\n If the SQL query have not yet been executed, and it contains no\n parameters, then the SQL query will first be executed before retrieving\n the result.\n\n cursor_next_tuple/2 will fail when all the results tuples for the query\n have been returned. If it is then called again for the same SQL query,\n this cancels the cursor, and raise the cursor cancelled error.\n\n cursor_next_tuple/2 is not resatisfiable, so to return successive tuples\n on backtracking, use repeat/0 to re-execute cursor_next_tuple/2:\n\n  match_tuple(Cursor, Tuple) :-\n    repeat,\n    ( cursor_next_tuple(Cursor, Tuple0) ->\n    Tuple0 = Tuple\n    ;\n    !, fail\n    ).\n\nFail Conditions\n   No more results are available for the SQL query\n\nResatisfiable\n   no\n\nExceptions\n     5 --- Cursor is not a valid cursor handle\n     5 --- Unable to convert tuple result to ECLiPSe type\n   dbi_error --- Error from DBMS while executing SQL associated with Cursor.\n   dbi_error --- Error from DBMS while fetching result\n   dbi_not_query --- The SQL associated with Cursor is not a query and so cannot return results.\n   dbi_buffer_over --- Result value(s) too big for the buffer\n   dbi_cancelled --- The cursor have been cancelled.\n\nExamples\n   \n  check_overdraft_limit(Session, Account) :-\n      L = [\"select count(id) from accounts \\\n    where     id = \",Account,\" and balance < overdraft\"],\n      concat_string(L,SQL),\n      session_sql_query(Session,c(0),SQL,OverdraftCheck),\n      cursor_next_tuple(OverdraftCheck,c(Count)),\n      Count = 0."},"dbi:dbi_desc":{"prefix":"lib","body":"lib(${1:dbi})$2\n$0","description":"lib(dbi)\n\n This library provides an interface to database management systems (DBMS)\n that supports SQL (Structure Query Language), allowing SQL commands,\n written in an ECLiPSe program, to be passed to the DBMS for processing,\n and their results (if any) to be passed back to ECLiPSe.\n\n The exact SQL supported by the library is determined by the underlying\n DBMS, as the SQL commands are passed directly to the DBMS via its C API. \n If supported by the C API, the library also allows the use of prepared SQL\n statements, where a SQL statement, possibly parameterised to accept\n different input data, is parsed once by the DBMS, and efficiently executed\n multiple times. Support for transactions (with commit and rollback) is also\n provided.\n\n The library provides a relatively low-level interface to the DBMS, but\n higher level interfaces (e.g. where a SQL query is viewed as a predicate,\n yielding different results tuples on backtracking) can be constructed on\n top of this.\n\n Currently, MySQL (version 5.0 or later) is supported by the library.\n Note that the MySQL client dynamic library (libmysqlclient.so on Unix\n systems, libmysql.dll on Windows) is not included with the distribution, and\n if this file is not found by ECLiPSe on loading lib(dbi), there will be \n an error. This file can be obtained by downloading MySQL, and placing the\n .so or .dll file into a place where ECLiPSe can find it, i.e. one of\n the following:\n \n <eclipsedir>/lib/<arch>\n ECLIPSEMYSQL/lib (ECLIPSEMYSQL can be either an environment variable, or\n as registry entry under HKEY_LOCAL_MACHINE/SOFTWARE/IC-Parc/Eclipse/<version>)\n PROGRAMFILES/MySQL/MySQL Server X.Y/lib\n your PATH or LD_LIBRARY_PATH\n \n Note that this client library must correspond in word size (32/64) to the\n word size of your ECLiPSe.  The word size of the MySQL server is irrelevant.\n \n\n Data is exchanged with the DBMS via:\n\nSQL statements (input)\n  Directly in the SQL statements passed to the DBMS;\n\nSQL query results (output)\n  The results returned by SQL queries are returned to ECLiPSe via\n      result tuples. Each tuple represents a single row of result, and is\n      returned to ECLiPSe as a Prolog structure, with each argument\n      represents one column in the result tuple. The ordering of the\n      arguments corresponds to the ordering defined by the SQL query.\nParameters for prepared SQL statements (input)\n  If prepared statements are supported by the DBMS, data can also be\n      passed to the DBMS via parameters (also known as placeholders). Each\n      parameter functions like a variable, whose value is instantiated when\n      the statement is executed. The library passes parameter values to the\n      DBMS via Prolog structures, with each argument represent one parameter. \n      The ordering of the arguments is defined by the ordering of the\n      parameters in the prepared SQL statement.\n \n\n Input and output data in the structures need to be converted from/to\n ECLiPSe datatypes. The ECLiPSe datatype is specified by a template, which\n specifies the datatype by example, i.e. an example result tuple structure\n (for output) or parameter structure (for input) where each argument\n specify the type for that argument, e.g.\n    emp(123,\"some name\",100.0,'some job',extra(data)),\n specifies that the first argument should be an integer, the second a \n string, the third a real, the fourth, an atom, and the last, a general\n Prolog term. Note that general Prolog terms are stored in the database in\n a binary representation, and the conversion is done by the library. \n\n The data is exchanged with the DBMS via buffers. Some DBMS require the\n sizes of the buffers to be specified. This is done automatically by the\n library, but if the default sizes need to overridden (e.g. if the argument\n is large), the template can be used to specify the size of buffers for\n variable length data, e.g.\n    emp(123,\"1000\",100.0,'2000',extra(5000)),\n where the second argument \"1000\" specifies a buffer size of 1000\n bytes, the third argument '2000' a buffer size of 2000 bytes,\n and the last argument, extra(5000), a buffer size of 5000 bytes.\n Note that any size specifications are simply ignored if not required."},"dbi:session_close/1":{"prefix":"session_close","body":"session_close(${1:Session})$2\n$0","description":"session_close(++Session)\n\n   close a session for the DBMS\n\nArguments\n   Session    A session handle\n\nType\n   library(dbi)\n\nDescription\n\n This closes a session explicitly, disconnecting from the DBMS server. It \n takes  effect immediately. Any uncommitted transactional updates are rolled \n back. Some resources associated with the session are also freed.\n\n Cursors for this session are not closed by the closing of the session,\n but they will no longer be able to access the database, but will still use\n some resources. It is recommended that cursors be closed before closing\n the session. All resources associated with a session are only freed when\n both the session and all the cursors are closed. \n\nExceptions\n     5 --- Session is not a session handle\n\nSee Also\n   session_start / 4, cursor_close / 1"},"dbi:session_commit/1":{"prefix":"session_commit","body":"session_commit(${1:Session})$2\n$0","description":"session_commit(++Session)\n\n   commits transactional changes made to the database.\n\nArguments\n   Session    A session handle\n\nType\n   library(dbi)\n\nDescription\n\n This commits any transactional updates to the database made within Session.\n By default, transactional updates are local to the session, and the changes\n only become global when a commit occurs, e.g. when session_commit/1 is\n executed. Note that non-transactional updates become globally visible \n immediately.\n\n When executed within the scope of a session_transaction/2 goal, this\n predicate simply succeeds without doing anything.\n\nExceptions\n     5 --- Session is not a valid session handle\n   dbi_error --- Problems from DBMS during commit.\n\nExamples\n   \n    session_sql(Session, \"insert into mytable values ('a')\", _),\n    session_commit(Session), % committing the insert of a to table mytable \n\nSee Also\n   session_rollback / 1, session_transaction / 2"},"dbi:session_rollback/1":{"prefix":"session_rollback","body":"session_rollback(${1:Session})$2\n$0","description":"session_rollback(++Session)\n\n   rollback transactional changes made to the database.\n\nArguments\n   Session    A session handle\n\nType\n   library(dbi)\n\nDescription\n\n  This undoes all transactional changes made to the database since the last\n  commit for this session. Note some DBMS can operate non-transactionally\n  (for example, non-transactional tables in MySQL), such operations cannot\n  be undone. Also, even for transactions, not all changes can be undone.\n  See DBMS's manual for details.\n\n  Outside a transaction this predicate will either succeed if rollback was\n  successful, or raise an error otherwise.\n\n  When executed within the scope of a session_transaction/2 goal, this \n  predicate will simply abort the complete outer transaction.\n\n NOTE: This predicate behaves very differently, depending on\n whether it is in a transaction or not. It is always advisable not\n to rely on it succeeding, but rather to fail or abort immediately\n after it adopting a coding style that causes a Prolog failure\n whenever a transaction cannot be completed.\n\nExceptions\n     5 --- Session is not a valid session handle\n   dbi_error --- Problems from DBMS during rollback.\n\nExamples\n   \n    session_sql(Session, \"insert into mytable values ('a')\", _),\n    session_commit(Session), % committing the insert of a to table mytable \n    session_sql(Session, \"insert into mytable values ('b')\", _),\n    session_sql(Session, \"insert into mytable values ('c')\", _),\n    % undo the inserting of b and c into table mytable (if tranactional)\n    session_rollback(Session), \n\nSee Also\n   session_commit / 1, session_transaction / 2"},"dbi:session_sql/3":{"prefix":"session_sql","body":"session_sql(${1:Session}, ${2:SQL}, ${3:RowProcessedCount})$4\n$0","description":"session_sql(++Session, ++SQL, -RowProcessedCount)\n\n   Executes a SQL statement on the database server.\n\nArguments\n   Session    A session handle\n   SQL    A SQL statement (string)\n   RowProcessedCount   Number of rows affected by this statement\n\nType\n   library(dbi)\n\nDescription\n\n Executes a SQL statement (without parameters) on the database server. The\n SQL statement should not have a terminating semicolon (;). If supported by\n the DBMS, SQL can consist of multiple statements separated by semicolons.\n RowProcessedCount will be unified with the number of rows affected by this\n statement.\n\n In the case of data definition language statements the RowProcessedCount\n parameter is undefined and should be passed as a free variable.\n\n In the case of data manipulation language statements, the\n RowProcessedCount is the number of rows, deleted, modified or inserted\n by the SQL statement.\n\n The SQL statement must be valid for the DBMS to execute. It can contain\n NULL characters, i.e. it can contain binary data.\n\n Any results generated by the statement is discarded.\n\nExceptions\n     5 --- Session is not a valid session handle or SQL not a string\n   dbi_error --- database returned an error when executing SQL.\n\nExamples\n   \nmake_accounts(Session) :-\n    session_sql(Session,\n    \"create table accounts \\\n    (id    decimal(4)      not null,\\\n    balance      decimal(9,2)    default 0.0 not null, \\\n    overdraft    decimal(9,2)    default 0.0 not null \\\n    )\" ,_),\n    session_sql(Session,\n    \"insert into accounts (id,balance) values (1001,1200.0)\",1),\n    session_sql(Session,\n    \"insert into accounts (id,balance) values (1002,4300.0)\",1)."},"dbi:session_sql_prepare/4":{"prefix":"session_sql_prepare","body":"session_sql_prepare(${1:Session}, ${2:ParamTemplate}, ${3:SQL}, ${4:Cursor})$5\n$0","description":"session_sql_prepare(++Session, +ParamTemplate, ++SQL, -Cursor)\n\n   Prepares a non-query SQL statement for execution by the DBMS.\n\nArguments\n   Session    A session handle\n   ParamTemplate       Template defining the types of the parameters (structure or [])\n   SQL    A SQL statement in prepared syntax (string)\n   Cursor    Returned cursor handle\n\nType\n   library(dbi)\n\nDescription\n\n Prepares a non-query SQL statement for execution. The statement is not actually\n executed, and a cursor_*_execute family of predicate is required to\n execute the predicate. This facility is only available if the DBMS\n supports prepared statements, and the SQL statement has to be written in\n the prepared statement syntax of the DBMS. The predicate returns the\n cursor handle representing this prepared statement in Cursor, which can\n then be used in subsequent library predicates.\n\n The SQL statement must be a non-query, i.e. it does not return any\n results. If the SQL statement is a query, an error would be raised\n when the statement is executed.\n\n A prepared SQL statement is parsed by the DBMS, so that it could be\n executed more efficiently. It can also be parameterised, where the \n parameters represent values to be filled in when the statement is\n executed. The statement can be executed multiple times with different\n parameters. The types of the parameters is specified by ParamTemplate,\n which is a Prolog structure of arity M (where M is the number of\n parameters for the statement), or the nil atom [] if there are no parameters.\n See the general description of this library or the manual for a\n description of the template specification.\n \n The SQL statement must be valid for the DBMS to execute. It can contain\n NULL characters, i.e. it can contain binary data. The SQL statement cannot\n return any results, i.e. it should not be a query. If it does, then\n an error would be raised when the SQL statement is actually executed.\n The error is not detected at this predicate because the database cannot\n tell if a SQL statement will return results or not until it is executed.\n\n Note that some DBMS restricts which SQL statements can be prepared. If an\n SQL statement cannot be prepared, it can still be executed using\n session_sql/3. \n\nExceptions\n     5 --- Session is not a valid session handle, or SQL not a string, or ParamTemplate not a structure\n   dbi_error --- Error from DBMS while preparing SQL\n   dbi_bad_template --- ParamTemplate has the wrong arity\n\nExamples\n   \n  % note '?' in SQL in the syntax MySQL uses for placeholders. This may be\n  % different in other DBMS\n  transfer_(Session, Amount, FromAccount, ToAccount) :-\n      SQL = \"update accounts set balance = balance + ? \\\n    where id = ?\",\n      Deduct is - Amount,\n      % incbal(1.0,12) is the parameter template\n      session_sql_prepare(Session,incbal(1.0,12),SQL,Update),\n      cursor_next_execute(Update,incbal(Deduct,FromAccount)),\n      cursor_next_execute(Update,incbal(Amount,ToAccount)).\n\nSee Also\n   cursor_next_execute / 2, cursor_all_execute / 2, cursor_N_execute / 4, cursor_close / 1, session_sql / 3, session_sql_prepare_query / 5"},"dbi:session_sql_prepare_query/5":{"prefix":"session_sql_prepare_query","body":"session_sql_prepare_query(${1:Session}, ${2:ParamTemplate}, ${3:ResultTemplate}, ${4:SQLQuery}, ${5:Cursor})$6\n$0","description":"session_sql_prepare_query(++Session, +ParamTemplate, +ResultTemplate, ++SQLQuery, -Cursor)\n\n   Prepares a SQL query for execution by the DBMS.\n\nArguments\n   Session    A session handle\n   ParamTemplate       Template defining the types of the parameters (structure or [])\n   ResultTemplate      Template defining the types of results tuple (structure)\n   SQLQuery    A SQL query in prepared syntax (string)\n   Cursor    Returned cursor handle\n\nType\n   library(dbi)\n\nDescription\n\n Prepares a SQL query for execution. The query is not actually\n executed, and a cursor_next_execute/2 needs to be called to execute the \n SQL query, giving values to any parameters. Then the cursor_*_tuple family\n of predicates can be used to obtain the results. This facility is only\n available if the DBMS supports prepared statements, and the SQL query has\n to be written in the prepared statement syntax of the DBMS. The predicate\n returns the cursor handle representing this prepared query in Cursor,\n which can then be used in subsequent library predicates.\n\n The SQL statement must be a query, i.e. it must return results. If\n the SQL statement is not a query, an error will be raised.\n\n A prepared SQL statement is parsed by the DBMS, so that it could be\n executed more efficiently. It can also be parameterised, where the \n parameters represent values to be filled in when the statement is\n executed. The statement can be executed multiple times with different\n parameters. The types of the parameters is specified by ParamTemplate,\n which is a Prolog structure of arity M (where M is the number of\n parameters for the statement), or the nil atom [] if there are no parameters.\n See the general description of this library or the manual for a\n description of the template specification.\n\n The SQL query returns result in tuples of N elements each. Each tuple is\n mapped to a Prolog structure of arity N. ResultTemplate is a structure of\n arity N specifying the types of the return data for ECLiPSe. If N\n does not match the number of elements expected for the query, an\n error will be raised. See the general description of this library or\n the manual for a description of the template specification.\n\n The SQL query must be valid for the DBMS to execute. It can contain\n NULL characters, i.e. it can contain binary data.\n\n Note that some DBMS restricts which SQL statements can be prepared. If an\n SQL statement cannot be prepared, it can still be executed using\n session_sql/3.\n\n MySQL specific note: not all SQL statements can be prepared by MySQL.\n Refer to the MySQL manual for details.\n\nExceptions\n     5 --- Session is not a valid session handle, or SQLQuery not a string, or ResultTemplate or ParamTemplate not a structure\n   dbi_error --- Error from DBMS while preparing SQLQuery.\n   dbi_bad_template --- ResultTemplate or ParamTemplate has the wrong arity\n\nExamples\n   \n make_check_overdraft_limit(Session, Cursor) :-\n      % note '?' in SQL in the syntax MySQL uses for placeholders. This may be\n      % different in other DBMS\n      SQL = \"select count(id) from accounts where ID = ? \\\n    and balance < overdraft\",\n      session_sql_prepare_query(Session,a(0),c(0),SQL,Cursor).\n\nSee Also\n   cursor_next_execute / 2, cursor_next_tuple / 2, cursor_all_tuples / 2, cursor_N_tuples / 4, session_sql / 3, session_sql_query / 4"},"dbi:session_sql_query/4":{"prefix":"session_sql_query","body":"session_sql_query(${1:Session}, ${2:ResultTemplate}, ${3:SQLQuery}, ${4:Cursor})$5\n$0","description":"session_sql_query(++Session, +ResultTemplate, ++SQLQuery, -Cursor)\n\n   Executes a SQL query on the database server.\n\nArguments\n   Session    A session handle\n   ResultTemplate      Template defining the types of results tuple (structure)\n   SQLQuery    A SQL statement query (string)\n   Cursor    Returned cursor handle\n\nType\n   library(dbi)\n\nDescription\n\n Executes a SQL query on the database server. The predicate returns in\n Cursor the cursor handle for this SQL query, and the results can then be\n retrieved using cursor_*_tuple family of predicates. \n\n The SQL query returns result in tuples of N elements each. Each tuple is\n mapped to a Prolog structure of arity N. ResultTemplate is a structure of\n arity N specifying the types of the return data for ECLiPSe. See the\n general description of this library or the manual for a description of \n the template specification.\n \n The SQL query must be valid for the DBMS to execute. It can contain\n NULL characters, i.e. it can contain binary data.\n \n This predicate is called with default options for the cursor, i.e. it is\n equivalent to calling session_sql_query/5 with an empty Options list.\n\nExceptions\n     5 --- Session is not a valid session handle, or SQLQuery not a string, or ResultTemplate not a structure\n   dbi_error --- Error from DBMS while executing SQLQuery.\n   dbi_bad_template --- ResultTemplate has the wrong arity\n\nExamples\n   \n  check_overdraft_limit(Session, Account) :-\n      L = [\"select count(id) from accounts \\\n    where     id = \",Account,\" and balance < overdraft\"],\n      concat_string(L,SQL),\n      session_sql_query(Session,c(0),SQL,OverdraftCheck),\n      cursor_next_tuple(OverdraftCheck,c(Count)),\n      Count = 0.\n\nSee Also\n   session_sql_query / 5, cursor_next_tuple / 2, cursor_all_tuples / 2, cursor_N_tuples / 4, session_sql_prepare_query / 5, cursor_close / 1"},"dbi:session_sql_query/5":{"prefix":"session_sql_query","body":"session_sql_query(${1:Session}, ${2:ResultTemplate}, ${3:SQLQuery}, ${4:Options}, ${5:Cursor})$6\n$0","description":"session_sql_query(++Session, +ResultTemplate, ++SQLQuery, ++Options, -Cursor)\n\n   Executes a SQL query on the database server with options specified by Options.\n\nArguments\n   Session    A session handle\n   ResultTemplate      Template defining the types of results tuple (structure)\n   SQLQuery    A SQL statement query (string)\n   Options    Options (list of Option:Value pairs or nil)\n   Cursor    Returned cursor handle\n\nType\n   library(dbi)\n\nDescription\n\n Executes a SQL query on the database server. The predicate returns in\n Cursor the cursor handle for this SQL query, and the results can then be\n retrieved using cursor_*_tuple family of predicates. Options is \n a (possibly empty) list of Option:Value pairs, specifying \n DBMS-specific options for the cursor.\n\n The SQL query returns result in tuples of N elements each. Each tuple is\n mapped to a Prolog structure of arity N. ResultTemplate is a structure of\n arity N specifying the types of the return data for ECLiPSe. See the\n general description of this library or the manual for a description of \n the template specification.\n \n The SQL query must be valid for the DBMS to execute. It can contain\n NULL characters, i.e. it can contain binary data.\n\n MySQL specific:\n\n Options is used to specify the type of cursor used. Currently this only\n applies to cursors for SQL queries. The options are:\n\nbuffering\nSpecifies where the result set of a SQL query is buffered. Value can be\n either client (the default) or server. By default, the\n whole of the result set for a query is copied to the client (i.e. the\n ECLiPSe process running lib(dbi)) after the SQL query is executed. The \n alternative is to leave the result set on the DBMS server, and only get\n the result tuples from the server one by one (with e.g. cursor_next_tuple/2).\n \n The default buffering is on the client side, because this is the default\n of the MySQL C API, and in addition, it imposes certain restrictions on\n how the result tuples can be retrieved. However, as the whole result set\n is retreived, this can impose significant memory overheads if there are\n many tuples in the result set. On the other hand, there is no restrictions\n on how many active client buffered cursor is allowed per session at the\n same time, but only one active server buffered cursor is allowed at any\n one time -- a query result must be exhausted or the cursor explicitly\n closed before another query can be issued for that session.\n \ntype\nThis option is not relevant for the direct SQL queries of\n session_sql_query/4. It is only relevant for prepared queries, and has no\n effect here.\n\nExceptions\n     5 --- Session is not a valid session handle, or SQLQuery not a string, or ResultTemplate not a structure\n     6 --- Invalid option specification in Options\n   dbi_error --- Error from DBMS while executing SQLQuery.\n   dbi_bad_template --- ResultTemplate has the wrong arity\n\nExamples\n   \n  check_overdraft_limit(Session, Account) :-\n      L = [\"select count(id) from accounts \\\n    where     id = \",Account,\" and balance < overdraft\"],\n      concat_string(L,SQL),\n      % the buffering:server option is MySQL specific\n      session_sql_query(Session,c(0),SQL,[buffering:server],OverdraftCheck),\n      cursor_next_tuple(OverdraftCheck,c(Count)),\n      Count = 0.\n\nSee Also\n   session_sql_query / 4, cursor_next_tuple / 2, cursor_all_tuples / 2, cursor_N_tuples / 4, session_sql_prepare_query / 5, cursor_close / 1"},"dbi:session_start/4":{"prefix":"session_start","body":"session_start(${1:Login}, ${2:Password}, ${3:Options}, ${4:Session})$5\n$0","description":"session_start(++Login, ++Password, ++Options, -Session)\n\n   starts a new session for the DBMS\n\nArguments\n   Login    DBMS login: ID or ID@Host. (ID,Host: string or atom)\n   Password    Password (string or atom)\n   Options    Options (list or nil)\n   Session    Session handle\n\nType\n   library(dbi)\n\nDescription\n\n Starts a new session with the DBMS. A new connection with the DBMS server is\n established, with the supplied DBMS user ID. Optionally, a host could be\n supplied, if the server is located on a remote machine. The host could be\n either the machine name, or an IP address. A session handle for this new\n connection is returned by the predicate.\n\n The session is closed automatically if the program backtracks or aborts back\n beyond this call. \n\n Options is a (possibly empty) list of Option:Value pairs, specifying any\n options for this session. The following options are supported:\n\ndbname\n Specifies the name of the database to use. Value can be a\n     string or an atom. The same effect can also be achieved by issuing the\n     SQL statement USE ... (where ... is the dbname).\n\nstorage\n (MySQL specific) specifies the default storage model to use for\n     the tables. Value can be either the string/atom transactional\n     or non-transactional. For transactional tables, changes are\n     local until they are committed. Uncommitted changes can be rollback.\n     For non-transactional tables, changes are global. InnoDB (with autocommit\n     turned off) is the storage  engine used for transactional, and MyISAM is\n     the storage engine used for non-transactional. See the MySQL manual for\n     details on storage engines and their effect on tables.\n\nExceptions\n     5 --- Login, Password or Options not of the correct type.\n     6 --- Invalid option specification in Options.\n   dbi_bad_field --- Problems with Option's argument.\n   dbi_error --- Problems connecting to DBMS server.\n\nExamples\n   \n     % connecting to a database server running on the local machine, as \n     % database user sqluser with password password\n     session_start(\"sqluser\", \"password\", [], S).\n\n     % connecting to a database server running on machine my.sql.host,\n     % as database user sqluser with password password, and selecting\n     % to use the database mydb\n     session_start(sqluser@my.sql.host, password, [dbame:\"mydb\"], S).\n\nSee Also\n   session_close / 1"},"dbi:session_transaction/2":{"prefix":"session_transaction","body":"session_transaction(${1:Session}, ${2:Goal})$3\n$0","description":"session_transaction(++Session, +Goal)\n\n   executes Goal as a database transaction.\n\nArguments\n   Session    A session handle\n   Goal    Prolog goal that implements a database update.\n\nType\n   library(dbi)\n\nDescription\n\n This executes Goal as a database transaction. This predicate is only useful\n if the database supports transactions (i.e. changes are local until committed).\n If Goal succeeds session_transaction/2  commits the update, cuts any\n alternative solutions to Goal and succeeds itself.\n\n If Goal fails or causes a database error, session_transaction/2 fails and\n rolls back any changes done to the database.\n\n If Goal aborts, the update is rolled back, and session_transaction/2 aborts.\n\n MySQL specific note: transactions are supported for transactional tables only\n (i.e. stored with a storage engine with transaction-safe capabilities).\n\n Calls of this predicate can be nested, but only the outermost transaction \n is real. All the inner transactions are simply equivalent to call(Goal).\n This way it is possible to write a call to session_transaction/2, into \n some code that implements a simple update, but then to include that simple \n update into a larger transaction.\n\n Similarly session_commit/1 and session_rollback/1 alter their behaviour so\n that they can be used within a transaction.\n\n Transactions are local to one session so there is no way to safely make an \n update relating to several sessions.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     5 --- Session is not a valid session handle\n   abort --- session_rollback/1 called within Goal\n\nExamples\n   \ntransfer(Session, Amount,FromAccount,ToAccount) :-\n     session_transaction(Session, \n    transfer_(Session,Amount,FromAccount,ToAccount)\n     ).\n\n% note '?' in SQL in the syntax MySQL uses for placeholders. This may be\n% different in other DBMS\ntransfer_(Session, Amount, FromAccount, ToAccount) :-\n    SQL = \"update accounts set balance = balance + ? \\\n    where id = ?\",\n    Deduct is - Amount,\n    session_sql_prepare(Session,incbal(1.0,12),SQL,1,Update),\n    cursor_next_execute(Update,incbal(Deduct,FromAccount)),\n    cursor_next_execute(Update,incbal(Amount,ToAccount)).\n\nSee Also\n   session_rollback / 1, session_commit / 1"},"document:document_desc":{"prefix":"lib","body":"lib(${1:document})$2\n$0","description":"lib(document)\n\n    This library contains the tools necessary to generate documentation\n    from ECLiPSe sources. It complements the file-to-file compiler\n    library(fcompile) as follows:\n    \n    xyz.ecl  ---fcompile-->  xyz.eco\n    xyz.ecl  ---icompile-->  xyz.eci  ---eci_to_html-->  xyz/...html"},"document:eci_to_html/3":{"prefix":"eci_to_html","body":"eci_to_html(${1:EciFile}, ${2:HtmlTopDir}, ${3:LinkBack})$4\n$0","description":"eci_to_html(++EciFile, ++HtmlTopDir, ++LinkBack)\n\n   Create HTML documentation from one .eci file\n\nArguments\n   EciFile    String\n   HtmlTopDir    String\n   LinkBack    HTML string (may be empty)\n\nType\n   library(document)\n\nDescription\n\n    This predicate processes one ECLiPSe interface information file\n\tEciFile (usually with .eci Extension) and generates .html\n\tfiles. The .html files are placed in a subdirectory in HtmlTopDir\n\twith the same name as EciFile but without the extension. This\n\tdirectory is created if it does not exist. The generated files are\n\tindex.html, containing a summary description of the library, plus\n\tone file for each predicate that was commented using a comment/2\n\tdirective in the source. The LinkBack argument should contain a\n\thyperlink in HTML format. This will appear at the top of the\n\tgenerated pages and should usually point back to a parent page.\n\nSee Also\n   ecis_to_htmls / 3, ecis_to_htmls / 0, comment / 2"},"document:ecis_to_htmls/0":{"prefix":"ecis_to_htmls","body":"ecis_to_htmls","description":"ecis_to_htmls\n\n   Generate the HTML documentation tree for all ECLiPSe libraries\n\nType\n   library(document)\n\nDescription\nGenerate the HTML documentation tree for all ECLiPSe libraries.\n    It takes into account all .eci files in the library path and generates\n    an HTML documentation tree in /doc/bips.\n    \n\nSee Also\n   ecis_to_htmls / 4"},"document:ecis_to_htmls/3":{"prefix":"ecis_to_htmls","body":"ecis_to_htmls(${1:LibDirs}, ${2:HtmlTopDir}, ${3:LinkBack})$4\n$0","description":"ecis_to_htmls(++LibDirs, ++HtmlTopDir, ++LinkBack)\n\n   Generate an HTML documentation tree for the given library directories\n\nArguments\n   LibDirs    A list of directory path names\n   HtmlTopDir    A directory path name\n   LinkBack    HTML string (may be empty)\n\nType\n   library(document)\n\nDescription\nSee ecis_to_htmls/4 for details\n\nSee Also\n   ecis_to_htmls / 4, ecis_to_htmls / 0"},"document:ecis_to_htmls/4":{"prefix":"ecis_to_htmls","body":"ecis_to_htmls(${1:LibDirs}, ${2:HtmlTopDir}, ${3:LinkBack}, ${4:SystemName})$5\n$0","description":"ecis_to_htmls(++LibDirs, ++HtmlTopDir, ++LinkBack, ++SystemName)\n\n   Generate an HTML documentation tree for the given library directories\n\nArguments\n   LibDirs    A directory path name or a list of them\n   HtmlTopDir    A directory path name\n   LinkBack    HTML string (may be empty)\n   SystemName    A string (may be empty)\n\nType\n   library(document)\n\nDescription\nThis predicate finds all ECLiPSe interface information (.eci)\n\tfiles in a list of directories and generates .html files in the\n\tdirectory HtmlTopDir (which is created if it does not exist).\n\tThe generated files are:\n\t\n\ta toplevel index of all the processed directories\n\t\t(only if LibDirs has more than one element)\n\tfor each directory an index of all the processed .eci files\n\tthe documentation generated from each .eci file\n\t\n\tThe LinkBack argument should contain a hyperlink in HTML format\n\twhich will appear at the top of the toplevel index.  The\n\tSystemName argument will appear in several places and should\n\tbe the name of the documented software system.\n\nSee Also\n   ecis_to_htmls / 0, eci_to_html / 3"},"document:gen_cons_table/3":{"prefix":"gen_cons_table","body":"gen_cons_table(${1:HtmlTopDir}, ${2:Roots}, ${3:Title})$4\n$0","description":"gen_cons_table(+HtmlTopDir, ++Roots, +Title)\n\n   Generate an HTML table of the constraints of the given types\n\nArguments\n   HtmlTopDir    A directory path name\n   Roots    List of atoms (solver root names)\n   Title    Descriptive title for the solver group\n\nType\n   library(document)\n\nDescription\nThis predicate generates an HTML page with a table\n of the constraints available for the solvers listed as Roots (e.g. ic, fd,\n gfd). The information is generated from the kind fields of the\n comment/2 documentation.\n\n The table list constraints by name in rows, and the solvers that\n support the particular constraint.If a constraint is supplied by a \n library other than the main solver library (e.g. ic_global for ic), \n then this library is shown (note a constraint may be supported by\n multiple libraries for the same solver, in which case, all the\n libraries are listed). \n\n In addition, the name(s) of the constraint(s) in the Gobal Constraint\n Catalog (GCCAT -- www.emn.fr/z-info/sdemasse/gccat/) is also listed,\n if described in the catalog. Note that each ECLiPSe constraint may\n map to multiple GCCAT constraint and vice versa."},"document:icompile/1":{"prefix":"icompile","body":"icompile(${1:File})$2\n$0","description":"icompile(+File)\n\n   Generates an information file from the ECLiPSe source File.\n\nArguments\n   File    Name of source file (Atom or string)\n\nType\n   library(document)\n\nDescription\n\n    Given an ECLiPSe source file (usually a file with a .ecl suffix), this\n    tool generates an ECLiPSe interface information file (with .eci suffix).\n    The output file is created in the same directory as the source file.\n    To create it elsewhere, use icompile/2.\n    \n    The given source file must contain a module definition. icompile then\n    extracts all information about this module's interface (in particular\n    all export directives), as well as the corresponding documentation\n    (comment/2) directives, and writes those into an interface information\n    file with .eci suffix. The latter can then be used to generate HTML\n    documentation about the module.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   icompile / 2, comment / 2, eci_to_html / 3, ecis_to_htmls / 4"},"document:icompile/2":{"prefix":"icompile","body":"icompile(${1:File}, ${2:Destination})$3\n$0","description":"icompile(+File, +Destination)\n\n   Generates an information file from the ECLiPSe source File in directory Destination.\n\nArguments\n   File    Name of source file (Atom or string)\n   Destination    Destination directory (Atom or string)\n\nType\n   library(document)\n\nDescription\n\n    Given an ECLiPSe source file (usually a file with a .ecl suffix), this\n    tool generates an ECLiPSe interface information file (with .eci suffix).\n    The output file is created in the Destination directory.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   icompile / 1"},"ech:constraints/1":{"prefix":"constraints","body":"constraints(${1:SpecList})$2\n$0","description":"constraints(+SpecList)\n\n   Directive for declaring SpecList to be CHR constraints\n\nArguments\n   SpecList    Sequence of the form Atom/Integer, or Atom/Integer:PrioSpec\n\nType\n   library(ech)\n\nDescription\n   Declares the predicates specified in SpecList as CHR constraints. This \n   allows the predicate to appear in the head of a CHR rule. A constraint\n   can be follwed by a priority specification PrioSpec, which can be one of:\n\n      1. at_lower(++N) 2. at_higher(++N) 3. at_absolute_priority(++N)\n\n   where N is an integer. This specifies the priority the CHR rules will be\n   executed at if the specified constraint is the active constraint.\n   at_lower and at_higher specifies that the priority is N lower or higher\n   than the default CHR priority, and for at_absolute_priority, it is the\n   actual priority. \n\n   Note that a predicate declared as a CHR constraint should not appear as\n   a normal ECLiPSe predicate. Any such definition of the predicate in the\n   user's program would be replaced by the CHR definition.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n      :- constraints leq/2.\n   :- op(700, xfx, leq).\n\n   X leq Y <=> \\+nonground(X), \\+nonground(Y) | X @=< Y.\n   X leq X <=> true."},"ech:ech_desc":{"prefix":"lib","body":"lib(${1:ech})$2\n$0","description":"lib(ech)\n\n   This library allows the user to write constraint handling rules (CHR) in \n   their ECLiPSe programs. CHR is a high-level language extension for writing\n   user-defined constraints, allowing for rapid prototyping of constraints.\n\n   This library provides some extensions over the older chr library: \n\n     support for multi (>2) headed simplification and simpagation rules\n\n     cleanup of semantics and syntax of CHRs\n\n     faster execution\n\n     more convenient compilation and mixing with ECLiPSe code\n\n   CHRs are compiled by source-to-source transformation into ECLiPSe code that\n   make calls to many ech library predicates that implements the CHR \n   functionality. Thus, most exported predicates predicates  are not intended\n   to be used by the user directly, and are not documented."},"ech:in_chrstore/1":{"prefix":"in_chrstore","body":"in_chrstore(${1:CHRConst})$2\n$0","description":"in_chrstore(+CHRConst)\n\n   Test if CHRConst is in the CHR constraint store or not\n\nArguments\n   CHRConst    A CHR constraint\n\nType\n   library(ech)\n\nDescription\n  This predicate is used to test if a particular CHR constraint is in the\n  CHR constraint store or not. It can be used to prevent the addition of\n  redundant constraints. This only useful if the 'already_in_store' \n  option is off. \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n       X leq Y, Y leq Z ==> \\+in_chrstore(X leq Z)| X leq Z."},"ech:option/2":{"prefix":"option","body":"option(${1:Option}, ${2:On_or_Off})$3\n$0","description":"option(++Option, ++On_or_Off)\n\n   Specify options for controlling ech compilation\n\nArguments\n   Option    Option Name (Atom)\n   On_or_Off    If Option should be on ('on') or off ('off'), or an integer between 1 and 11\n\nType\n   library(ech)\n\nDescription\n   Allows the user to set options that affect the way the CHRs are compiled.\n   These options can be turned on or off, with the default state being on.\n   The options controls if certain run-time safety checks are performed or\n   not. With the option off, the associated safety check will not be generated\n   for the CHR code when compiled. Such code can run more efficiently, but\n   can lead to incorrect behaviour that the checks would have been able to\n   prevent.\n   \n\n     check_guard_bindings\n    When executing a guard in a CHR rule, checks are performed\n    so that if a guard goal attemps to touch a global variable (i.e. a\n    variable which occurs in the rule head), the guard will fail. With\n    this option set to `off', then the checks are not performed.\n\n     already_in_store\n    Before adding a user-defined CHR constraint to the constraint\n    store, a check is performed to see if the particular constraint\n    (i.e. with exactly the same variables) is already in the store.\n    If this option is set to `off', then the check is not performed.\n    The user can explicitly check if a constraint is in store by the\n    in_chrstore/1 predicate.\n\n     chr_priority\n    On_or_Off is an integer between 1 and 11, specifying the\n    default priority for CHR constraints generated by the compiler.\n    It also specifies the priority that at_lower/at_higher\n    declarations will be calculated from in the constraints/1\n    declarations. Note that all priorities are determined at the\n    point of the constraint declaration and is not affected by any\n    subsequent changes in chr_priority.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"edge_finder:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    List of start times for tasks (integer variables or integers)\n   Durations    List of duration for tasks (integer variables or integers)\n   Resources    List of resource uages by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(edge_finder)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of integer\n   variables or integers.  ResourceLimit is an integer. The declarative\n   meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\n   This constraint can propagate more information than the implementation\n   in library(ic_cumulative) and library(cumulative).\n\nSee Also\n   disjunctive / 2, cumulative / 5, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"edge_finder:cumulative/5":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Areas}, ${5:ResourceLimit})$6\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, +Areas, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   Resources    Collection of resource usages by tasks (integer variables or integers)\n   Areas    Collection of areas covered by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(edge_finder)\n\nDescription\n\n   In this variant, an area (the product of duration and resource usage of\n   a task) can be specified, e.g. if duration or reource usage are not\n   known in advance. The edge-finder algorithm can make use of this information\n   to derive bound updates.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive / 2, cumulative / 4, lists : collection_to_list / 2, edge_finder3 : cumulative / 5, ic_edge_finder : cumulative / 5, ic_edge_finder3 : cumulative / 5"},"edge_finder:disjunctive/2":{"prefix":"disjunctive","body":"disjunctive(${1:StartTimes}, ${2:Durations})$3\n$0","description":"disjunctive(+StartTimes, +Durations)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n\nType\n   library(edge_finder)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    Any input variables which do not already have finite bounds will be\n    given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive_bools / 3, lists : collection_to_list / 2, edge_finder3 : disjunctive / 2, ic_edge_finder : disjunctive / 2, ic_edge_finder3 : disjunctive / 2, gfd : disjunctive / 2"},"edge_finder:disjunctive_bools/3":{"prefix":"disjunctive_bools","body":"disjunctive_bools(${1:StartTimes}, ${2:Durations}, ${3:OrderingBools})$4\n$0","description":"disjunctive_bools(+StartTimes, +Durations, ?OrderingBools)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   OrderingBools       Variable, or list of ordering Booleans (variable or 0 or 1)\n\nType\n   library(edge_finder)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    OrderingBools is a list of ordering Booleans. For each possible pair of\n    tasks, there is one Boolean which describes the order of these two tasks.\n    If the Tasks are numbered 1..N, and the Booleans are numbered\n    1..N*(N-1)//2, then the Boolean corresponding to the task pair I,J\n    (with I>J) has the index (I-1)(I-2)//2 + J.  In other words, the\n    OrderingBools list is a flattened version of a strictly lower\n    triangular matrix of ordering Booleans, i.e.\n    \n    I\\J|  1    2    3    4    5\n    ---+--------------------------\n    1  |  .    .    .    .    .\n    2  | B[1]  .    .    .    .\n    3  | B[2] B[3]  .    .    .\n    4  | B[4] B[5] B[6]  .    .\n    5  | B[7] B[8] B[9] B[10] .\n    \n    The Boolean being set to 1 indicates that task I is before task J,\n    a value of 0 indicates that task J is before task I. If uninstantiated,\n    the order is not (yet) determined. Operationally, the constraint will\n    both infer start time bounds from the setting of the Booleans, and\n    infer Boolean settings from the start times and durations.\n\n    The Booleans should be used for making search choices, typically by\n    setting them such that a task is chosen to be first (or last) among\n    a group of tasks.\n\n    Any Start and Duration variables which do not already have finite bounds\n    will be given default bounds of -10000000 to 10000000. The Booleans on\n    the other hand can be domainless variables, and the only way in which\n    the constraint will affect them is by instantiation to 0 or 1.\n\nModes and Determinism\n   disjunctive_bools(+, +, +)\n   disjunctive_bools(+, +, -)\n\nSee Also\n   disjunctive / 2, lists : collection_to_list / 2, edge_finder3 : disjunctive_bools / 3, ic_edge_finder : disjunctive_bools / 3, ic_edge_finder3 : disjunctive_bools / 3"},"edge_finder:edge_finder_desc":{"prefix":"lib","body":"lib(${1:edge_finder})$2\n$0","description":"lib(edge_finder)\n\n   \n    This library implements the quadratic edge-finder algorithm for the\n    disjunctive and cumulative scheduling constraints for the FD solver.\n    It provides stronger propagation than the cumulative library, but\n    weaker than the cubic edge_finder3 library for cumulative constraints.\n    It is however computationally cheaper than the edge_finder3 library.\n\n    Note that the same predicates are implemented in both edge_finder and\n    edge_finder3 libraries."},"edge_finder3:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    List of start times for tasks (integer variables or integers)\n   Durations    List of duration for tasks (integer variables or integers)\n   Resources    List of resource uages by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(edge_finder3)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of integer\n   variables or integers.  ResourceLimit is an integer. The declarative\n   meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\n   This constraint can propagate more information than the implementation\n   in library(ic_cumulative) and library(cumulative).\n\nSee Also\n   disjunctive / 2, cumulative / 5, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"edge_finder3:cumulative/5":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Areas}, ${5:ResourceLimit})$6\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, +Areas, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   Resources    Collection of resource usages by tasks (integer variables or integers)\n   Areas    Collection of areas covered by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(edge_finder3)\n\nDescription\n\n   In this variant, an area (the product of duration and resource usage of\n   a task) can be specified, e.g. if duration or reource usage are not\n   known in advance. The edge-finder algorithm can make use of this information\n   to derive bound updates.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive / 2, cumulative / 4, lists : collection_to_list / 2, edge_finder : cumulative / 5, ic_edge_finder : cumulative / 5, ic_edge_finder3 : cumulative / 5"},"edge_finder3:disjunctive/2":{"prefix":"disjunctive","body":"disjunctive(${1:StartTimes}, ${2:Durations})$3\n$0","description":"disjunctive(+StartTimes, +Durations)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n\nType\n   library(edge_finder3)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    Any input variables which do not already have finite bounds will be\n    given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive_bools / 3, lists : collection_to_list / 2, edge_finder : disjunctive / 2, ic_edge_finder : disjunctive / 2, ic_edge_finder3 : disjunctive / 2, gfd : disjunctive / 2"},"edge_finder3:disjunctive_bools/3":{"prefix":"disjunctive_bools","body":"disjunctive_bools(${1:StartTimes}, ${2:Durations}, ${3:OrderingBools})$4\n$0","description":"disjunctive_bools(+StartTimes, +Durations, ?OrderingBools)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   OrderingBools       Variable, or list of ordering Booleans (variable or 0 or 1)\n\nType\n   library(edge_finder3)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    OrderingBools is a list of ordering Booleans. For each possible pair of\n    tasks, there is one Boolean which describes the order of these two tasks.\n    If the Tasks are numbered 1..N, and the Booleans are numbered\n    1..N*(N-1)//2, then the Boolean corresponding to the task pair I,J\n    (with I>J) has the index (I-1)(I-2)//2 + J.  In other words, the\n    OrderingBools list is a flattened version of a strictly lower\n    triangular matrix of ordering Booleans, i.e.\n    \n    I\\J|  1    2    3    4    5\n    ---+--------------------------\n    1  |  .    .    .    .    .\n    2  | B[1]  .    .    .    .\n    3  | B[2] B[3]  .    .    .\n    4  | B[4] B[5] B[6]  .    .\n    5  | B[7] B[8] B[9] B[10] .\n    \n    The Boolean being set to 1 indicates that task I is before task J,\n    a value of 0 indicates that task J is before task I. If uninstantiated,\n    the order is not (yet) determined. Operationally, the constraint will\n    both infer start time bounds from the setting of the Booleans, and\n    infer Boolean settings from the start times and durations.\n\n    The Booleans should be used for making search choices, typically by\n    setting them such that a task is chosen to be first (or last) among\n    a group of tasks.\n\n    Any Start and Duration variables which do not already have finite bounds\n    will be given default bounds of -10000000 to 10000000. The Booleans on\n    the other hand can be domainless variables, and the only way in which\n    the constraint will affect them is by instantiation to 0 or 1.\n\nModes and Determinism\n   disjunctive_bools(+, +, +)\n   disjunctive_bools(+, +, -)\n\nSee Also\n   disjunctive / 2, lists : collection_to_list / 2, edge_finder : disjunctive_bools / 3, ic_edge_finder : disjunctive_bools / 3, ic_edge_finder3 : disjunctive_bools / 3"},"edge_finder3:edge_finder3_desc":{"prefix":"lib","body":"lib(${1:edge_finder3})$2\n$0","description":"lib(edge_finder3)\n\n   \n    This library implements the cubic edge-finder algorithm for the\n    disjunctive and cumulative scheduling constraints for the FD solver.\n    It provides the strongest propagation of the three libraries for\n    cumulative constraints: cumulative, edge_finder and edge_finder3.\n    It is also computationally the most expensive.\n\n    Note that the same predicates are implemented in both edge_finder and\n    edge_finder3 libraries."},"eplex:EG/2":{"prefix":"Ind","body":"Ind","description":"Ind => LinCon\nEplexInstance:(Ind => LinCon)\n\n   Linear constraint conditional on binary variable\n\nArguments\n   Ind    A binary variable or negated binary variable\n   LinCon    A linear constraint\n\nType\n   library(eplex)\n\nDescription\n\tLogical implication Ind =&ge; LinCon.  The linear constraint LinCon\n\tis enforced when the indicator Ind is 1, and violation of LinCon\n\tforces the indicator Ind to 0.\n\n\tInd can be a variable, or a subscript expression resulting in a\n\tvariable.  It can also be negated using the neg/1 prefix operator.\n\tCorrespondingly, LinCon is either enforced by the binary being 0 or 1.\n\n\tLinCon is any linear constraint accepted by eplex, i.e. an equality\n\tor inequality constraint over linear expressions.\n\n\tThis constraint does not implicitly impose bounds or a type on the\n\tbinary variable in Ind.  It will usually make sense to separately\n\timpose bounds of 0..1 and invoke integers/1.\n\n\tIndicator constraints are not supported by every external solver.\n\tUse lp_get(has_indicator_constraints,yes) to check availability.\n\n    \n\nExamples\n   \n    B => ( X1 $>= X2+8 )\n    neg B => ( X1+5 $=< X2 )\n    B[12] => ( sum(Costs) $= 42 )\n\nSee Also\n   ic : => / 2, suspend : => / 2, gfd : => / 2, $>= / 2, $= / 2, $=< / 2, eplex_add_constraints / 2"},"eplex:EL/2":{"prefix":"EplexInstance","body":"EplexInstance","description":"EplexInstance:(?X =< ?Y)\n\n   Constrains X to be less than or equal to Y.\n\nArguments\n   X    Linear expression\n   Y    Linear expression\n\nType\n   library(eplex)\n\nDescription\n\tLogically: Constrains X to be less than or equal to Y.\n\tX and Y are linear expressions.\n\tOperationally, the constraint gets delayed until the external\n    solver state for EplexInstance is invoked.\n\nSee Also\n   =:= / 2, =< / 2, iso_strict : =< / 2, iso_light : =< / 2, ic : =< / 2, suspend : =< / 2, >= / 2, $>= / 2, $= / 2, $=< / 2, eplex_solver_setup / 1, eplex_solver_setup / 4, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3, eplex_cleanup / 0"},"eplex:ENE/2":{"prefix":"EplexInstance","body":"EplexInstance","description":"EplexInstance:(?X =:= ?Y)\n\n   Constrains X to be equal to Y.\n\nArguments\n   X    Linear expression\n   Y    Linear expression\n\nType\n   library(eplex)\n\nDescription\n\tLogically: Constrains X to be equal to Y.\n\tX and Y are linear expressions.\n\tOperationally, the constraint gets delayed until the external\n    solver state for EplexInstance is invoked.\n\nSee Also\n   =:= / 2, iso_strict : =:= / 2, iso_light : =:= / 2, ic : =:= / 2, suspend : =:= / 2, =< / 2, >= / 2, $>= / 2, $= / 2, $=< / 2, eplex_solver_setup / 1, eplex_solver_setup / 4, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3, eplex_cleanup / 0"},"eplex:GE/2":{"prefix":"EplexInstance","body":"EplexInstance","description":"EplexInstance:(?X >= ?Y)\n\n   Constrains X to be greater than or equal to Y.\n\nArguments\n   X    Linear expression\n   Y    Linear expression\n\nType\n   library(eplex)\n\nDescription\n\tLogically: Constrains X to be greater than or equal to Y.\n\tX and Y are linear expressions.\n\tOperationally, the constraint gets delayed until the external\n    solver state for EplexInstance is invoked.\n\nSee Also\n   >= / 2, iso_strict : >= / 2, iso_light : >= / 2, ic : >= / 2, suspend : >= / 2, =:= / 2, =< / 2, $>= / 2, $= / 2, $=< / 2, eplex_solver_setup / 1, eplex_solver_setup / 4, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3, eplex_cleanup / 0"},"eplex:eplex_add_constraints/2":{"prefix":"eplex_add_constraints","body":"eplex_add_constraints(${1:Constraints}, ${2:Integers})$3\n$0","description":"eplex_add_constraints(+Constraints,+Integers)\nEplexInstance: eplex_add_constraints(+Constraints,+Integers)\n\n   Add new constraints to the eplex instance EplexInstance, possibly triggering it.\n\nArguments\n   Constraints    A (possibly empty) list of equality or inequality constraints\n   Integers    A (possibly empty) list of variables to be considered as integers\n\nType\n   library(eplex)\n\nDescription\n\n  Add new constraints (with possibly new variables) to the eplex instance\n  EplexInstance.  Cstrs is a list of equality or inequality constraints; \n  NewIntegers is a list of (possibly new) variables that should be\n  consider as integers  This is logically the same as posting the\n  constraints one by one to the solver, but it may be more convenient if \n  the constraints are already collected as a list.\n\n  Operationally, if a solver state has been associated with the eplex\n  instance, the constraints are added to the solver state in one go. \n  For some solvers, this can be more efficient than adding the constraints\n  incrementally. \n\n  If the new_constraint trigger option was selected, then the solver will\n  be invoked after the adding of the constraints if these constraints are \n  not already satisfied.  The constraints will be removed on backtracking.\n\n  The constraints are normalised and simplified before being passed to\n  the external solver. If any constraint is ground, they are tested for\n  consistency.\n\n  The constraints can be linear equalities and inequalities, sos/1 and\n  sos2/1 constraints, and =&ge;/2 indicator constraints.\n\n  Note that variables in NewIntegers can be any problem variables. In\n  previous versions of ECLiPSe, there was a restriction that the variables\n  be new problem variables; this restriction has been removed.\n\n \n\nFail Conditions\n   Any ground (no variable) or bound constraints (one variable) is self-inconsistent.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Constraints or Integers uninstantiated.\n     5 --- Some constraint in Constraints is non-linear.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   lp_add_constraints / 3, lp_demon_setup / 5, lp_add / 3, lp_add_constraints / 4, $= / 2, $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2, sos1 / 1, sos2 / 1, => / 2"},"eplex:eplex_cleanup/0":{"prefix":"eplex_cleanup","body":"eplex_cleanup","description":"eplex_cleanup\nEplexInstance:eplex_cleanup\n\n   Destroy the external solver associated with EplexInstance.\n\nType\n   library(eplex)\n\nDescription\n\n    Destroy the specified solver, free all memory, etc.  Note that ECLiPSe\n    will normally do the cleanup automatically, for instance when execution\n    fails across the solver setup. The solver is disassociated with \n    EplexInstance, and any outstanding constraints not yet collected by the\n    solver are removed, with a warning to the user. In effect, EplexInstance\n    is reinitialised and can now be associated with a new solver without\n    backtracking. Note that this last behaviour is unlike lp_cleanup/1, which\n    also destroy the solver and disassociate it from the eplex instance (if \n    any), but does not remove any outstanding constraints.\n\n    This predicate should be used with caution as the information from the\n    solver state will no longer be available. In particular, if the program\n    backtracks to a point between the problem set up and clean up,\n    accessing the solver state directly or indirectly (e.g. unifying a\n    problem variable) will result in a stale handle error."},"eplex:eplex_desc":{"prefix":"lib","body":"lib(${1:eplex})$2\n$0","description":"lib(eplex)\n\n   This library lets you use an external Mathematical Programming solver \n   from within ECLiPSe. This is done either directly to the solver, like\n   CPLEX, XPRESS-MP or Gurobi, or indirectly via COIN-OR project's Open Solver\n   Interface (OSI), giving access to the CLP, CBC and SYMPHONY solvers.\n   For the commercial solvers, the library provides just the interface, \n   and does not include the solver or any required licence to use them.\n\n    The constraints provided are:\n    \n    Vs $:: BoundBounds on variables\n    X $= Yequality over linear expressions\n    X $>= Yinequality over linear expressions\n    X $=< Yinequality over linear expressions\n    integers(Xs)integrality of variables\n    sos1(Xs)all but one are zero\n    sos2(Xs)all but two consecutive values are zero\n    Cond=>Linearindicator constraint (some solvers only)\n    \n    The operational behaviour of the linear constraints is as follows:\n\n    When they contain no variables, they simply succeed or fail.\n\n    When they contain exactly one variable, they are translated into a\n    bound update on that variable for the external solver instance. This\n    can lead to immediate failure if the lower bound is greater than the upper.\n\n    Otherwise, the constraint is transferred to the external solver\n    immediately (or as soon as the solver is set up).\n\nThe following arithmetic expression can be used inside the constraints:\n\nX\nVariables. If X is not yet a problem variable for the external solver\n    instance, it  is turned into one via an implicit declaration \n    X :: -inf..inf.\n\n123, 3.4\nInteger or floating point constants.\n\n+Expr\nIdentity.\n\n-Expr\nSign change.\n\nE1+E2\nAddition.\n\nsum(ListOfExpr)\nEquivalent to the sum of all list elements.\n\nE1-E2\nSubtraction.\n\nE1*E2\nMultiplication.\n\nListOfExpr1*ListOfExpr2\nScalar product: The sum of the products of the corresponding\nelements in the two lists.  The lists must be of equal length.\n\nThe external solver can either be explicitly invoked to solve the\nproblem represented by the constraints, or be invoked in response to\ncertain trigger conditions. This mechanism makes it possible to tailor\nthe solving behaviour for a particular application's needs."},"eplex:eplex_get/2":{"prefix":"eplex_get","body":"eplex_get(${1:ParamName}, ${2:Value})$3\n$0","description":"eplex_get(++ParamName, -Value)\nEplexInstance:eplex_get(++ParamName, -Value)\n\n   Retrieve information about solver state and results for eplex instance EplexInstance.\n\nArguments\n   ParamName    Name of parameter (atom)\n   Value    Returned value for ParamName\n\nType\n   library(eplex)\n\nDescription\n\n   Retrieve information about solver state and the logically most recent\n   results for the eplex instance EplexInstance. ParamName \n   is the same as that for lp_get/3, which retrieves the same information \n   via the solver state.\n\n  \n     vars\n     Returns a term ''(X1,...,Xn) whose arity is the number of\n    variables involved in the solver's constraint set, and whose\n    arguments are these variables.\n\n     ints\n     Returns a list [Xi1,...,Xik] which is the subset of the problem\n    variables that the solver considers to be integers.\n\n     constraints_norm\n     Returns a list of the problem constraints (excluding any cutpool\n    constraints) in normalised form.  They may be simplified with\n    respect to the originals that were passed to the problem.\n\n     constraints\n     Returns a list of the problem constraints (excluding any cutppol\n    constraints) in denormalised (readable) form.  They may be\n    simplified with respect to the originals that were passed to the\n    problem.\n\n     objective\n     Returns a term min(E) or max(E), representing objective function\n    and optimisation direction. E is a linear expression: any\n    quadratic components will not be retrieved.\n\n     num_cols\n     Returns the number of columns (i.e. variables) in the matrix of the\n     solver state.\n\n     num_rows\n     Returns the number of rows (i.e. constraints) in the matrix of the\n     solver state.\n\n     num_nonzeros\n     Returns the number of non-zero coefficients in the matrix of the\n     solver state.\n\n     num_ints\n     Returns the number of columns (i.e. variables) constrained to be\n     integers in the matrix of the solver state.\n\n     num_quads\n     Returns the number of non-zero coefficients in the quadratic\n     coefficient matrix (Q-matrix) of the solver state.\n\n     method\n     Returns the method that is specified to solve the problem. If an\n     auxiliary  method can be given for the method, and this auxiliary\n     method is not default, the method will be returned as \n     Method(Aux), e.g. barrier(none). The method will be \n     default unless otherwise specified by the the user (at setup or \n     via eplex_setup/2 or lp_setup/3).  In that case, the external solver's\n     defaults and any settings done via optimizer_param(_) will be used.\n\n     node_method\n     Applicable to MIP problems only. Returns the method that is\n     specified to solve the problem at the nodes of the branch-and-bound\n     tree. If an auxiliary method can be given for the method, and this\n     auxiliary method is not default, the method will be returned\n     as Method(Aux), e.g. barrier(none). The method will be\n     default unless otherwise specified by the the user (at setup\n     or via eplex_setup/2 or lp_setup/3).  In that case, the external solver's\n     defaults and any settings done via optimizer_param(_) will be used.\n\n     status\n     Status that was returned by the most recent invocation of the \n    external solver.\n\n     cost\n     Objective value (i.e. cost/profit) of the current solution.\n    Fails if no solution has been computed yet.\n\n     best_bound\n     The best bound (for minimisation, the lower bound) on the optimal \n    objective value for the current problem. Together with the\n    worst_bound, this specifies the range for the optimal objective\n    value. Note that a non-empty range does not mean that the problem\n    is feasible unless an objective value (cost) is also\n    available. The best_bound is the same as the current objective\n    value if the problem has been solved to optimality. It can be\n    better than the objective value either because a) (for MIP\n    problems only) the problem has been optimised to within the\n    mipgap tolerance, or b) the problem was not solved to optimality,\n    i.e. it was aborted before the optimal solution was found.\n\n     worst_bound\n     The worst bound (for minimisation, the upper bound) on the optimal \n    objective value for the current problem. Together with the\n    best_bound, this specifies the range for the optimal objective\n    value. Note that a non-empty range does not mean that the problem\n    is feasible unless an objective value (cost) is also\n    available. The worst_bound is the same as the current objective\n    value if a solution has been computed for the problem, whether\n    the problem was solved to optimality or not. Depending on the \n    problem type and method used to solve the problem, a worst bound\n    can be returned for a problem even if the solving of the problem\n    was aborted before a solution was obtained. \n\n     typed_solution\n     Returns a term ''(X1,...,Xn) whose arguments are the properly\n    typed (integer or float) solution values for the corresponding\n    problem variables (vars).  The floating point solutions\n    are the same as returned by solution, the integers are\n    obtained by rounding the corresponding floating-point solution to\n    the nearest integer.  To instantiate the problem variables to\n    their solutions, unify this term with the corresponding term\n    containing the variables. Note that this unification could fail\n    if two problem variables Xa and Xb were unified after the solution \n    was lasted computed, as the solutions values in the Xa and Xb\n    positions could be different, even though they are now represented \n    by one variable.\n    Fails if no solution has been computed yet.\n\n    instantiate_solution(Handle) :-\n    lp_get(Handle, vars, Vars),\n    lp_get(Handle, typed_solution, Values),\n    Vars = Values.\n\n    slack\n    Returns a list of floating-point values representing the constraint\n    slacks in the logically last solve. The problem consists of normal\n    constraints followed by any added cutpool constraints, and the\n    order corresponds to the list order in constraints for\n    normal constraints, and to cutpool_info(last_added,Info) for the\n    cutpool constraints.  Fails if no solution has been computed yet.\n\n    slack(Indexes)\n    Returns a list of floating-point values representing the slack\n    values for the constraints represented by Indexes. Indexes are a\n    list of constraint indices (as returned by lp_add_constraints/4 for\n    normal constraints, and lp_add_cutpool_constraints/4 for cutpool\n    constraints), and the order of the returned list corresponds to the\n    order in Indexes.  Fails if no slack value has been\n    computed yet for any of the constraints in Indexes -- note that \n    values are only computed for cutpool constraints if they were added\n    to the problem.\n\n    dual_solution\n    Returns a list of floating-point values representing the dual\n    solutions in the logically last solve. The problem consists of\n    normal constraints followed by any added cutpool constraints, and\n    the order corresponds to the list order in constraints for\n    normal constraints, and to cutpool_info(last_added,Info) for the\n    cutpool constraints.  Fails if no solution has been computed yet.\n\n    dual_solution(Indexes)\n    Returns a list of floating-point values representing the dual\n    solutions for the constraints represented by Indexes. Indexes are a\n    list of constraint indices (as returned by lp_add_constraints/4\n    normal constraints, and lp_add_cutpool_constraints/4 for cutpool\n    constraints), and the order of the returned list corresponds to the\n    order in Indexes.  Fails if no dual solution has been\n    computed yet for any of the constraints in Indexes -- note that\n    values are only computed for cutpool constraints if they were added\n    to the problem.\n\n    constraints(Indexes)\n    Returns a list of problem constraints as specified by\n    Indexes in denormalised form. The constraints can be either \n    normal constraints or cutpool constraints.\n\n    constraints_norm(Indexes)\n    Returns a list of problem constraints as specified by\n    Indexes in normalised form. The constraints can be either \n    normal constraints or cutpool constraints.\n\n    cutpool_info(Select,Info)\n    Returns the information specified by Info for the cutpool constraints\n    specified by Select. The returned information is either\n    i) a pair of lists Indexes-Values where Indexes is the index for\n    the constraint in the corresponding position of Values, or \n    ii) a list of Indexes if the information requested is index. Info \n    can be:\n\n    index\n    the indexes for the selected constraints. A list\n    of Indexes are returned.\n    active\n    the current active status of the selected constraints. \n    The status is either 0 (not active) or 1 (active).\n    A pair of lists Indexes-ActiveStatus is returned.\n    add_initially\n    the current add_initially status of the selected \n    constraints. The status is either 0 (not add) or 1 (add).\n    Note that although inactive constraints have a\n    add_initially status, they will not be added to a problem.\n    A pair of lists Indexes-AddInitially is returned.\n    binding_state\n    the binding state for the selected constraints in the\n    logically last solve for the problem. A pair of lists\n    Indexes-BindingStates is returned. To get this\n    information, the slack values must be available from the\n    last solve.\n    The state can be:\n    a) binding - the constraint was satisfied and binding, i.e.\n    it is within tolerance of its RHS value in the\n    normalised form. \n    b) satisfied - the constraint was satisfied but not\n    binding. \n    c) inactive - the constraint was inactive.\n    constraints_norm\n    the normalised form of the constraints for the selected \n    constraints is returned in a pair of lists \n    Indexes-Constraints.\n    constraints\n    the denormalised form of the constraints for the selected \n    constraints is returned in a pair of lists \n    Indexes-Constraints.\n\n    The constraints are selected by Select, which can be:\n\n    cstr(Idx)\n    The cutpool constraint as specified by Idx. \n    group(Name)\n    The cutpool constraints in the group Name. Both\n    active and non-active constraints are returned. Note that\n    the name of the default group is the atom nil ([]).\n    last_added\n    The cutpool constraints that were added to the\n    problem in the logically previous solve of the problem. \n    The constraints were either added initially, or were\n    added because they were violated in an intermediate\n    invocation. \n    last_notadded\n    The cutpool constraints that were not added to the\n    problem in the logically previous solve of the problem,\n    i.e. they were not violated.\n    last_inactive\n    The cutpool constraints that were inactive during the\n    logically last solve of the problem. This does not\n    include any constraints that were added since the last\n    solve. \n\n    demon_tolerance\n    Returns a comma-separated pair (RealTol,IntTol) of\n    floating-point values which specify how far outside a variable's\n    range an lp-solution can fall before lp_demon_setup/5\n    re-triggers. The tolerances differ for real (default 0.00001) and\n    integer (default 0.5) variables.\n\n    simplex_iterations\n    Returns the external solver's count of simplex iterations.\n\n    node_count\n    Returns the external MIP solver's node count. Note that this may \n    or may not include the initial root node.\n\n    statistics\n    Returns a list of counter values [Successes, Failures,\n    Aborts], indicating how often lp_solve/2 was invoked on the\n    Handle, and how many invocations succeeded, failed and aborted\n    respectively.\n\n    timeout\n    Returns the time-out value for the solver state. This is the amount\n    of CPU time in seconds that the external solver will be allow to\n    spend solving the problem before timing out. The value is 0 if \n    no time-out has been set.\n\n     optimizer_param(Param)\n     Returns the value of the external solver's parameter Param\n    for the problem represented by Handle. The external solver \n    has a number of parameters that affect the way they work, and \n    this queries their values. If Param is not a valid parameter for\n    the solver, an out of range exception is raised. See below for \n    more details on the parameters.\n\n    post_equality_when_unified\n    Returns the value (yes or no) if an equality constraint will be\n    posted to a solver if two variables in the solver's problem are \n    unified. \n\n    pool\n    Returns the name of the eplex instance (if any) associated with \n    the solver state. Fails otherwise. Only useful if called with \n    lp_get/3.\n\n    handle\n    Returns the solver state handle (if any) associated with the eplex \n    instance. Fails otherwise. Only useful if called with eplex_get/2.\n\nNote that reduced_cost, slack, dual_solution can only be retrieved\nwhen previously requested in the option list of lp_setup/4 or with lp_set/3.\nAn out of range error will be raised otherwise.\n\nFor the external solver's control parameter specified by\noptimizer_param(Param), Param must be an atom. The Value returned is\neither an integer, float or atom, depending on the parameter. The parameter\nis generally specific to a solver and version, and also, they may be\nproblem specific, or global, again depending on the solver version. In all\ncases, the value returned by lp_get/3 is the current value for the parameter\nfor the problem Handle. Refer to the solver documentation for details on the \nparameters. The names of the parameters are derived from the names of the \nparameters in the external solver. For CPLEX, take the parameter name from \nthe CPLEX manual (or cplex.h), remove the CPX_PARAM_ prefix and convert the \nrest to lower case, e.g.\n\n    CPX_PARAM_NODELIM becomes nodelim. \n\nFor XPRESS-MP (version 13 and newer), take the parameter name from the \nmanual (or xpresso.h), remove the XPRS_ prefix (if present) and convert \nthe rest to lower case, e.g.\n\n\tXPRS_MAXNODE becomes maxnode. \n\nFor Gurobi, take the parameter name from the manual and convert it to\nall lower case, e.g.\n\n\tIntFeasTol becomes intfeastol. \n\nFor solvers used via the OSI, there are a few generic parameters supported \nvia OSI, and depending on the actual solver, there may be some additional\nsolver-specific parameters. For the generic parameters, take the parameter\nname, remove the Osi prefix and convert the rest to lower case, e.g.\n\n    OsiPrimalTolerance becomes primaltolerance\n\n    The following parameter names are additional aliases that work for\n    several solvers:\n\n    feasibility_tol\n\tCPX_PARAM_EPRHS (CPLEX) or XPRS_FEASTOL (XPRESS-MP) or\n    OsiPrimalTolerance (OSI) or FeasibilityTol (GRB) - float\n    integrality\n\tCPX_PARAM_EPINT (CPLEX) or XPRS_MIPTOL (XPRESS-MP) or\n    CbcIntegerTolerance (OSI,Cbc specific) or IntFeasTol (GRB) - float\n    iteration_limit\n\tCPX_PARAM_ITLIM (CPLEX) or XPRS_LPITERLIMIT (XPRESS-MP) or\n    OsiMaxNumIteration (OSI) or IterationLimit (GRB) - integer\n    node_limit\n\tCPX_PARAM_NODELIM (CPLEX) or XPRS_MAXNODE (XPRESS-MP) or\n    CbcMaxNumNode (OSI, Cbc specific) or NodeLimit (GRB)- integer\n    objdifference\n\tCPX_PARAM_OBJDIF (CPLEX) or XPRS_MIPADDCUTOFF (XPRESS-MP) or\n    CbcCutoffIncrement (OSI, Cbc specific) - float\n\n    \n\nExceptions\n     5 --- EplexInstance does not a solver setup for it.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   eplex_solver_setup / 4, eplex_set / 2, lp_set / 3, lp_get / 3, lp_add_constraints / 4"},"anti_unify:anti_unify/3":{"prefix":"anti_unify","body":"anti_unify(${1:Term1}, ${2:Term2}, ${3:General})$4\n$0","description":"anti_unify(Term1, Term2, General)\n\n   Computes the most specific generalization of two terms in\n    N*log(N) time, where N is the size of the smaller term.\n\nType\n   library(anti_unify)\n\nExamples\n   \n    [eclipse 10]: anti_unify(a, b, X).\n    X = _65\n    yes.\n\n    [eclipse 11]: anti_unify(a, a, X).\n    X = a\n    yes.\n\n    [eclipse 9]: anti_unify(foo(a,b,c), foo(b,b,b), X).\n    X = foo(_115, b, _98)\n    yes.\n\n    [eclipse 8]: anti_unify(foo(a,a,a), foo(b,b,b), X).\n    X = foo(_98, _98, _98)\n    yes."},"apply:apply_desc":{"prefix":"lib","body":"lib(${1:apply})$2\n$0","description":"lib(apply)\n\n    This library defines the apply/2 predicate which constructs a goal\n    from a term and a list of additional arguments:\n    \n    \t?- P=plus(1), apply(P, [3,X]).\n\tP = plus(1)\n\tX = 4\n\tYes (0.00s cpu)\n    \n    Loading this library also enables the syntax option var_functor_is_apply.\n    This means that it is allowed to write terms with variables functors,\n    which will be parsed as apply/2 terms which can the be executed.\n    The above example can thus be written as:\n    \n    \t?- P=plus(1), P(3,X).\n\tP = plus(1)\n\tX = 4\n\tYes (0.00s cpu)"},"apply_macros:applist/2":{"prefix":"applist","body":"applist(${1:Pred}, ${2:List})$3\n$0","description":"applist(+Pred, +List)\n\n   Apply a predicate to all list elements\n\nType\n   library(apply_macros)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   applist(<(0), [1,2,3])."},"eplex:eplex_get_iis/4":{"prefix":"eplex_get_iis","body":"eplex_get_iis(${1:NumConstraints}, ${2:NumVars}, ${3:ConstraintIdxs}, ${4:VarInfos})$5\n$0","description":"eplex_get_iis(-NumConstraints, -NumVars, -ConstraintIdxs, -VarInfos)\nEplexInstance:eplex_get_iis(-NumConstraints, -NumVars, -ConstraintIdxs, -VarInfos)\n\n   Returns an IIS for an infeasible problem associated with EplexInstance.\n\nArguments\n   NumConstraints      Number of constraints in the IIS\n   NumVars    Number of variables in the IIS\n   ConstraintIdxs      List of Indexes of the constraints in the IIS\n   VarInfos    List of Variable:Status pairs where Variables are the variables in the IIS and Status is the status of that variable\n\nType\n   library(eplex)\n\nDescription\n    \n    If the solver found that the problem was infeasible, this predicate\n    will return an IIS (Irreducible Infeasible Subsystem or Irreducible\n    Inconsistent Subsystem) for the problem, if supported by the solver. \n\n    This predicate must be called from within a user defined \n    infeasible_handler, and with the cache_iis option set to yes (both\n    can be set during solver set-up or using eplex_set/2). The reason for\n    this is the IIS must be computed by the solver before the failed\n    solver state changes, and backtracking pass the failure (the normal \n    behaviour when a problem is infeasible) will logically remove the failed \n    state. cache_iis is needed because the default setting for this\n    option is no, as the IIS need to be computed as an extra step, so\n    IIS is normally not computed.\n\n    An IIS is a subset of the problem constraints and variables which\n    defines an infeasible subproblem. It is usually irreducible in that\n    any proper subset of the IIS is feasible. Finding an IIS allows the\n    diagnostic analysis of the infeasible problem. Note that a problem\n    may have more than one infeasibility, and thus more than one IIS, \n    but this predicate only returns one. \n    \n    NumConstraints and NumVars are the number of constraints and variables\n    that are in the IIS. ConstraintIdxs is a list of the constraint indexes\n    of the constraints in the IIS, these indexes are the indexes that are\n    returned by lp_add_constraints/4 and lp_add_cutpool_constraints/4, and can \n    also be used to retrieve the constraint with the constraints_norm(Indexes)\n    and constraints(Indexes) options of eplex_get/2 and lp_get/3. VarInfos gives\n    information for the variables in the IIS, and is a list of Var:Status\n    pair, where Var is a variable in the IIS, and Status is its status.\n    Status is a one character string, and can be:\n\n       \"b\": if both bounds of the variable are involved in the infeasibility\n       \"u\": if the upper bound of the variable is involved in the infeasibility\n       \"l\": if the lower bound of the variable is involved in the infeasibility\n       \"x\": if it is unknown which bound is involved in the infeasibility\n\n    An IIS is returned only if finding IIS is supported by the external\n    solver. In addition, the solver may limit the type of problems and the\n    information returned by the IIS, for example, finding an IIS may be\n    limited to linear problems, and/or bound status information may be\n    unavailable for the variables (hence the need for the \"x\" status).\n    Consult the solver's manual entry for infeasibility analyses for more detail.   \n\n    For some external solvers, and for problems on the boundary between\n    feasible and infeasible, it is possible that the routine that finds\n    the IIS will conclude that the problem is feasible, even though it was\n    considered infeasible when the problem was solved. In such cases, an\n    empty IIS will be returned.\n\nExceptions\n   141 --- External solver does not support finding IIS\n   213 --- Error in external solver while getting IIS\n\nExamples\n   \n % simple inconsistency, get the constraints with constraints option of eplex_get/2\n [eclipse 6]: eplex:(X=:=Y),\n    eplex:(X+Y>=3),\n    eplex:(X+Y=<2),\n    eplex_solver_setup(min(X)),\n    eplex_set(cache_iis, yes),\n    eplex_set(infeasible_handler,\n    eplex_get_iis(NC,BV, Is, Vs),\n    eplex_get(constraints(Is), Cs))),\n    eplex_solve(C).\n  CPLEX Error  1217: No solution exists.\n \n  X = X{-1e+20 .. 1e+20}\n  Y = Y{-1e+20 .. 1e+20}\n  NC = 2\n  BV = 0\n  Is = [0, 1]\n  Vs = []\n  Cs = [X{-1e+20 .. 1e+20} + Y{-1e+20 .. 1e+20} =< 2.0, X + Y >= 3.0]\n  C = C\n  Yes (0.00s cpu)\n  [eclipse 7]:\n\n  % simple example using cutpool constraints and cache_iis option\n  [eclipse 7]:    eplex:(X=:=Y), eplex_solver_setup(min(X)),\n    eplex_set(cache_iis, yes), eplex_set(infeasible_handler, eplex_get_iis(NC,NV,Is,Vs)),\n    eplex_get(handle, H),\n    lp_add_cutpool_constraints(H, [(X+Y>=4),(2*X =:= 2*Y), (X+Y=<3)], [], Idxs),\n    eplex_solve(C).\n  \n    CPLEX Error  1217: No solution exists.\n \n  X = X{-1e+20 .. 1e+20}\n  Y = Y{-1e+20 .. 1e+20}\n  NC = 2\n  NV = 0\n  Is = [g(2, 0), g(2, 2)]\n  Vs = []\n  H = lp_handle(0)\n  Idxs = [g(2, 0), g(2, 1), g(2, 2)]\n  C = C\n  Yes (0.00s cpu)\n  [eclipse 8]:\n  \n\nSee Also\n   lp_get_iis / 5, eplex_solver_setup / 4, eplex_solve / 1, eplex_probe / 2, eplex_get / 2, eplex_set / 2, lp_add_constraints / 4, lp_add_cutpool_constraints / 4"},"eplex:eplex_instance/1":{"prefix":"eplex_instance","body":"eplex_instance(${1:EplexInstance})$2\n$0","description":"eplex_instance(++EplexInstance)\n\n   Initialises the eplex instance EplexInstance.\n\nArguments\n   EplexInstance       Eplex instance name (atom)\n\nType\n   library(eplex)\n\nDescription\n  \n  Initialises the eplex instance EplexInstance. An eplex instance is an\n  instance of the eplex solver, to which eplex linear arithmetic and \n  integrality constraints can be posted, and to which an external LP/MIP\n  solver can be associated and used to optimise the posted constraints\n  with respect to some objective. \n  \n  If EplexInstance is not an already existing eplex instance, a new eplex\n  instance will be created and initialised. If it is an existing eplex\n  instance, and it is not currently being used (having no outstanding posted\n  constraints and no associated solver), it is effectively reinitialised.\n  Otherwise, the predicate aborts with an error. Note that an eplex instance\n  is a module, and each eplex instance can be associated with at most one\n  solver at any time and vice versa. An eplex instance should NOT be\n  erased (e.g. using erase_module/1), as this would only erase the module,\n  but not the information that eplex keeps on it as an eplex instance.\n  \n  \n\nSee Also\n   $= / 2, $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2, $:: / 2, :: / 2, integers / 1, reals / 1, eplex_solver_setup / 1, eplex_solver_setup / 4, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3, eplex_cleanup / 0"},"eplex:eplex_probe/2":{"prefix":"eplex_probe","body":"eplex_probe(${1:Probes}, ${2:Cost})$3\n$0","description":"eplex_probe(+Probes, -Cost)\nEplexInstance:eplex_probe(+Probes, -Cost)\n\n   Invoke EplexInstance's external solver, probing the problem temporarily modified by the probe specifications.\n\nArguments\n   Probes    Temporary probe specification(s)\n   Cost    Value of solution\n\nType\n   library(eplex)\n\nDescription\n\n   Similar to eplex_solve/1, but the problem is first temporarily modified\n   as specified in Probes. Probes is a list of one or more probe\n   specifications that specifies how the problem is modified. The\n   objective value of the modified problem is unified with Cost\n   after the solve. Cost should be a free variable.\n\n   After the call to this predicate, the problem is restored for the \n   external solver. However, the results from the probe (obtainable from\n   eplex_var_get/3 and eplex_get/2) are retained.\n\n   The following probe specifications are allowed:\n\n    min(Expr)/max(Expr)\n    Minimise/maximise the problem with the objective function Expr.\n    Only existing problem variables can be given in Expr. Cannot be\n    used in conjunction with objsense, objexpr or perturb_obj.\n    objsense(Sense)\n    Sense is either min or max. Solves the problem with the original\n    objective function, but with the sense given in Sense rather than\n    that specified at setup. If only the sense of the objective is to \n    be changed, this changes the objective more efficiently than using\n    min(Expr)/max(Expr). Cannot be used in conjunction with min/max.\n    objexpr(Expr)\n    Optimise the problem with respect to the objective function Expr,\n    without changing the optimisation direction specified at problem\n    setup. Cannot be used in conjunction with min/max or perturb_obj.\n    perturb_obj(ObjDeltas)\n    Perturb the existing linear objective coefficients as specified by\n    ObjDeltas. ObjDeltas is a (possibly empty) list of specifications\n    Var : Delta, where Var is a problem variable and Delta is the\n    amount its existing objective coefficient should be changed by. For\n    example, if the existing objective is 2*X + 3*Y + Z, \n    perturb_obj([X : 1, Y : -0.5]) will modify the objective to \n    3*X + 2.5*Y + Z for the probe. If a variable occurs more than once in\n    ObjDeltas, the change to the objective coefficient is cumulative.\n    Perturb_obj is not strictly needed, as its effect can be achieved\n    by constructing the whole objective and then probing with that.\n    However, this can be expensive if most of the objective stays \n    unchanged, with only a few of its coefficients changed. It is \n    recommended that perturb_obj probe be used in such cases. \n    Cannot be used in conjunction with objexpr or min/max.\n    rhscoeffs(RhsCoeffs)\n    Alter the rhs coefficients of the matrix as specified by RhsCoeffs.\n    RhsCoeffs is a (possibly empty) list of rhs coefficient\n    specifications of the form Idx : Rhs, where Idx is the index of the\n    expandable constraint obtained from using lp_add_constraints/4, and\n    Rhs is the value for the right-hand side constant to use during the\n    probe. Any constraints not specified in RhsCoeffs remain unchanged\n    during the probe. If Idx occurs more than once in RhsCoeffs, the\n    result is undefined.\n    bounds(BoundsChanges)\n    Alter the bounds of problem variables as specified by\n    BoundsChanges. BoundsChanges is a (possibly empty) list of bounds\n    changes of the form Var $:: Lo..Hi, where Var is a problem variable\n    and Lo and Hi are the new lower and upper bounds to use for the\n    variable during the probe. Unlike normal bound changes, the bounds\n    can be widened as well narrowed, although failure will still occur\n    if Hi < Lo. Variables not specified in BoundsChanges retain their\n    bounds during the probe. If Var occurs more than once in \n    BoundsChanges, the result is undefined.\n    fixed\n    The problem is solved as an LP problem by `fixing' the integer\n    variables to their optimal MIP solution values. If there is an\n    existing MIP solution for the problem, eplex will try to use that;\n    otherwise, a MIP solution is obtained first.\n    `Fixed' probing is useful for providing reduced costs for\n    MIP problems. Note that reduced costs for the variables will only be\n    available if the reduced_cost option for the problem is set to yes\n    (this can be done either at problem setup, or by using\n    eplex_set/2). For a problem without integer variables, the original\n    problem is solved without change.  Note that this probe\n    specification is not available if the mip_use_copy option is set to\n    no for external solvers that cannot modify a MIP problem.  Cannot\n    be used in conjunction with `relaxed'.\n    relaxed\n    The problem is solved as an LP problem by relaxing all the integer\n    constraints.  For a problem with integer variables, this should be\n    equivalent to the initial relaxation solved at the start of the MIP\n    search. Depending on the solver, the discreteness of the integer\n    variables may still be taken into account during presolve. To\n    ensure that the problem solved is exactly the LP problem without\n    any integer constraints, presolve should be off. For a problem\n    without integer variables, the original problem is solved without\n    change. Note that this probe specification is not available if the\n    mip_use_copy option is set to no for external solvers that cannot\n    modify a MIP problem. Cannot be used in conjunction with `fixed'.\n\nFail Conditions\n   External solver was unable to find a solution, or bounds probe used and the specified interval for some variable is empty\n\nExceptions\n     5 --- EplexInstance does not have a solver setup for it.\n   eplex_suboptimal --- Solution was found, but is possibly suboptimal\n   eplex_unbounded --- Problem is unbounded, no solution values\n   eplex_unknown --- Result is unknown (infeasible or unbounded)\n   eplex_abort --- External solver aborted for some reason\n   abort --- Incorrect specification for the probe(s)\n     6 --- mip_use_copy option was set to no (solver dependent) for probes that require yes.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   eplex_solve / 1, eplex_solver_setup / 1, eplex_solver_setup / 4, eplex_get / 2, eplex_var_get / 3, eplex_set / 2, lp_add_constraints / 4"},"eplex:eplex_read/2":{"prefix":"eplex_read","body":"eplex_read(${1:Format}, ${2:File})$3\n$0","description":"eplex_read(++Format,++File)\nEplexInstance:eplex_read(++Format,++File)\n\n   Read a problem from a file into eplex instance EplexInstance.\n\nArguments\n   Format    lp or mps\n   File    File name\n\nType\n   library(eplex)\n\nDescription\n\n   Read a problem from a file and setup a solver for it in EplexInstance.\n   A solver should not already be setup for EplexInstance. Format is lp or\n   mps. Note that minimisation of the objective is assumed for mps format,\n   as the sense of the objective is not included in the mps format.\n   Minimisation is also assumed for external solvers that ignore the\n   optimisation direction of the lp file (e.g. Xpress).  Note also that\n   although quadratic problems can be read in correctly if supported by the\n   external solver, the quadratic objective coefficients are not extracted\n   from the problem by eplex. These coefficients are used to set/reset the\n   objective when a problem is probed with a different objective in\n   eplex_probe/2 or lp_probe/3, so the objective will not be changed or\n   restored correctly in this case.  \n\nExceptions\n     5 --- EplexInstance already has a solver setup for it.\n\nSee Also\n   eplex_write / 2, lp_write / 3, lp_setup / 4, eplex_probe / 2"},"eplex:eplex_set/2":{"prefix":"eplex_set","body":"eplex_set(${1:ParamName}, ${2:Value})$3\n$0","description":"eplex_set(++ParamName, -Value)\nEplexInstance:eplex_set(++ParamName, -Value)\n\n   Change initial options for solver state associated with EplexInstance\n\nArguments\n   ParamName    Name of parameter (atom)\n   Value    New value for ParamName\n\nType\n   library(eplex)\n\nDescription\n\nThis primitive can be used to change some of the initial options\neven after setup of a solver for eplex instance EplexInstance.\nWhat can be one of the following:\n\n    method\n    Set the method that will be used to solve the problem.  Value\n    is one of default, auto, primal, dual, net, net(Simplex), barrier,\n    barrier(Crossover), sifting, sifting(SubMethod), concurrent,\n\tconcurrent_det.  Simplex can be one of default, auto, primal, dual,\n\tspecifying the Simplex method to use in the Network Simplex algorithm.\n\tCrossover can be one of default, auto, primal, dual, none,\n\tspecifying the crossover method to use for the barrier method.\n\tSubMethod could be one of default, auto, primal, dual, net, barrier,\n\tspecifying the method to use for the subproblems in the sifting method.\n\tNote that not every method is available on every external solver.\n\tIn case of MIP solving, this is the start algorithm (the one that\n\tis used to solve the initial relaxation). This method setting will\n\toverride similar settings done via optimizer_param(_).\n\n    node_method\n    Applicable to MIP problems only. Set the method that will be\n    used to solve the problem at the nodes (except the root) of the \n    branch-and-bound tree. Note that the method for solving the root\n    node is controlled by the method option. Value can be set\n    to the same values as in the method option, although \n    there may be more restrictions on what the actual methods/auxiliary\n    methods that are allowed in combination with the root method,\n    due to limitations/restrictions from the external solver. A warning\n    will be given when the problem is solved if this is the case, and \n    the default method used instead.  This node_method setting will\n\toverride similar settings done via optimizer_param(_).\n\n    solution\n    Make the solutions available each time the problem has been\n    (re-)solved successfully.\n    Value is one of the atoms yes or no.\n\n    reduced_cost\n    Make the reduced costs available each time the problem has been\n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values\n    for the optimal LP node. \n    Value is one of the atoms yes or no.\n\n    slack\n    Make the constraint slacks available each time the problem has been\n    (re-)solved successfully.\n    Value is one of the atoms yes or no.\n\n    dual_solution\n    Make the dual solutions available each time the problem has been\n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values\n    for the optimal LP node. \n    Value is one of the atoms yes or no.\n\n    keep_basis\n    Store the basis each time the problem has been solved successfully,\n    and use this basis as a starting point for re-solving next time.\n    Value is one of the atoms yes or no.\n\n    mipstart\n    Use the previous solution values as a warm-start heuristics for\n\tthe MIP search.  This only has an effect for certain solvers (e.g.\n\tGurobi), if there are integrality constraints, and if there is a \n\tprevious solution available.  Possible values are none\n\t(no mipstart values, the default), all (use previous\n\tsolution for all variables), or integers (use previous\n\tsolution for all variables that are now constrained to be integral).  \n\n    cache_iis\n    When a problem is found to be infeasible, compute an IIS for the problem\n    (if supported by the external solver), and store it so that it can bee retrieved\n    by eplex_get_iis/4 or lp_get_iis/5. This will be done before the problem can\n    be modified and make the computing of the IIS impossible. The IIS will only\n    be available before the problem is solved again, and before the infeasible  \n    solve is backtracked. This option has no effect if the external solver does not \n    support the finding of IIS. Note that if this option is set, eplex will always ask\n    for an IIS to computed for an infeasible problem, even if it is immediately backtracked \n    by the infeasible handler failing, and that the option is only needed if the problem \n    instance in the external solver is modified before eplex_get_iis/4 or lp_get_iis/5 is called. \n    Value is one of the atoms yes or no.\n\n    demon_tolerance\n    Specify how far outside a variable's range an lp-solution\n    can fall before lp_demon_setup/5 re-triggers.\n    Value is a comma-separated pair (RealTol,IntTol) of \n    floating-point values (default (0.00001,0.5)).\n\n    use_var_names\n    Specify if variable names (set using set_var_name/2 of the\n    var_name library) should be passed to the external solver. If a\n    particular variable does not have a name, a solver's default name\n    would be used. Note that for XPRESS-MP, there is a limit on the\n    length of the name, which can be changed between 8 and 64 in steps\n    of 8 with the parameter N_NAMLEN. Variable names longer\n    than this limit are truncated to the limit. Note also that only \n    new variables from constraints added after the lp_set/3 call \n    will pass their names to the external solver.\n    Value is one of the atoms yes or no.\n\n    timeout\n    Set the external solver to time-out after Value\n    seconds.  The solver will abort (in either the abort or suboptimal\n    state, depending on if a suboptimal solution was found) if the\n    optimal solution was not found within the time limit. In cases\n    where the solver expects an integer for the time-out interval, the\n    time given is rounded up to the next integer value. This should be\n    used instead of the solver specific optimizer_param(Param) for\n    setting timeouts, as eplex sets these parameter(s) itself. Note\n    that the exact behaviour of the timeout setting is solver dependent.\n    Value is a positive number.\n\nsuboptimal_handler\n    Value is a user defined goal to handle the case when the\n    external solver returned a suboptimal solution (because the problem\n    was aborted). Value would replace any existing suboptimal handler,\n    and would also be run in place of raising the default\n    eplex_suboptimal event.\n\nunbounded_handler\n    Value is a user defined goal to handle the case when the\n    problem is unbounded. Value would replace any existing unbounded\n    handler, and would be run in place of raising the default\n    eplex_unbounded event.\n\ninfeasible_handler\n    Value is a user defined goal to handle the case when the\n    external solver found the problem to be infeasible. Value would\n    replace any existing infeasible handler, and would be run in place\n    of raising the default eplex_infeasible event. Note that\n    the default and logically correct behaviour is to fail, this\n    handler is provided to allow the user to analyse the cause of the\n    infeasibility. It is recommended that the handler should also fail\n    after performing the analysis.\n\nunknown_handler\n    Value is a user defined goal to handle the case when the\n    external solver was not able to determine if the problem is\n    unbounded Value would replace any existing unknown handler, and\n    would be run in place of raising the default eplex_unknown\n    event.\n\nabort_handler\n    Value is a user defined goal to handle the case when the\n    external solver aborted without finding any solution.  Value would\n    replace any existing abort handler, and would be run in place of\n    raising the default eplex_abort event.\n\n    optimizer_param(Param)\n    Set the external solver's control parameter Param for the problem\n    Handle. If the solver's parameters are global and not\n    problem specific, an unimplemented functionality exception would\n    be raised. See lp_get/3 for more details on the external solver's\n    parameters. Note that the new setting is not undone on \n    backtracking.\n\n    write_before_solve\n       Value can be the pair (Format,File) or the atom no. If\n       (Format,File) is given, Eplex will ask the external solver to dump\n       the problem each time the solver is solved. This allows the problem\n       in an eplex_probe/2 or lp_probe/3 to be dumped. As\n       in lp_write/3, Format is the format of the dumped\n       problem, and File is the filename. See for more details. Note that\n       the problem is dumped each time the external solver is invoked if\n       the problem has cutpool constraints, where there may be multiple\n       invocations of the solver per solver call.  `no' for Value will turn\n       off this dumping.\n\n    post_equality_when_unified\n    Value can be the atoms yes or no. Determines if an equality\n    constraint will be posted to a solver when two of its variables are\n    unified. Setting Value to no means that the constraint will not be\n    posted. Note that this could mean that the\n    solver's problem may become inconsistent with ECLiPSe's. \n\n  Making solutions available means that they can be retrieved using\n  lp_get/3 or lp_var_get/4 after the solver has been run successfully.\n\n  All settings apart from optimizer_param(Param) will be undone on backtracking!\n\nResatisfiable\n   no\n\nExceptions\n     5 --- EplexInstance does not a solver setup for it.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   eplex_solver_setup / 4, eplex_set / 2, eplex_get_iis / 4, lp_set / 3, lp_get / 3"},"eplex:eplex_solve/1":{"prefix":"eplex_solve","body":"eplex_solve(${1:Cost})$2\n$0","description":"eplex_solve(-Cost)\nEplexInstance:eplex_solve(-Cost)\n\n   Explicitly invoke the external solver associated with EplexInstance.\n\nArguments\n   Cost    Value of returned solution\n\nType\n   library(eplex)\n\nDescription\n\n   Explicitly triggers the solver associated with the eplex instance \n   EplexInstance. If the solver was set up without any trigger conditions,\n   then it needs to be explicitly triggered via a call to this predicate.\n   The objective value of the solve is unified with Cost, which should be a\n   free variable.\n\n   The external solver's LP, QP or MIP solver is applied to the\n   problem represented by the eplex instance.  Precisely which method is used\n   depends on the options given at set up.  eplex_solve/1 fails if\n   there is no solution or succeeds if an optimal solution is found,\n   returning the solution's cost in Cost. After a success, various\n   solution and status information can be retrieved using eplex_get/2\n   and eplex_var_get/3.\n\n   Normally, the external solver is invoked once per call in this\n   predicate, but if the problem contain cutpool constraints (see\n   lp_add_cutpool_constraints/4), then the external solver may be invoked\n   repeatedly to produce a solution which does not violate the cutpool\n   constraints. \n\n   When a solver is triggered repeatedly, each invocation will\n   automatically take into account the current variable bounds.  The set of\n   constraints considered by the solver is the one given when the solver\n   was created plus any new constraints that were posted in the\n   meantime.\n\n   The user can define their own handlers (per eplex instance/problem) to\n   handle cases where there was some  error condition, or some limits were \n   exceeded during the solving of the problem. If no handler was defined,\n   by default an event would be raised. These are:\n\n    suboptimal handler (eplex_suboptimal event)\n    \tThis means that a solution was found but it may be suboptimal.\n\tThe default behaviour is to print a warning and succeed.\n    unbounded_handler (eplex_unbounded event)\n\tThis means that the problem is unbounded. The default\n\tbehaviour is to bind Cost to infinity (positive or negative\n\tdepending on the optimisation direction), print a warning and\n\tsucceed.  CAUTION: No solution values are computed when the\n\tproblem is unbounded, so unless the problem was set up with\n\tthe solution(no) option, an error will occur when trying to\n\tcontinue as if the optimisation had succeeded.\n    infeasible_handler (eplex_infeasible event)\n    \tThis means that the problem is infeasible. The default\n\tbehaviour is to fail. Redefining this handler allows the \n    examination of the failed problem, e.g. obtaining an IIS for it.\n    unknown_handler (eplex_unknown event)\n    \tThis means that due to the solution method chosen, it is unknown\n\twhether the problem is unbounded or infeasible. The default\n\tbehaviour is to print a warning and fail (even though this\n\tmay be logically wrong!).\n    abort_handler (eplex_abort event)\n    \tSome other error condition occurred during optimisation.\n\tThe default behaviour is to print an error and abort.\n\n   Note that the events are raised for the low-level primitive lp_solve/2,\n   which is called by eplex_solve/1.\n\nFail Conditions\n   External solver was unable to find a solution (default behaviour)\n\nExceptions\n     5 --- EplexInstance does not a solver setup for it.\n   eplex_suboptimal --- Solution was found, but is possibly suboptimal\n   eplex_unbounded --- Problem is unbounded, no solution values\n   eplex_unknown --- Result is unknown (infeasible or unbounded)\n   eplex_abort --- External solver aborted for some reason\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   eplex_solver_setup / 4, eplex_solver_setup / 1, eplex_var_get / 3, eplex_get / 2, $= / 2, $=< / 2, $>= / 2, =:= / 2, >= / 2, =< / 2, $:: / 2, :: / 2, integers / 1, reals / 1"},"eplex:eplex_solver_setup/1":{"prefix":"eplex_solver_setup","body":"eplex_solver_setup(${1:Objective})$2\n$0","description":"eplex_solver_setup(+Objective)\nEplexInstance:eplex_solver_setup(+Objective)\n\n   Setup an external solver state for eplex instance EplexInstance\n\nArguments\n   Objective    Objective function: min(CostExpr) or max(CostExpr)\n\nType\n   library(eplex)\n\nDescription\n\n  Setup a new external solver state for the eplex instance EplexInstance. \n  The solver state will be associated with EplexInstance;\n  EplexInstance must not already have a solver state associated with it.\n  Once the solver state is setup, it can be invoked (e.g. via eplex_solve/1 \n  or eplex_probe/2) to optimise the Objective function. \n\n    CostExpr is a linear expression\n    (or quadratic if supported by the external solver).\n\n  Declaratively, this can be seen as a compound constraint representing all\n  the individual linear constraints that have been set so far and are going\n  to be set up later for EplexInstance. The invoking of this \n  constraint is done explicitly by the user, usually via eplex_solve/1.\n  Operationally, when the external solver is invoked, the delayed \n  constraints posted to EplexInstance are collected and taken into\n  account.\n\n  This is a simplified version of eplex_solver_setup/4, it is equivalent to\n  calling eplex_solver_setup/4 with the following defaults:\n\n       eplex_solver_setup(Objective, _, [], [])\n\nSee Also\n   $= / 2, $=< / 2, $>= / 2, =:= / 2, >= / 2, =< / 2, $:: / 2, :: / 2, integers / 1, reals / 1, eplex_solver_setup / 4, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3"},"eplex:eplex_solver_setup/4":{"prefix":"eplex_solver_setup","body":"eplex_solver_setup(${1:Objective}, ${2:Cost}, ${3:ListOfOptions}, ${4:TriggerModes})$5\n$0","description":"eplex_solver_setup(+Objective, ?Cost, ++ListOfOptions, +TriggerModes)\nEplexInstance:eplex_solver_setup(+Objective, ?Cost, ++ListOfOptions, +TriggerModes)\n\n   Setup an external solver state for eplex instance EplexInstance\n\nArguments\n   Objective    Objective function: min(CostExpr) or max(CostExpr)\n   Cost    Variable bounded by the optimal solution\n   ListOfOptions       List of solver options\n   TriggerModes    List of conditions for re-triggering solver\n\nType\n   library(eplex)\n\nDescription\n\n  Setup a new external solver state for the eplex instance EplexInstance. \n  The solver state will be associated with EplexInstance;\n  EplexInstance must not already have a solver state associated with it.\n  This predicate allow various options to be specified when setting up the\n  solver state. ListOfOptions allows a list of solver options to \n  be specified, and TriggerModes allows the \n  solver state to be set up as a demon so that the external solver is \n  automatically invoked when the conditions for re-triggering specified in\n  TriggerModes are met. The external solver can also be invoked \n  explicitly via eplex_solve/1. \n\n  Declaratively, this can be seen as a compound constraint representing all\n  the individual linear constraints that have been set so far and are going\n  to be set up later for EplexInstance. Operationally, when the\n  external solver is invoked, the delayed constraints posted to \n  EplexInstance are collected and taken into account.\n\n  CostExpr is a linear cost expression (or quadratic, if supported\n  by the external solver).\n\n  The external solver's best objective bound will be exported as a bound\n  for Cost: For a minimisation problem, each solution's best bound\n  becomes a lower bound, for maximisation an upper bound on Cost.  This\n  technique allows for repeated re-solving with reduced bounds or added\n  constraints. Note that Cost is not automatically made a problem variable\n  (it can be a problem variable if there are constraints that involve it),\n  and thus may not have bounds associated with in. In order for the bounds\n  information not to be lost, some bounds should be given to Cost\n  (e.g. making it a problem variable (but this might introduce unnecessary\n  self-waking on bounds change), or via another solver with bounds\n  (e.g. ic)).\n\n  ListOfOptions is the same as in the low-level primitive \n  lp_demon_setup/5, except that EplexInstance is implicitly associated with\n  the new external solver state, so the collect_from option of\n  lp_demon_setup/5 is not allowed (it is set to \n  collect_from(pool(EplexInstance)) by the predicate). See \n  below for more details.\n\n  TriggerModes specifies under which conditions the external solver\n  will be re-triggered. If no condition is specified, then the solver must\n  be explicitly triggered, usually via eplex_solve/1. The conditions are the\n  same as in the low-level primitive lp_demon_setup/5 called by this predicate.\n  See below (after ListOfOptions descriptions) for more details.\n\n  Note: Some external solvers need to write temporary files when they\n  are solving a problem. These are written to the temporary directory\n  specified in ECLiPSe's tmp_dir setting (get_flag/2, set_flag/2).\n\nListOfOptions are (unless explicitly specified otherwise, each option should \noccur no more than once):\n\ninitial_solve(+YesNo)\n    Specifies if an initial solve (call to the external solver) should\n    be performed immediately after problem setup.\n    YesNo is one of the atoms yes or no, the default is \n    yes if any trigger condition is specified in TriggerModes, \n    no if no trigger condition is specified.\n\nmethod(+Method)\n    Use the specified method (default, auto, primal, dual, net,\n    barrier, sifting, concurrent, concurrent_det) (representing Primal\n    Simplex, Dual Simplex, Network Simplex, Barrier, Sifting etc) to solve\n    the problem. For MIP problems, this specifies the start algorithm (the\n    one that is used to solve the initial relaxation). See the external\n    solver's manual for a description of these methods.\n \n    For some of the methods, an additional `auxiliary' method may be \n    specified in brackets. These are:\n\n      net(Simplex): \n      specifies the Simplex method (primal or dual) to \n      follow the network optimisation. For LP problems only.\n\n      barrier(Crossover): \n      specifies how the crossover to a basic solution from the barrier\n      solution is performed. Crossover can be primal, \n      dual, or none. none means no crossover is\n      performed. \n\n      sifting(SubMethod): \n      specifies the method for solving the sifting subproblem. \n      SubMethod can be primal, dual, net, barrier.\n\n    For all the auxiliary methods, default can also be specified.\n    This is equivalent to not specifying an auxiliary method at all. \n\n    Note that not every method is available on every external solver.\n    The default method would use the solver's default method, or any\n    selections done via solver-specific optimizer_param(_) settings.\n\nnode_method(+Method)\n    For MIP problems only. Use the specified method (default, primal,\n    dual, net, barrier, sifting) to solve the subproblem at each node\n    of the MIP search-tree, except the root node, which is specified by\n    method option above. See method option for more description of\n    the methods. Note that there are less choices in the specifications of\n    the auxiliary methods that in the method option, due to limitations in\n    the solvers. If a specified auxiliary method cannot be used, `default'\n    will be used instead.\n\nsolution(+YesNo)\n    Make the solutions available each time the problem has been (re-)solved\n    successfully.\n    YesNo is one of the atoms yes or no, the default is \n    yes.\n\ndual_solution(+YesNo)\n    Make the dual solutions available each time the problem has been \n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nslack(+YesNo)\n    Make the constraint slacks available each time the problem has been \n    (re-)solved successfully.\n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nreduced_cost(+YesNo)\n    Make the reduced costs available each time the problem has been \n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nkeep_basis(+YesNo)\n    Store the basis each time the problem has been solved successfully,\n    and use this basis as a starting point for re-solving next time.\n    This option only affects performance.\n    YesNo is one of the atoms yes or no, the default is \n    no.\n\n    mipstart(+Option)\n    Use the previous solution values as a warm-start heuristics for\n    the MIP search.  This only has an effect for certain solvers (e.g.\n    Gurobi), if there are integrality constraints, and if there is a \n    previous solution available.  Possible values are none\n    (no mipstart values, the default), all (use previous\n    solution for all variables), or integers (use previous\n    solution for all variables that are now constrained to be integral).  \n\n    cache_iis(YesNo)\n     Specify if an IIS should be computed immediately for an infeasible problem\n     (if supported by the external solver), and store it so that it can bee retrieved by\n     eplex_get_iis/4 or lp_get_iis/5 (called from within a user-defined infeasible \n     handler). This will be done before the problem can be modified and make the computing \n     of the IIS impossible. The IIS will only be available before the problem is solved\n     again, and also before the infeasible solve is backtracked. This option has no effect  \n     if the external solver does not support the computation of an IIS. Note that if this \n     option is set, eplex will always ask for an IIS to computed for an infeasible problem, \n     even if it is immediately backtracked by the infeasible handler failing, and that the \n     option is only needed if the problem instance in the external solver is modified \n     before eplex_get_iis/4 or lp_get_iis/5 is called. \n     YesNo is one of the atoms yes or no, the default is \n    no.\n\ndemon_tolerance(RealTol, IntTol)\n    Specify how far outside a variable's range an lp-solution\n    can fall before lp_demon_setup/5 re-triggers.\n    RealTol and IntTol are floats and default to\n    0.00001 and 0.5 respectively.\n\nsos1(VarList) - deprecated, use sos1/1 constraint\n    VarList is a list of variables which the solver should\n    treat as variables of a type 1 special ordered set (SOS), i.e. at most\n    one of the variables in the set can be non-zero. This can occur multiple\n    times, for different sets of variables.\n\nsos2(VarList) - deprecated, use sos2/1 constraint\n    VarList is a list of variables which the solver should\n    treat as variables of a type 2 special ordered set (SOS), i.e. at most\n    two of the variables in the set can be non-zero. This can occur multiple\n    times, for different sets of variables.\n\npresolve(+YesNo)\n    Specify if the external solver should perform presolve for this\n    problem. With presolving, the external solver will transform the\n    problem before solving it. This can lead to significantly faster times\n    to find solutions. However, as the problem has been transformed, some\n    external solvers have restriction on accessing or changing the problem\n    state. In addition, if the solver is repeatedly called because the\n    problem is frequently modified, then presolve may not be an advantage.\n    YesNo is one of the atoms yes or no, the default is \n    determined by the global setting of presolve, which can be\n    changed via lp_set/2. The initial default is yes.\n    Note that the presolve setting cannot be changed for a problem once it\n    is set.  If the external solver supports per-problem optimizer_params, \n    their global defaults will be used for presolve(yes).\n\ntimeout(+TimeOut)\n    Set the external solver to time-out after TimeOut seconds.\n    TimeOut is a positive number. The solver will abort (in either\n    the abort or suboptimal state, depending on if a suboptimal solution\n    was found) if the optimal solution was not found within the time\n    limit. This should be used instead of setting the solver-specific\n    parameter for time-out directly. In cases where the solver expects an\n    integer for the time-out interval, the time given is rounded up to the\n    next integer value. The timeout is set by setting the external\n    solver's timeout settings, and the exact behaviour may be solver dependent.\n\nsuboptimal_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver returned a suboptimal solution (because the problem\n    was aborted). Goal would be run in place of raising the default \n    eplex_suboptimal event.\n\nunbounded_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    problem is unbounded. Goal would be run in place of raising the  \n    default eplex_unbounded event.\n\ninfeasible_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver found that the problem is infeasible. Goal would be run\n    in place of raising the default eplex_infeasible event.  Note\n    that the default and logically correct behaviour is to fail, this\n    handler is provided to allow the user to analyse the cause of the\n    infeasibility. It is recommended that the handler should also fail\n    after performing the analysis.\n\nunknown_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver was not able to determine if the problem is unbounded\n    or infeasible. Goal would be run in place of raising the default \n    eplex_unknown event.\n\nabort_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver aborted without finding any solution. Goal would be \n    run in place of raising the default eplex_abort event.\n\nuse_var_names(+YesNo)\n    Specify if variable names (set using set_var_name/2 of the \n    var_name library) should be passed to the external solver. If a \n    particular variable does not have a name when it is first passed to the\n    external solver, a default name determined by the solver would be used.\n    Note that for XPRESS-MP, there is a limit on the length of the name,\n    which can be changed between 8 and 64 in steps of 8 with the \n    parameter mpsnamelength (XPRS_MPSNAMELENGTH). Variable \n    names longer than this limit are truncated to the limit. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\npriority(+Prio)\n  Prio is the scheduling priority with which the solver gets\n  woken up.  This priority determines whether the solver is run before or\n  after other constraints. By default, if no priority is specified, the\n  default priority (0, mapped to 5 unless changed) is used. Normally, the\n  default priority should be sufficient and this option is not needed,\n  unless there is a specific need to have the external solver invoked with\n  higher or lower priority than some other constraints.\n\nmip_use_copy(+YesNo)\n    Some external solvers do not allow a MIP problem to be modified\n    once the MIP search has been started. Eplex works around this\n    problem by making a copy of the problem and solving that, so that\n    the original problem can still be modified. This can be turned off to\n    avoid the overhead of making this copy, in which case the MIP\n    problem cannot be modified. This option is used only when solving a\n    MIP problem, and the external solver does not allow a MIP problem to\n    be modified; otherwise it is ignored.\n    YesNo is one of the atoms yes or no, the default \n    is yes so that the problem can be modified.\n\nwrite_before_solve(+Format,+File)\n    This option is most useful for debugging purposes. If given, Eplex\n    will ask the external solver to dump the problem each time the problem\n    is solved. This allows the problem in an eplex_probe/2 or\n    lp_probe/3 to be dumped. As in lp_write/3,\n    Format is the format of the dumped file and File is\n    its name. Note that the problem is dumped each time the external solver\n    is invoked if the problem has cutpool constraints, where there may be\n    multiple invocations of the solver per solver call. \n    The default without this option is that the problem would not be dumped.\n\npost_equality_when_unified(+YesNo)\n    This option determines if an equality constraint between two\n    variables will be posted to the solver when these variables are\n    unified. Setting YesNo to no means that the constraint \n    will not be posted. Note that this can lead to the\n    solver's problem becoming inconsistent with ECLiPSe's. \n    YesNo is one of the atoms yes or no, the default is \n    yes.\n\nsync_bounds(+YesNo)\n    This option determines if the bounds of the problems variables are\n    synchronised with other solvers (i.e. the generic bounds are obtained\n    with get_var_bounds/3 and then passed to the external solver) before\n    the external solver is invoked. This was always done for previous\n    non-standalone version of eplex. For standalone eplex, as the bounds\n    are communicated directly to the external solver, the synchronisation\n    of variable bounds is not needed unless the user is using eplex\n    co-operatively with other solvers (e.g. ic). Even in such cases, it may\n    be more efficient to communicate these bounds changes by explicitly\n    programming it, especially if the problem has many variables and bounds\n    changes happen only to a few of the variables. Setting YesNo\n    to yes should increase compatibility with previous code (but note that\n    previous eplex obtained the bounds from a specific bounds keeper like\n    ic rather than the generic bounds).  YesNo is one of the atoms\n    yes or no, the default is no.\n\nTriggerModes can be a list of the following specifiers:\n\n  inst\n  re-trigger if a problem variable gets instantiated.\n\n  ModuleName:Index\n  re-trigger when the  suspension list given by ModuleName:Index is woken\n  for any of the problem variables.\n  The format for ModuleName:Index is the same as for specifying\n  the suspension list in suspend/3,4.\n\n  deviating_inst\n  re-trigger if a problem variable gets instantiated\n      to a value that differs from its lp-solution more than a tolerance.\n\n  bounds\n  re-trigger each time a variable bound for the solver instance changes.\n\n  deviating_bounds\n  re-trigger each time a variable's solver instance bound changes\n      such that its lp-solution gets excluded more than a tolerance.\n\n  new_constraint\n  re-trigger each time a new (arithmetic or integral) constraint is\n      added to the solver instance. Note that adding integral constraint\n      on new problem variables, or adding bounds constraint, or adding \n      constraints to the cutpool will *not* re-trigger.\n\n  trigger(Atom)\n  re-trigger each time the symbolic trigger Atom is pulled by invoking \n      schedule_suspensions/1\n\n  pre(Goal)\n  an additional condition to be used together with other triggers. When \n      the demon is triggered, it first executes PreGoal. Only if \n      that succeeds, does the appropriate external solver get invoked.\n      This provides a way of reducing the number of (possibly expensive)\n      solver invocations when given preconditions are not met.\n\n  post(Goal)\n  this is not a trigger condition, but specifies a goal to be executed\n      after solver success, but before the Cost variable gets\n      constrained. It is intended as a hook for exporting solution\n      information, e.g. copying solutions from the solver state into\n      variable attributes (eg. tentative value), or computing weights for\n      labelling heuristics from the solver state.  \n  suspension(Susp)\n  this is not a trigger condition, but instead is used to access the \n      demon used to trigger the solver. Susp is instantiated to\n      the suspension that triggers the solver: by waking Susp, the solver\n      is triggered. Susp is a demon in that it stays around after being\n      woken. Accessing Susp allows the user to specify arbitrary conditions \n      for triggering the solver.\n\n  The tolerances mentioned can be specified in lp_setup/4 or lp_set/3\n  as demon_tolerance.\n\n  If several trigger conditions are specified, then any of them will trigger\n  the solver.\n\n  When a solver demon runs frequently on relatively small problems,\n  it can be important for efficiency to switch off the presolve option\n  to reduce overheads.\n\nSee Also\n   $= / 2, $=< / 2, $>= / 2, =:= / 2, >= / 2, =< / 2, $:: / 2, :: / 2, integers / 1, reals / 1, eplex_solver_setup / 1, eplex_probe / 2, eplex_solve / 1, eplex_get / 2, eplex_var_get / 3, eplex_get_iis / 4, lp_demon_setup / 5, lp_setup / 4"},"eplex:eplex_var_get/3":{"prefix":"eplex_var_get","body":"eplex_var_get(${1:Var}, ${2:What}, ${3:Value})$4\n$0","description":"eplex_var_get(+Var, ++What, -Value)\nEplexInstance:eplex_var_get(+Var, ++What, -Value)\n\n   Obtain information for an individual solver problem variable Var.\n\nArguments\n   Var    A solver problem variable for solver associated with EplexInstance\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(eplex)\n\nDescription\n\n   Retrieve information about the (logically) most recent solver state and\n   results related to a particular variable, for the eplex instance\n   EplexInstance.  Fails if no solution has been computed yet.  What can\n   take one of the following values:\n\n    solution\n    Returns the floating-point solution for variable Var.\n\n    typed_solution\n    Returns the properly typed (integer or float) solution for variable\n    Var, depending on if the variable was constrained to be an integer\n    or not for EplexInstance.\n\n    reduced_cost\n    Returns the reduced cost for variable Var. If the problem is a MIP, \n    then depending on the external solver, this is either unavailable\n    or is the value at the optimal LP node. \n    Note that reduced cost is defined as the minimal amount the\n    objective value will be changed by if the variable's value is\n    increased by 1 from its solution value.\n\n    type\n    Returns the type the variable Var is constrained to in\n    EplexInstance. Possible values are integer or real.\n\n  Note that solution or reduced_cost can only be retrieved\n  when previously requested in the option list of eplex_solver_setup/4,\n  lp_demon_setup/5, lp_setup/4 or with lp_set/3.\n\nExceptions\n     6 --- What is not a valid value.\n     6 --- Var is not a problem variable for EplexInstance.\n     6 --- What is unavailable; the information was not requested at solver setup.\n    40 --- Solver state had been previously destroyed."},"eplex:eplex_var_get_bounds/3":{"prefix":"eplex_var_get_bounds","body":"eplex_var_get_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"eplex_var_get_bounds(+Var, -Lo, -Hi)\nEplexInstance:eplex_var_get_bounds(+Var, -Lo, -Hi)\n\n   Returns the bounds stored in the solver state for Var in eplex instance EplexInstance.\n\nArguments\n   Var    A problem variable for EplexInstance\n   Lo    Lower bound for Var\n   Hi    Upper bound for Var\n\nType\n   library(eplex)\n\nDescription\n\n    \n    Returns the numeric bounds for Var stored in the solver state\n    associated with the eplex instance EplexInstance. The bounds are\n    returned as floats. Var must be an existing problem variable for\n    EplexInstance. \n\nResatisfiable\n   no\n\nExceptions\n     5 --- EplexInstance does not a solver setup for it.\n     6 --- Var is not a problem variable for EplexInstance.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   lp_var_get_bounds / 4, eplex_solver_setup / 1, eplex_solver_setup / 4"},"eplex:eplex_verify_solution/2":{"prefix":"eplex_verify_solution","body":"eplex_verify_solution(${1:ViolatedCstrs}, ${2:ViolatedVars})$3\n$0","description":"eplex_verify_solution(-ViolatedCstrs,-ViolatedVars)\nEplexInstance:eplex_verify_solution(-ViolatedCstrs,-ViolatedVars)\n\n   Verifies the current solution for the problem associated with EplexInstance.\n\nArguments\n   ViolatedCstrs       List of violated Constraints.\n   ViolatedVars    List of violated variables.\n\nType\n   library(eplex)\n\nDescription\n\n This predicate checks the current solution for the problem associated with\n EplexInstance. It verifies that all the constraints are satisfied by the\n solution values for the problem variables, and that the solution values do\n not violate their bounds, and the values are integral for integer variables.\n Violated Constraints are returned in ViolatedCstrs, and violated variables in \n ViolatedVars.\n\n Under normal circumstances, if the external solver produces a solution, it \n should produce no violations. Any violation probably indicates a problem\n with the external solver. However, because the external solver is a complex\n piece of software and may contain problems, it is a good idea to verify the\n solution, and this predicate provides an easy way to do this.\n\n Each violation is returned as a structure of the following form:\n   vio(type,delta,idx,item) \n where\n\n       type:   the type of violation:\n    \n    norm:   the violated item is a normal constraint.\n    condcp: the violated item is an active cutpool constraint.\n    int:    the violated item is an integer variable whose \n    solution value is not integral.    \n    lower:  the violated item is a variable whose solution value\n    is less than the lower bound.    \n    upper:  the violated item is a variable whose solution value\n    is greater than the upper bound.    \n    \n    delta: the absolute value of the violation. \n    idx:   the index used by the external solver for the item (most\n    likely the row/column number in the problem matrix). This \n    is needed to locate the violation in the solver for reporting\n    or investigating the problem.\n    item:  the violated item, i.e. the constraint or variable.\n\n For checking of constraints, a fresh copy of the constraint is made with\n the solution values, as this avoids binding the original variables. Any active\n cutpool constraints in the (logically) last solve of the problem are checked,\n along with the normal constraints. A constraint is considered to be  violated\n if the difference between the sum of the left-hand side and the right-hand side \n for the constraint is greater than the feasibility tolerance (feasibility_tol)\n parameter for the instance. For variables, a bound is considered violated if\n the solution value falls outside the bound by more than feasibility tolerance,\n and integrality is considered to be violated if the fractional part of the\n soltuion is greater than the integrality parameter for the instance. \n\nFail Conditions\n   no solution values are available."},"eplex:eplex_write/2":{"prefix":"eplex_write","body":"eplex_write(${1:Format}, ${2:File})$3\n$0","description":"eplex_write(++Format,++File)\nEplexInstance:eplex_write(++Format,++File)\n\n   Write the problem in the solver for eplex instance  EplexInstance to a file.\n\nArguments\n   Format    lp or mps\n   File    File name\n\nType\n   library(eplex)\n\nDescription\n\n   Write the problem in the solver for EplexInstance to a file. The set of\n   supported formats depends on the actual external solver which is used.\n   All solvers support the mps format. Some solvers on some operating\n   system platforms may change or append a suffix to the filename. \n   Note that the mps format does not specify the sense (min or max) of the\n   objective function. Minimisation is also assumed for external solvers\n   that ignore the optimisation direction of the lp file (e.g. Xpress).\n   Note also that any active cutpool constraints in the problem will be \n   included in the dump, even though they could be left out of the problem\n   that the external solver actually solves.\n\nExceptions\n     5 --- EplexInstance does not a solver setup for it.\n    40 --- Solver state had been previously destroyed.\n\nSee Also\n   eplex_read / 2, lp_write / 3, lp_setup / 4"},"eplex:get_changeable_value/2":{"prefix":"get_changeable_value","body":"get_changeable_value(${1:Var}, ${2:Val})$3\n$0","description":"get_changeable_value(?Var, -Val)\nEplexInstance:get_changeable_value(?Var, -Val)\n\n   Interface predicate to access the <EM>changeable</EM> value for this variable.\n\nArguments\n   Var    A solver problem variable for solver associated with EplexInstance\n   Val    The typed_solution value for this variable\n\nType\n   library(eplex)"},"eplex:instantiation_deviates/1":{"prefix":"instantiation_deviates","body":"instantiation_deviates(${1:Handle})$2\n$0","description":"instantiation_deviates(+Handle)\n\n   A trigger goal for lp_demon_setup/5.\n\nArguments\n   Handle    Handle to a solver state\n\nType\n   library(eplex)\n\nDescription\n\n  This is intended as a useful pre(Goal) for lp_demon_setup/5 in connection\n  with the inst trigger mode.  It succeeds if any of the variables\n  originally involved in Handle have been instantiated to a value that is\n  not within +/- tolerance from the latest simplex solution for that\n  variable.  The admissible tolerances can be specified in lp_setup/4 or\n  lp_set/3 as demon_tolerance.\n\nSee Also\n   lp_demon_setup / 5"},"eplex:integers/1":{"prefix":"integers","body":"integers(${1:Vars})$2\n$0","description":"integers(?Vars)\nEplexInstance:integers(?Vars)\n\n   Constrains Vars to integers for eplex instance EplexInstance.\n\nArguments\n   Vars    Variable or number, or a list or submatrix of variables/numbers\n\nType\n   library(eplex)\n\nDescription\n\tConstrains list Vars to integers in the eplex instance\n    EplexInstance. If a variable in Vars is not already a problem\n    variable for EplexInstance, it will be added as a new problem\n    variable. The external solver will then take the integrality into\n    account, i.e. to solve a MIP/MIQP rather than a relaxed LP/QP\n    problem.  Unlike integers/1 constraints from other solvers, the\n    variables are not constrained to be integer type at the ECLiPSe\n    level. However, when a typed_solution is retrieved (e.g. via\n    eplex_var_get/3), this will be rounded to the nearest integer.\n\t\n\tNote that even when problem variables have been declared as\n    integers in other solvers (ic or other external solver\n    states), if the integrality constraint is not made known to this\n    EplexInstance, any invocation of the eplex external solver (e.g. via\n    eplex_solve/1) will only solve a continuous relaxation.\n\t\n\t\n\nSee Also\n   ic_kernel : integers / 1, fd : integers / 1, bfs : integers / 1, ic : integers / 1, suspend : integers / 1, gfd : integers / 1, reals / 1, :: / 2"},"eplex:lp_add/3":{"prefix":"lp_add","body":"lp_add(${1:Handle}, ${2:NewNormCons}, ${3:NewIntegers})$4\n$0","description":"lp_add(+Handle, +NewNormCons, +NewIntegers)\n\n   Add new constraints to a solver state Handle.\n\nArguments\n   Handle    Handle to a solver state\n   NewNormCons    List of new normalised constraints\n   NewIntegers    List of variables to be considered as integers\n\nType\n   library(eplex)\n\nDescription\n\n  Add new normalised constraints (with possibly new variables) to a solver.\n  This is a lower level predicate called by lp_add_constraints/3 and when\n  constraints are collected from the constraints pool by the solver. The\n  constraints are not simplified and must already be normalised, so\n  constraints which would otherwise be simplified away by the higher level\n  predicates can be added to the external solver. The constraints will be\n  removed on backtracking. Note that the solver will not be invoked directly.\n\n  Note that variables in NewIntegers can be any problem variables. In\n  previous versions of ECLiPSe, there was a restriction that the variables\n  be new problem variables; this restriction has been removed.\n\nResatisfiable\n   no\n\nSee Also\n   lp_setup / 4"},"eplex:lp_add_columns/2":{"prefix":"lp_add_columns","body":"lp_add_columns(${1:Handle}, ${2:Columns})$3\n$0","description":"lp_add_columns(+Handle, +Columns)\n\n   Add new variables as columns to the external solver's matrix.\n\nArguments\n   Handle    Handle to a solver state\n   Columns    A list of Variable:ColumnSpecification pairs.\n\nType\n   library(eplex)\n\nDescription\n\n   Add new variables as columns to the external solver's matrix. This \n   allows non-zero coefficients for the objective and existing constraints\n   to be specified for these variables. \n\n   Each column is specified as a Variable:ColumnSpecification pair.\n   Variable is the variable that is being added to the problem, and\n   ColumnSpecification is the specification for the non-zero coefficients\n   for the column representing the variable in the external solver matrix:\n   this is a list of Index:Coefficient pairs. Where index is the index of an\n   existing constraint (obtained when the constraint was added using\n   lp_add_constraints/4), and coefficient is its coefficient.\n\n   The ColumnSpecification list can optionally start with a special element\n   'obj':Coeff, in which case the coefficient is the objective coefficient\n   for the column (otherwise zero).  This can be optionally followed by two\n   entries of the form 'lo':Lwb,'hi':Upb, which specify initial lower and\n   upper bound on the column variable (otherwise unbounded).  Each\n   constraint coefficient should only occur once. Any index not specified\n   is given a zero value.\n\n   Note that lp_add_columns/2 essentially modifies the problem represented\n   by Handle. This is not compatible with the view of the problem as a\n   compound constraint, and therefore, lp_add_columns/2 can only be used\n   for problems that are not eplex instances, and/or have no trigger\n   conditions for triggering the external solver. \n\n  \n\nExceptions\n     4 --- Handle or Columns are uninstantiated.\n     5 --- A Variable in Columns is already a problem variable for problem represented by Handle.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n   abort --- Handle is an eplex instance problem, or trigger conditions have been specified."},"eplex:lp_add_constraints/3":{"prefix":"lp_add_constraints","body":"lp_add_constraints(${1:Handle}, ${2:Constraints}, ${3:Integers})$4\n$0","description":"lp_add_constraints(+Handle, +Constraints, ++Integers)\n\n   Add new constraints to the solver Handle, possibly triggering it.\n\nArguments\n   Handle    Handle to a solver state\n   Constraints    A (possibly empty) list of equality or inequality constraints\n   Integers    A (possibly empty) list of variables to be considered as integers in the problem\n\nType\n   library(eplex)\n\nDescription\n\n  Add new constraints (with possibly new variables) to a solver.\n  NewIntegers is a list of variables that the external solver should\n  consider as integers  The new constraints will be taken into\n  account the next time the solver is run: if the new_constraint option of\n  lp_demon_setup was turned on, then the solver will be invoked after the\n  adding of the constraints, unless they are already satisfied.  The \n  constraints will be removed on backtracking.\n\n  The constraints are normalised and simplified before being passed to\n  the external solver. If any constraint is ground, they are tested for\n  consistency.\n\n  The constraints can be linear equalities and inequalities, sos/1 and\n  sos2/1 constraints, and =&ge;/2 indicator constraints.\n\n  Note that variables in NewIntegers can be any problem variables. In\n  previous versions of ECLiPSe, there was a restriction that the variables\n  be new problem variables; this restriction has been removed.\n\n \n\nFail Conditions\n   Any ground (no variable) or bound constraints (one variable) is self-inconsistent.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Handle, Constraints or Integers uninstantiated.\n     5 --- Some constraint in Constraints is non-linear.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   lp_demon_setup / 5, lp_add / 3, lp_add_constraints / 4, eplex_add_constraints / 2, $= / 2, $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2, sos1 / 1, sos2 / 1, => / 2"},"eplex:lp_add_constraints/4":{"prefix":"lp_add_constraints","body":"lp_add_constraints(${1:Handle}, ${2:Constraints}, ${3:Integers}, ${4:Indices})$5\n$0","description":"lp_add_constraints(+Handle, +Constraints, ++Integers, -Indices)\n\n   Add new expandable constraints to the demon solver Handle.\n\nArguments\n   Handle    Handle to a solver state\n   Constraints    A (possibly empty) list of expandablelinear equality or inequality constraints\n   Integers    A (possibly empty) list of problem variables to be considered as integers\n   Indices    Indices for the constraints in Constraints\n\nType\n   library(eplex)\n\nDescription\n\n  Add new expandable constraints (with possibly new variables) to a solver.\n  An expandable constraint can be expanded when new variables are added to\n  the problem. These constraints are in the form of having a constant on\n  the right-hand side, and coefficients for the problem variables on the\n  left. When new variables are added (via lp_add_columns/2), the\n  coefficients for these variables can be given for the expandable\n  constraints. Note that the constraints can only be expanded if there are\n  no trigger conditions (i.e. the problem must be solved explicitly), or if\n  the problem is not associated with an eplex instance. Otherwise, the\n  added constraints are treated as normal (non-expandable) constraints.\n\n  Constraints is a list of expandable constraints.  NewIntegers is a list\n  of variables that the external solver should consider as integers,\n  Indices is a list of the indices for the added constraints. It is\n  returned by the predicate, and has the same length as Constraints. Each\n  element in Indices is the index for the constraint in Constraints at the\n  same position in the list. This index is used to refer to the constraint\n  in lp_add_columns/2.\n\n  Operationally lp_add_constraints/4 behaves like lp_add_constraints/3,\n  except that it never trigger the solver as a demon:\n  The new constraints will be taken into account the next time the solver\n  is run, and  removed on backtracking. The constraints are normalised \n  before being passed to the external solver. Unlike lp_add_constraints/3,\n  they are not simplified, and no consistency checks are performed. If any\n  of the constraints are ground, a type error is raised. \n\n  Note that variables in NewIntegers can be any problem variables.\n \n\nResatisfiable\n   no\n\nExceptions\n     4 --- Handle, Constraints or Integers uninstantiated.\n     5 --- Some constraint in Constraints is ground.\n     5 --- Some constraint in Constraints is non-linear.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   lp_add_constraints / 3, lp_demon_setup / 5, lp_add / 3, lp_add_columns / 2, $= / 2, $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2"},"eplex:lp_add_cutpool_constraints/4":{"prefix":"lp_add_cutpool_constraints","body":"lp_add_cutpool_constraints(${1:Handle}, ${2:Constraints}, ${3:Options}, ${4:Indices})$5\n$0","description":"lp_add_cutpool_constraints(+Handle, +Constraints, +Options, -Indices)\n\n   Add constraints to the cutpool associated  with solver state Handle.\n\nArguments\n   Handle    Handle to a solver state\n   Constraints    A (possibly empty) list of equality or inequality constraints\n   Options    A (possibly empty) list of Option:Value pairs\n   Indices    Indices for the constraints in CstrSpecs\n\nType\n   library(eplex)\n\nDescription\n\n  Add constraints to the cutpool associated with solver state Handle.\n  Unlike normal constraints, cutpool constraints are not added directly to\n  the problem, and are *NOT* removed on backtracking. Logically, cutpool\n  constraints are valid for all solves of the problem, regardless of when\n  a constraint is added to the pool -- they are `globally valid'. The \n  purpose of the cutpool is to give the user more flexibility on how\n  constraints are used by the external solver.\n\n  Constraints is the list of constraints to be added to the\n  cutpool. As they are not removed on backtracking, they can only involve\n  variables that are present at problem setup. Otherwise, an out of range\n  error is raised. Variables can be created for a problem before setup by\n  posting normal constraints involving the variables, in particular, using\n  reals/1. The constraints are normalised before being passed to the\n  external solver.  They are not simplified, and no consistency checks\n  are performed. If any of the constraints are ground, a type error is\n  raised. Instantiated variables are treated as constants (i.e. the value\n  they are instantiated to when the predicate is called), even when the\n  execution backtracks to a point before the instantiations.\n \n  Options is a possibly empty list of Option:Value pairs specifying \n  the options. Valid options are:\n\nadd_initially\n   specifies if the constraints should be added to the problem matrix\n   before the external solver is invoked. Valid values are 1 for\n   adding the constraints before solving, and 0 for not adding.\n   The default is 1.\nactive\n   specifies if the constraints should be active. Valid values are \n   1 for active, and 0 for non-active. The default is 1.\ngroup\n   specifies the cutpool constraints group that the constraints will be\n   added to. Value must be an existing group name for the cutpool,\n   i.e. the default group, or a group name previously created with \n   the cutpool_group option of lp_set/3. The default is the default group\n   name ([]).\n\n  Operationally, the cutpool constraints are taken into account when the\n  external solver is invoked, and the user can specify how they are taken\n  into account by setting the status of these constraints: by default,\n  cutpool constraints are active, and are taken into account during solver\n  invocation: none of these constraints will be violated in the solution\n  produced: they are either part of the problem matrix solved by the\n  external solver, or they have been explicitly checked for non-violation. \n  This is done as follows: active cutpool constraints that are labelled as \n  `add_initially' (the default) are added to the problem matrix, and the \n  external solver is invoked. When a solution is produced, the unadded\n  active cutpool constraints are checked to see if they are violated. Any\n  violated constraints are added to the problem matrix and the problem is\n  resolved by the external solver. This is repeated until there are no\n  violated constraints. This approach allows the user to leave out\n  constraints that might be expensive (i.e. slow down the solving) unless\n  they usefully constrain the problem. \n\n  Checking for violations require the solution values of the problem\n  variables. Thus, if the solution option is turned off and no\n  solution value is available, and there are unadded active cutpool \n  constraints, an out of range error would be raised when the solver tries\n  to solve the problem.\n\n  The violation checking is only done if the external solver produces a \n  solution with solution values. If the problem is unbounded (or unknown,\n  i.e. the solver cannot determine if the problem is infeasible or\n  unbounded), then all the active cutpool constraints are added to the\n  problem without checking for violations, and the problem is resolved once\n  more. This is done because adding constraints to the problem can make the\n  problem become bounded.\n\n  The user can change a cutpool constraint's status to non-active, in which\n  case it is neither checked for violations nor added to the problem.\n  For logical  correctness, the user should only make a constraint non-active\n  if it is certain that the constraint will not be violated, e.g. if it is\n  superceded by a stronger constraint. \n\n  Cutpool constraints are organised into named groups, allowing multiple\n  constraints to be referred to as a unit, e.g. with the cutpool_info\n  option of lp_get/3.\n\n  Note that as the constraints are added to the cutpool, and not to the\n  problem directly, this is not considered as adding new constraints, and\n  will not cause the solver to trigger with the new_constraint trigger\n  condition set.\n  \n\nResatisfiable\n   no\n\nExceptions\n     6 --- Constraints contains variable(s) that is not in the problem during setup.\n     5 --- A constraint in Constraints is ground.\n\nSee Also\n   lp_get / 3, lp_set / 3"},"eplex:lp_add_vars/2":{"prefix":"lp_add_vars","body":"lp_add_vars(${1:Handle}, ${2:Vars})$3\n$0","description":"lp_add_vars(+Handle, +Vars)\n\n   Declare Vars to be problem variables for the solver state Handle\n\nArguments\n   Handle    Handle to a solver state\n   Vars    A list of variables or numbers\n\nType\n   library(eplex)\n\nDescription\n\n   Declares variables in Vars as problem variables for the solver state\n   represented by Handle. Any of the variables that are not existing \n   problem variables for Handle are added to the problem. The new\n   variables' bounds are constrained to -infinity..infinity (infinity as \n   defined by the external solver).\n\nFail Conditions\n   Vars contain elements which are neither variables or numbers.\n\nSee Also\n   lp_setup / 4, lp_demon_setup / 5"},"eplex:lp_cleanup/1":{"prefix":"lp_cleanup","body":"lp_cleanup(${1:Handle})$2\n$0","description":"lp_cleanup(+Handle)\n\n   Destroy the specified solver Handle and clean up.\n\nArguments\n   Handle    Handle to a solver state\n\nType\n   library(eplex)\n\nDescription\n\n    Destroy the specified solver, free all memory, etc.  Note that ECLiPSe\n    will normally do the cleanup automatically, for instance when execution\n    fails across the solver setup, or when a solver handle gets garbage\n    collected.\n\n    This predicate should be used with caution as the information from the\n    solver state will no longer be available. In particular, if the program\n    backtracks to a point between the problem set up and clean up,\n    accessing the solver state directly or indirectly (e.g. unifying a\n    problem variable) will result in a stale handle error."},"eplex:lp_demon_setup/5":{"prefix":"lp_demon_setup","body":"lp_demon_setup(${1:Objective}, ${2:Cost}, ${3:ListOfOptions}, ${4:TriggerModes}, ${5:Handle})$6\n$0","description":"lp_demon_setup(+Objective, ?Cost, ++ListOfOptions, ++TriggerModes, -Handle)\n\n   Setup the external solver as a simplex demon.\n\nArguments\n   Objective    Objective function: min(CostExpr) or max(CostExpr)\n   Cost    Variable bounded by the optimal solution\n   ListOfOptions       List of solver options\n   TriggerModes    List of conditions for re-triggering solver\n   Handle    handle to solver state\n\nType\n   library(eplex)\n\nDescription\n\n  Setup the external solver as a simplex demon. A simplex demon collects\n  linear constraints and re-solves the problem whenever the triggering\n  conditions in TriggerModes are met.\n\n  Declaratively, this can be seen as a compound constraint representing all\n  the individual linear constraints that have been set so far and are going\n  to be set up later.  Operationally, the delayed constraints are collected\n  and an external solver is set up (as with lp_setup/4).  Then the problem\n  is solved once initially (if initial_solve option is yes) and a\n  delayed goal lp_demon is set up which will re-trigger the solver when \n  certain  conditions are met.\n\n  CostExpr is a linear cost expression (or quadratic, if supported\n  by the external solver).\n\n  Handle refers to the created solver state (as in lp_setup/4 or\n  lp_read/3 described below). It can be used to access and modify the state\n  of the solver, retrieve solution information etc. \n\n  Unlike with lp_solve/2, Cost will not be instantiated to a\n  solution's cost, but only be bounded by the best-bound on cost:\n  For a minimisation problem, each solution's best-bound becomes a lower bound,\n  for maximisation an upper bound on Cost.  This technique allows for\n  repeated re-solving with reduced bounds or added constraints. Note that\n  Cost is not automatically made a problem variable (it can be a problem\n  variable if there are constraints that involve it), and thus may not have\n  bounds associated with in. In order for the bounds information not to be\n  lost, some bounds should be given to Cost (e.g. making it a\n  problem variable (but this might introduce unnecessary self-waking on\n  bounds change), or via another solver with bounds (e.g. ic)).\n\n  ListOfOptions is a list of solver options as described for\n  lp_setup/4. In addition, the following extra options are also available:\n   \n\ncollect_from(+Pool)\n    Specifies if this solver state should be associated with an eplex\n    instance. If Pool is none, then the solver is not associated\n    with an eplex instance. If Pool is pool(Instance), where\n    Instance is the (atomic) name of an existing eplex instance, then this\n    eplex instance would be associated with the solver state, i.e. when the\n    solver is invoked, it will collect constraints posted to\n    Instance.  Note that Instance must not be associated\n    with any other solver state already.\n    The default value for Pool is pool(eplex) (for backward\n    compatibility).\n\ninitial_solve(+YesNo)\n    Specifies if an initial solve (call to the external solver) should\n    be performed immediately after problem setup.\n    YesNo is one of the atoms yes or no, the default is \n    yes if any trigger condition is specified in TriggerModes, \n    no if no trigger condition is specified.\n\npriority(+Prio)\n    Prio is the scheduling priority with which the solver gets\n    woken up.  This priority determines whether the solver is run before or\n    after other constraints. By default, if no priority is specified, the\n    default priority (0, mapped to 5 unless changed) is used. Normally, the\n    default priority should be sufficient and this option is not needed,\n    unless there is a specific need to have the external solver invoked with\n    higher or lower priority than some other constraints.\n\n   \n\n  TriggerModes specifies under which conditions the solver demon\n  will be re-triggered. It can be a list of the following specifiers\n\n  inst\n  re-trigger if a problem variable gets instantiated.\n\n  ModuleName:Index\n  re-trigger when the  suspension list given by ModuleName:Index is woken\n  for any of the problem variables.\n  The format for ModuleName:Index is the same as for specifying\n  the suspension list in suspend/3,4.\n\n  deviating_inst\n  re-trigger if a problem variable gets instantiated\n      to a value that differs from its lp-solution more than a tolerance.\n\n  bounds\n  re-trigger each time a variable bound for the solver instance changes.\n\n  deviating_bounds\n  re-trigger each time a variable's solver instance bound changes\n      such that its lp-solution gets excluded more than a tolerance.\n\n  new_constraint\n  re-trigger each time a new (arithmetic or integral) constraint is\n      added to the solver instance. Note that adding integral constraint\n      on new problem variables, or adding bounds constraint, or adding \n      constraints to the cutpool will *not* re-trigger.\n\n  trigger(Atom)\n  re-trigger each time the symbolic trigger Atom is pulled by invoking \n      schedule_suspensions/1\n\n  pre(Goal)\n  an additional condition to be used together with other triggers. When \n      the demon is triggered, it first executes PreGoal. Only if \n      that succeeds, does the appropriate external solver get invoked.\n      This provides a way of reducing the number of (possibly expensive)\n      solver invocations when given preconditions are not met.\n\n  post(Goal)\n  this is not a trigger condition, but specifies a goal to be executed\n      after solver success, but before the Cost variable gets\n      constrained. It is intended as a hook for exporting solution\n      information, e.g. copying solutions from the solver state into\n      variable attributes (eg. tentative value), or computing weights for\n      labelling heuristics from the solver state.  \n  suspension(Susp)\n  this is not a trigger condition, but instead is used to access the \n      demon used to trigger the solver. Susp is instantiated to\n      the suspension that triggers the solver: by waking Susp, the solver\n      is triggered. Susp is a demon in that it stays around after being\n      woken. Accessing Susp allows the user to specify arbitrary conditions \n      for triggering the solver.\n\n  The tolerances mentioned can be specified in lp_setup/4 or lp_set/3\n  as demon_tolerance.\n\n  If several trigger conditions are specified, then any of them will trigger\n  the solver.\n\n  When a solver demon runs frequently on relatively small problems,\n  it can be important for efficiency to switch off the presolve option\n  to reduce overheads.\n\n  The solver demon calls lp_solve/2 when it wakes up. See the description\n  of lp_solve/2 for the handling of exceptions.\n\n  Note: Some external solvers need to write temporary files when they\n  are solving a problem. These are written to the temporary directory\n  specified in ECLiPSe's tmp_dir setting (get_flag/2, set_flag/2).\n\nExamples\n      Some common invocations patterns for this predicate are the following.\n   The first triggers the solver only on instantiation of variables to\n   values that don't fit with the simplex solution:\n\n      lp_demon_setup(min(Expr), C, [], [deviating_inst], H)\n\nSee Also\n   lp_solve / 2, lp_set / 3, lp_setup / 4, lp_get_iis / 5, solution_out_of_range / 1, schedule_suspensions / 1, library(constraint_pools)"},"eplex:lp_get/2":{"prefix":"lp_get","body":"lp_get(${1:ParamName}, ${2:Value})$3\n$0","description":"lp_get(++ParamName, ?Value)\n\n   Obtain the value of a global parameter.\n\nArguments\n   ParamName    Atom or structure\n   Value    Variable, integer, float or atom\n\nType\n   library(eplex)\n\nDescription\n    Eplex has a number of global (i.e. not specific to a\n    particular problem) parameters. These can be queried using this \n    predicate.\n\n    has_indicator_constraints\n\tReturns 'yes' if the solver supports =&ge;/2 indicator constraints,\n\telse 'no'.\n    has_miqp\n\tReturns 'yes' if the solver supports mixed integer problems\n\twith quadratic objectives, else 'no'.\n    has_qp\n\tReturns 'yes' if the solver supports quadratic objectives,\n\telse 'no'.\n    optimizer\n\tReturns the name of the external solver, currently\n\t'cplex', 'xpress', 'osi' or gurobi.\n    optimizer_version\n\tReturns an integer derived from the version of the\n\texternal solver (for osi, the version is the actual solvers\n    used, including any significant third-party packages such as \n    sparse matrix ordering packages required by the barrier solver)\n    presolve\n\tReturns the default presolve setting for solver setup, i.e. the\n    presolve setting that a solver state would be given if it was not\n    directly specified during setup. A value of 0 disables presolving.\n\tA value of 1 either enables presolving (for external solvers that\n\thave only global parameters), or uses the default optimizer_param\n\tsettings (for external solvers with per-problem parameters).\n    timeout\n    Returns the default time-out setting that a solver state would\n    be given if it was not directly specified during setup. Value is\n    0 if there is no time-out.\n    optimizer_param(Param)\n    Get the Value of the external solver's parameter Param.\n    The exact behaviour and available parameters are dependent on the \n    external solver: if the external solver has only problem specific \n    parameters (e.g. XPRESS-MP 13 and later), this gets the default \n    setting that would be used for new problems; if the external solver\n    has global parameters, this gets the global value for the parameter.\n    If Param is not a valid parameter for the solver, an out of range \n    error is raised. See lp_get/3 for more details on the parameters. \n\nModes and Determinism\n   lp_get(++, -)\n   lp_get(++, +)\n\nSee Also\n   lp_set / 2"},"eplex:lp_get_license/0":{"prefix":"lp_get_license","body":"lp_get_license","description":"lp_get_license\n\n   Get a runtime license token for the external solver.\n\nType\n   library(eplex)\n\nDescription\n    \tThe eplex-library interfaces to an external simplex/MIP solver\n\twhich might require a license to run (e.g. CPLEX, XPRESS-MP, Gurobi).\n\tWhen the eplex-library is loaded, it tries to obtain a license\n\timmediately.  If this is not possible, for example because the\n\tlicense pool is temporarily empty, a warning is printed. The\n\tapplication program should then call lp_get_license/0 later\n\tto obtain a license before any eplex functionality is used.\n\tIf a license is successfully obtained or already held,\n\tlp_get_license succeeds, otherwise it fails.\n    \n    \tThis predicate uses information from the file eplex_lic_info.ecl\n\tin the ECLiPSe library directory, or solver specific environment\n\tvariable settings to locate the licensing information.\n    \n\nFail Conditions\n   Fails if no license can (currently) be obtained\n\nSee Also\n   lp_get_license / 2, lp_release_license / 0"},"eplex:lp_get/3":{"prefix":"lp_get","body":"lp_get(${1:Handle}, ${2:ParamName}, ${3:Value})$4\n$0","description":"lp_get(+Handle, ++ParamName, -Value)\n\n   Retrieve information about solver state and results for solver state Handle.\n\nArguments\n   Handle    Handle to an existing solver state\n   ParamName    Name of parameter (atom or structure)\n   Value    Returned value for ParamName\n\nType\n   library(eplex)\n\nDescription\n\n   Retrieve information about solver state and results for the (logically) \n   most recent solved solver state represented by Handle. \n   ParamName is the same as that for eplex_get/2, which retrieves \n   the same information via the EplexInstance.\n   It can  be one of:\n\n  \n     vars\n     Returns a term ''(X1,...,Xn) whose arity is the number of\n    variables involved in the solver's constraint set, and whose\n    arguments are these variables.\n\n     ints\n     Returns a list [Xi1,...,Xik] which is the subset of the problem\n    variables that the solver considers to be integers.\n\n     constraints_norm\n     Returns a list of the problem constraints (excluding any cutpool\n    constraints) in normalised form.  They may be simplified with\n    respect to the originals that were passed to the problem.\n\n     constraints\n     Returns a list of the problem constraints (excluding any cutpool\n    constraints) in denormalised (readable) form.  They may be\n    simplified with respect to the originals that were passed to the\n    problem.\n\n     objective\n     Returns a term min(E) or max(E), representing objective function\n    and optimisation direction. E is a linear expression: any\n    quadratic components will not be retrieved.\n\n     num_cols\n     Returns the number of columns (i.e. variables) in the matrix of the\n     solver state.\n\n     num_rows\n     Returns the number of rows (i.e. constraints) in the matrix of the\n     solver state.\n\n     num_nonzeros\n     Returns the number of non-zero coefficients in the matrix of the\n     solver state.\n\n     num_ints\n     Returns the number of columns (i.e. variables) constrained to be\n     integers in the matrix of the solver state.\n\n     num_quads\n     Returns the number of non-zero coefficients in the quadratic\n     coefficient matrix (Q-matrix) of the solver state.\n\n     method\n     Returns the method that is specified to solve the problem. If an\n     auxiliary  method can be given for the method, and this auxiliary\n     method is not default, the method will be returned as \n     Method(Aux), e.g. barrier(none). The method will be \n     default unless otherwise specified by the the user (at setup or \n     via eplex_setup/2 or lp_setup/3).  In that case, the external solver's\n     defaults and any settings done via optimizer_param(_) will be used.\n\n     node_method\n     Applicable to MIP problems only. Returns the method that is\n     specified to solve the problem at the nodes of the branch-and-bound\n     tree. If an auxiliary method can be given for the method, and this\n     auxiliary method is not default, the method will be returned\n     as Method(Aux), e.g. barrier(none). The method will be\n     default unless otherwise specified by the the user (at setup or\n     via eplex_setup/2 or lp_setup/3).  In that case, the external solver's\n     defaults and any settings done via optimizer_param(_) will be used.\n\n     status\n     Status that was returned by the most recent invocation of the \n    external solver.\n\n     cost\n     Cost of the current solution.\n    Fails if no solution has been computed yet.\n\n     best_bound\n     The best bound (for minimisation, the lower bound) on the optimal \n    objective value for the current problem. Together with the\n    worst_bound, this specifies the range for the optimal objective\n    value. Note that a non-empty range does not mean that the problem\n    is feasible unless an objective value (cost) is also\n    available. The best_bound is the same as the current objective\n    value if the problem has been solved to optimality. It can be\n    better than the objective value either because a) (for MIP\n    problems only) the problem has been optimised to within the\n    mipgap tolerance, or b) the problem was not solved to optimality,\n    i.e. it was aborted before the optimal solution was found.\n\n     worst_bound\n     The worst bound (for minimisation, the upper bound) on the optimal \n    objective value for the current problem. Together with the\n    best_bound, this specifies the range for the optimal objective\n    value. Note that a non-empty range does not mean that the problem\n    is feasible unless an objective value (cost) is also\n    available. The worst_bound is the same as the current objective\n    value if a solution has been computed for the problem, whether\n    the problem was solved to optimality or not. Depending on the \n    problem type and method used to solve the problem, a worst bound\n    can be returned for a problem even if the solving of the problem\n    was aborted before a solution was obtained. \n\n     typed_solution\n     Returns a term ''(X1,...,Xn) whose arguments are the properly\n    typed (integer or float) solution values for the corresponding\n    problem variables (vars).  The floating point solutions\n    are the same as returned by solution, the integers are\n    obtained by rounding the corresponding floating-point solution to\n    the nearest integer.  To instantiate the problem variables to\n    their solutions, unify this term with the corresponding term\n    containing the variables:\n\n    instantiate_solution(Handle) :-\n    lp_get(Handle, vars, Vars),\n    lp_get(Handle, typed_solution, Values),\n    Vars = Values.\n\n    Note that this unification could fail if two problem variables Xa\n    and Xb were unified after the solution was lasted computed, as the\n    solutions values in the Xa and Xb positions could be different,\n    even though they are now represented by one variable.\n    Fails if no solution has been computed yet.\n\n    slack\n    Returns a list of floating-point values representing the constraint\n    slacks in the logically last solve. The problem consists of normal\n    constraints followed by any added cutpool constraints, and the\n    order corresponds to the list order in constraints for\n    normal constraints, and to cutpool_info(last_added,Info) for the\n    cutpool constraints.  Fails if no solution has been computed yet.\n\n    slack(Indexes)\n    Returns a list of floating-point values representing the slack\n    values for the constraints represented by Indexes. Indexes are a\n    list of constraint indices (as returned by lp_add_constraints/4 for\n    normal constraints, and lp_add_cutpool_constraints/4 for cutpool\n    constraints), and the order of the returned list corresponds to the\n    order in Indexes.  Fails if no slack value has been\n    computed yet for any of the constraints in Indexes -- note that \n    values are only computed for cutpool constraints if they were added\n    to the problem.\n\n    dual_solution\n    Returns a list of floating-point values representing the dual\n    solutions in the logically last solve. The problem consists of\n    normal constraints followed by any added cutpool constraints, and\n    the order corresponds to the list order in constraints for\n    normal constraints, and to cutpool_info(last_added,Info) for the\n    cutpool constraints.  Fails if no solution has been computed yet.\n\n    dual_solution(Indexes)\n    Returns a list of floating-point values representing the dual\n    solutions for the constraints represented by Indexes. Indexes are a\n    list of constraint indices (as returned by lp_add_constraints/4\n    normal constraints, and lp_add_cutpool_constraints/4 for cutpool\n    constraints), and the order of the returned list corresponds to the\n    order in Indexes.  Fails if no dual solution has been\n    computed yet for any of the constraints in Indexes -- note that\n    values are only computed for cutpool constraints if they were added\n    to the problem.\n\n    constraints(Indexes)\n    Returns a list of problem constraints as specified by\n    Indexes in denormalised form. The constraints can be either \n    normal constraints or cutpool constraints.\n\n    constraints_norm(Indexes)\n    Returns a list of problem constraints as specified by\n    Indexes in normalised form. The constraints can be either \n    normal constraints or cutpool constraints.\n\n    cutpool_info(Select,Info)\n    Returns the information specified by Info for the cutpool constraints\n    specified by Select. The returned information is either\n    i) a pair of lists Indexes-Values where Indexes is the index for\n    the constraint in the corresponding position of Values, or \n    ii) a list of Indexes if the information requested is index. Info \n    can be:\n\n    index\n    the indexes for the selected constraints. A list\n    of Indexes are returned.\n    active\n    the current active status of the selected constraints. \n    The status is either 0 (not active) or 1 (active).\n    A pair of lists Indexes-ActiveStatus is returned.\n    add_initially\n    the current add_initially status of the selected \n    constraints. The status is either 0 (not add) or 1 (add).\n    Note that although inactive constraints have a\n    add_initially status, they will not be added to a problem.\n    A pair of lists Indexes-AddInitially is returned.\n    binding_state\n    the binding state for the selected constraints in the\n    logically last solve for the problem. A pair of lists\n    Indexes-BindingStates is returned. To get this\n    information, the slack values must be available from the\n    last solve.\n    The state can be:\n    a) binding - the constraint was satisfied and binding, i.e.\n    it is within tolerance of its RHS value in the\n    normalised form. \n    b) satisfied - the constraint was satisfied but not\n    binding. \n    c) inactive - the constraint was inactive.\n    constraints_norm\n    the normalised form of the constraints for the selected \n    constraints is returned in a pair of lists \n    Indexes-Constraints.\n    constraints\n    the denormalised form of the constraints for the selected \n    constraints is returned in a pair of lists \n    Indexes-Constraints.\n\n    The constraints are selected by Select, which can be:\n\n    cstr(Idx)\n    The cutpool constraint as specified by Idx. \n    group(Name)\n    The cutpool constraints in the group Name. Both\n    active and non-active constraints are returned. Note that\n    the name of the default group is the atom nil ([]).\n    last_added\n    The cutpool constraints that were added to the\n    problem in the logically previous solve of the problem. \n    The constraints were either added initially, or were\n    added because they were violated in an intermediate\n    invocation. \n    last_notadded\n    The cutpool constraints that were not added to the\n    problem in the logically previous solve of the problem,\n    i.e. they were not violated.\n    last_inactive\n    The cutpool constraints that were inactive during the\n    logically last solve of the problem. This does not\n    include any constraints that were added since the last\n    solve. \n\n    demon_tolerance\n    Returns a comma-separated pair (RealTol,IntTol) of\n    floating-point values which specify how far outside a variable's\n    range an lp-solution can fall before lp_demon_setup/5\n    re-triggers. The tolerances differ for real (default 0.00001) and\n    integer (default 0.5) variables.\n\n    simplex_iterations\n    Returns the external solver's count of simplex iterations.\n\n    node_count\n    Returns the external MIP solver's node count.\n\n    statistics\n    Returns a list of counter values [Successes, Failures,\n    Aborts], indicating how often lp_solve/2 was invoked on the\n    Handle, and how many invocations succeeded, failed and aborted\n    respectively.\n\n    timeout\n    Returns the time-out value for the solver state. This is the amount\n    of CPU time in seconds that the external solver will be allow to\n    spend solving the problem before timing out. The value is 0 if \n    no time-out has been set.\n\n     optimizer_param(Param)\n     Returns the value of the external solver's parameter Param\n    for the problem represented by Handle. The external solver \n    has a number of parameters that affect the way they work, and \n    this queries their values. If Param is not a valid parameter for\n    the solver, an out of range exception is raised. See below for \n    more details on the parameters.\n\n    post_equality_when_unified\n    Returns the value (yes or no) if an equality constraint will be\n    posted to a solver if two variables in the solver's problem are \n    unified. \n\n    pool\n    Returns the name of the eplex instance (if any) associated with \n    the solver state. Fails otherwise. Only useful if called with \n    lp_get/3.\n\n    handle\n    Returns the solver state handle (if any) associated with the eplex \n    instance. Fails otherwise. Only useful if called with eplex_get/2.\n\nNote that reduced_cost, slack, dual_solution can only be retrieved\nwhen previously requested in the option list of lp_setup/4 or with lp_set/3.\nAn out of range error would be raised otherwise.\n\nFor the external solver's control parameter specified by\noptimizer_param(Param), Param must be an atom. The Value returned is\neither an integer, float or atom, depending on the parameter. The parameter\nis generally specific to a solver and version, and also, they may be\nproblem specific, or global, again depending on the solver version. In all\ncases, the value returned by lp_get/3 is the current value for the parameter\nfor the problem Handle. Refer to the solver documentation for details on the \nparameters. The names of the parameters are derived from the names of the \nparameters in the external solver. For CPLEX, take the parameter name from \nthe CPLEX manual (or cplex.h), remove the CPX_PARAM_ prefix and convert the \nrest to lower case, e.g.\n\n    CPX_PARAM_NODELIM becomes nodelim. \n\nFor XPRESS-MP (version 13 and newer), take the parameter name from the \nmanual (or xpresso.h), remove the XPRS_ prefix (if present) and convert \nthe rest to lower case, e.g.\n\n\tXPRS_MAXNODE becomes maxnode. \n\nFor Gurobi, take the parameter name from the manual and convert it to\nall lower case, e.g.\n\n\tIntFeasTol becomes intfeastol. \n\nFor solvers used via the OSI, there are a few generic parameters supported \nvia OSI, and depending on the actual solver, there may be some additional\nsolver-specific parameters. For the generic parameters, take the parameter\nname, remove the Osi prefix and convert the rest to lower case, e.g.\n\n    OsiPrimalTolerance becomes primaltolerance\n\n    The following parameter names are additional aliases that work for\n    either solver:\n\n    feasibility_tol\n\tCPX_PARAM_EPRHS (CPLEX) or XPRS_FEASTOL (XPRESS-MP) or\n    OsiPrimalTolerance (OSI) or FeasibilityTol (GRB) - float\n    integrality\n\tCPX_PARAM_EPINT (CPLEX) or XPRS_MIPTOL (XPRESS-MP) or\n    CbcIntegerTolerance (OSI,Cbc specific) or IntFeasTol (GRB) - float\n    iteration_limit\n\tCPX_PARAM_ITLIM (CPLEX) or XPRS_LPITERLIMIT (XPRESS-MP) or\n    OsiMaxNumIteration (OSI) or IterationLimit (GRB) - integer\n    node_limit\n\tCPX_PARAM_NODELIM (CPLEX) or XPRS_MAXNODE (XPRESS-MP) or\n    CbcMaxNumNode (OSI, Cbc specific) or NodeLimit (GRB)- integer\n    objdifference\n\tCPX_PARAM_OBJDIF (CPLEX) or XPRS_MIPADDCUTOFF (XPRESS-MP) or\n    CbcCutoffIncrement (OSI, Cbc specific) - float\n\nSee Also\n   lp_setup / 4, lp_set / 3, eplex_get / 2, lp_add_constraints / 4"},"eplex:lp_get_changeable_value/3":{"prefix":"lp_get_changeable_value","body":"lp_get_changeable_value(${1:Handle}, ${2:Var}, ${3:Val})$4\n$0","description":"lp_get_changeable_value(+Handle, ?Var, -Val)\n\n   Interface predicate to access the <EM>changeable</EM> value for this variable.\n\nArguments\n   Handle    Handle to a solver state\n   Var    A solver problem variable for solver state represented by Handle\n   Val    The typed_solution value for this variable\n\nType\n   library(eplex)"},"eplex:lp_get_iis/5":{"prefix":"lp_get_iis","body":"lp_get_iis(${1:Handle}, ${2:NumConstraints}, ${3:NumVars}, ${4:ConstraintIdxs}, ${5:VarInfos})$6\n$0","description":"lp_get_iis(+Handle, -NumConstraints, -NumVars, -ConstraintIdxs, -VarInfos)\n\n   Returns an IIS for an infeasible problem.\n\nArguments\n   Handle    Handle to a solver state\n   NumConstraints      Number of constraints in the IIS\n   NumVars    Number of variables in the IIS\n   ConstraintIdxs      List of Indexes of the constraints in the IIS\n   VarInfos    List of Variable:Status pairs where Variables are the variables in the IIS and Status is the status of that variable\n\nType\n   library(eplex)\n\nDescription\n    \n    If the solver found that the problem was infeasible, this predicate\n    will return an IIS (Irreducible Infeasible Subsystem or Irreducible\n    Inconsistent Subsystem) for the problem, if supported by the solver. \n    \n    This predicate must be called from within a user defined \n    infeasible_handler, and with the cache_iis option set to yes (both\n    can be set during solver set-up or using lp_set/2). The reason for\n    this is the IIS must be computed by the solver before the failed\n    solver state changes, and backtracking pass the failure (the normal \n    behaviour when a problem is infeasible) will logically remove the failed \n    state. cache_iis is needed because the default setting for this\n    option is no, as the IIS need to be computed as an extra step, so\n    IIS is normally not computed.\n    \n    An IIS is a subset of the problem constraints and variables which\n    defines an infeasible subproblem. It is usually irreducible in that\n    any proper subset of the IIS is feasible. Finding an IIS allows the\n    diagnostic analysis of the infeasible problem. Note that a problem\n    may have more than one infeasibility, and thus more than one IIS, \n    but this predicate only returns one. \n    \n    NumConstraints and NumVars are the number of constraints and variables\n    that are in the IIS. ConstraintIdxs is a list of the constraint indexes\n    of the constraints in the IIS, these indexes are the indexes that are\n    returned by lp_add_constraints/4 and lp_add_cutpool_constraints/4, and can \n    also be used to retrieve the constraint with the constraints_norm(Indexes)\n    and constraints(Indexes) options of eplex_get/2 and lp_get/3. VarInfos gives\n    information for the variables in the IIS, and is a list of Var:Status\n    pair, where Var is a variable in the IIS, and Status is its status.\n    Status is a one character string, and can be:\n\n       \"b\": if both bounds of the variable are involved in the infeasibility\n       \"u\": if the upper bound of the variable is involved in the infeasibility\n       \"l\": if the lower bound of the variable is involved in the infeasibility\n       \"x\": if it is unknown which bound is involved in the infeasibility\n\n    An IIS is returned only if finding IIS is supported by the external\n    solver. In addition, the solver may limit the type of problems and the\n    information returned by the IIS, for example, finding an IIS may be\n    limited to linear problems, and/or bound status information may be\n    unavailable for the variables (hence the need for the \"x\" status).\n    Consult the manual entry for infeasibility analyses for more detail.   \n\n    For some external solvers, and for problems on the boundary between\n    feasible and infeasible, it is possible that the routine that finds\n    the IIS will conclude that the problem is feasible, even though it was\n    considered infeasible when the problem was solved. In such cases, an\n    empty IIS will be returned.\n\nExceptions\n   141 --- External solver does not support finding IIS\n\nSee Also\n   eplex_get_iis / 4, lp_setup / 4, lp_demon_setup / 5, lp_solve / 2, lp_probe / 3, lp_get / 3, lp_set / 3, lp_add_constraints / 4, lp_add_cutpool_constraints / 4"},"eplex:lp_get_license/2":{"prefix":"lp_get_license","body":"lp_get_license(${1:LicStr}, ${2:LicNum})$3\n$0","description":"lp_get_license(+LicStr, +LicNum)\n\n   Get a runtime license token for the external solver.\n\nArguments\n   LicStr    String or Atom\n   LicNum    Integer\n\nType\n   library(eplex)\n\nDescription\n    \tThe eplex-library interfaces to an external simplex/MIP solver\n\twhich might require a license to run (e.g. CPLEX, XPRESS-MP, Gurobi).\n\tWhen the eplex-library is loaded, it tries to obtain a license\n\timmediately.  However, this might not be possible, either\n\tbecause no licenses are currently available, or because\n\tspecific licensing information needs to be supplied.\n    \n\tIn the latter case, lp_get_license/2 must be called explicitly\n\tby the programmer, and the relevant licensing information must\n\tbe supplied as arguments.  The meaning of the arguments is\n\tspecific to the solver used:\n    \n    LicStr    LicNum\n\n    CPLEX development       unused    unused\n    CPLEX runtime    licenvstring    serialnum\n    XPRESS-MP development   xpress_path     unused\n    XPRESS-MP runtime       xpress_path     response\n    Gurobi    license_file    unused\n    OSI    unused    unused\n    \n    If LicStr is a file or directory name, it is expected to be in\n\tthe native operating system syntax.\n    \n\nFail Conditions\n   Fails if no license can (currently) be obtained\n\nSee Also\n   lp_get_license / 0, lp_release_license / 0, lp_get_license_challenge / 1"},"eplex:lp_release_license/0":{"prefix":"lp_release_license","body":"lp_release_license","description":"lp_release_license\n\n   Release a runtime license token for the external solver.\n\nType\n   library(eplex)\n\nDescription\n    \tThe eplex-library interfaces to an external simplex/MIP solver\n\twhich might require a license to run (e.g. CPLEX, XPRESS-MP, Gurobi).\n\tWhen the eplex-library is loaded, it tries to obtain a license\n\timmediately, or a license can be obtained by calling\n\tlp_get_license/0.  A held license can then be released using\n\tlp_release_license/0.  The predicate always succeeds, even\n\tif no license was held.\n    \n\nSee Also\n   lp_get_license / 0, lp_get_license / 2"},"eplex:lp_get_license_challenge/1":{"prefix":"lp_get_license_challenge","body":"lp_get_license_challenge(${1:Challenge})$2\n$0","description":"lp_get_license_challenge(-Challenge)\n\n   Get parameter for computing license key (some external solvers only)\n\nArguments\n   Challenge    Variable\n\nType\n   library(eplex)\n\nDescription\n\tThis is only needed for certain OEM versions of external solvers!\n    \n    \tThe eplex-library interfaces to an external simplex/MIP solver\n\twhich might require a license to run (e.g. CPLEX, XPRESS-MP).\n\tCertain versions of these external solvers use a challenge-\n\tresponse licensing system. Only in such cases is this predicate\n\tneeded. lp_get_license_challenge/1 returns a value which is used to\n\tcompute a license key. This key is then passed into lp_get_license/2.\n\tFor the details of this procedure you will need to consult the\n\tdocumentation of the solver vendor.\n    \n    Be aware that the magic formula supplied by the vendor is usually\n    designed to be performed in a language like C, and may rely on the\n    behaviour of overflowing with 32 bit integers. In ECLiPSe, no\n    overflowing will takes place because of bignums, and this has to be\n    taken into account if the magic formula is calculated in ECLiPSe.\n    \n\tIf you have a development license of CPLEX or XPRESS-MP, this\n\tpredicate does not need to be called. If called anyway, it fails.\n    \n\nFail Conditions\n   Fails if the solver doesn't use a challenge-response licensing system\n\nExamples\n   \n     ?- ( lp_get_license_challenge(Challenge) ->\n\t    magic_formula(Challenge, Response),\n\t    lp_get_license(RuntimeLicenseString, Response)\n\t;\n\t    lp_get_license(DevelopmentLicensePath, 0)\n\t).\n    \n\nSee Also\n   lp_get_license / 2"},"eplex:lp_probe/3":{"prefix":"lp_probe","body":"lp_probe(${1:Handle}, ${2:Probes}, ${3:Cost})$4\n$0","description":"lp_probe(+Handle, +Probes, -Cost)\n\n   Invoke external solver, probing the problem temporarily modified by the probe specifications.\n\nArguments\n   Handle    Handle to existing solver state\n   Probes    Temporary probe specification(s)\n   Cost    Value of solution\n\nType\n   library(eplex)\n\nDescription\n\n   Similar to lp_solve/2, but the problem is first temporarily modified\n   as specified in Probes. Probes is a list of one or more probe\n   specifications that specifies how the problem is modified. After the call\n   to this predicate, the problem is restored for the external\n   solver. However, the results from the probe (obtainable from\n   lp_var_get/4 and lp_get/3) are retained.\n\n   The following probe specifications are allowed:\n\n    min(Expr)/max(Expr)\n    Minimise/maximise the problem with the objective function Expr.\n    Only existing problem variables can be given in Expr. Cannot be\n    used in conjunction with objsense, objexpr or perturb_obj.\n    objsense(Sense)\n    Sense is either min or max. Solves the problem with the original\n    objective function, but with the sense given in Sense rather than\n    that specified at setup. If only the sense of the objective is to \n    be changed, this changes the objective more efficiently than using\n    min(Expr)/max(Expr). Cannot be used in conjunction with min/max.\n    objexpr(Expr)\n    Optimise the problem with respect to the objective function Expr,\n    without changing the optimisation direction specified at problem\n    setup. Cannot be used in conjunction with min/max or perturb_obj.\n    perturb_obj(ObjDeltas)\n    Perturb the existing linear objective coefficients as specified by\n    ObjDeltas. ObjDeltas is a (possibly empty) list of specifications\n    Var : Delta, where Var is a problem variable and Delta is the\n    amount its existing objective coefficient should be changed by. For\n    example, if the existing objective is 2*X + 3*Y + Z, \n    perturb_obj([X : 1, Y : -0.5]) will modify the objective to \n    3*X + 2.5*Y + Z for the probe. If a variable occurs more than once in\n    ObjDeltas, the change to the objective coefficient is cumulative.\n    Perturb_obj is not strictly needed, as its effect can be achieved\n    by constructing the whole objective and then probing with that.\n    However, this can be expensive if most of the objective stays \n    unchanged, with only a few of its coefficients changed. It is \n    recommended that perturb_obj probe be used in such cases. \n    Cannot be used in conjunction with objexpr or min/max.\n    rhscoeffs(RhsCoeffs)\n    Alter the rhs coefficients of the matrix as specified by RhsCoeffs.\n    RhsCoeffs is a (possibly empty) list of rhs coefficient\n    specifications of the form Idx : Rhs, where Idx is the index of the\n    expandable constraint obtained from using lp_add_constraints/4, and\n    Rhs is the value for the right-hand side constant to use during the\n    probe. Any constraints not specified in RhsCoeffs remain unchanged\n    during the probe. If Idx occurs more than once in RhsCoeffs, the\n    result is undefined.\n    bounds(BoundsChanges)\n    Alter the bounds of problem variables as specified by\n    BoundsChanges. BoundsChanges is a (possibly empty) list of bounds\n    changes of the form Var $:: Lo..Hi, where Var is a problem variable\n    and Lo and Hi are the new lower and upper bounds to use for the\n    variable during the probe. Unlike normal bound changes, the bounds\n    can be widened as well narrowed, although failure will still occur\n    if Hi < Lo. Variables not specified in BoundsChanges retain their\n    bounds during the probe. If Var occurs more than once in \n    BoundsChanges, the result is undefined.\n    fixed\n    The problem is solved as an LP problem by `fixing' the integer\n    variables to their optimal MIP solution values. If there is an\n    existing MIP solution for the problem, eplex will try to use that;\n    otherwise, a MIP solution is obtained first.\n    `Fixed' probing is useful for providing reduced costs for\n    MIP problems. Note that reduced costs for the variables will only be\n    available if the reduced_cost option for the problem is set to yes\n    (this can be done either at problem setup, or by using\n    eplex_set/2). For a problem without integer variables, the original\n    problem is solved without change.  Note that this probe\n    specification is not available if the mip_use_copy option is set to\n    no for external solvers that cannot modify a MIP problem.  Cannot\n    be used in conjunction with `relaxed'.\n    relaxed\n    The problem is solved as an LP problem by relaxing all the integer\n    constraints.  For a problem with integer variables, this should be\n    equivalent to the initial relaxation solved at the start of the MIP\n    search. Depending on the solver, the discreteness of the integer\n    variables may still be taken into account during presolve. To\n    ensure that the problem solved is exactly the LP problem without\n    any integer constraints, presolve should be off. For a problem\n    without integer variables, the original problem is solved without\n    change. Note that this probe specification is not available if the\n    mip_use_copy option is set to no for external solvers that cannot\n    modify a MIP problem. Cannot be used in conjunction with `fixed'.\n\nFail Conditions\n   External solver was unable to find a solution, or bounds probe used and the specified interval for some variable is empty\n\nExceptions\n     5 --- EplexInstance does not have a solver setup for it.\n   eplex_suboptimal --- Solution was found, but is possibly suboptimal\n   eplex_unbounded --- Problem is unbounded, no solution values\n   eplex_unknown --- Result is unknown (infeasible or unbounded)\n   eplex_abort --- External solver aborted for some reason\n   abort --- Incorrect specification for the probe(s)\n     6 --- mip_use_copy option was set to no (solver dependent) for probes that require yes.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   lp_solve / 2, lp_setup / 4, lp_var_get / 4, lp_get / 3, lp_set / 3, lp_add_constraints / 4"},"eplex:lp_read/3":{"prefix":"lp_read","body":"lp_read(${1:File}, ${2:Format}, ${3:Handle})$4\n$0","description":"lp_read(+File, ++Format, -Handle)\n\n   Read a problem from a file and setup a solver for it.\n\nArguments\n   File    File name\n   Format    lp or mps\n   Handle    Returns a handle to the new solver state\n\nType\n   library(eplex)\n\nDescription\n\n   Read a problem from a file and setup a solver for it.  Format is\n   lp or mps. The result is a handle similar to the one obtained by \n   lp_setup/4. Note that minimisation of the objective is assumed \n   for mps format, as the sense of the objective is not included in \n   the mps format. Minimisation is also assumed for external solvers\n   that ignore the optimisation direction of the lp file (e.g. Xpress).\n   Note also that although quadratic problems can be read in correctly if\n   supported by the external solver, the quadratic objective coefficients\n   are not extracted from the problem by eplex. These coefficients are\n   used to set/reset the objective when a problem is probed with a\n   different objective in eplex_probe/2 or lp_probe/3, so the objective\n   will not be changed or restored correctly in this case.\n\nSee Also\n   lp_write / 3, lp_setup / 4, eplex_read / 2, eplex_write / 2, lp_probe / 3"},"eplex:lp_set/2":{"prefix":"lp_set","body":"lp_set(${1:ParamName}, ${2:Value})$3\n$0","description":"lp_set(++ParamName, ++Value)\n\n   Set a global parameter for the external solver.\n\nArguments\n   ParamName    Atom or structure\n   Value    Integer, float, string or structure\n\nType\n   library(eplex)\n\nDescription\n\n    Set a global parameter. The parameter names are the same as described\n    in lp_get/2. For the timeout parameter, Value can be of any numeric\n    type. Note that for the external solver's parameters (set via\n    optimizer_param(Param)), the exact behaviour is solver dependent: if\n    the solver has global parameters, this sets the value of the parameter\n    globally; otherwise, this sets the default value of the parameter that\n    would be assigned to a new problem. The setting is not undone \n    on backtracking.\n\n    In addition, lp_set/2 is used to control the output from the external \n    solver:\n\n    lp_set(SolverChannel, +(Stream))\n       Send output from SolverChannel to the ECLiPSe I/O stream Stream.\n    lp_set(SolverChannel, -(Stream))\n       Stop sending output from SolverChannel to the ECLiPSe I/O stream \n       Stream.\n\n    SolverChannel is one of result_channel, error_channel, warning_channel, \n    log_channel, and Stream is an ECLiPSe stream identifier (e.g. \n    output, or the result of an open/3 operation).\n\n    By default, error_channel is directed to ECLiPSe's\n    error stream, warning_channel to warning_output\n    while result_channel and log_channel are suppressed.\n    To see the output on these channels, do\n\n   :- lp_set(result_channel, +output).\n   :- lp_set(log_channel, +log_output).\n\nSimilarly, to create a log file:\n\n   :- open('mylog.log', write, logstream), lp_set(log_channel, +logstream).\n\nand to stop logging:\n\n   :- lp_set(log_channel, -logstream), close(logstream).\n\nResatisfiable\n   no\n\nSee Also\n   lp_get / 2"},"eplex:lp_set/3":{"prefix":"lp_set","body":"lp_set(${1:Handle}, ${2:What}, ${3:Value})$4\n$0","description":"lp_set(+Handle, ++What, +Value)\n\n   Change initial options for solver state Handle.\n\nArguments\n   Handle    Handle to a solver state\n   What    Option to set\n   Value    Value being set\n\nType\n   library(eplex)\n\nDescription\n\nThis primitive can be used to change some of the initial options\neven after setup. \nHandle refers to an existing solver state,\nWhat can be one of the following:\n\n    method\n    Set the method that will be used to solve the problem.  Value\n    is one of default, auto, primal, dual, net, net(Simplex), barrier,\n    barrier(Crossover), sifting, sifting(SubMethod), concurrent,\n\tconcurrent_det.  Simplex can be one of default, auto, primal, dual,\n\tspecifying the Simplex method to use in the Network Simplex algorithm.\n\tCrossover can be one of default, auto, primal, dual, none,\n\tspecifying the crossover method to use for the barrier method.\n\tSubMethod could be one of default, auto, primal, dual, net, barrier,\n\tspecifying the method to use for the subproblems in the sifting method.\n\tNote that not every method is available on every external solver.\n\tIn case of MIP solving, this is the start algorithm (the one that\n\tis used to solve the initial relaxation). This method setting will\n\toverride similar settings done via optimizer_param(_).\n\n    node_method\n    Applicable to MIP problems only. Set the method that will be\n    used to solve the problem at the nodes (except the root) of the \n    branch-and-bound tree. Note that the method for solving the root\n    node is controlled by the method option. Value can be set\n    to the same values as in the method option, although \n    there may be more restrictions on what the actual methods/auxiliary\n    methods that are allowed in combination with the root method,\n    due to limitations/restrictions from the external solver. A warning\n    will be given when the problem is solved if this is the case, and \n    the default method used instead.  This node_method setting will\n\toverride similar settings done via optimizer_param(_).\n\n    solution\n    Make the solutions available each time the problem has been\n    (re-)solved successfully.\n    Value is one of the atoms yes or no.\n\n    reduced_cost\n    Make the reduced costs available each time the problem has been\n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    Value is one of the atoms yes or no.\n\n    slack\n    Make the constraint slacks available each time the problem has been\n    (re-)solved successfully.\n    Value is one of the atoms yes or no.\n\n    dual_solution\n       Make the dual solutions available each time the problem has been\n       (re-)solved successfully.  If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    Value is one of the atoms yes or no.\n\n    keep_basis\n    Store the basis each time the problem has been solved successfully,\n    and use this basis as a starting point for re-solving next time.\n    Value is one of the atoms yes or no.\n\n    mipstart\n    Use the previous solution values as a warm-start heuristics for\n\tthe MIP search.  This only has an effect for certain solvers (e.g.\n\tGurobi), if there are integrality constraints, and if there is a \n\tprevious solution available.  Possible values are none\n\t(no mipstart values, the default), all (use previous\n\tsolution for all variables), or integers (use previous\n\tsolution for all variables that are now constrained to be integral).  \n\n    cache_iis\n    When a problem is found to be infeasible, compute an IIS for the problem\n    (if supported by the external solver), and store it so that it can bee retrieved\n    by eplex_get_iis/4 or lp_get_iis/5. This will be done before the problem can\n    be modified and make the computing of the IIS impossible. The IIS will oulu\n    be available before the problem is solved again, and before the infeasible  \n    solve is backtracked. This option has no effect if the external solver does not \n    support the finding of IIS. Note that if this option is set, eplex will always ask\n    for an IIS to computed for an infeasible problem, even if it is immediately backtracked \n    by the infeasible handler failing, and that the option is only needed if the problem \n    instance in the external solver is modified before eplex_get_iis/4 or lp_get_iis/5 is called. \n    Value is one of the atoms yes or no.\n\n    demon_tolerance\n    Specify how far outside a variable's range an lp-solution\n    can fall before lp_demon_setup/5 re-triggers.\n    Value is a comma-separated pair (RealTol,IntTol) of \n    floating-point values (default (0.00001,0.5)).\n\n    use_var_names\n    Specify if variable names (set using set_var_name/2 of\n    the var_name library) should be passed to the external solver. If a\n    particular variable does not have a name, a solver's default name\n    would be used. Note that for XPRESS-MP, there is a limit on the length\n    of the name, which can be changed between 8 and 64 in steps of 8 with\n    the parameter N_NAMLEN. Variable names longer than this limit\n    are truncated to the limit.  \n    Value is one of the atoms yes or no, the default \n    is no.\n\n    timeout\n    Set the external solver to time-out after Value\n    seconds.  The solver will abort (in either the abort or suboptimal\n    state, depending on if a suboptimal solution was found) if the\n    optimal solution was not found within the time limit. In cases\n    where the solver expects an integer for the time-out interval, the\n    time given is rounded up to the next integer value. This should be\n    used instead of the solver specific optimizer_param(Param) for\n    setting timeouts, as eplex sets these parameter(s) itself. Note\n    that the exact behaviour of the timeout setting is solver dependent.\n    Value is a positive number.\n\n    cutpool_option(Idx,Option)\n    Set the option Option as specified by Value for the cutpool\n    constraint with index Idx. Option is one of the following:\n\n    active\n    Set the active status for the constraint Idx to Value.\n    Value can be 0 or 1. 0 is non-active, 1 is active.\n    add_initially\n    Specify if the constraint Idx should be added to a\n    problem before the solver is invoked. \n    Value can be 0 or 1. 1 is to add initially, 0 not.\n\n    Note that the option is not undone on\n    backtracking.\n\n    cutpool_group\n    Value is an atom, and is used to specify the name of a group of\n    cutpool constraints. If Name is not a current group name, a new\n    group with that name is created. Once created, a named group exists\n    until the problem is destroyed. The default group (with the atom\n    nil ([]) as its name) is predefined and does not need to\n    be created with cutpool_group.\n\n    suboptimal_handler\n    Value is a user defined goal to handle the case when the\n    external solver returned a suboptimal solution (because the problem\n    was aborted). Value would replace any existing suboptimal handler,\n    and would also be run in place of raising the default\n    eplex_suboptimal event.\n\n    unbounded_handler\n    Value is a user defined goal to handle the case when the\n    problem is unbounded. Value would replace any existing unbounded\n    handler, and would be run in place of raising the default\n    eplex_unbounded event.\n\n    infeasible_handler\n    Value is a user defined goal to handle the case when the\n    external solver found the problem to be infeasible. Value would\n    replace any existing infeasible handler, and would be run in place\n    of raising the default eplex_infeasible event. Note that\n    the default and logically correct behaviour is to fail, this\n    handler is provided to allow the user to analyse the cause of the\n    infeasibility. It is recommended that the handler should also fail\n    after performing the analysis.\n\n    unknown_handler\n    Value is a user defined goal to handle the case when the\n    external solver was not able to determine if the problem is\n    unbounded Value would replace any existing unknown handler, and\n    would be run in place of raising the default eplex_unknown\n    event.\n\n    abort_handler\n    Value is a user defined goal to handle the case when the\n    external solver aborted without finding any solution.  Value would\n    replace any existing abort handler, and would be run in place of\n    raising the default eplex_abort event.\n\n    optimizer_param(Param)\n    Set the external solver's control parameter Param for the problem\n    Handle. If the solver's parameters are global and not\n    problem specific, an unimplemented functionality exception would\n    be raised. See lp_get/3 for more details on the external solver's\n    parameters. Note that the new setting is not undone on \n    backtracking.\n\n    write_before_solve\n       Value can be the pair (Format,File) or the atom no. If\n       (Format,File) is given, Eplex will ask the external solver to dump\n       the problem each time the solver is solved. This allows the problem\n       in an eplex_probe/2 or lp_probe/3 to be dumped. As\n       in lp_write/3, Format is the format of the dumped\n       problem, and File is the filename. See for more details. Note that\n       the problem is dumped each time the external solver is invoked if\n       the problem has cutpool constraints, where there may be multiple\n       invocations of the solver per solver call.  `no' for Value will turn\n       off this dumping.\n\n    post_equality_when_unified\n    Value can be the atoms yes or no. Determines if an equality\n    constraint between two solver variables will be posted to the\n    solver when these variables are unified. Setting Value to no means\n    that the constraint will not be posted. Note that this can\n    lead to the solver's problem becoming inconsistent with\n    ECLiPSe's. \n\n  Making solutions available means that they can be retrieved using\n  lp_get/3 or lp_var_get/4 after the solver has been run successfully.\n\n  All settings apart from optimizer_param(Param) and cutpool settings \n  will be undone on backtracking!\n\nResatisfiable\n   no\n\nSee Also\n   lp_setup / 4, lp_get / 3, lp_var_get / 4, lp_get_iis / 5, eplex_set / 2"},"eplex:lp_setup/4":{"prefix":"lp_setup","body":"lp_setup(${1:NormConstraints}, ${2:Objective}, ${3:ListOfOptions}, ${4:Handle})$5\n$0","description":"lp_setup(+NormConstraints, +Objective, ++ListOfOptions, -Handle)\n\n   Create a new external solver state for the constraints NormConstraints.\n\nArguments\n   NormConstraints     normalised constraints\n   Objective    Objective function: min(CostExpr) or max(CostExpr)\n   ListOfOptions       List of solver options\n   Handle    handle to solver state\n\nType\n   library(eplex)\n\nDescription\n\n    Create a new solver state for the set of constraints NormConstraints\n    (see normalise_cstrs/3 for how to obtain a set of normalised\n    constraints).  Apart from the explicitly listed constraints, the\n    variable's ranges will be taken into account as the variable bounds for\n    the simplex algorithm.  Undeclared variables are implicitly declared as\n    reals.\n\n    However, when variables have been declared integers by other solvers (e.g.\n    integers/1 of the ic library) that is not taken into account by the\n    solver by default.  This means that the solver will only work on the\n    relaxed problem (ie. ignoring the integrality constraints),\n    unless specified otherwise in the options.\n\n    CostExpr is a linear expression\n    (or quadratic if supported by the external solver).\n\n    Options is a list of options (see below). Unless explicitly specified\n    otherwise, each option should occur no more than once.\n\n    A solver-handle Handle is returned which is used to refer to the solver\n    subsequently.\n\n    Note: Some external solvers need to write temporary files when they\n    are solving a problem. These are written to the temporary directory\n    specified in ECLiPSe's tmp_dir setting (get_flag/2, set_flag/2).\n\nThe solver Options are:\n\nintegers(+ListOfVars)\n    Consider the specified variables to be integers (whether or not\n    they have been declared such).\n    This option will instruct the external solver to use its own MIP solver\n    (ie. branch-and-bound search happens within the external solver).\n\nreals(+ListOfVars)\n    Consider the specified variables to be problem variables, but does\n    not otherwise constrain the variables. This option allows variables to\n    be added to the problem without requiring them to occur in other\n    constraints. \n\nmethod(+Method)\n    Use the specified method (default, auto, primal, dual, net,\n    barrier, sifting, concurrent, concurrent_det) (representing Primal\n    Simplex, Dual Simplex, Network Simplex, Barrier, Sifting etc) to solve\n    the problem. For MIP problems, this specifies the start algorithm (the\n    one that is used to solve the initial relaxation). See the external\n    solver's manual for a description of these methods.\n \n    For some of the methods, an additional `auxiliary' method may be \n    specified in brackets. These are:\n\n      net(Simplex): \n      specifies the Simplex method (primal or dual) to \n      follow the network optimisation. For LP problems only.\n\n      barrier(Crossover): \n      specifies how the crossover to a basic solution from the barrier\n      solution is performed. Crossover can be primal, \n      dual, or none. none means no crossover is\n      performed. \n\n      sifting(SubMethod): \n      specifies the method for solving the sifting subproblem. \n      SubMethod can be primal, dual, net, barrier.\n\n    For all the auxiliary methods, default can also be specified.\n    This is equivalent to not specifying an auxiliary method at all. \n\n    Note that not every method is available on every external solver.\n    The default method would use the solver's default method, or any\n    selections done via solver-specific optimizer_param(_) settings.\n\nnode_method(+Method)\n    For MIP problems only. Use the specified method (default, primal,\n    dual, net, barrier, sifting) to solve the subproblem at each node\n    of the MIP search-tree, except the root node, which is specified by\n    method option above. See method option for more description of\n    the methods. Note that there are less choices in the specifications of\n    the auxiliary methods that in the method option, due to limitations in\n    the solvers. If a specified auxiliary method cannot be used, `default'\n    will be used instead.\n\nsolution(+YesNo)\n    Make the solutions available each time the problem has been (re-)solved\n    successfully.\n    YesNo is one of the atoms yes or no, the default is \n    yes.\n\ndual_solution(+YesNo)\n    Make the dual solutions available each time the problem has been \n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nslack(+YesNo)\n    Make the constraint slacks available each time the problem has been \n    (re-)solved successfully.\n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nreduced_cost(+YesNo)\n    Make the reduced costs available each time the problem has been\n    (re-)solved successfully. If the problem is a MIP, then depending on\n    the external solver, this is either unavailable or are the values for\n    the optimal LP node. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\nkeep_basis(+YesNo)\n    Store the basis each time the problem has been solved successfully,\n    and use this basis as a starting point for re-solving next time.\n    This option only affects performance.\n    YesNo is one of the atoms yes or no, the default is \n    no.\n\n    mipstart(+Option)\n    Use the previous solution values as a warm-start heuristics for\n    the MIP search.  This only has an effect for certain solvers (e.g.\n    Gurobi), if there are integrality constraints, and if there is a \n    previous solution available.  Possible values are none\n    (no mipstart values, the default), all (use previous\n    solution for all variables), or integers (use previous\n    solution for all variables that are now constrained to be integral).  \n\n    cache_iis(YesNo)\n     Specify if an IIS should be computed immediately for an infeasible problem\n     (if supported by the external solver), and store it so that it can bee retrieved by\n     eplex_get_iis/4 or lp_get_iis/5 (called from within a user-defined infeasible \n     handler). This will be done before the problem can be modified and make the computing \n     of the IIS impossible. The IIS will only be available before the problem is solved\n     again, and also before the infeasible solve is backtracked. This option has no effect  \n     if the external solver does not support the computation of an IIS. Note that if this \n     option is set, eplex will always ask for an IIS to computed for an infeasible problem, \n     even if it is immediately backtracked by the infeasible handler failing, and that the \n     option is only needed if the problem instance in the external solver is modified \n     before eplex_get_iis/4 or lp_get_iis/5 is called. \n     YesNo is one of the atoms yes or no, the default is \n    no.\n\ndemon_tolerance(RealTol, IntTol)\n    Specify how far outside a variable's range an lp-solution\n    can fall before lp_demon_setup/5 re-triggers.\n    RealTol and IntTol are floats and default to\n    0.00001 and 0.5 respectively.\n\nintegers(+ListOfVars)\n    Consider the specified variables to be integers (whether or not\n    they have been declared such).\n    This option will instruct the external solver to use its own MIP solver\n    (ie. branch-and-bound search happens within the external solver).\n\nsos1(VarList)\n    VarList is a list of variables which the solver should\n    treat as variables of a type 1 special ordered set (SOS), i.e. at most\n    one of the variables in the set can be non-zero. This can occur multiple\n    times, for different sets of variables.\n\nsos2(VarList)\n    VarList is a list of variables which the solver should\n    treat as variables of a type 2 special ordered set (SOS), i.e. at most\n    two of the variables in the set can be non-zero. This can occur multiple\n    times, for different sets of variables.\n\npresolve(+YesNo)\n    Specify if the external solver should perform presolve for this\n    problem. With presolving, the external solver will transform the\n    problem before solving it. This can lead to significantly faster times\n    to find solutions. However, as the problem has been transformed, some\n    external solvers have restriction on accessing or changing the problem\n    state. In addition, if the solver is repeatedly called because the\n    problem is frequently modified, then presolve may not be an advantage.\n    YesNo is one of the atoms yes or no, the default is \n    determined by the global setting of presolve, which can be\n    changed via lp_set/2. The initial default is yes.\n    Note that the presolve setting cannot be changed for a problem once it\n    is set.  If the external solver supports per-problem optimizer_params, \n    their global defaults will be used for presolve(yes).\n\ntimeout(+TimeOut)\n    Set the external solver to time-out after TimeOut seconds.\n    TimeOut is a positive number. The solver will abort (in either\n    the abort or suboptimal state, depending on if a suboptimal solution\n    was found) if the optimal solution was not found within the time\n    limit. This should be used instead of setting the solver-specific\n    parameter for time-out directly. In cases where the solver expects an\n    integer for the time-out interval, the time given is rounded up to the\n    next integer value. The timeout is set by setting the external solver's\n    timeout settings, and the exact behaviour may be solver dependent.\n\nsuboptimal_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver returned a suboptimal solution (because the problem\n    was aborted). Goal would be run in place of raising the default \n    eplex_suboptimal event.\n\nunbounded_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    problem is unbounded. Goal would be run in place of raising the  \n    default eplex_unbounded event.\ninfeasible_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver found that the problem is infeasible. Goal would be run\n    in place of raising the default eplex_infeasible event.  Note\n    that the default and logically correct behaviour is to fail, this\n    handler is provided to allow the user to analyse the cause of the\n    infeasibility. It is recommended that the handler should also fail\n    after performing the analysis.\n\nunknown_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver was not able to determine if the problem is unbounded\n    or infeasible. Goal would be run in place of raising the default \n    eplex_unknown event.\n\nabort_handler(+Goal)\n    Specifies a user defined goal Goal to handle the case when the\n    external solver aborted without finding any solution. Goal would be \n    run in place of raising the default eplex_abort event.\n\nuse_var_names(+YesNo)\n    Specify if variable names (set using set_var_name/2 of the \n    var_name library) should be passed to the external solver. If a \n    particular variable does not have a name when it is first passed to the\n    external solver, a default name determined by the solver would be used.\n    Note that for XPRESS-MP, there is a limit on the length of the name,\n    which can be changed between 8 and 64 in steps of 8 with the \n    parameter mpsnamelength (XPRS_MPSNAMELENGTH). Variable \n    names longer than this limit are truncated to the limit. \n    YesNo is one of the atoms yes or no, the default is \n    no.\n\n    mip_use_copy(YesNo)\n    Some external solvers do not allow a MIP problem to be modified\n    once the MIP search has been started. Eplex works around this\n    problem by making a copy of the problem and solving that, so that\n    the original problem can still be modified. This can be turned off to\n    avoid the overhead of making this copy, in which case the MIP\n    problem cannot be modified. This option is used only when solving a\n    MIP problem, and the external solver does not allow a MIP problem to\n    be modified; otherwise it is ignored.\n    YesNo is one of the atoms yes or no, the default \n    is yes so that the problem can be modified.\n\n    write_before_solve(Format,File)\n    This option is most useful for debugging purposes. If given,\n    Eplex will ask the external solver to dump the problem each time\n    the problem is solved. This allows the problem in an\n    eplex_probe/2 or lp_probe/3 to be dumped. As in\n    lp_write/3, Format is the format of the dumped\n    file and File is its name. Note that the problem is dumped\n    each time the external solver is invoked if the problem has cutpool\n    constraints, where there may be multiple invocations of the solver\n    per solver call. \n    The default without this option is that the problem would not be \n    dumped.\n\n    post_equality_when_unified(+YesNo)\n    This option determines if an equality constraint between two\n    variables will be posted to the solver when these variables are\n    unified. Setting YesNo to no means that the constraint \n    will not be posted. Note that this can lead to the\n    solver's problem becoming inconsistent with ECLiPSe's. \n\nsync_bounds(+YesNo)\n    This option determines if the bounds of the problems variables are\n    synchronised with other solvers (i.e. the generic bounds are obtained\n    with get_var_bounds/3 and then passed to the external solver) before\n    the external solver is invoked. This was always done for previous\n    non-standalone version of eplex. For standalone eplex, as the bounds\n    are communicated directly to the external solver, the synchronisation\n    of variable bounds is not needed unless the user is using eplex\n    co-operatively with other solvers (e.g. ic). Even in such cases, it may\n    be more efficient to communicate these bounds changes by explicitly\n    programming it, especially if the problem has many variables and bounds\n    changes happen only to a few of the variables. Setting YesNo\n    to yes should increase compatibility with previous code (but note that\n    previous eplex obtained the bounds from a specific bounds keeper like\n    ic rather than the generic bounds).  YesNo is one of the atoms\n    yes or no, the default is no.\n\nSee Also\n   lp_add / 3, lp_set / 3, lp_add_vars / 2, lp_add_constraints / 3, lp_solve / 2, lp_probe / 3, lp_get / 3, lp_get_iis / 5, normalise_cstrs / 3, lp_write / 3"},"eplex:lp_solve/2":{"prefix":"lp_solve","body":"lp_solve(${1:Handle}, ${2:Cost})$3\n$0","description":"lp_solve(+Handle, -Cost)\n\n   Explicitly invoke the external solver.\n\nArguments\n   Handle    Handle to a solver state\n   Cost    Value of returned solution\n\nType\n   library(eplex)\n\nDescription\n\n   A solver that was setup manually with lp_solve/2 needs to be \n   triggered explicitly using this predicate. \n\n   The external solver's LP, QP or MIP solver is applied to the\n   problem represented by Handle.  Precisely which method is used\n   depends on the options given to lp_setup/4.  lp_solve/2 fails if\n   there is no solution or succeeds if an optimal solution is found,\n   returning the solution's cost in Cost (unlike with lp_demon_setup/5,\n   Cost gets instantiated to a number).  After a success, various\n   solution and status information can be retrieved using lp_get/3\n   and lp_var_get/4.\n\n   Normally, the external solver is invoked once per call in this\n   predicate, but if the problem contain cutpool constraints (see\n   lp_add_cutpool_constraints/4), then the external solver may be invoked\n   repeatedly to produce a solution which does not violate the cutpool\n   constraints. \n\n   When a solver is triggered repeatedly, each invocation will\n   automatically take into account the current variable bounds.  The set of\n   constraints considered by the solver is the one given when the solver\n   was created plus any new constraints that were added (lp_add/3) in the\n   meantime.\n\n   The user can define their own handlers (per eplex instance/problem) to\n   handle cases where there was some  error condition, or some limits were \n   exceeded during the solving of the problem. If no handler was defined,\n   by default an event would be raised. These are:\n\n    suboptimal handler (eplex_suboptimal event)\n    \tThis means that a solution was found but it may be suboptimal.\n\tThe default behaviour is to print a warning and succeed.\n    unbounded_handler (eplex_unbounded event)\n\tThis means that the problem is unbounded.  The default\n\tbehaviour is to bind Cost to infinity (positive or negative\n\tdepending on the optimisation direction), print a warning and\n\tsucceed.  CAUTION: No solution values are computed when the\n\tproblem is unbounded, so unless the problem was set up with\n\tthe solution(no) option, an error will occur when trying to\n\tcontinue as if the optimisation had succeeded.\n    infeasible_handler (eplex_infeasible event)\n    \tThis means that the problem is infeasible. The default\n\tbehaviour is to fail. Redefining this handler allows the \n    examination of the failed problem, e.g. obtaining an IIS for it.\n    unknown_handler (eplex_unknown event)\n    \tThis means that due to the solution method chosen, it is unknown\n\twhether the problem is unbounded or infeasible. The default\n\tbehaviour is to print a warning and fail (even though this\n\tmay be logically wrong!).\n    abort_handler (eplex_abort event)\n    \tSome other error condition occurred during optimisation.\n\tThe default behaviour is to print an error and abort.\n\nFail Conditions\n   External solver was unable to find a solution.\n\nExceptions\n   eplex_suboptimal --- Solution was found, but is possibly suboptimal\n   eplex_unbounded --- Problem is unbounded, no solution values\n   eplex_unknown --- Result is unknown (infeasible or unbounded)\n   eplex_abort --- External solver aborted for some reason\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   lp_setup / 4, lp_add / 3, lp_get / 3, lp_var_get / 4, lp_add_cutpool_constraints / 4"},"eplex:lp_suspend_on_change/3":{"prefix":"lp_suspend_on_change","body":"lp_suspend_on_change(${1:Handle}, ${2:Var}, ${3:Susp})$4\n$0","description":"lp_suspend_on_change(+Handle, ?Var, +Susp)\n\n   Record the given suspension to be scheduled whenever a solution is found for the Eplex handle.\n\nArguments\n   Handle    Handle to a solver state\n   Var    A solver problem variable for solver state represented by Handle\n   Susp    Suspension to schedule when the typed solution for this variable changes\n\nType\n   library(eplex)"},"eplex:lp_var_get/4":{"prefix":"lp_var_get","body":"lp_var_get(${1:Handle}, ${2:Var}, ${3:What}, ${4:Value})$5\n$0","description":"lp_var_get(+Handle, +Var, ++What, -Value)\n\n   Obtain information for an individual solver problem variable Var.\n\nArguments\n   Handle    Handle to a solver state\n   Var    A solver problem variable for Handle\n   What    Specification for information wanted (atom)\n   Value    Returned value of What\n\nType\n   library(eplex)\n\nDescription\n\n   Retrieve information about the (logically) most recent solver state and\n   results related to a particular variable, for the solver state\n   represented by Handle. Fails if no solution has been computed yet. What\n   can take the same values as those in eplex_var_get/3.\n\nExceptions\n     4 --- Handle is not instantiated.\n     5 --- Handle is not a compound term.\n     6 --- What is not a valid value.\n     6 --- Var is not a problem variable for Handle.\n     6 --- What is unavailable; the information was not requested at solver setup.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   eplex_var_get / 3"},"eplex:lp_var_get_bounds/4":{"prefix":"lp_var_get_bounds","body":"lp_var_get_bounds(${1:Handle}, ${2:Var}, ${3:Lo}, ${4:Hi})$5\n$0","description":"lp_var_get_bounds(+Handle, ?Var, -Lo, -Hi)\n\n   Returns the bounds stored in the solver state of Handle for Var.\n\nArguments\n   Handle    Handle to a solver state\n   Var    A solver problem variable for Handle\n   Lo    Lower bound for Var\n   Hi    Upper bound for Var\n\nType\n   library(eplex)\n\nDescription\n\n    \n    Returns the numeric bounds stored in the solver state of Handle for the\n    variable Var. The bounds are returned as floats. Var must be an\n    existing problem variable for Handle, i.e. it must occur in the \n    constraints posted to the solver state. \n\nResatisfiable\n   no\n\nExceptions\n     5 --- Handle is not in the form of a solver handle.\n     6 --- Var is not a problem variable for Handle.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   eplex_var_get_bounds / 3, lp_var_set_bounds / 4"},"eplex:lp_var_occurrence/3":{"prefix":"lp_var_occurrence","body":"lp_var_occurrence(${1:Var}, ${2:Handle}, ${3:Index})$4\n$0","description":"lp_var_occurrence(?Var, ?Handle, -Index)\n\n   Returns the column number Index for Var in the external solver represented by Handle\n\nArguments\n   Var    Variable\n   Handle    Handle to a solver state, or a variable\n   Index    Column number for Var in Handle's matrix (integer)\n\nType\n   library(eplex)\n\nDescription\n\n    \n    If Handle is a problem handle, then Index is the column number for the\n    variable Var in the problem matrix of the external solver presented by\n    Handle. If Handle is a variable, then the predicate returns the handles\n    and index for each problem handle the variable non-determinately. \n    \n\nModes and Determinism\n   lp_var_occurrence(?, +, -)\n   lp_var_occurrence(?, -, -)\n\nResatisfiable\n   Yes (if Handle is a variable)."},"eplex:lp_var_set_bounds/4":{"prefix":"lp_var_set_bounds","body":"lp_var_set_bounds(${1:Handle}, ${2:Var}, ${3:Lo}, ${4:Hi})$5\n$0","description":"lp_var_set_bounds(+Handle, ?Var, +Lo, +Hi)\n\n   Imposes new bounds for Var on the solver state of Handle.\n\nArguments\n   Handle    Handle to a solver state\n   Var    A solver problem variable for Handle\n   Lo    New lower bound for Var (number)\n   Hi    New upper bound for Var (number)\n\nType\n   library(eplex)\n\nDescription\n\n    \n    Imposes numeric bounds on the solver state of Handle for the variable\n    Var. Each bound is only updated if it is more narrow than the current\n    bound for the variable. The bounds are converted to floats before they\n    are imposed, and no typing is implied by the type of the numbers. It is\n    possible to impose incompatible bounds for the same variable on\n    different solver states. Var must be an existing problem variable for\n    Handle, i.e. it must occur in the constraints posted to the solver\n    state. \n\nFail Conditions\n   Lo is greater than Hi.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- Handle is not in the form of a solver handle.\n     6 --- Var is not a problem variable for Handle.\n    40 --- Handle not valid: solver state had been destroyed by cleanup\n\nSee Also\n   lp_var_get_bounds / 4"},"eplex:lp_verify_solution/3":{"prefix":"lp_verify_solution","body":"lp_verify_solution(${1:Handle}, ${2:ViolatedCstrs}, ${3:ViolatedVars})$4\n$0","description":"lp_verify_solution(+Handle, -ViolatedCstrs, -ViolatedVars)\n\n   Verifies the current solution for the problem associated with Handle.\n\nArguments\n   Handle    Handle to a solver state\n   ViolatedCstrs       List of violated Constraints.\n   ViolatedVars    List of violated variables.\n\nType\n   library(eplex)\n\nDescription\n\n This predicate checks the current solution for the problem associated with\n Handle. It verifies that all the constraints are satisfied by the\n solution values for the problem variables, and that the solution values do\n not violate their bounds, and the values are integral for integer variables.\n Violated Constraints are returned in ViolatedCstrs, and violated variables in \n ViolatedVars.\n\n Under normal circumstances, if the external solver produces a solution, it \n should produce no violations. Any violation probably indicates a problem\n with the external solver. However, because the external solver is a complex\n piece of software and may contain problems, it is a good idea to verify the\n solution, and this predicate provides an easy way to do this.\n\n Each violation is returned as a structure of the following form:\n   vio(type,delta,idx,item) \n where\n\n       type:   the type of violation:\n    \n    norm:   the violated item is a normal constraint.\n    condcp: the violated item is an active cutpool constraint.\n    int:    the violated item is an integer variable whose \n    solution value is not integral.    \n    lower:  the violated item is a variable whose solution value\n    is less than the lower bound.    \n    upper:  the violated item is a variable whose solution value\n    is greater than the upper bound.    \n    \n    delta: the absolute value of the violation. \n    idx:   the index used by the external solver for the item (most\n    likely the row/column number in the problem matrix). This \n    is needed to locate the violation in the solver for reporting\n    or investigating the problem.\n    item:  the violated item, i.e. the constraint or variable.\n\n For checking of constraints, a fresh copy of the constraint is made with\n the solution values, as this avoids binding the original variables. Any active\n cutpool constraints in the (logically) last solve of the problem are checked,\n along with the normal constraints. A constraint is considered to be  violated\n if the difference between the sum of the left-hand side and the right-hand side \n for the constraint is greater than the feasibility tolerance (feasibility_tol)\n parameter for the instance. For variables, a bound is considered violated if\n the solution value falls outside the bound by more than feasibility tolerance,\n and integrality is considered to be violated if the fractional part of the\n soltuion is greater than the integrality parameter for the instance. \n\nFail Conditions\n   no solution values are available."},"eplex:lp_write/3":{"prefix":"lp_write","body":"lp_write(${1:Handle}, ${2:Format}, ${3:File})$4\n$0","description":"lp_write(+Handle, ++Format, +File)\n\n   Write a solver problem to a file.\n\nArguments\n   Handle    Handle to an existing solver state\n   Format    lp or mps\n   File    File name\n\nType\n   library(eplex)\n\nDescription\n\n   Write the problem which corresponds to Handle to a file. The set of\n   supported formats depends on the actual external solver which is used.\n   All solvers support the mps format. Some solvers on some operating\n   system platforms may change or append a suffix to the filename.  Note\n   that the mps format does not specify the sense (min or max) of the\n   objective function. Note also that any active cutpool constraints in the\n   problem will be included in the dump, even though they could be left out\n   of the problem that the external solver actually solves.\n\nSee Also\n   lp_read / 3, lp_setup / 4"},"eplex:normalise_cstrs/3":{"prefix":"normalise_cstrs","body":"normalise_cstrs(${1:Constraints}, ${2:NormConstraints}, ${3:NonlinConstraints})$4\n$0","description":"normalise_cstrs(+Constraints, -NormConstraints, -NonlinConstraints)\n\n   Normalise the linear constraints in Constraints.\n\nArguments\n   Constraints    List of arithmetic relations\n   NormConstraints     Linear constraints from Constraints (normalised)\n   NonlinConstraints   Non-linear constraints from Constraints\n\nType\n   library(eplex)\n\nDescription\n  Constraints is a list of terms of the form X $= Y, X $>= Y or X $=< Y (or\n  their non-$ equivalents)  where X and Y are arithmetic expressions.  The linear\n  constraints are returned in normalised form in NormConstraints, the\n  nonlinear ones are returned unchanged in NonlinConstr.\n\nSee Also\n   $= / 2, $=< / 2, $>= / 2, =:= / 2, =< / 2, >= / 2"},"eplex:piecewise_linear_hull/3":{"prefix":"piecewise_linear_hull","body":"piecewise_linear_hull(${1:X}, ${2:Points}, ${3:Y})$4\n$0","description":"piecewise_linear_hull(?X, ++Points, ?Y)\nEplexInstance:piecewise_linear_hull(?X, ++Points, ?Y)\n\n   Relates X and Y according to a piecewise linear function.\n\nArguments\n   X    Parameter/domain of the piecewise function\n   Points    List of points defining the piecewise function\n   Y    Result/range of piecewise the function\n\nType\n   library(eplex)\n\nDescription\n\nThis predicate is intended for use with hybrid ic/eplex solving. It\nimposes the constraint Y = f(X), where f is a piecewise\nlinear function defined by Points: the piecewise_linear/3 constraint for\n the ic solver, and a linear relaxation of it for the eplex instance\n EplexInstance. Please see the documentation for\npiecewise_linear/3 for details of how the piecewise linear function is\nspecified.\n\nThis predicate extends lib(ic)'s piecewise_linear/3 by also computing the convex hull\nof the portions of the constraint which are feasible with respect to the\ncurrent bounds (stored with the IC bounds) of X and Y.  Constraints (and\n bounds) defining this convex hull are then\npassed to the eplex instance.  Changes in the IC bounds of the variables are\n automatically forwarded to the eplex instance, so that these constraints are updated whenever new\nbounds on X or Y change the convex hull. Note that the reverse, i.e. bounds\n  changes on the eplex instance,  are NOT forwarded to the IC bounds. \n\nThis implementation of the piecewise\nconstraint accepts bounded reals in its arguments, but it\ndoes not fully support bounded reals of non-zero width (i.e.\nthose which do not correspond to a single floating point value).  As a\nresult, use of such bounded reals is not recommended at this time.\n\nSee Also\n   ic : piecewise_linear / 3"},"eplex:reals/1":{"prefix":"reals","body":"reals(${1:Vars})$2\n$0","description":"reals(?Vars)\nEplexInstance:reals(?Vars)\n\n   Constraints Vars to the real domain for EplexInstance.\n\nArguments\n   Vars    Variable or number, or a list or submatrix of variables/numbers\n\nType\n   library(eplex)\n\nDescription\n\tConstrains Vars to the real domain in the eplex instance\n    EplexInstance. Any variables that are not problem variables\n    for EplexInstance are added to the problem, with unconstrained\n    bounds (except by the external solver's idea of infinity).\n\n    Note that the notion of real is used here in the pure mathematical\n    sense, where real numbers subsume the integers. If the variables\n    are already instantiated, this call checks that the variable is\n    instantiated to a number.\n\n    \n\nFail Conditions\n   Vars contain elements which are neither variable or number.\n\nSee Also\n   ic_kernel : reals / 1, ic : reals / 1, suspend : reals / 1, integers / 1, :: / 2"},"eplex:reduced_cost_pruning/2":{"prefix":"reduced_cost_pruning","body":"reduced_cost_pruning(${1:Handle}, ${2:GlobalCost})$3\n$0","description":"reduced_cost_pruning(+Handle, ?GlobalCost)\n\n   Prune bounds of all problem variables based on their reduced costs\n\nArguments\n   Handle    Handle to a (solved) solver state\n   GlobalCost    Bounded global cost variable\n\nType\n   library(eplex)\n\nDescription\n\n    \n    Handle is a problem handle referring to the linear relaxation of\n    a more complex problem. GlobalCost is the overall cost variable\n    of the complex problem.\n    \n    This predicate tries to prune the bounds of all variables that\n    occur in the linear relaxation, based on their reduced costs,\n    the optimum of the relaxation, and the currently known bounds\n    (lower if maximising, upper if minimising) on the global cost.\n    \n    This predicate should be called just after the Handle has been solved.\n    In particular, it can be used as the post-goal in an lp-demon.\n    The solver should have been set up with the reduced_cost(yes)\n    option.\n    \n    Note that the bounds of GlobalCost is obtained using the generic\n    get_var_bounds/3. For correct pruning, GlobalCost should only have\n    bounds that are relevant to this problem. \n\nFail Conditions\n   None\n\nSee Also\n   lp_demon_setup / 5"},"eplex:solution_out_of_range/1":{"prefix":"solution_out_of_range","body":"solution_out_of_range(${1:Handle})$2\n$0","description":"solution_out_of_range(+Handle)\n\n   A trigger goal for lp_demon_setup/5.\n\nArguments\n   Handle    Handle to a solver state\n\nType\n   library(eplex)\n\nDescription\n\n  This is intended as a useful pre(Goal) for lp_demon_setup/5 in connection\n  with the bounds trigger mode.  It succeeds if any of the\n  solutions (computed by the most recent successful solving) of Handle are\n  more than a tolerance outside the range of the corresponding variables,\n  ie. couldn't be instantiated to this value.  The admissible tolerances\n  can be specified in lp_setup/4 or lp_set/3 as demon_tolerance.\n\nSee Also\n   lp_demon_setup / 5"},"eplex:sos1/1":{"prefix":"sos1","body":"sos1(${1:Vars})$2\n$0","description":"sos1(?Vars)\nEplexInstance:sos1(?Vars)\n\n   Constrains all but one of Vars to be zero.\n\nArguments\n   Vars    A collection of variables\n\nType\n   library(eplex)\n\nDescription\n\tConstrains all but one of Vars to be zero.  In MIP terminology\n\tthis is called a Special Ordered Set (SOS) of type 1.\n\n\tIf the variables are also required to be integral, this must\n\tbe separately declared using integers/1.  Similarly for bounds.\n\n\t\n\nSee Also\n   _53936 : sos1 / 1, sos2 / 1, integers / 1"},"eplex:sos2/1":{"prefix":"sos2","body":"sos2(${1:Vars})$2\n$0","description":"sos2(?Vars)\nEplexInstance:sos2(?Vars)\n\n   Constrains all but two consecutive elements of Vars to be zero.\n\nArguments\n   Vars    A collection of variables\n\nType\n   library(eplex)\n\nDescription\n\tConstrains all but two consecutive elements of Vars to be zero.  In\n\tMIP terminology this is called a Special Ordered Set (SOS) of type 2.\n\n\tIf the variables are also required to be integral, this must\n\tbe separately declared using integers/1.  Similarly for bounds.\n\n\t\n\nSee Also\n   _54574 : sos2 / 1, sos1 / 1, integers / 1"},"eplex:suspend_on_change/2":{"prefix":"suspend_on_change","body":"suspend_on_change(${1:Var}, ${2:Susp})$3\n$0","description":"suspend_on_change(?Var, +Susp)\nEplexInstance:suspend_on_change(?Var, +Susp)\n\n   Record the given suspension to be scheduled whenever a solution is found for the EplexInstance.\n\nArguments\n   Var    A solver problem variable for solver associated with EplexInstance\n   Susp    Suspension to schedule when the typed solution for this variable changes\n\nType\n   library(eplex)"},"fcompile:fcompile/1":{"prefix":"fcompile","body":"fcompile(${1:File})$2\n$0","description":"fcompile(++File)\n\n   Generates a byte-form object file from the ECLiPSe source File.\n\nArguments\n   File    Name of source file (Atom or string)\n\nType\n   library(fcompile)\n\nDescription\n\n   This predicate is obsolete, use compile/2 instead.\n\n   Same as fcompile/2 with all options set to their default\n   values: the object file is placed in the current working directory,\n   byte format is generated, non-verbose, and fcompile tries to\n   compile the program first.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   fcompile / 2"},"fcompile:fcompile/2":{"prefix":"fcompile","body":"fcompile(${1:File}, ${2:Options})$3\n$0","description":"fcompile(++File, ++Options)\n\n   Generates an object file from the ECLiPSe source File with specified options.\n\nArguments\n   File    Name of source file (Atom or string)\n   Options    List of valid options and their values\n\nType\n   library(fcompile)\n\nDescription\n\n   This predicate is obsolete, use compile/2 instead.\n\n   Compiles the specified Prolog source file and generates an object file\n   with the same base name as the source file but with suffix .eco.\n   Object files can be loaded by the built-in predicates use_module/1,\n   lib/1, compile/1 and ensure_loaded/1, and also\n   with the eclipse -b command-line option.\n\n   File must be instantiated to a legitimate specification for an existing\n   file except for the suffix, which may be omitted. Options is a list of\n   Option:Value pairs where Option and value can be:\n\n   compile: YesOrNo\n\n    YesOrNo is either the  atom yes or no. For 'yes', fcompile will\n       try to first compile File (checking that it has not already been\n       compiled first).  This is usually what is required, as it ensures\n       that File can be properly read to generate the object file. The\n       default is 'yes'.\n\n   format: ByteOrText\n\n      ByteOrText is either the atom byte or text.  If 'text', the\n      object file will be in a textual format.  If 'byte', the object file\n      will be in a binary format which is larger, but will load faster\n      and is not human readable. The default is byte.\n\n   outdir: OutputDirectory\n\n    OutputDirectory is the directory where the generated object\n       file will be placed. It can be an atom or a string. The default is\n       the current working directory.\n\n   verbose: YesOrNo\n\n    YesOrNo is either the  atom yes or no. For 'yes', fcompile will\n       report in detail the predicates it is dumping out. This is probably\n       only needed for debugging fcompile, to trace its progress. The default\n       is 'no'.\n\n   The predicate will look for File with a `source' suffix (i.e. no\n   suffix, .ecl or .pl), compile the file by calling compile, and\n   generate an object form of the source file with suffix .eco.\n   The user should use include/1 directives to include all files that are\n   in the same module as the master file, and use_module/1 directives for\n   files that define a different module. Files mentioned in include\n   directives will not need to be fcompiled separately for their object\n   form.\n\n   This object form can be loaded into an ECLiPSe session even on a\n   different operating system/hardware platform from the one on which\n   it was generated.  However, the object format may change incompatibly\n   between different releases of ECLiPSe.\n\n   The fcompile library does not need to be loaded in order to load the object\n   file.  The built-in predicates ensure_loaded/1, use_module/1\n   and lib/1,2 will try to load an object file in preference to a\n   source file, if both are present.  The compile built-ins on the\n   other hand will prefer source files, unless the .eco\n   suffix is explicitly given.\n\n   It is recommended that object files always contain proper modules.\n   If an object file contains module-free code, then loading it into\n   an existing module that already has code can cause conflicts with\n   auxiliary predicates (e.g. from do/2 loop constructs).\n\n   Restrictions:\n\n     macro definitions should be quoted using \n     no_macro_expansion/1, e.g.\n     \n    :- local macro(no_macro_expansion(maxint), 9999).\n     \n\n     directives in the module should not change the state \n    of compiled code.\n\n     big integer constants between -2^63 and -2^31 and between\n     \t2^31 and 2^63 should not appear directly in the source, and\n\twill provoke a warning because the generated object code will\n\tnot be portable between 32 and 64 bit machines.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n      fcompile(my_prog, []).   % equivalent to fcompile(my_prog)\n\n   fcompile(my_prog, [format:text, outdir:'../']).\n   % generate the object file in text format, and place it in the parent dir\n\nSee Also\n   fcompile / 1"},"fcompile:fcompile_desc":{"prefix":"lib","body":"lib(${1:fcompile})$2\n$0","description":"lib(fcompile)\n\n    This module contains fcompile/1,2 for backward compatibility."},"fd_global:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:Vars})$2\n$0","description":"alldifferent(+Vars)\n\n   All members of Vars are different\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n\nType\n   library(fd_global)\n\nDescription\n    Constrains all elements of a collection to be pairwise different (and\n    integral).  This is an implementation with the same semantics as the\n    standard alldifferent/1 constraint, but with stronger propagation\n    behaviour.  It checks for exhaustion of all sub-ranges of possible\n    values.\n    \n    The algorithm is based roughly on: Jean Francois Puget, A fast algorithm\n    for the bound consistency of the alldiff constraint, AAAI 1998, but\n    makes some additional inferences based on domain size.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nExamples\n   \n    ?- length(Xs,5), Xs::1..4, alldifferent(Xs).\n    no (more) solution.\n\n    ?- [X1,X2]::1..2, [X3,X4,X5]::1..5, alldifferent([X1,X2,X3,X4,X5]).\n\n    X1 = X1{[1, 2]}\n    X2 = X2{[1, 2]}\n    X3 = X3{[3..5]}\n    X4 = X4{[3..5]}\n    X5 = X5{[3..5]}\n\n    Delayed goals:\n    alldifferent([X1{[1, 2]}, X2{[1, 2]}], 1)\n    alldifferent([X3{[3..5]}, X4{[3..5]}, X5{[3..5]}], 1)\n    \n\nSee Also\n   fd : alldifferent / 1, ic_global : alldifferent / 1, ic_symbolic : alldifferent / 1, sd : alldifferent / 1, ic : alldifferent / 1, gfd : alldifferent / 1, ic_global_gac : alldifferent / 1, fd_global_gac : alldifferent / 1, alldifferent / 2, lists : collection_to_list / 2"},"fd_global:alldifferent/2":{"prefix":"alldifferent","body":"alldifferent(${1:Vars}, ${2:Capacity})$3\n$0","description":"alldifferent(+Vars, ++Capacity)\n\n   Vars contains at most Capacity elements of each value\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n   Capacity    Maximum number of times a value can appear in Vars\n\nType\n   library(fd_global)\n\nDescription\n    This is a generalization of alldifferent/1.  It allows repeated elements\n    in the collection, but there can be no more than Capacity elements with\n    a particular value.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nSee Also\n   alldifferent / 1, lists : collection_to_list / 2"},"fd_global:alldifferent_matrix/1":{"prefix":"alldifferent_matrix","body":"alldifferent_matrix(${1:Matrix})$2\n$0","description":"alldifferent_matrix(+Matrix)\n\n   Constrain the rows and columns of Matrix to be different values\n\nArguments\n   Matrix    A two dimensional square matrix of Variables or integer\n\nType\n   library(fd_global)\n\nDescription\n\n    This constraint is a matrix version of alldifferent. Matrix is a two\n    dimensional square (NxN) matrix, and the constraint ensures that the \n    elements in each row and column of the matrix are different. The same\n    value can occur in different rows and columns. It is logically \n    equivalent to imposing 2N alldifferent constraints, on each row and column,\n    but it allows more reasoning because it considers the rows and columns \n    together. The alldifferent constraint used is the lib(fd_global) version.\n    The maximum propagation occurs when the variables' domains also\n    have N values\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   alldifferent / 1, ic_global : alldifferent_matrix / 1, ic_global_gac : alldifferent_matrix / 1, fd_global_gac : alldifferent_matrix / 1"},"fd_global:atleast/3":{"prefix":"atleast","body":"atleast(${1:N}, ${2:Vars}, ${3:V})$4\n$0","description":"atleast(+N, ?Vars, +V)\n\n   At least N elements of Vars have the value V.\n\nArguments\n   +N    An integer\n   ?Vars    A collection (a la collection_to_list/2) of domain variables or integers\n   +V    An integer\n\nType\n   library(fd_global)\n\nDescription\n   This constraint ensures that at least N element of Vars have the value V.\n   As soon as some domain variable from the collection is updated, this\n   constraint is woken and it checks if the constraint is still satisfiable\n   and if so, if it is already satisfied or not.\n\nFail Conditions\n      Fails if less than N elements of Vars can take value V.\n\nSee Also\n   atmost / 3, occurrences / 3, lists : collection_to_list / 2"},"fd_global:atmost/3":{"prefix":"atmost","body":"atmost(${1:N}, ${2:Vars}, ${3:V})$4\n$0","description":"atmost(+N, ?Vars, +V)\n\n   At most N elements of Vars have the value V.\n\nArguments\n   +N    An integer\n   ?Vars    A collection (a la collection_to_list/2) of domain variables or integers\n   +V    An integer\n\nType\n   library(fd_global)\n\nDescription\n   This constraint ensures that at most N element of Vars have the value V.\n   As soon as some domain variable from the collection is updated, this\n   constraint is woken and it checks if the constraint is still satisfiable\n   and if so, if it is already satisfied or not.\n\nFail Conditions\n      Fails if more than N elements of Vars are instantiated to V.\n\nSee Also\n   atleast / 3, occurrences / 3, lists : collection_to_list / 2"},"fd_global:bin_packing/3":{"prefix":"bin_packing","body":"bin_packing(${1:ItemBins}, ${2:ItemSizes}, ${3:BinLoads})$4\n$0","description":"bin_packing(+ItemBins, ++ItemSizes, +BinLoads)\n\n   The one-dimensional bin packing constraint with loads: packing N items into M bins, each bin having a load\n\nArguments\n   ItemBins    A collection of N variables or integers (domain/value between 1 and M)\n   ItemSizes    A collection of N non-negative integers\n   BinLoads    A collection of M variables or non-negative integers\n\nType\n   library(fd_global)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack N\n   items with individual sizes into M bins, such that the sum of sizes of\n   items in each bin equals the load of that bin, as specified in BinLoads.\n   Each element of ItemBins and its corresponding element in ItemSizes\n   represents an item, such that the i'th element of ItemSizes is the size\n   of the i'th item, and the i'th element of Item is the bin this item is\n   packed into. BinLoads represent the load of each bin, i.e. the sum\n   of the sizes of items assigned to that bin, with the j'th element \n   representing the load for bin j. An (integer finite domain) variable for \n   the load allows a constraint on the load to be specified, such as a\n   minimum and/or maximum load for the bin.\n\n   This constraint and the algorithm used to implement it is described in\n   P. Shaw, 'A Constraint for Bin Packing', CP'2004, and is described in\n   the global constraint catalog as bin_packing_capa, where the CAPACITY\n   parameter is replaced by a collection of domain variables\n   \n\nSee Also\n   bin_packing / 4"},"fd_global:bin_packing/4":{"prefix":"bin_packing","body":"bin_packing(${1:ItemBins}, ${2:ItemSizes}, ${3:M}, ${4:BinSize})$5\n$0","description":"bin_packing(+ItemBins, ++ItemSizes, +M, +BinSize)\n\n   The one-dimensional bin packing constraint: packing N items into M bins\n\nArguments\n   ItemBins    A collection of N variables or integers (domain/value between 1 and M)\n   ItemSizes    A collection of N non-negative integers\n   M    A non-negative Integer, the number of bins\n   BinSize    A non-negative integer\n\nType\n   library(fd_global)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack N\n   items with individual sizes into M bins, such that the sum of sizes of \n   items in each bin does not exceed BinSize. Each element of ItemBins and its \n   corresponding element in ItemSizes represents an item, such that the i'th \n   element of ItemSizes is the size of the i'th item, and the i'th element in\n   ItemBins is the bin this item is packed into. \n\n   This constraint can be seen as a special case of the cumulative/4\n   constraint, where all task durations are equal to 1, each bin\n   represents a time point, and BinSize corresponds to the Resource.\n\n   This constraint and the algorithm used to implement it is described in\n   P. Shaw, 'A Constraint for Bin Packing', CP'2004, with a fixed size for \n   the bins. It is also described in the global constraint catalog as \n   bin_packing, but with slightly different arguments: in the catalog, M\n   (the number of bins) is implicitly defined by the domain of the variables \n   in ItemBins, and the representation of item is grouped into a single\n   argument of collection of pairs, each pair representing an item:\n   the bin to pack the item, and its size.\n\nSee Also\n   bin_packing / 3, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"fd_global:bool_channeling/3":{"prefix":"bool_channeling","body":"bool_channeling(${1:Var}, ${2:DomainBools}, ${3:Min})$4\n$0","description":"bool_channeling(?Var, +DomainBools, +Min)\n\n   Channel the domain values of Vars to the 0/1 boolean variables in DomainBools\n\nArguments\n   Var    An integer domain variable\n   DomainBools    A collection of N 0/1 domain variables or integers\n   Min    An integer\n\nType\n   library(fd_global)\n\nDescription\n\n    Var is an integer domain variable whose initial interval is Min..(Min+N),\n    and this constraint links the domain values of Var with the N 0/1\n    variables in DomainBools such that the i'th variable in DomainBools\n    represents the value Min+i, and its value is 0 if the value is not in\n    Var's domain, and 1 if Var is assigned the value [Thus, only one variable\n    in DomainBools can take the value 1].\n\n    A variant of this constraint, called 'domain_constraint' is in the global \n    constraint catalog. There, instead of having DomainBools and Min, there\n    is a collection of Value-Bool pairs, representing a possible domain value\n    and its associated 0/1 variable. The implementation here is described in\n    the graph model for the domain_constraint in the catalog, and is \n    generalised arc-consistent."},"fd_global:inverse/2":{"prefix":"inverse","body":"inverse(${1:Succ}, ${2:Pred})$3\n$0","description":"inverse(+Succ, +Pred)\n\n   Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph\n\nArguments\n   Succ    A collection of N different variables or integers\n   Pred    A collection  of N different variables or integers\n\nType\n   library(fd_global)\n\nDescription\n\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predessor node, and\n     that if node y is the successor of node x, then node x is the\n     predecessor of node y.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensive and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list."},"fd_global:lex_le/2":{"prefix":"lex_le","body":"lex_le(${1:List1}, ${2:List2})$3\n$0","description":"lex_le(+List1, +List2)\n\n   List1 is lexicographically less or equal to List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(fd_global)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails.\n\nExamples\n       L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]).\t\t% X::0..2\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X=2.\t% Y::0..3\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X#>2.\t% fail\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X#<2.\t% true\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y=3.\t% X::0..2\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y#>3.\t% X::0..1\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y#<3.\t% X::0..2\n    lex_le([2, 3, 1], [3]).\t\t\t\t\t% true\n    \n\nSee Also\n   ordered / 2, ic_global : lex_le / 2, gfd : lex_le / 2, ic_global_gac : lex_le / 2, fd_global_gac : lex_le / 2, lex_lt / 2"},"fd_global:lex_lt/2":{"prefix":"lex_lt","body":"lex_lt(${1:List1}, ${2:List2})$3\n$0","description":"lex_lt(+List1, +List2)\n\n   List1 is lexicographically less than  List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(fd_global)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached) is strictly smaller than any existing element.\n\nSee Also\n   ordered / 2, ic_global : lex_lt / 2, gfd : lex_lt / 2, ic_global_gac : lex_lt / 2, fd_global_gac : lex_lt / 2, lex_le / 2"},"fd_global:maxlist/2":{"prefix":"maxlist","body":"maxlist(${1:List}, ${2:Max})$3\n$0","description":"maxlist(+List, ?Max)\n\n   Max is the maximum of the values in List\n\nArguments\n   List    Collection of integers or domain variables\n   Max    Variable or integer\n\nType\n   library(fd_global)\n\nDescription\n\tMax is the maximum of the values in List.  Operationally: \n\tMax gets updated to reflect the current range of the maximum\n\tof variables and values in List.  Likewise, the list\n\telements get constrained to the maximum given.\n\nSee Also\n   minlist / 2, sumlist / 2, lists : collection_to_list / 2"},"fd_global:minlist/2":{"prefix":"minlist","body":"minlist(${1:List}, ${2:Min})$3\n$0","description":"minlist(+List, ?Min)\n\n   Min is the minimum of the values in List\n\nArguments\n   List    Collection of integers or domain variables\n   Min    Variable or integer\n\nType\n   library(fd_global)\n\nDescription\n    \tMin is the minimum of the values in List.  Operationally: \n\tMin gets updated to reflect the current range of the minimum\n\tof variables and values in List.  Likewise, the list\n\telements get constrained to the minimum given\n\nSee Also\n   maxlist / 2, sumlist / 2, lists : collection_to_list / 2"},"fd_global:occurrences/3":{"prefix":"occurrences","body":"occurrences(${1:Value}, ${2:Vars}, ${3:N})$4\n$0","description":"occurrences(++Value, +Vars, ?N)\n\n   The value Value occurs in Vars N times\n\nArguments\n   Value    Atomic term\n   Vars    Collection (a la collection_to_list/2) of atomic terms or domain variables\n   N    Variable or integer\n\nType\n   library(fd_global)\n\nDescription\n    \t  The value Value occurs in Vars N times.  Operationally:  N\n\t  gets updated to reflect the number of possible occurrences in the\n\t  collection.  Collection elements may get instantiated to Value, or\n\t  Value may be removed from their domain if required by N.\n\nSee Also\n   atleast / 3, atmost / 3, lists : collection_to_list / 2"},"fd_global:ordered/2":{"prefix":"ordered","body":"ordered(${1:Relation}, ${2:List})$3\n$0","description":"ordered(++Relation, +List)\n\n   Constrains List to be ordered according to Relation\n\nArguments\n   Relation    One of the atoms <, =<, >, >=, =\n   List    Collection of integers or domain variables\n\nType\n   library(fd_global)\n\nSee Also\n   lex_le / 2, ordered_sum / 2, sorted / 2, lists : collection_to_list / 2"},"fd_global:ordered_sum/2":{"prefix":"ordered_sum","body":"ordered_sum(${1:List}, ${2:Sum})$3\n$0","description":"ordered_sum(+List, ?Sum)\n\n   The list elements are ordered and their sum is Sum\n\nArguments\n   List    List of integers or domain variables\n   Sum    Variable or integer\n\nType\n   library(fd_global)\n\nDescription\n    This constraint is declaratively equivalent to:\n\n\tordered_sum(List, Sum) :-\n\t    ordered(=\n    However, additional propagation is performed.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nSee Also\n   ordered / 2, sumlist / 2"},"fd_global:sequence_total/6":{"prefix":"sequence_total","body":"sequence_total(${1:Min}, ${2:Max}, ${3:Low}, ${4:High}, ${5:K}, ${6:ZeroOnes})$7\n$0","description":"sequence_total(+Min, +Max, +Low, +High, +K, +ZeroOnes)\n\n   The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes, and the total occurrences of 1 in ZeroOnes is between Min and Max\n\nArguments\n   Min    Non-negative integer\n   Max    Positive integer\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   ZeroOnes    A list of 0/1 variables or integers\n\nType\n   library(fd_global)\n\nDescription\n\n    This constraint ensures that the number of occurrences of the value 1 is \n    at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes, and at least Min and at most Max in total \n    for all ZeroOnes. ZeroOnes are 0/1 variables (or integers), i.e. they \n    have the domain [0,1].\n\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. For example,\n    sequence_total/7 is implemented by linking the N ZeroOnes variables to  \n    a matching collection of N finite domain `original' variables using \n    element/3 constraints to constrain the ZeroOnes to be 1 if the \n    corresponding original value takes one of the specified values. The\n    ZeroOnes can then be used in further constraint reasoning.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence_total / 7, fd : element / 3, fd_global_gac : sequence / 4, fd_global_gac : sequence / 5"},"fd_global:sequence_total/7":{"prefix":"sequence_total","body":"sequence_total(${1:Min}, ${2:Max}, ${3:Low}, ${4:High}, ${5:K}, ${6:Vars}, ${7:Values})$8\n$0","description":"sequence_total(+Min, +Max, +Low, +High, +K, +Vars, ++Values)\n\n   The number of values taken from Values is between Low and High for all sequences of K variables in Vars, and the total occurrence of each value in Vars is between Min and Max\n\nArguments\n   Min    Non-negative integer\n   Max    Positive integer\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   Vars    A list of variables or integers\n   Values    A list of (different) integers\n\nType\n   library(fd_global)\n\nDescription\n\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars, and at least Min and at most\n    Max in total for all Vars.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence_total / 6, fd : element / 3, fd_global_gac : sequence / 4, fd_global_gac : sequence / 5"},"fd_global:sorted/2":{"prefix":"sorted","body":"sorted(${1:List}, ${2:Sorted})$3\n$0","description":"sorted(?List, ?Sorted)\n\n   Sorted is a sorted permutation of List\n\nArguments\n   List    List of domain variables or integers\n   Sorted    List of domain variables or integers\n\nType\n   library(fd_global)\n\nDescription\n    Declaratively: The two lists have the same length and Sorted is a\n    sorted permutation of List.\n\n    Operationally:  the elements in both lists are constrained such\n    that their domains are consistent with the assumption that the\n    list Sorted is the sorted version of the list List.\n\n    One of the two arguments can be uninstantiated or partial lists\n    at call time.\n\n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n    \n\nModes and Determinism\n   sorted(+, +)\n   sorted(+, -)\n   sorted(-, +)\n\nExamples\n   \n    ?- length(Xs,4), Xs::0..100, sorted(Xs,Ys), Xs = [8,20|_].\n\n    Xs = [8, 20, _340{[0..100]}, _353{[0..100]}]\n    Ys = [_431{[0..8]}, _413{[0..20]}, _523{[8..100]}, _621{[20..100]}]\n\n    ?- length(Ys,4), Ys::0..100, sorted(Xs,Ys), Ys = [8,20|_].\n\n    Xs = [_464{[8..100]}, _477{[8..100]}, _490{[8..100]}, _503{[8..100]}]\n    Ys = [8, 20, _340{[20..100]}, _353{[20..100]}]\n    \n\nSee Also\n   sorted / 3, ordered / 2"},"fd_global:sorted/3":{"prefix":"sorted","body":"sorted(${1:List}, ${2:Sorted}, ${3:Positions})$4\n$0","description":"sorted(?List, ?Sorted, ?Positions)\n\n   Sorted is a sorted permutation (described by Positions) of List\n\nArguments\n   List    List of domain variables or integers\n   Sorted    List of domain variables or integers\n   Positions    List of domain variables or integers\n\nType\n   library(fd_global)\n\nDescription\n    Declaratively:  Sorted is a sorted permutation of List.  Positions\n    is a list whose elements range from 1 to N (where N is the length\n    of the lists) indicating the position of each unsorted list\n    element within the sorted list.  The positions are all different. \n    The three lists are constrained to have the same length.\n\n    Operationally:  the elements in all three lists are constrained\n    such that their domains are consistent with the declarative\n    meaning.\n\n    Two of the three arguments can be uninstantiated or partial lists\n    at call time.\n\n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n    \n\nModes and Determinism\n   sorted(+, ?, ?)\n   sorted(?, +, ?)\n   sorted(?, ?, +)\n\nExamples\n   \n    ?- length(Xs,4), Xs::0..100, sorted(Xs,Ys,Ps), Xs = [8,20|_].\n\n    Xs = [8, 20, _346{[0..100]}, _359{[0..100]}]\n    Ys = [_445{[0..8]}, _427{[0..20]}, _537{[8..100]}, _635{[20..100]}]\n    Ps = [_882{[1..3]}, _895{[2..4]}, _908{[1..4]}, _921{[1..4]}]\n    \n\nSee Also\n   sorted / 2, ordered / 2"},"fd_prop_test_util:make_n_random_seeds/2":{"prefix":"make_n_random_seeds","body":"make_n_random_seeds(${1:NSeeds}, ${2:Seeds})$3\n$0","description":"make_n_random_seeds(+NSeeds, -Seeds)\n\n   Create random seeds for seed/1\n\nArguments\n   NSeeds    Number of seeds (integer)\n   Seeds    List of seeds (output)\n\nType\n   library(fd_prop_test_util)\n\nModes and Determinism\n   make_n_random_seeds(+, -) is det"},"fd_global:sumlist/2":{"prefix":"sumlist","body":"sumlist(${1:List}, ${2:Sum})$3\n$0","description":"sumlist(+List, ?Sum)\n\n   The sum of the list elements is Sum\n\nArguments\n   List    List of integers or domain variables\n   Sum    Variable or integer\n\nType\n   library(fd_global)\n\nDescription\n    \t  The sum of the list elements is Sum.  This constraint is\n\t  more efficient than the general arithmetic constraint if\n\t  the list is long and Sum is not constrained frequently.\n\t  \n\t  Any input variables which do not already have finite bounds will\n\t  be given default bounds of -10000000 to 10000000.\n\nSee Also\n   ordered / 2, ordered_sum / 2, fd : #= / 2, ic : #= / 2, suspend : #= / 2, gfd : #= / 2"},"fd_prop_test_util:make_n_random_variables/4":{"prefix":"make_n_random_variables","body":"make_n_random_variables(${1:NVars}, ${2:Min}, ${3:Max}, ${4:Vars})$5\n$0","description":"make_n_random_variables(+NVars, +Min, +Max, -Vars)\n\n   Create random domain variables\n\nArguments\n   NVars    Number of variables to create (integer)\n   Min    Minimum lower domain bound (integer)\n   Max    Maximum upper domain bound (integer)\n   Vars    List of variables (output)\n\nType\n   library(fd_prop_test_util)\n\nModes and Determinism\n   make_n_random_variables(+, +, +, -) is det"},"fd_prop_test_util:random_bound_reduction_test/2":{"prefix":"random_bound_reduction_test","body":"random_bound_reduction_test(${1:Out}, ${2:Goal})$3\n$0","description":"random_bound_reduction_test(+Out, +Goal)\n\n   Run and keep waking a constraint until ground\n\nArguments\n   Out    An output stream for printing the execution protocol\n   Goal    A goal, usually a constraint with domain variables\n\nType\n   library(fd_prop_test_util)\n\nDescription\n\n    This utility shows constraint propagation at work.  Goal should be\n    a constraint involving domain variables.  The Goal is first called,\n    i.e. the constraint is being set up.  Then (if it does not fail),\n    some of its variables are reduced in their domains, which may lead\n    to the Goal waking up and propagating the domain changes.  This\n    process is repeated until either the Goal fails, or all variables\n    are instantiated and the goal succeeds.\n\n    Throughout the process, a protocol is printed to the Out stream.\n    Output lines are marked with C (initial call), P (propagation result)\n    or L (imposed domain reduction, or labeling), and display the\n    corresponding state of the constraint with its variable domains.\n\n    Domain reductions are chosen randomly: in each step, 1 to 3 variables\n    are selected randomly, and each receives a random domain reduction\n    (upper and/or lower bound).  To create a reproducible sequence, it\n    is recommended to invoke seed/1 beforehand.\n\nModes and Determinism\n   random_bound_reduction_test(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- [X,Y]::1..3, random_bound_reduction_test(output, alldifferent([X,Y])).\n    C alldifferent([_{1 .. 3}, _{1 .. 3}])\n    P alldifferent([_{1 .. 3}, _{1 .. 3}])\n    L alldifferent([_{1 .. 3}, _{[1, 2]}])\n    L alldifferent([_{[1, 2]}, 1])\n    P alldifferent([2, 1])\n    yes.\n\nSee Also\n   random_bound_reduction_test / 3"},"fd_prop_test_util:random_bound_reduction_test/3":{"prefix":"random_bound_reduction_test","body":"random_bound_reduction_test(${1:Out}, ${2:Goal}, ${3:Vars})$4\n$0","description":"random_bound_reduction_test(+Out, +Goal, +Vars)\n\n   Run and keep waking a constraint until ground\n\nArguments\n   Out    An output stream for printing the execution protocol\n   Goal    A goal, usually a constraint with domain variables\n   Vars    Subset of Goal's variables to be domain-reduced\n\nType\n   library(fd_prop_test_util)\n\nModes and Determinism\n   random_bound_reduction_test(+, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   random_bound_reduction_test / 2"},"fd_prop_test_util:random_int_between/3":{"prefix":"random_int_between","body":"random_int_between(${1:Min}, ${2:Max}, ${3:X})$4\n$0","description":"random_int_between(+Min, +Max, -X)\n\n   Create random integer\n\nArguments\n   Min    Minimum value (integer)\n   Max    Maximum value (integer)\n   X    Random value (output integer)\n\nType\n   library(fd_prop_test_util)\n\nModes and Determinism\n   random_int_between(+, +, -) is det"},"fd:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:List})$2\n$0","description":"alldifferent(?List)\n\n   The elements of the list List are pairwise different.\n\nArguments\n   ?List    A list of integers and domain variables.\n\nType\n   library(fd)\n\nDescription\n   This constraint imposes the constraint ##/2 on every pair of element of\n   List.\n\nFail Conditions\n      Fails if two element of the list are equal.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2, ## / 2, fd_global : alldifferent / 1"},"fd:alldistinct/1":{"prefix":"alldistinct","body":"alldistinct(${1:List})$2\n$0","description":"alldistinct(?List)\n\n   The elements of the list List are pairwise different.\n\nArguments\n   ?List    A list of integers and domain variables.\n\nType\n   library(fd)\n\nDescription\n\tThis constraint imposes the constraint ##/2 on every pair of\n\telement of List.  It is just a compatibility alias for alldifferent/1.\n\nFail Conditions\n      Fails if two element of the list are equal.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2, ## / 2, alldifferent / 1"},"fd:atmost/3":{"prefix":"atmost","body":"atmost(${1:N}, ${2:List}, ${3:V})$4\n$0","description":"atmost(+N, ?List, +V)\n\n   At most N elements of the list List have the value V.\n\nArguments\n   +N    An integer\n   ?List    A list of domain variables or integers\n   +V    An integer\n\nType\n   library(fd)\n\nDescription\n   If List is a list of domain variables and/or integers, this constraint\n   takes care that at most N element of this list have the value V. As soon\n   as some domain variable from the list is updated, this constraint is\n   woken and it checks if the constraint is still satisfiable and if so, if\n   it is already satisfied or not.\n\nFail Conditions\n      Fails if more than N elements of List are instantiated to V.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2, ## / 2, element / 3"},"fd:constraints_number/2":{"prefix":"constraints_number","body":"constraints_number(${1:Var}, ${2:N})$3\n$0","description":"constraints_number(?Var, ?N)\n\n   The number of constraints and suspended goals associated with the variable\nVar is N.\n\nArguments\n   ?Var    Prolog term\n   ?N    Variable or integer\n\nType\n   library(fd)\n\nDescription\n   N is the number of constraints and suspended goals currently attached to\n   the variable Var.  Note that this number may not correspond to the exact\n   number of different constraints attached to Var, as goals in different\n   suspending lists are counted separately.  This predicate is often used\n   when looking for the most or least constrained variable from a set of\n   domain variables.  If Var is instantiated, N is bound to a very large\n   integer, if Var is a free variable, N is zero.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2, deleteff / 3, deleteffc / 3"},"fd:default_domain/1":{"prefix":"default_domain","body":"default_domain(${1:Var})$2\n$0","description":"default_domain(-Var)\n\n   This predicate is called to assign a default domain to a free variable Var\nwhich occurs in arithmetic constraints.\n\nArguments\n   -Var    \n   A    variable\n\nType\n   library(fd)\n\nDescription\n   This is a simple hook predicate which allows the user to modify the\n   domain which is by default assigned to domainless variables that occur\n   in arithmetic constraints.  When such a variable is encountered, this\n   predicate is invoked and it must give the variable an integer finite\n   domain.  To modify the default domain, it is necessary to recompile this\n   predicate in the module fd_arith.\n\nFail Conditions\n      None\n\nResatisfiable\n      No.\n\nExamples\n   \n   [eclipse 13]: A #> B.\n   A = A[-9999999..10000000]\n   B = B[-10000000..9999999]\n   ...\n   [eclipse 14]: compile(user, fd_arith).\n   default_domain(X) :- X::0..100000000.\n   user       compiled traceable 56 bytes in 0.00 seconds\n   yes.\n   [eclipse 20]: X #> Y.\n   X = X[1..100000000]\n   Y = Y[0..99999999]\n\nSee Also\n   new_domain_var / 1, :: / 2, #:: / 2"},"fd:deleteff/3":{"prefix":"deleteff","body":"deleteff(${1:Var}, ${2:List}, ${3:Rest})$4\n$0","description":"deleteff(?Var, +List, -Rest)\n\n   Select from List the variable Var which has the smallest domain and return\nthe rest of the list.\n\nArguments\n   -Var    A variable.\n   -Rest    A term unifying with a list of domain variables or integers.\n   +List    A list of domain variables or integers.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used in the labeling procedures.  When we look for the\n   instantiation of a list of domain variables which is consistent with a\n   set of constraints, it is better to start with instantiations which are\n   most likely to fail, because this will cut down the size of the search\n   space considerably.\n\n   The predicate deleteff/3 selects the variable with the smallest\n   domain. If there are several variables with the same domain size,\n   the leftmost one in the list is taken. Constants are treated like\n   variables of domain size one. The list Rest is the same as List\n   except that the selected element is missing. In particular, any\n   existing list order is preserved.\n\nFail Conditions\n      Fails if List is nil.\n\nResatisfiable\n      No.\n\nSee Also\n   deleteffc / 3, indomain / 1, fd_search : search / 6"},"fd:deleteffc/3":{"prefix":"deleteffc","body":"deleteffc(${1:Var}, ${2:List}, ${3:Rest})$4\n$0","description":"deleteffc(?Var, +List, -Rest)\n\n   Select from List the variable Var which has the smallest domain and most\nconstraints and return the rest of the list.\n\nArguments\n   -Var    A variable.\n   -Rest    A term unifying with a list of domain variables or integers.\n   +List    A list of domain variables or integers.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used in the labeling procedures.  When we look for the\n   instantiation of a list of domain variables which is consistent with a\n   set of constraints, it is better to start with instantiations which are\n   most likely to fail, because this will cut down the size of the search\n   space considerably.  The predicate deleteffc/3 selects among the\n   variables with the smallest domain that one which has most constraints\n   attached to it.  This choice is based on the heuristics that variables\n   with more constraints are more likely to fail when instantiated.\n\n   If several variables are equally eligible, the leftmost one in the\n   list is taken.  Constants are treated like variables of domain size\n   one with no constraints attached.  The list Rest is the same as\n   List except that the selected element is missing.  In particular,\n   any existing list order is preserved.\n\nFail Conditions\n      Fails if List is nil.\n\nResatisfiable\n      No.\n\nSee Also\n   constraints_number / 2, deleteff / 3, indomain / 1, fd_search : search / 6"},"fd:deletemin/3":{"prefix":"deletemin","body":"deletemin(${1:Var}, ${2:List}, ${3:Rest})$4\n$0","description":"deletemin(?Var, +List, -Rest)\n\n   Select from List the variable Var which has the smallest lower domain bound,\nand return the rest of the list.\n\nArguments\n   -Var    A variable.\n   -Rest    A term unifying with a list of domain variables or integers.\n   +List    A list of domain variables or integers.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used in labeling procedures.  Especially when labeling\n   start times in scheduling problems, it is often a good strategy to start\n   with the earliest possible tasks, because fixing those will cause useful\n   bounds propagation on the start times of the other tasks. This predicate\n   selects from a list the variable with the smallest lower bound. Numbers\n   are treated as if they were variables with singleton domains.\n\nFail Conditions\n      Fails if List is empty.\n\nResatisfiable\n      No.\n\nExamples\n   \n   start_time_labeling([]) :- !.\n   start_time_labeling(Vars) :-\n    deletemin(X, Vars, Rest),\n\tindomain(X),\n\tstart_time_labeling(Rest).\n\nSee Also\n   deleteff / 3, deleteffc / 3, indomain / 1, labeling / 1"},"fd:disjunction/5":{"prefix":"disjunction","body":"disjunction(${1:Start1}, ${2:Duration1}, ${3:Start2}, ${4:Duration2}, ${5:Flag})$6\n$0","description":"disjunction(?Start1, +Duration1, ?Start2, +Duration2, ?Flag)\n\n   Flag indicates which of the two non-overlapping tasks is scheduled as\nfirst.  Either the one with starting time Start1 and duration Duration1\n(then the value of Flag is 1), or the second one with starting time Start2\nand duration Duration2 (and the Flag is 2).\n\nArguments\n   ?Start1    A finite domain variable or integer\n   +Duration1    An integer\n   ?Start2    A finite domain variable or integer\n   +Duration2    An integer\n   ?Flag    A finite domain variable or integer\n\nType\n   library(fd)\n\nDescription\n   This constraint can be used to model two non-overlapping tasks with\n   known durations.  Given the starting times and durations, this\n   constraint uses constructive disjunction to remove all inconsistent\n   values from the domains of Start1 and Start2.  In addition to\n   maintaining their bounds in a consistent state, it also locally executes\n   both cases (first task before the second one or voce versa) and removes\n   all values which are not consistent with any of these two alternatives.\n\n   If Duration1 or Duration2 is not integer, it obtains a default domain.\n\nFail Conditions\n      Fails if there is no possibility to schedule given two tasks in any\n   order under given conditions.\n\nResatisfiable\n      No.\n\nExamples\n   \n   [eclipse 5]: [X, Y]::1..10, disjunction_choose(X, 5, Y, 7, F).\n   X = X[1..10]\n   Y = Y[1..10]\n   F = F[1, 2]\n   Delayed goals:\n   disjunction_choose_1(X[1..10], 5, Y[1..10], 7, F[1, 2])\n   yes.\n   [eclipse 6]: [X, Y]::1..10, disjunction(X, 5, Y, 7, F).\n   X = X[1..5, 8..10]\n   Y = Y[1..3, 6..10]\n   F = F\n   Delayed goals:\n   disjunction(X[1..5, 8..10], 5, Y[1..3, 6..10], 7, F)\n   yes.\n\nSee Also\n   disjunctive / 3, disjunction_choose / 5"},"fd:disjunction_choose/5":{"prefix":"disjunction_choose","body":"disjunction_choose(${1:Start1}, ${2:Duration1}, ${3:Start2}, ${4:Duration2}, ${5:Flag})$6\n$0","description":"disjunction_choose(?Start1, +Duration1, ?Start2, +Duration2, ?Flag)\n\n   Flag indicates which of the two non-overlapping tasks is scheduled as\nfirst.  Either the one with starting time Start1 and duration Duration1\n(then the value of Flag is 1), or the second one with starting time Start2\nand duration Duration2 (and the Flag is 2).\n\nArguments\n   ?Start1    A finite domain variable or integer\n   +Duration1    An integer\n   ?Start2    A finite domain variable or integer\n   +Duration2    An integer\n   ?Flag    A variable or integer\n\nType\n   library(fd)\n\nDescription\n   This constraint can be used, if there are two tasks that have to be\n   scheduled on the same machine.  It states which of the two tasks given\n   by their starting times and durations is scheduled as first.  It is\n   activated whenever the maximum or minimum of domain variables Start1 or\n   Start2 resp.  changes or the Flag is set to an integer.\n\nFail Conditions\n      Fails if there is no possibility to schedule given two tasks in any\n   order under given conditions.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- Duration1 or Duration2 is not instantiated.\n     5 --- Duration1 or Duration2 or Flag is instantiated but not an    integer.\n\nExamples\n   \n   [eclipse 5]: [X, Y]::1..10, disjunction_choose(X, 5, Y, 7, F).\n   X = X[1..10]\n   Y = Y[1..10]\n   F = F[1, 2]\n   Delayed goals:\n   disjunction_choose_1(X[1..10], 5, Y[1..10], 7, F[1, 2])\n   yes.\n   [eclipse 6]: [X, Y]::1..10, disjunction_choose(X, 5, Y, 7, 1).\n   X = X[1..5]\n   Y = Y[6..10]\n   Delayed goals:\n   Y[6..10] - X[1..5]#>=5\n   disjunction_choose_1(X[1..5], 5, Y[6..10], 7, 1)\n   yes.\n   [eclipse 8]: [X, Y]::1..5, disjunction_choose(X, 5, Y, 7, 2).\n   no (more) solution.\n\nSee Also\n   disjunctive / 3, disjunction / 5"},"fd:disjunctive/3":{"prefix":"disjunctive","body":"disjunctive(${1:Starts}, ${2:Durations}, ${3:Flags})$4\n$0","description":"disjunctive(?Starts, +Durations, ?Flags)\n\n   Succeeds if there exists a sequential ordering of non-overlapping tasks\nwith starting times Starts and durations Durations, with respect to the\nordering priorities of single pairs of tasks (elementary disjunctions)\nrepresented in the list Flags.\n\nArguments\n   ?Starts    A list of finite domain variables or integers\n   +Durations    A list of integers\n   ?Flags    A list of finite domain variables or integers\n\nType\n   library(fd)\n\nDescription\n   This constraint can be used by job-shop problems on single machine.  The\n   tasks to be scheduled on one machine are represented by their starting\n   times (Starts) and durations (Durations).  The actual ordering of tasks\n   is represented by list of priority flags (Flags).  The core constraint\n   performs an exhaustive scheme based on maximal subset using extended\n   Carlier and Pinson techniques.  This constraint reacts to reduction\n   events on the flags of the elementary disjunctions it is connected to,\n   in turn it might perform reductions on those flags.  It also updates\n   starting times of operations according to the necessary partial\n   orderings it discovers.\n\n   If some of the elements in the lists Starts or Flags is not ground, this\n   predicate delays.\n\nFail Conditions\n      Fails, if no possible ordering of given list of tasks exist.\n\nResatisfiable\n      No.\n\nExamples\n   \n   [eclipse 3]: [X, Y]::1..10, disjunctive([X, Y], [5, 7], F).\n   X = X[1..10]\n   Y = Y[1..10]\n   F = [_g1124[1, 2]]\n   Delayed goals:\n   disjunction_choose_1(X[1..10], 5, Y[1..10], 7, _g1124[1, 2])\n   disjunctive(starts(X[1..10], Y[1..10]), durations(5, 7), [_g1124[1, 2]],\n   flags(_g998, _g1124, _g1002, _g1004))\n   yes.\n   [eclipse 3]: [X, Y, Z]::1..10, disjunctive([X, Y, Z], [3, 7, 5], [1, 2,\n   1]).\n   no (more) solution.\n   [eclipse 4]: [X, Y, Z]::1..10, disjunctive([X, Y, Z], [3, 7, 5], [1, 1,\n   2]).\n   X = X[1, 2]\n   Y = Y[9, 10]\n   Z = Z[4, 5]\n   Delayed goals:\n   Y[9, 10] - X[1, 2]#>=3\n   Y[9, 10] - Z[4, 5]#>=5\n   Z[4, 5] - X[1, 2]#>=3\n   Z[4, 5] - X[1, 2]#>=3\n   disjunction_choose_1(X[1, 2], 3, Z[4, 5], 5, 1)\n   disjunction_choose_1(X[1, 2], 3, Y[9, 10], 7, 1)\n   disjunction_choose_1(Y[9, 10], 7, Z[4, 5], 5, 2)\n   disjunctive(starts(X[1, 2], Y[9, 10], Z[4, 5]), durations(3, 7, 5), [1,\n   1, 2], flags(_g1080, 1, 1, _g1086, _g1088, 2, _g1092, _g1094, _g1096))\n   yes.\n\nSee Also\n   disjunction_choose / 5"},"fd:dom/2":{"prefix":"dom","body":"dom(${1:Var}, ${2:List})$3\n$0","description":"dom(+Var, ?List)\n\n   List is the list of elements in the domain of Var.\n\nArguments\n   +Var    A domain variable or an integer.\n   ?List    Term unifying with a list of integers.\n\nType\n   library(fd)\n\nDescription\n   If Var is a domain variable, List is unified with a sorted list of all\n   elements in its domain.  If Var is an integer, List is unified with a\n   singleton list.\n\n   The predicates ::/2 and #::/2 can also be used to query the domain of a domain\n   variable, however they yield a list of integer intervals, which is the\n   direct domain representation (it is therefore also more efficient\n   because no new structures have to be created).\n\n   Use this predicate with care, because it might expand a compact\n   representation of large intervals into an explicit list of their\n   elements.  Unless an explicit list representation of the domain is\n   really required, the predicates working on domains should be preferred.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- Var is not a domain variable.\n\nExamples\n   \n   [eclipse 9]: X::[1..3, 100..102], dom(X, List), X::I.\n   List = [1, 2, 3, 100, 101, 102]\n   X = X :: [1 .. 3, 100 .. 102]\n   I = [1 .. 3, 100 .. 102]\n   yes.\n\nSee Also\n   :: / 2, #:: / 2, maxdomain / 2, mindomain / 2"},"fd:dom_check_in/2":{"prefix":"dom_check_in","body":"dom_check_in(${1:Element}, ${2:Dom})$3\n$0","description":"dom_check_in(+Element, +Dom)\n\n   Element is in the domain Dom.\n\nArguments\n   +Element    A Prolog term.\n   +Dom    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   Succeed if the term Element is in the domain Dom.\n\nFail Conditions\n      Fails if the element does not occur in the domain.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_compare / 3, dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dom_compare/3":{"prefix":"dom_compare","body":"dom_compare(${1:Res}, ${2:Dom1}, ${3:Dom2})$4\n$0","description":"dom_compare(?Res, +Dom1, +Dom2)\n\n   Res is the result of the comparison of the domains Dom1 and Dom2.\n\nArguments\n   ?Res    Atom or variable.\n   +Dom1    A finite domain.\n   +Dom2    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   Works like compare/3 for terms.  Res is unified with\n\n  * = iff Dom1 is equal to Dom2,\n\n  * < iff Dom1 is a proper subset of Dom2,\n\n  * > iff Dom2 is a proper subset of Dom1.\n\nFail Conditions\n      Fails if neither domain is a subset of the other one.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dom_copy/2":{"prefix":"dom_copy","body":"dom_copy(${1:Dom1}, ${2:Dom2})$3\n$0","description":"dom_copy(+Dom1, -Dom2)\n\n   Dom2 is a copy of the domain Dom1.\n\nArguments\n   +Dom1    A finite domain.\n   -Dom2    A variable.\n\nType\n   library(fd)\n\nDescription\n   Dom2 is a copy of the domain Dom1.  Since the updates are done in-place,\n   two domain variables must not share the same physical domain and so when\n   defining a new variable with an existing domain, the domain has to be\n   copied first.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_compare / 3, dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dom_difference/4":{"prefix":"dom_difference","body":"dom_difference(${1:Dom1}, ${2:Dom2}, ${3:DomDiff}, ${4:Size})$5\n$0","description":"dom_difference(+Dom1, +Dom2, -DomDiff, -Size)\n\n   The domain DomDifference is Dom1 \\Dom2 and Size is the number of its\nelements.\n\nArguments\n   +Dom1    A finite domain.\n   +Dom2    A finite domain.\n   -DomDiff    A variable.\n   -Size    A variable.\n\nType\n   library(fd)\n\nDescription\n   The domain DomDifference is Dom1 \\Dom2 and Size is the number of its\n   elements.\n\nFail Conditions\n      Fails if Dom1 is a subset of Dom2.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_compare / 3, dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dom_intersection/4":{"prefix":"dom_intersection","body":"dom_intersection(${1:Dom1}, ${2:Dom2}, ${3:DomInt}, ${4:Size})$5\n$0","description":"dom_intersection(+Dom1, +Dom2, -DomInt, -Size)\n\n   The domain DomInt is the intersection of domains Dom1 and Dom2 and Size is\nthe number of its elements.\n\nArguments\n   +Dom1    A finite domain.\n   +Dom2    A finite domain.\n   -DomInt    A variable.\n   -Size    A variable.\n\nType\n   library(fd)\n\nDescription\n   The domain DomInt is the intersection of domains Dom1 and Dom2 and Size\n   is the number of its elements.\n\nFail Conditions\n      Fails if the intersection is empty.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_compare / 3, dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dom_member/2":{"prefix":"dom_member","body":"dom_member(${1:Element}, ${2:Dom})$3\n$0","description":"dom_member(?Element, +Dom)\n\n   Element is in the domain Dom.\n\nArguments\n   ?Element    A Prolog term.\n   +Dom    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   Successively instantiate Element to the values in the domain Dom\n   (similar to indomain/1).\n\nFail Conditions\n      None.\n\nResatisfiable\n      Yes.\n\nSee Also\n   dom_check_in / 2, indomain / 1"},"fd:dom_range/3":{"prefix":"dom_range","body":"dom_range(${1:Dom}, ${2:Min}, ${3:Max})$4\n$0","description":"dom_range(+Dom, ?Min, ?Max)\n\n   Return the minimum and maximum value in the integer domain Dom.\n\nArguments\n   +Dom    A finite domain.\n   ?Min    An integer or a variable.\n   ?Max    An integer or a variable.\n\nType\n   library(fd)\n\nDescription\n   Return the minimum and maximum value in the integer domain Dom.  This\n   predicate can also be used to test if a given domain is an integer one\n   or not.\n\nFail Conditions\n      Fails if Dom is a domain containing non-integer atomic elements.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_check_in / 2, is_integer_domain / 1"},"fd:dom_size/2":{"prefix":"dom_size","body":"dom_size(${1:Dom}, ${2:Size})$3\n$0","description":"dom_size(+Dom, ?Size)\n\n   Size is the number of elements in the domain Dom.\n\nArguments\n   +Dom    A finite domain.\n   ?Size    An integer or a variable.\n\nType\n   library(fd)\n\nDescription\n   Size is the number of elements in the domain Dom.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_check_in / 2, dom_range / 3, dvar_domain / 2"},"fd:dom_to_list/2":{"prefix":"dom_to_list","body":"dom_to_list(${1:Dom}, ${2:List})$3\n$0","description":"dom_to_list(+Dom, ?List)\n\n   List is the list of elements in the domain Dom.\n\nArguments\n   +Dom    A finite domain.\n   ?List    Term unifying with a list of integers.\n\nType\n   library(fd)\n\nDescription\n   List is unified with a sorted list of all elements in the domain Dom.\n\n   The predicates ::/2 and #::/2 can also be used to query the domain of a domain\n   variable, however they yield a list of integer intervals, which is the\n   direct domain representation (it is therefore also more efficient\n   because no new structures have to be created).\n\n   Use this predicate with care, because it might expand a compact\n   representation of large intervals into an explicit list of their\n   elements.  Unless an explicit list representation of the domain is\n   really required, the predicates working on domains should be preferred.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- Var is not a domain variable.\n\nExamples\n   \n   [eclipse 9]: X::[1..3, 100..102], dvar_domain(X, D), dom_to_list(D,\n   List), X::I.\n   D = [1..3, 100..102]\n   List = [1, 2, 3, 100, 101, 102]\n   X = X :: [1 .. 3, 100 .. 102]\n   I = [1 .. 3, 100 .. 102]\n   yes.\n\nSee Also\n   :: / 2, #:: / 2, maxdomain / 2, mindomain / 2"},"fd:dom_union/4":{"prefix":"dom_union","body":"dom_union(${1:Dom1}, ${2:Dom2}, ${3:DomUnion}, ${4:Size})$5\n$0","description":"dom_union(+Dom1, +Dom2, -DomUnion, -Size)\n\n   The domain DomUnion is the union of domains Dom1 and Dom2 and Size is the\nnumber of its elements.\n\nArguments\n   +Dom1    A finite domain.\n   +Dom2    A finite domain.\n   -DomUnion    A variable.\n   -Size    A variable.\n\nType\n   library(fd)\n\nDescription\n   The domain DomUnion is the union of domains Dom1 and Dom2 and Size is\n   the number of its elements.\n\n   Note that the main use of the predicate is to yield the most specific\n   generalisation of two domains, in the usual cases the domains become\n   smaller, not bigger.\n\nFail Conditions\n      Fails if the union is empty.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_compare / 3, dom_member / 2, dom_range / 3, dom_size / 2, dvar_domain / 2"},"fd:dvar_attribute/2":{"prefix":"dvar_attribute","body":"dvar_attribute(${1:DVar}, ${2:Attrib})$3\n$0","description":"dvar_attribute(+DVar, ?Attrib)\n\n   Attrib is the attribute of the domain variable DVar.\n\nArguments\n   +DVar    A domain variable.\n   ?Attrib    Any Prolog term.\n\nType\n   library(fd)\n\nDescription\n   Attrib is the attribute of the domain variable DVar.  If DVar is\n   instantiated, Attrib is bound to an attribute with a singleton domain\n   and empty suspension lists.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   #:: / 3, dvar_domain / 2, :: / 2, #:: / 2"},"fd:dvar_domain/2":{"prefix":"dvar_domain","body":"dvar_domain(${1:DVar}, ${2:Dom})$3\n$0","description":"dvar_domain(+DVar, -Dom)\n\n   Dom is the domain of the domain variable DVar.\n\nArguments\n   +DVar    A domain variable.\n   -Dom    A variable.\n\nType\n   library(fd)\n\nDescription\n   Dom is the domain of the domain variable DVar.  If DVar is instantiated,\n   Dom is bound to a singleton domain.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2"},"fd:dvar_msg/3":{"prefix":"dvar_msg","body":"dvar_msg(${1:DVar1}, ${2:DVar2}, ${3:MsgDVar})$4\n$0","description":"dvar_msg(+DVar1, +DVar2, -MsgDVar)\n\n   MsgDVar is a domain variable which is the most specific generalisation of\ndomain variables or atomic values DVar1 and DVar2.\n\nArguments\n   +DVar1    A finite domain or an atomic term.\n   +DVar2    A finite domain or an atomic term.\n   -MsgDVar    A free variable.\n\nType\n   library(fd)\n\nDescription\n   MsgVar is a domain variable which is the most specific generalisation of\n   domain variables or atomic values Var1 and Var2.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dom_union / 4, dom_intersection / 4, dvar_domain / 2"},"fd:dvar_range/3":{"prefix":"dvar_range","body":"dvar_range(${1:DVar}, ${2:Min}, ${3:Max})$4\n$0","description":"dvar_range(+DVar, ?Min, ?Max)\n\n   Return the minimum and maximum domain value of DVar\n\nArguments\n   +DVar    A domain variable or integer.\n   ?Min    An integer or a variable.\n   ?Max    An integer or a variable.\n\nType\n   library(fd)\n\nDescription\n\tReturn the minimum and maximum domain value of the domin\n\tvariable DVar.  This predicate can also be used to test if a\n\tgiven domain is an integer one or not. \n\tIf DVar is instantiated, Min and Max will be identical.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_domain / 2, dom_range / 3"},"fd:dvar_remove_element/2":{"prefix":"dvar_remove_element","body":"dvar_remove_element(${1:DVar}, ${2:El})$3\n$0","description":"dvar_remove_element(+DVar, +El)\n\n   The element El is removed from the domain of DVar and all concerned lists\nare woken.\n\nArguments\n   +DVar    A domain variable.\n   +El    An atomic term.\n\nType\n   library(fd)\n\nDescription\n   The element El is removed from the domain of DVar and all concerned\n   lists are woken.  If the resulting domain is empty, this predicate\n   fails.  If it is a singleton, DVar is instantiated.  If the domain does\n   not contain the element, no updates are made.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2"},"fd:dvar_remove_greater/2":{"prefix":"dvar_remove_greater","body":"dvar_remove_greater(${1:DVar}, ${2:El})$3\n$0","description":"dvar_remove_greater(+DVar, +El)\n\n   Remove all elements in the domain of DVar which are greater than the\ninteger El and wake all concerned lists.\n\nArguments\n   +DVar    A domain variable.\n   +El    An atomic term.\n\nType\n   library(fd)\n\nDescription\n   Remove all elements in the domain of DVar which are greater than the\n   integer El and wake all concerned lists.  If the resulting domain is\n   empty, this predicate fails, if it is a singleton, DVar is instantiated.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2"},"fd:dvar_remove_smaller/2":{"prefix":"dvar_remove_smaller","body":"dvar_remove_smaller(${1:DVar}, ${2:El})$3\n$0","description":"dvar_remove_smaller(+DVar, +El)\n\n   Remove all elements in the domain of DVar which are smaller than the\ninteger El and wake all concerned lists.\n\nArguments\n   +DVar    A domain variable.\n   +El    An atomic term.\n\nType\n   library(fd)\n\nDescription\n   Remove all elements in the domain of DVar which are smaller than the\n   integer El and wake all concerned lists.  If the resulting domain is\n   empty, this predicate fails, if it is a singleton, DVar is instantiated.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2"},"fd:dvar_replace/2":{"prefix":"dvar_replace","body":"dvar_replace(${1:DVar}, ${2:NewDom})$3\n$0","description":"dvar_replace(+DVar, +NewDom)\n\n   Change the domain of the domain variable DVar to NewDom without propagating\nthe changes.\n\nArguments\n   +DVar    A domain variable.\n   +NewDom    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   If the size of the domain NewDom is 0, the predicate fails.  If the size\n   of the new domain is 1, DVar is given this singleton domain.  Otherwise,\n   if the size of the new domain is smaller than the size of the domain\n   variable's domain, the domain of DVar is replaced by NewDom, but no\n   suspensions are passed to the waking scheduler.\n\n   This predicate is useful for local consistency checks.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2, dvar_update / 2"},"fd:dvar_update/2":{"prefix":"dvar_update","body":"dvar_update(${1:DVar}, ${2:NewDom})$3\n$0","description":"dvar_update(+DVar, +NewDom)\n\n   Change the domain of the domain variable DVar to NewDom and propagate the\nchanges.\n\nArguments\n   +DVar    A domain variable.\n   +NewDom    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   If the size of the domain NewDom is 0, the predicate fails.  If it is 1,\n   the domain variable DVar is instantiated to the value in the domain.\n   Otherwise, if the size of the new domain is smaller than the size of the\n   domain variable's domain, the domain of DVar is replaced by NewDom, the\n   appropriate suspension lists in its attribute are passed to the waking\n   scheduler and so is the constrained list in the suspend attribute of the\n   domain variable.  If the size of the new domain is equal to the old one,\n   no updates and no waking is done, i.e.  this predicate does not check an\n   explicit equality of both domains.  If the size of the new domain is\n   greater than the old one, an error is raised.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   dvar_attribute / 2, :: / 2, #:: / 2, dvar_replace / 2"},"fd:element/3":{"prefix":"element","body":"element(${1:Index}, ${2:List}, ${3:Value})$4\n$0","description":"element(?Index, +List, ?Value)\n\n   Value is the Index'th element of the integer list List.\n\nArguments\n   ?Index    A variable or an integer.\n   +List    A non-empty list of integers.\n   ?Value    A variable or an integer.\n\nType\n   library(fd)\n\nDescription\n   This constraints can be used in a variety of programs to state a\n   relation between two domain variables.  List is a list of integers and\n   the constraint states that its Index'th element is equal to Value, i.e.\n\n    List_Index = Value\n\n   Every time Index or Value is updated, this constraint is activated and\n   the domain of the other variable is updated accordingly.\n\nFail Conditions\n      Fails if Value is not the Index'th element of List.\n\nResatisfiable\n      No.\n\nExamples\n   \n   [eclipse 13]: element(I, [1,3,6,3], V).\n   I = I :: [1 .. 4]\n   V = V :: [1, 3, 6]\n   Delayed goals:\n   element(I :: [1 .. 4], t(1, 3, 6, 3), V :: [1, 3, 6], 4, 3)\n   yes.\n   [eclipse 14]: element(I, [1,3,6,3], V), V ## 3.\n   I = I :: [1, 3]\n   V = V :: [1, 6]\n   Delayed goals:\n   element(I :: [1, 3], t(1, 3, 6, 3), V :: [1, 6], 2, 2)\n   yes.\n\nSee Also\n   :: / 2, #:: / 2, atmost / 3"},"fd:fd_desc":{"prefix":"lib","body":"lib(${1:fd})$2\n$0","description":"lib(fd)\n\n    The library fd.pl implements constraints over finite domains that can\n    contain integer as well as atomic elements.  More detailed documentation\n    can be found in the 'Obsolete Libraries Manual', since this library is\n    now largely superseded by library(ic).\n    \n    Glossary\n    \n    domain variable\n\tA domain variable is a variable which can be instantiated only\n\tto a value from a given finite set.  Unification with a term\n\toutside of this domain fails.  The domain can be associated\n\twith the variable using the predicate ::/2.  Built-in\n\tpredicates that expect domain variables treat atomic and other\n\tground terms as variables with singleton domains.\n    \n    integer domain variable\n\tAn integer domain variable is a domain variable whose domain\n\tcontains only integer numbers.  Only such variables are\n\taccepted in inequality constraints and in rational terms. \n\tNote that a non-integer domain variable can become an integer\n\tdomain variable when the non-integer values are removed from\n\tits domain.\n    \n    integer interval\n\tAn integer interval is written as Min .. Max\n\twith integer expressions Min =< Max and it represents the set\n\t{Min, Min + 1, ..., Max}.\n    \n    linear term\n\tA linear term is a linear integer combination of integer\n\tdomain variables.  The constraint predicates accept linear\n\tterms even in a non-canonical form, containing functors +, -\n\tand *, e.g.  5*(3+(4-6)*Y-X*3).\n\tIf the constraint predicates encounter a variable without a\n\tdomain, they give it a default domain -10000000..10000000. \n\tNote that arithmetic operations on linear terms are performed\n\twith standard machine word integers without any overflow\n\tchecks.  If the domain ranges or coefficients are too large,\n\tthe operation will not yield correct results.  Both the\n\tmaximum and minimum value of a linear term must be\n\trepresentable in a machine word, and so must the maximum and\n\tminimum value of every ci xi term.\n    \n    rational term\n\tA rational term is a term constructed from integers and integer\n\tdomain variables using the arithmetic operations +, -, *, /,\n\tabs, min and max.  The nonlinear parts are handled by introducing\n\tan auxiliary constraint with a new result variable, and using this\n\tresult variable in the linear term context. Every subexpression\n\tof the form VarA/VarB must have an integer value in the solution.\n\tThe system replaces such a subexpression by a new variable X and\n\tadds a new constraint VarA #= VarB * X.  Similarly, all\n\tsubexpressions of the form VarA*VarB are replaced by a new\n\tvariable X and a new constraint X #= VarA * VarB is added,\n\tand similary for the functions abs/1, min/2 and max/2.\n    \n    constraint expression\n\tA constraint expression is either an arithmetic constraint or\n\ta combination of constraint expressions using the logical FD\n\tconnectives #/\\/2, #\\//2, #=>/2, #<=>/2, #\\+/1."},"fd:fd_eval/1":{"prefix":"fd_eval","body":"fd_eval(${1:C})$2\n$0","description":"fd_eval(?C)\n\n   Evaluate and state the constraint expression C.\n\nArguments\n   ?C    An arithmetic constraint expression.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used to enforce the evaluation of a given constraint\n   expression on runtime, without macro expansion.  This can be useful in\n   situation where the compile-time macro expansion cannot process its\n   argument properly, because it has no type and mode information about the\n   variable arguments.\n\nFail Conditions\n      Fails C fails.\n\nResatisfiable\n      No.\n\nSee Also\n   isd / 2"},"fd:indomain/1":{"prefix":"indomain","body":"indomain(${1:Var})$2\n$0","description":"indomain(?Var)\n\n   Instantiate Var to a value in its domain.\n\nArguments\n   ?Var    An integer or a domain variable\n\nType\n   library(fd)\n\nDescription\n   This predicate instantiates the domain variable Var to a value from its\n   domain.  Its starts with the smallest element in the domain and on\n   backtracking successive elements are taken.  It is used mostly to find\n   an instantiation of the variable which is consistent with the current\n   set of constraints in labeling procedures.  If List is a list of all\n   domain variables occurring in the program, the simplest labeling\n   procedure is written as\n\n    labeling([]).\n    labeling([Var|Rest]) :-\n    indomain(Var),\n    labeling(Rest).\n\nFail Conditions\n      None.\n\nResatisfiable\n      Yes.\n\nSee Also\n   :: / 2, #:: / 2, par_indomain / 1, labeling / 1, fd_search : search / 6"},"fd:integer_list_to_dom/2":{"prefix":"integer_list_to_dom","body":"integer_list_to_dom(${1:List}, ${2:Dom})$3\n$0","description":"integer_list_to_dom(+List, -Dom)\n\n   Convert a sorted list of integers and integer intervals into a domain Dom.\n\nArguments\n   +List    A list of integers and integer interval.\n   -Dom    Variable.\n\nType\n   library(fd)\n\nDescription\n   Convert a sorted list of integers and integer intervals into a domain\n   Dom.  List must be sorted and integers must not overlap with intervals.\n   Note that using sort/2 on a list of integers and intervals does not\n   produce correct results because intervals are considered compound terms\n   and thus sorted after all integers.  This predicate converts a list of\n   successive integers into an interval and/or merges it with adjacent\n   intervals.  Typically, it will be used to convert a sorted list of\n   integers into a list of intervals and an appropriate domain.  If the\n   list is already known to contain the right intervals, it is quicker to\n   use sorted_list_to_dom/2.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- List is not ground.\n     5 --- List contains an element which is neither integer nor an    integer interval.\n     6 --- The size of the resulting domain is too large.\n     6 --- The list is not sorted properly.\n\nSee Also\n   sorted_list_to_dom / 2, dvar_domain / 2"},"fd:integers/1":{"prefix":"integers","body":"integers(${1:Vars})$2\n$0","description":"integers(+Vars)\n\n   Constrains Vars to be integers.\n\nArguments\n   Vars    List of variables or integers.\n\nType\n   library(fd)\n\nDescription\n  Constrains the list Vars to be integers. If Vars contains non-domain \n  variable, such variables will be given the default domain.\n\nFail Conditions\n      Fails if Vars contains non-integers, or variables with non-integer domains.\n\nResatisfiable\n     No.\n\nExceptions\n     5 --- Vars is a variable."},"fd:is_domain/1":{"prefix":"is_domain","body":"is_domain(${1:Term})$2\n$0","description":"is_domain(?Term)\n\n   Succeeds if Term is a domain variable.\n\nArguments\n   ?Term    A Prolog term.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used to test if a term is a domain variable.\n\nFail Conditions\n      Fails if Term is not a domain variable.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2"},"fd:is_integer_domain/1":{"prefix":"is_integer_domain","body":"is_integer_domain(${1:Term})$2\n$0","description":"is_integer_domain(?Term)\n\n   Succeeds if Term is a domain variable with an integer domain.\n\nArguments\n   ?Term    A Prolog term.\n\nType\n   library(fd)\n\nDescription\n   This predicate is used to test if a term is a domain variable with an\n   integer domain.\n\nFail Conditions\n      Fails if Term is not an integer domain variable.\n\nResatisfiable\n      No.\n\nSee Also\n   is_domain / 1, :: / 2, #:: / 2"},"fd:labeling/1":{"prefix":"labeling","body":"labeling(${1:Vars})$2\n$0","description":"labeling(+Vars)\n\n   Instantiate all variables in a list to values in their domain\n\nArguments\n   Vars    List of variables or ground terms.\n\nType\n   library(fd)\n\nDescription\n    This predicate instantiates all variables in a list to values in their\n    domain, using the indomain/1 predicate. It is simply defined as:\n\n    labeling([]).\n    labeling([Var|Rest]) :-\n    indomain(Var),\n    labeling(Rest).\n\n    The list can contain ground terms, i.e. variables that are already\n    instantated. These are just skipped, in other words, they are\n    considered as variables with a single value in their domain.\n    \n\nResatisfiable\n   Yes\n\nSee Also\n   indomain / 1, fd_search : search / 6"},"fd:list_to_dom/2":{"prefix":"list_to_dom","body":"list_to_dom(${1:List}, ${2:Dom})$3\n$0","description":"list_to_dom(+List, -Dom)\n\n   Convert a list of atomic terms and integer intervals into a domain Dom.\n\nArguments\n   +List    A list of atomic terms and integer interval.\n   -Dom    Variable.\n\nType\n   library(fd)\n\nDescription\n   Convert a list of atomic terms and integer intervals into a domain Dom.\n   List does not have to be sorted and integers and intervals may overlap.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- List is not ground.\n     5 --- List contains an element which is neither atomic nor an    integer interval.\n     6 --- The size of the resulting domain is too large.\n     6 --- The lower bound of an integer interval is greater than its    upper bound.\n\nSee Also\n   sorted_list_to_dom / 2, dvar_domain / 2"},"fd:maxdomain/2":{"prefix":"maxdomain","body":"maxdomain(${1:Var}, ${2:Max})$3\n$0","description":"maxdomain(+Var, ?Max)\n\n   Max is the maximum element in the domain of Var.\n\nArguments\n   +Var    A domain variable or an integer.\n   ?Max    A variable or an integer.\n\nType\n   library(fd)\n\nDescription\n   If Var is a domain variable then Max is unified with the maximum value\n   in the domain of Var.  If Var is an integer then Max is unified with\n   Var.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   mindomain / 2, :: / 2, #:: / 2, dom_to_list / 2"},"fd:min_max/2":{"prefix":"min_max","body":"min_max(${1:Goal}, ${2:C})$3\n$0","description":"min_max(?Goal, ?C)\n\n   Find the solution of Goal that minimizes the maximum of elements of C.\n\nArguments\n   +Goal    A callable term.\n   ?C    A linear term or a list of linear terms.\n\nType\n   library(fd)\n\nDescription\n   If C is a linear term, a solution of the goal Goal is found that\n   minimizes the value of C. If C is a list of linear terms, the returned\n   solution minimizes the maximum value of terms in the list.  The solution\n   is found using the branch and bound method; as soon as a partial\n   solution is found that is worse than a previous solution, the search is\n   abandoned and a new solution is searched for.  Every time a new better\n   solution is found, the event 280 is raised, its default handler prints\n   the current cost.\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize / 8, deleteff / 3"},"fd:min_max/4":{"prefix":"min_max","body":"min_max(${1:Goal}, ${2:Template}, ${3:Solution}, ${4:C})$5\n$0","description":"min_max(+Goal, ?Template, ?Solution, ?C)\n\n   Find the solution of Goal that minimizes the maximum of elements of C,\nand unify the minimized Template with Solution.\n\nArguments\n   +Goal    A callable term.\n   ?Template    A term containing all or some of Goal's variables\n   ?Solution    Term to be unified with the minimized Template\n   ?C    A linear term or a list of linear terms.\n\nType\n   library(fd)\n\nDescription\n   If C is a linear term, a solution of the goal Goal is found that\n   minimizes the value of C. If C is a list of linear terms, the returned\n   solution minimizes the maximum value of terms in the list.  The solution\n   is found using the branch and bound method; as soon as a partial\n   solution is found that is worse than a previous solution, the search is\n   abandoned and a new solution is searched for.  Every time a new better\n   solution is found, the event 280 is raised, its default handler prints\n   the current cost.\n\n   Solutions will be unified with a copy of Template where the variables\n   are replaced with their minimized values. Typically, the Template will\n   contain all or a subset of Goal's variables.\n\n   min_max/2 can be written in terms of min_max/4 as follows:\n\n\tmin_max(Goal, Cost) :-\n\t    min_max(Goal, Goal, Goal, Cost).\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nExamples\n   \n    % Find the minimal C and bind X to the corresponding value\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), X, X, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = 3\n    C = 0\n    yes.\n\n    % Find the minimal C and don't bind anything\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), [], [], C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\n    % Find the minimal C and return it in MinC. Don't bind X or C.\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), C, MinC, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    MinC = 0\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\nSee Also\n   min_max / 2, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize / 8"},"fd:min_max/5":{"prefix":"min_max","body":"min_max(${1:Goal}, ${2:C}, ${3:Lower}, ${4:Upper}, ${5:Percent})$6\n$0","description":"min_max(?Goal, ?C, +Lower, +Upper, +Percent)\n\n   Find the solution of Goal that minimizes the maximum of elements of C,\nwithin the bounds set by Lower,Upper and Percent.\n\nArguments\n   ?Goal    A callable term.\n   ?C    A linear term or a list of linear terms.\n   +Lower    An integer.\n   +Upper    An integer.\n   +Percent    An integer.\n\nType\n   library(fd)\n\nDescription\n   If C is a linear term, a solution of the goal Goal is found that\n   minimizes the value of C. If C is a list of linear terms, the returned\n   solution minimizes the maximum value of terms in the list.  The solution\n   is found using the branch and bound method; as soon as a partial\n   solution is found that is worse than a previous solution, the search is\n   abandoned and a new solution is searched for.  The starting assumption\n   is that the value to minimize is less than Upper and that any value less\n   than Lower can be considered as a final solution.  Moreover, solutions\n   whose minimized values are closer than Percent % are considered equal.\n   Every time a new better solution is found, the event 280 is raised, its\n   default handler prints the current cost.\n\n   This predicate is to be used for optimization problems when the whole\n   search space is too large or when a suboptimal solution is sufficient.\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize / 8"},"fd:min_max/6":{"prefix":"min_max","body":"min_max(${1:Goal}, ${2:C}, ${3:Lower}, ${4:Upper}, ${5:Percent}, ${6:Timeout})$7\n$0","description":"min_max(?Goal, ?C, +Lower, +Upper, +Percent, +Timeout)\n\n   Find the solution of Goal that minimizes the maximum of elements of C,\nwithin the bounds set by Lower,Upper and Percent in time not longer than\nTimeout.\n\nArguments\n   ?Goal    A callable term.\n   ?C    A linear term or a list of linear terms.\n   +Lower    An integer.\n   +Upper    An integer.\n   +Percent    An integer.\n   +Timeout    A number.\n\nType\n   library(fd)\n\nDescription\n   If C is a linear term, a solution of the goal Goal is found that\n   minimizes the value of C. If C is a list of linear terms, the returned\n   solution minimizes the maximum value of terms in the list.  The solution\n   is found using the branch and bound method; as soon as a partial\n   solution is found that is worse than a previous solution, the search is\n   abandoned and a new solution is searched for.  The starting assumption\n   is that the value to minimize is less than Upper and that any value less\n   than Lower can be considered as a final solution.  Moreover, solutions\n   whose minimized values are closer than Percent % are considered equal.\n   Every time a new better solution is found, the event 280 is raised, its\n   default handler prints the current cost.\n\n   If Timeout is not zero, the predicate will stop after Timeout seconds\n   and report the best solution it has found so far.  Calls with specified\n   Timeout cannot be nested.\n\n   This predicate is to be used for optimization problems when the whole\n   search space is too large or when a suboptimal solution is sufficient.\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize / 8"},"fd:min_max/8":{"prefix":"min_max","body":"min_max(${1:Goal}, ${2:Template}, ${3:Solution}, ${4:C}, ${5:Lower}, ${6:Upper}, ${7:Percent}, ${8:Timeout})$9\n$0","description":"min_max(+Goal, ?Template, ?Solution, ?C, +Lower, +Upper, +Percent, +Timeout)\n\n   Find the solution of Goal that minimizes the maximum of elements of C,\nwithin the bounds set by Lower,Upper and Percent in time not longer than\nTimeout.\n\nArguments\n   +Goal    A callable term.\n   ?Template    A term containing all or some of Goal's variables\n   ?Solution    Term to be unified with the minimized Template\n   ?C    A linear term or a list of linear terms.\n   +Lower    An integer.\n   +Upper    An integer.\n   +Percent    An integer.\n   +Timeout    A number.\n\nType\n   library(fd)\n\nDescription\n   This is the most general version of the min_max predicate with all\n   options.\n\n   If C is a linear term, a solution of the goal Goal is found that\n   minimizes the value of C. If C is a list of linear terms, the returned\n   solution minimizes the maximum value of terms in the list.  The solution\n   is found using the branch and bound method; as soon as a partial\n   solution is found that is worse than a previous solution, the search is\n   abandoned and a new solution is searched for.  The starting assumption\n   is that the value to minimize is less than Upper and that any value less\n   than Lower can be considered as a final solution.  Moreover, solutions\n   whose minimized values are closer than Percent % are considered equal.\n   Every time a new better solution is found, the event 280 is raised, its\n   default handler prints the current cost.\n\n   Solutions will be unified with a copy of Template where the variables\n   are replaced with their minimized values. Typically, the Template will\n   contain all or a subset of Goal's variables.\n\n   If Timeout is not zero, the predicate will stop after Timeout seconds\n   and report the best solution it has found so far.  Calls with specified\n   Timeout cannot be nested.\n\n   All other variants of min_max can be written in terms of min_max/9, eg.\n\n\tmin_max(Goal, Cost) :-\n\t    minint(Min), maxint(Max),\n\t    min_max(Goal, Goal, Goal, Cost, Min, Max, 0, 0).\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nExamples\n   \n    % Find the minimal C and bind X to the corresponding value\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), X, X, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = 3\n    C = 0\n    yes.\n\n    % Find the minimal C and don't bind anything\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), [], [], C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\n    % Find the minimal C and return it in MinC. Don't bind X or C.\n    [eclipse]: X::1..3, C #= 3-X, min_max(indomain(X), C, MinC, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    MinC = 0\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize / 8"},"fd:mindomain/2":{"prefix":"mindomain","body":"mindomain(${1:Var}, ${2:Min})$3\n$0","description":"mindomain(+Var, ?Min)\n\n   Min is the minimum element in the domain of Var.\n\nArguments\n   +Var    A domain variable or an integer.\n   ?Min    A variable or an integer.\n\nType\n   library(fd)\n\nDescription\n   If Var is a domain variable then Min is unified with the minimum value\n   in the domain of Var.  If Var is an integer then Min is unified with\n   Var.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nSee Also\n   maxdomain / 2, :: / 2, #:: / 2, dom_to_list / 2"},"fd:minimize/2":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:C})$3\n$0","description":"minimize(?Goal, ?C)\n\n   Find the solution of Goal that minimizes C.\n\nArguments\n   +Goal    A callable term.\n   ?C    A linear term.\n\nType\n   library(fd)\n\nDescription\n   A solution of the goal Goal is found that minimizes the value of C. \n   The solution is found using the branch and bound method.  Whenever\n   a better solution is found, the upper cost bound is tightened and\n   the search for a better solution continues.  Every time a new\n   better solution is found, the event 280 is raised, its default\n   handler prints the current cost.\n\n   Note:  Operationally, the difference with min_max/2 is that, after\n   finding a solution, the search is not abandoned and restarted, but\n   continued with a tightened cost bound.\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 4, minimize / 5, minimize / 6, minimize / 8, minimize_bound_check / 0"},"fd:minimize/4":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:Template}, ${3:Solution}, ${4:C})$5\n$0","description":"minimize(+Goal, ?Template, ?Solution, ?C)\n\n   Find the solution of Goal that minimizes C,\nand unify the minimized Template with Solution.\n\nArguments\n   +Goal    A callable term.\n   ?Template    A term containing all or some of Goal's variables\n   ?Solution    Term to be unified with the minimized Template\n   ?C    A linear term or a list of linear terms.\n\nType\n   library(fd)\n\nDescription\n   A solution of the goal Goal is found that minimizes the value of C. \n   The solution is found using the branch and bound method.  Whenever\n   a better solution is found, the upper cost bound is tightened and\n   the search for a better solution continues.  Every time a new\n   better solution is found, the event 280 is raised, its default\n   handler prints the current cost.\n\n   Solutions will be unified with a copy of Template where the variables\n   are replaced with their minimized values. Typically, the Template will\n   contain all or a subset of Goal's variables.\n\n   minimize/2 can be written in terms of minimize/4 as follows:\n\n\tminimize(Goal, Cost) :-\n\t    minimize(Goal, Goal, Goal, Cost).\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nExamples\n   \n    % Find the minimal C and bind X to the corresponding value\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), X, X, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = 3\n    C = 0\n    yes.\n\n    % Find the minimal C and don't bind anything\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), [], [], C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\n    % Find the minimal C and return it in MinC. Don't bind X or C.\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), C, MinC, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    MinC = 0\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 5, minimize / 6, minimize / 8, minimize_bound_check / 0"},"fd:minimize_bound_check/0":{"prefix":"minimize_bound_check","body":"minimize_bound_check","description":"minimize_bound_check\n\n   If within a minimization, force a check of the cost variable against\nthe cost bound, which may lead to earlier failure.\n\nArguments\n\nType\n   library(fd)\n\nDescription\n   This predicate can be used within a goal that is being minimized\n   using minimize/2 or any of its variants. If used in other contexts\n   it has no effect just succeeds.\n\n   The behaviour of minimize/2 is such that the cost bound is tightened\n   whenever a better solution is found, but this tightening does not\n   trigger an automatic check.  It can therefore be advantageous and\n   lead to earlier failure when minimize_bound_check/0 is called after\n   every labeling step.\n\nFail Conditions\n      Fails if the current cost cannot become smaller that the cost bound.\n\nResatisfiable\n      No.\n\nExamples\n   \n    labeling([]).\n    labeling([X|Xs]) :-\n\t% do the check urgently, before any propagation happens\n\tcall_priority((indomain(X), minimize_bound_check), 2),\n\tlabeling(Xs).\n\nSee Also\n   minimize / 2, minimize / 4, minimize / 6, minimize / 8"},"fd:minimize/5":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:C}, ${3:Lower}, ${4:Upper}, ${5:Percent})$6\n$0","description":"minimize(?Goal, ?C, +Lower, +Upper, +Percent)\n\n   Find the solution of Goal that minimizes C, within the bounds set by Lower,\nUpper and Percent.\n\nArguments\n   ?Goal    A callable term.\n   ?C    A linear term.\n   +Lower    Integer.\n   +Upper    Integer.\n   +Percent    Integer.\n\nType\n   library(fd)\n\nDescription\n   A solution of the goal Goal is found that minimizes the value of C. \n   The solution is found using the branch and bound method.  Whenever\n   a better solution is found, the upper cost bound is tightened and\n   the search for a better solution continues.\n\n   The starting assumption is that the value to minimize is less than\n   Upper and that any value less than Lower can be considered as a\n   solution.  Moreover, solutions whose minimized values are closer\n   than Percent % are considered equal.  Every time a new better\n   solution is found, the event 280 is raised, its default handler\n   prints the current cost.\n\n   This predicate is to be used for optimization problems when the whole\n   search space is too large or when a suboptimal solution is sufficient.\n\nFail Conditions\n      Fails if Goal fails.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 6, minimize / 8, minimize_bound_check / 0"},"fd:minimize/6":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:C}, ${3:Lower}, ${4:Upper}, ${5:Percent}, ${6:Timeout})$7\n$0","description":"minimize(?Goal, ?C, +Lower, +Upper, +Percent, +Timeout)\n\n   Find the solution of Goal that minimizes C, within the bounds set by Lower,\nUpper and Percent in time not longer than Timeout.\n\nArguments\n   ?Goal    A callable term.\n   ?C    A linear term.\n   +Lower    Integer.\n   +Upper    Integer.\n   +Percent    Integer.\n   +Timeout    A number.\n\nType\n   library(fd)\n\nDescription\n   A solution of the goal Goal is found that minimizes the value of C. \n   The solution is found using the branch and bound method.  Whenever\n   a better solution is found, the upper cost bound is tightened and\n   the search for a better solution continues.\n\n   The starting assumption is that the value to minimize is less than\n   Upper and that any value less than Lower can be considered as a\n   solution.  Moreover, solutions whose minimized values are closer\n   than Percent % are considered equal.  Every time a new better\n   solution is found, the event 280 is raised, its default handler\n   prints the current cost.\n\n   If Timeout is not zero, the predicate will stop after Timeout seconds\n   and report the best solution it has found so far.  Calls with specified\n   Timeout cannot be nested.\n\n   This predicate is to be used for optimization problems when the whole\n   search space is too large or when a suboptimal solution is sufficient.\n\nFail Conditions\n      Fails if Goal fails.\n\nResatisfiable\n      No.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 8, minimize_bound_check / 0"},"fd:minimize/8":{"prefix":"minimize","body":"minimize(${1:Goal}, ${2:Template}, ${3:Solution}, ${4:C}, ${5:Lower}, ${6:Upper}, ${7:Percent}, ${8:Timeout})$9\n$0","description":"minimize(+Goal, ?Template, ?Solution, ?C, +Lower, +Upper, +Percent, +Timeout)\n\n   Find the solution of Goal that minimizes the maximum of elements of C,\nwithin the bounds set by Lower,Upper and Percent in time not longer than\nTimeout.\n\nArguments\n   +Goal    A callable term.\n   ?Template    A term containing all or some of Goal's variables\n   ?Solution    Term to be unified with the minimized Template\n   ?C    A linear term or a list of linear terms.\n   +Lower    An integer.\n   +Upper    An integer.\n   +Percent    An integer.\n   +Timeout    A number.\n\nType\n   library(fd)\n\nDescription\n   This is the most general version of the minimize predicate with all\n   options.\n\n   A solution of the goal Goal is found that minimizes the value of C. \n   The solution is found using the branch and bound method.  Whenever\n   a better solution is found, the upper cost bound is tightened and\n   the search for a better solution continues.\n\n   The starting assumption is that the value to minimize is less than\n   Upper and that any value less than Lower can be considered as a\n   final solution.  Moreover, solutions whose minimized values are\n   closer than Percent % are considered equal.  Every time a new\n   better solution is found, the event 280 is raised, its default\n   handler prints the current cost.\n\n   Solutions will be unified with a copy of Template where the variables\n   are replaced with their minimized values. Typically, the Template will\n   contain all or a subset of Goal's variables.\n\n   If Timeout is not zero, the predicate will stop after Timeout seconds\n   and report the best solution it has found so far.  Calls with specified\n   Timeout cannot be nested.\n\n   All other variants of minimize can be written in terms of minimize/9, eg.\n\n\tminimize(Goal, Cost) :-\n\t    minint(Min), maxint(Max),\n\t    minimize(Goal, Goal, Goal, Cost, Min, Max, 0, 0).\n\nFail Conditions\n      Fails if there is no solution to Goal.\n\nResatisfiable\n      No.\n\nExamples\n   \n    % Find the minimal C and bind X to the corresponding value\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), X, X, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = 3\n    C = 0\n    yes.\n\n    % Find the minimal C and don't bind anything\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), [], [], C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\n    % Find the minimal C and return it in MinC. Don't bind X or C.\n    [eclipse]: X::1..3, C #= 3-X, minimize(indomain(X), C, MinC, C).\n    Found a solution with cost 2\n    Found a solution with cost 1\n    Found a solution with cost 0\n    X = X{[1..3]}\n    MinC = 0\n    C = C{[0..2]}\n\n    Delayed goals:\n\t    -3 + X{[1..3]} + C{[0..2]}#=0\n    yes.\n\nSee Also\n   min_max / 2, min_max / 4, min_max / 5, min_max / 6, min_max / 8, minimize / 2, minimize / 4, minimize / 5, minimize / 6, minimize_bound_check / 0"},"fd:new_domain_var/1":{"prefix":"new_domain_var","body":"new_domain_var(${1:Var})$2\n$0","description":"new_domain_var(-Var)\n\n   A user hook predicate which is called whenever a variable obtains a default\ndomain from the solver.\n\nArguments\n   -Var    A variable.\n\nType\n   library(fd)\n\nDescription\n   This predicate is a simple hook to notify about free variables being\n   converted into domain variables.  Whenever the finite domain solver\n   assigns a free variable a domain, it invokes this predicate in the\n   module fd_domain with the variable as argument.  To use the mechanism,\n   it is necessary to recompile this predicate in the module fd_domain.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExamples\n   \n   [eclipse 22]: compile(user, fd_domain).\n   new_domain_var(X) :- printf(\"new domain variable created: %mw%n\", [X]).\n   user       compiled traceable 88 bytes in 0.00 seconds\n   yes.\n   [eclipse 23]: X+Y #> T.\n   new domain variable created: X[-10000000..10000000]\n   new domain variable created: Y[-10000000..10000000]\n   new domain variable created: T[-10000000..10000000]\n\nSee Also\n   :: / 2, #:: / 2, default_domain / 1"},"fd:par_indomain/1":{"prefix":"par_indomain","body":"par_indomain(${1:Var})$2\n$0","description":"par_indomain(?Var)\n\n   Instantiate Var to a number of values in its domain in parallel.\n\nArguments\n   ?Var    An integer or a domain variable\n\nType\n   library(fd)\n\nDescription\n   This predicate instantiates the domain variable Var to a value from its\n   domain.  The instantiation is executed in Or-parallel, i.e.  several\n   parallel jobs are created which may be executed in parallel on different\n   processors.  There is no specified order of enumerating the domain of\n   the variable, the user should not rely on a particular order.  It is\n   used mostly to find an instantiation of the variable which is consistent\n   with the current set of constraints in labeling procedures of a parallel\n   program.  If List is a list of all domain variables occurring in the\n   program, the simplest parallel labeling procedure is written as\n\n    labeling([]).\n    labeling([Var|Rest]) :-\n    par_indomain(Var),\n    labeling(Rest).\n\nFail Conditions\n      None.\n\nResatisfiable\n      Yes.\n\nSee Also\n   :: / 2, #:: / 2, indomain / 1"},"fd:sorted_list_to_dom/2":{"prefix":"sorted_list_to_dom","body":"sorted_list_to_dom(${1:List}, ${2:Dom})$3\n$0","description":"sorted_list_to_dom(+List, -Dom)\n\n   Convert a sorted list of atomic terms and integer intervals into a domain\nDom.\n\nArguments\n   +List    A sorted list of atomic terms and integer interval.\n   -Dom    Variable.\n\nType\n   library(fd)\n\nDescription\n   Convert a sorted list of atomic terms and integer intervals into a\n   domain Dom.  List is assumed to be in the correct order and format for a\n   finite domain.  If it is not, the program will not work correctly.  The\n   purpose of this predicate is to quickly convert small lists to domains.\n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExceptions\n     4 --- List is not ground.\n     5 --- List contains an element which is neither atomic nor an    integer interval.\n     6 --- The size of the resulting domain is too large.\n     6 --- The lower bound of an integer interval is greater than its    upper bound.\n\nSee Also\n   integer_list_to_dom / 2, list_to_dom / 2, dvar_domain / 2"},"fd:var_fd/2":{"prefix":"var_fd","body":"var_fd(${1:Var}, ${2:Dom})$3\n$0","description":"var_fd(+Var, +Dom)\n\n   Create a domain variable with a given domain.\n\nArguments\n   +Var    A variable or a domain variable.\n   +Dom    A finite domain.\n\nType\n   library(fd)\n\nDescription\n   If Var is a free variable, is becomes a domain variable with the domain\n   Dom and with empty suspension lists.  The domain Dom is copied to make\n   in-place updates logically sound.  If Var is already a domain variable,\n   its domain is intersected with the domain Dom.\n\nFail Conditions\n      Fails if Var is not a variable.\n\nResatisfiable\n      No.\n\nSee Also\n   :: / 2, #:: / 2, dvar_domain / 2"},"fd_sbds:fd_sbds_desc":{"prefix":"lib","body":"lib(${1:fd_sbds})$2\n$0","description":"lib(fd_sbds)\n\n   Symmetry Breaking During Search (SBDS) library, provides predicates to initalise symmetry breaking during search search and to perform the search, as well as utility functions for prining and unification."},"fd_sbds:is_sbds_var/1":{"prefix":"is_sbds_var","body":"is_sbds_var(${1:Var})$2\n$0","description":"is_sbds_var(?Var)\n\n   checks whether a variable is an SBDS variable\n\nArguments\n   Var    Variable to check\n\nType\n   library(fd_sbds)\n\nDescription\n\tSucceeds if and only if Var is a variable and has been initialised\n\tas an SBDS variable (through a call to sbds_initialise/4 or\n\tsbds_initialise/5).\n\nFail Conditions\n   Var is not a variable or not an SBDS variable.\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5"},"fd_sbds:sbds_get_index/2":{"prefix":"sbds_get_index","body":"sbds_get_index(${1:Var}, ${2:Idx})$3\n$0","description":"sbds_get_index(?Var, -Idx)\n\n   get the index of an SBDS attributed variable\n\nArguments\n   Var    SBDS variable\n   Idx    The index of Var\n\nType\n   library(fd_sbds)\n\nDescription\n\tUnifies Idx with the index of the SBDS variable Var.  The index of\n\tthe variable is its position in the matrix provided in the\n\tcorresponding call to sbds_initialise/4 or sbds_initialise/5\n\nFail Conditions\n   Var is not an SBDS variable."},"fd_sbds:sbds_get_matrix/2":{"prefix":"sbds_get_matrix","body":"sbds_get_matrix(${1:Var}, ${2:Matrix})$3\n$0","description":"sbds_get_matrix(?Var, -Matrix)\n\n   get the matrix (array) of SBDS attributed variables\n\nArguments\n   Var    SBDS variable\n   Matrix    The matrix that Var appears in\n\nType\n   library(fd_sbds)\n\nDescription\n\tUnifies Matrix with the matrix (array) provided to a call to\n\tsbds_initialise/4 or sbds_initialise/5 which contains Var.\n\nFail Conditions\n   Var is not an SBDS variable."},"fd_sbds:sbds_initialise/4":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:SymPreds}, ${3:FixPred}, ${4:Options})$5\n$0","description":"sbds_initialise(+VarMatrix, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(fd_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to, in this case a 1-dimensonal matrix, for the n-dimensonal case see \t\tsbds_initalise/5.\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation\n\ti.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), \n\tyou only need to specify the parameters that you have added. So for the above \t\tpredicate,\n\tthe entry to the list would be: symmetry_predicate(Matrix)\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a 1 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\n\t\n\tr180(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\t\n\t\n\tr270(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trx(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is Value.\n\t\n\n\t\n\try(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\n\t\n\trd1(Matrix, _N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trd2(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\t\n\t Then to initialise SBDS\n\t%If the Board is a list of variables then we change it to a matrix\t\n\tMatrix =.. [[] | Board],\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 5, sbds_try / 2"},"fd_sbds:sbds_initialise/5":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:NDims}, ${3:SymPreds}, ${4:FixPred}, ${5:Options})$6\n$0","description":"sbds_initialise(+VarMatrix, ++NDims, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   NDims    The Dimenson of VarMatrix\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(fd_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to.\n\t\n\t\n\tNDims is the dimenson of VarMatrix\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation i.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), you only need to specify the parameters that you have added. \t\tSo for the above predicate, the entry to the list would \t\t\t\tbe: symmetry_predicate(Matrix).\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a boolean encoding on a 2 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t\n\tr180(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\tr270(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, X],\n    \t\tSymValue is Value.\n\t\t\n\t\n\trx(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, Y],\n    \t\tSymValue is Value.\n\t\n\t\n\try(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\trd1(Matrix, _N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, X],\n    \t\tSymValue is Value.\n\t\n\t\n\trd2(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t Then to initialise SBDS\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, 2, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 4, sbds_try / 2"},"fd_sbds:sbds_try/2":{"prefix":"sbds_try","body":"sbds_try(${1:Var}, ${2:Val})$3\n$0","description":"sbds_try(?Var, ++Val)\n\n   tries to assign a variable to a value\n\nArguments\n   Var    SBDS Variable\n   Val    Value to try and assign to Value\n\nType\n   library(fd_sbds)\n\nDescription\nCalled for each variable, value pair tried at a decision point \t\tduring search.\n\t\n\t\n\tInitally tries to assign a variable to a value, if this is succesful then it \t\tupdates the symmetry functions to take account of any symmetries which have \t\tbeen broken by this assignment.\n\t\n\t\n\tIf this assignment is unsuccesful then it stipulates that the variable cannot \t\tbe assigned to this value, before placing constraints to eliminate the \t\t\tsymmetrical equivalent of this assgnment. If these symmetries are not already \t\tbroken\n\nExceptions\n   abort --- Var is not an sbds attributed variable\n\nExamples\n Replacement for labeling/1 which takes SBDS into account \t\t\n\t\n\tsbds_labeling(AllVars) :-\n    ( foreach(Var, AllVars) do\n\t  count_backtracks,\n    sbds_indomain(Var)    \n    ).\n    \n\tReplacement for indomain/1 which takes SBDS into account.\n\t\n\t% value ordering is input order\n\tsbds_indomain(X) :-\n\t\tnonvar(X).\n\tsbds_indomain(X) :-\n\t\tvar(X),\n\t\tmindomain(X, LWB),\n\t\t%sbds_try called here\n\t\tsbds_try(X, LWB),\n\t\tsbds_indomain(X).\n\t\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5, ic : search / 6"},"fd_search:delete/5":{"prefix":"delete","body":"delete(${1:X}, ${2:List}, ${3:R}, ${4:Arg}, ${5:Select})$6\n$0","description":"delete(-X, +List, -R, ++Arg, ++Select)\n\n   Choose a domain variable from a list according to selection criterion.\n\nArguments\n   X    a free variable\n   List    a list of variables or terms \n   R    a free variable \n   Arg    an integer\n   Select    the name of the selection criterion\n\nType\n   library(fd_search)\n\nDescription\n\nThis predicate chooses one entry in a list of variables or terms based\non some selection criterion.  The criteria are explained in detail in\nthe search/6 predicate. The selected entry is returned in X, with\nthe rest of the list without X returned in R.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   fails if the list is empty\n\nResatisfiable\n   no\n\nExamples\n   \n\nSee Also\n   search / 6"},"fd_search:fd_search_desc":{"prefix":"lib","body":"lib(${1:fd_search})$2\n$0","description":"lib(fd_search)\n\nThis library contains a generic search routine which \nimplements a number of partial search methods (complete, credit, lds, bbs, \ndbs) and some of their combinations."},"fd_search:indomain/2":{"prefix":"indomain","body":"indomain(${1:Var}, ${2:Method})$3\n$0","description":"indomain(?Var, ++Method)\n\n   a flexible way to assign values to finite domain variables\n\nArguments\n   Var    a domain variable or an integer\n   Method    one of the atoms min, max, middle, median, split, interval, random or an integer\n\nType\n   library(fd_search)\n\nDescription\nThis predicate provides a flexible way to assign values to finite \ndomain variables.\nThe available methods are:\n\nenum Identical to indomain/1. Start enumeration from the smallest\n    value upwards, without first removing previously tried values.\n\nmin Start the enumeration from the smallest value upwards. \n    This behaves like the built-in indomain/1, except that it\n    removes previously tested values on backtracking.\n\nmax Start the enumeration from the largest value\n    downwards.\n\nreverse_min Like min, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nreverse_max Like max, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nmiddle Try the enumeration starting from the middle of the\n    domain.  On backtracking, this chooses alternatively values above and\n    below the middle value, until all alternatives have been tested.\n\nmedian Try the enumeration starting from the median value\n    of the domain.  On backtracking, this chooses alternatively values\n    above and below the median value, until all alternatives have been\n    tested.\n\nsplit Try the enumeration by splitting the domain\n    successively into halves until a ground value is reached.  This\n    sometimes can detect failure earlier than the normal enumeration\n    methods, but enumerates the values in the same order as min.\n\nreverse_split Like split, but tries the upper half of the\n    domain first.\n\ninterval If the domain consists of several intervals, then\n    we branch first on the choice of the interval.  For one interval, we\n    use domain splitting.\n\nrandom Try the enumeration in a random order.  On\n    backtracking, the previously tested value is removed.  This method\n    uses random/1 to create random numbers, use seed/1\n    before to make results reproducible.\n\nValue:integer Like middle, but start with the given integer\n    Value\n\nsbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the SBDS symmetry breaking\n    library).\n\ngap_sbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the GAP-based SBDS symmetry\n    breaking library, lib(ic_gap_sbds)).\n\ngap_sbdd_min Like min, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_max Like max, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_middle Like middle, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_median Like median, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_random Like random, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd(Value:integer) Like Value:integer, but use sbdd_try/2\n    to make choices (for use in conjunction with the GAP-based SBDD symmetry\n    breaking library, lib(ic_gap_sbdd)).\n\nOn backtracking, all methods except enum first remove the previously tested\nvalue before choosing a new one.  This sometimes can have a huge impact on the\nconstraint propagation, and normally does not cause much overhead, even if no\nadditional propagation occurs.\n\nFail Conditions\n   No\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tX :: 1..10,\n\tindomain(X,min),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,max),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 10 9 8 7 6 5 4 3 2 1\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,middle),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,median),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,3),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 3 4 2 5 1 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,split),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,random),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes for example 5 3 7 6 8 1 2 10 9 4\n\nSee Also\n   search / 6, fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, random / 1, seed / 1, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_try / 2"},"fd_search:nth_value/3":{"prefix":"nth_value","body":"nth_value(${1:Domain}, ${2:N}, ${3:Value})$4\n$0","description":"nth_value(+Domain, ++N, -Value)\n\n   return the nth value in a domain\n\nArguments\n   Domain    The domain list to select a value from\n   N    The position of the value to select\n   Value    The selected value\n\nType\n   library(fd_search)\n\nDescription\nFind the nth value in a domain given by an interval or a list of\nintegers and intervals, as it is returned for example by ic's\nget_domain/2 or fd's ::/2.\n\nFail Conditions\n   N < 1 or there are less than N values in the domain.\n\nResatisfiable\n   no\n\nExamples\n   \n% a typical use\n\n\t....\n\tget_domain(X, L),\n\tnth_value(L, 2, Value),\n\t....\n\nSee Also\n   fd : :: / 2, ic : get_domain / 2"},"fd_search:search/6":{"prefix":"search","body":"search(${1:L}, ${2:Arg}, ${3:Select}, ${4:Choice}, ${5:Method}, ${6:Option})$7\n$0","description":"search(+L, ++Arg, ++Select, +Choice, ++Method, +Option)\n\n   A generic search routine for finite domains or IC which implements \ndifferent partial search methods (complete, credit, lds, bbs, dbs, sbds,\ngap_sbds, gap_sbdd)\n\nArguments\n   L    a collection (a la collection_to_list/2) of domain\n\t    variables (Arg = 0) or a collection of terms (Arg > 0)\n   Arg    an integer, which is 0 if the list is a list of domain\n\t    variables, or greater than 0 if the list consists of terms\n\t    with arity at least Arg (the value Arg indicating the argument\n\t    that contains the domain variables to be labeled)\n   Select    the name of a predefined selection method (input_order,\n\t    first_fail, smallest, largest, occurrence, most_constrained,\n\t    max_regret, anti_first_fail), or an atom or compound term\n\t    specifying a user-defined selection method\n   Choice    the name of a predefined choice method (indomain,\n\t    indomain_min, indomain_max, indomain_middle, indomain_reverse_min,\n\t    indomain_reverse_max, indomain_median, indomain_split,\n\t    indomain_reverse_split, indomain_random, indomain_interval),\n\t    or an atom or compound term specifying a user-defined method\n   Method    one of the following search method specifications:\n\t    complete, bbs(Steps:integer), lds(Disc:integer),\n\t    credit(Credit:integer, Extra:integer or bbs(Steps:integer)\n\t    or lds(Disc:integer)), dbs(Level:integer, Extra:integer or\n\t    bbs(Steps:integer) or lds(Disc:integer)), sbds, gap_sbds,\n\t    gap_sbdd\n   Option    a list of option terms.  Currently recognized\n\t   are backtrack(-N), node(++Call), nodes(++N)\n\nType\n   library(fd_search)\n\nDescription\nSearch/6 provides a generic interface to a set of different search\nmethods.  It can currently be used with either the finite domains (if\nloaded via lib(fd_search)), or integer IC domains (if loaded via\nlib(ic_search)).  By changing the Method argument, different partial\nsearch algorithms (and their parameters) can be selected and\ncontrolled. The search predicate also provides a number of pre-defined\nvariable selection methods (to choose which variable will be assigned next)\nand some pre-defined value assignment methods (to try out the possible\nvalues for the selected variable in some heuristic order), but user-defined\nmethods can be used in their place as well.  In order to allow more\nstructure in the application program, it is possible to pass a collection\nof terms rather than only a collection of domain variables. In this way all\ninformation about some entity can be easily grouped together. It also\nallows more complex labeling methods which combine the assignment of\nmultiple variables (like a preference value and a decision variable).\n\nAll search methods use a stable selection method. If several entries\nhave the same heuristic value, then the first one is selected.  The rest of\nthe collection (treated as a list) is equal to the original list with the\nselected entry removed, the order of the non-selected entries does not\nchange.\n\nThe pre-defined selection methods are the following:\n\ninput_order\n\tthe first entry in the list is selected\nfirst_fail\n\tthe entry with the smallest domain size is selected\nanti_first_fail\n\tthe entry with the largest domain size is selected\nsmallest\n\tthe entry with the smallest value in the domain is selected\nlargest\n\tthe entry with the largest value in the domain is selected\noccurrence\n\tthe entry with the largest number of attached constraints is selected\nmost_constrained\n\tthe entry with the smallest domain size is selected.  If several\n\tentries have the same domain size, the entry with the largest number\n\tof attached constraints is selected.\nmax_regret\n\tthe entry with the largest difference between the smallest and second\n\tsmallest value in the domain is selected. This method is typically\n\tused if the variable represents a cost, and we are interested in\n\tthe choice which could increase overall cost the most if the best\n\tpossibility is not taken. Unfortunately, the implementation does\n\tnot always work: If two decision variables incur the same minimal\n\tcost, the regret is not calculated as zero, but as the difference\n\tfrom this minimal value to the next greater value.\n\nAny other atom will be taken as the specification of a user-defined\nselection predicate.  This will be invoked with 2 arguments (X,Criterion)\nadded and is expected to compute a selection criterion (typically a number)\nfrom a variable or value X.  E.g. if Select is 'my_select', a predicate\ndefinition like the following has to be provided:\n\n    my_select(X,Criterion) :-\n\t...\t% compute Criterion from variable X\n\nThe variable-selection will then select the variable with the lowest value\n(in standard term order) of Criterion.  If several variables have the same\nvalue, the first one is selected.  \n\nThe above selection methods use the predefined delete/5 predicate.\nIf this is not general enough, you can replace it with your own: if Select\nis given as select(my_delete), then my_delete(-SelectedVar,+List,-Rest,+Arg)\nwill be invoked for selecting a variable from List.\n\nThe pre-defined choice methods have the following meaning:\n\nindomain\n    uses the built-in indomain/1.  Values are tried in increasing order. \n    On failure, the previously tested value is not removed.\n\nindomain_min\n    Values are tried in increasing order.  On failure, the previously\n    tested value is removed.  The values are tested in the same order as\n    for indomain, but backtracking may occur earlier.\n\nindomain_max\n    Values are tried in decreasing order.  On failure, the previously\n    tested value is removed.\n\nindomain_reverse_min\n    Like indomain_min, but the alternatives are tried in reverse order.\n    I.e. the smallest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_reverse_max\n    Like indomain_max, but the alternatives are tried in reverse order.\n    I.e. the largest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_middle\n    Values are tried beginning from the middle of the domain.  On failure,\n    the previously tested value is removed.\n\nindomain_median\n    Values are tried beginning from the median value of the domain.  On\n    failure, the previously tested value is removed.\n\nindomain_split\n    Values are tried by succesive domain splitting, trying the lower half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_min, but\n    may fail earlier.\n\nindomain_reverse_split\n    Values are tried by succesive domain splitting, trying the upper half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_max, but\n    may fail earlier.\n\nindomain_random\n    Values are tried in a random order.  On backtracking, the previously\n    tried value is removed.  Using this rutine may lead to unreproducable\n    results, as another call wil create random numbers in a different\n    sequence.  This method uses the built-in random/1 to create\n    random numbers, seed/1 can be used to force the same number\n    generation sequence in another run.\n\nindomain_interval\n    If the domain consists of several intervals, we first branch on the\n    choice of the interval.  For one interval, we use domain\n    splitting.\n\nAny other name is taken as the name of a user-defined predicate of\narity 1, to which the variable to be labeled (or a whole element of\nlist L, in the Arg>0 case) is passed, e.g.\n\n    my_choice(X) :-\n\t...\t% make a choice on variable X\n\nAlternatively, a term with 2 arguments can be given as the choice-method,\ne.g. my_choice(FirstIn,LastOut). this will lead to the invocation of a\nchoice predicate with arity 3, e.g.\n\n    my_choice(X,In,Out) :-\n\t...\t% make a choice on variable X, using In-Out\n\nThis allows user-defined state to be transferred between the subsequent\ninvocations of the choice-predicate (the Out argument of a call to\nmy_choice/3 for one variable is unified with the In argument of the call to\nmy_choice/3 for the next variable, and so on).\n\nIn addition, a fixed argument can be passed: my_choice(Param) leads to\ninvocation of my_choice(X,Param), and my_choice(Param,FirstIn,LastOut)\nleads to invocation of my_choice(X,Param,In,Out).\n\nThe different search methods are\n\ncomplete\n    a complete search routine which explores all alternative choices.\n\nbbs(Steps)\n    The bounded backtracking search allows Steps\n    backtracking steps.\n\nlds(Disc)\n    A form of the  limited discrepancy search .  This method\n    iteratively tries 0, 1, 2 ..  Disc changes against the\n    heuristic (first) value.  Typical values are between 1 and 3 (which\n    already may create too many alternatives for large problems).  The\n    original LDS paper stated that the discrepancy to be tested first\n    should be at the top of the tree.  Our implementation tries the first\n    discrepancy at the bottom of the tree.  This means that solutions may\n    be found in a different order compared to the original algorithm. \n    This change is imposed by the evaluation strategy used and can not be\n    easily modified.\n\ncredit(Credit, bbs(Steps))\n    The credit based search explores the top of the search tree\n    completely.  Initially, a given number of credits (Credit) are\n    given.  At each choice point, the first alternative gets half of the\n    available credit, the second alternative half of the remaining credit,\n    and so on.  When the credit run out, the system switches to another\n    search routine, here bbs.  In each of these bounded backtracking\n    searches Steps backtracking steps are allowed before returning\n    to the top most part of the tree and choosing the next remaining\n    candidate.  A good value for Steps is 5, a value of 0 forces a\n    deterministic search using the heuristic.  Typical values for\n    Credit are either N or N*N, where N is the number of entries in\n    the collection.\n\ncredit(Credit, lds(Disc))\n    like the one above, but using lds when the credit runs out. \n    Typically, only one (perhaps 2) discrepancies should be allowed.\n\ndbs(Level, bbs(Steps))\n    The depth bounded search explores the first Level\n    choices in the search tree completely, i.e.  it tries all values for\n    the first Level selected variables.  After that, it switches to\n    another search method, here bbs.  In each of these searches,\n    Steps backtracking steps are allowed.  \n\ndbs(Level, lds(Disc))\n    like the method above, but switches to lds after the first\n    Level variables.\n\nsbds\n    A complete search routine which uses the SBDS symmetry breaking library\n    (lib(ic_sbds) or lib(fd_sbds)) to exclude symmetric parts of the search tree\n    from consideration.  The symmetry breaking must be initialised through a\n    call to sbds_initialise/4,5 before calling search/6.  Currently the only\n    pre-defined choice methods supported by this search method are\n    indomain_min, indomain_max, indomain_middle,\n    indomain_median and indomain_random.  Any user-defined choice\n    method used in conjunction with this search method must use sbds_try/2 to\n    assign/exclude values or the symmetry breaking will not work correctly.\n\ngap_sbds (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDS symmetry breaking\n    library lib(ic_gap_sbds) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbds_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbds_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\ngap_sbdd (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDD symmetry breaking\n    library lib(ic_gap_sbdd) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbdd_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbdd_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\nThe option list is used to pass additional parameters to and from the\nprocedure.  The currently recognized options are:\n\nbacktrack(-N)\n    returns the number of backtracking steps used in the search routine\n\nnodes(++N)\n    sets an upper limit on the number of nodes explored in the search.  If\n    the given limit is exceeded, the search routine stops the exploration\n    of the search tree.\n\nnode(daVinci)\n    create a drawing of the search tree using the daVinci graph drawing\n    tool.  Each node of the search tree is shown as a node in the tree. \n    The label of the node is the selected term of the collection.\n\nnode(daVinci(++Call))\n    as the previous option, it creates a drawing of the search tree using\n    the daVinci graph drawing tool.  But instead of using the complete\n    selected term as the label, it call the predicate Call/2 to\n    choose which part of the selected term to display.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the search tree generated does not contain any solution. \nFor partial search methods, this does not mean that the problem does not \nhave a solution, but only that the part of the tree generated did not \ncontain one.\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,complete,[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,bbs(15),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,lds(2),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,credit(64,bbs(5)),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,dbs(2,lds(1)),[]).\n\n% a more complex example with different methods and heuristics\n% the list to be assigned is a list of terms queen/2\n\n:- local struct(queen(place,var)).\n\ntop:-\n\tmember(Method,[complete,lds(2),credit(64,5),bbs(1000),dbs(5,10)]),\n\tmember(Select,[first_fail,most_constrained,input_order]),\n\tmember(Choice,[indomain,\n\t    indomain_min,\n\t\t       indomain_max,\n\t\t       indomain_middle,\n\t\t       indomain_median,\n\t\t       indomain_split,\n\t\t       indomain_random]),\n\twriteln(queen(Method,Select,Choice)),\n\tonce(queen_credit(64,Select,Choice,Method,L,Back)),\n\twriteln(L),\n\twriteln(backtrack(Back)),\n\tfail.\ntop:-\n\tnl.\n\nqueen_credit(N,Select,Choice,Method,L,Back):-\n\tcreate_queens(1,N,Queens,L),\n\tsetup(L),\n\trearrange(Queens,Queens,[],[],Queens1),\n\tsearch(Queens1, var of queen, Select, Choice, Method, [backtrack(Back)]).\n\nrearrange([],Last,Last,Res,Res).\nrearrange([_],[Mid|Last],Last,Res,[Mid|Res]).\nrearrange([_,_|S],[H|T],A1,In,Res):-\n\trearrange(S,T,[A|A1],[H,A|In],Res).\n\ncreate_queens(N,M,[],[]):-\n\tN > M,\n\t!.\ncreate_queens(N,M,[queen{place:N,var:X}|T],[X|L]):-\n\tX :: 1..M,\n\tN1 is N+1,\n\tcreate_queens(N1,M,T,L).\n\nsetup([]).\nsetup([H|T]):-\n\tsetup1(H,T,1),\n\tsetup(T).\n\nsetup1(_,[],_).\nsetup1(X,[Y|R],N):-\n\tX #\\= Y,\n\tX #\\= Y + N,\n\tY #\\= X + N,\n\tN1 is N+1,\n\tsetup1(X,R,N1).\n\n% this example shows how to pass information from one assignment step \n% to the next\n% this uses a term of two arguments as the choice argument\n% The example also shows the use of the option argument:\n% the search tree generated is drawn with the daVinci graph drawing tool\n% and the search is limited to 1000 nodes.\n% The number of backtracking steps is returned in the variables Back.\n:-local struct(country(name,color)).\n\ntop:-\n\tcountries(C),\n\tcreate_countries(C,Countries,Vars),\n\tfindall(n(A,B),n(A,B),L),\n\tsetup(L,Countries),\n\tsearch(Countries,\n\t       color of country, % select based on this variable\n\t       most_constrained,\n\t       assign([1,2,3,4],Out), % this calls assign/3\n\t       complete,\n\t       [backtrack(Back),node(daVinci),nodes(1000)]),\n\twriteln(Vars),\n\twriteln(Back),\n\twriteln(Out).\n\ncreate_countries([],[],[]).\ncreate_countries([C|C1],[country{name:C, color:V}|R1],[V|V1]):-\n\tV :: 1..4,\n\tcreate_countries(C1,R1,V1).\n\nsetup([],_L).\nsetup([n(A,B)|N1],L):-\n\tmember(country{name:A, color:Av},L),\n\tmember(country{name:B, color:Bv},L),\n\tAv #\\= Bv,\n\tsetup(N1,L).\n\n% this is the choice predicate\n% the first argument is the complete selected term\n% the second is the input argument\n% the third is the output argument\n% here we pass a list of values and rotate this list from one step to the next\nassign(country{color:X},L,L1):-\n\trotate(L,L1),\n\tmember(X,L).\n\nrotate([A,B,C,D],[B,C,D,A]).\n\n% another example of argument passing \n% here each entry gets the same information\n% it is passed unchanged from one level to the next\n\ntop:-\n\t...\n\tlength(L,N),\n\tL :: 1..10,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       % pass two lists as the In argument of assign\n\t       % try the odd numbers before the even numbers\n\t       assign([1,3,5,7,9]-[2,4,6,8,10],_), \n\t       complete,[]),\n\t...\n\n% this is the assignment routine\n% the first argument is a \n% Pass the In argument as the Out argument\n% try values from list L1 before values from list L2\nassign(X,L1-L2,L1-L2):-\n\tmember(X,L1);member(X,L2).\n\n% and another example from square placement\n% alternatively try minimal and maximal values first\n\n:-local struct(square(x,y,size)).\n\ntop:-\n\tdata(L),\n\tcreate_squares(L,Squares),\n\t...\n    search(Squares,\n\t       0, % this value does not matter if input_order is chosen\n\t       input_order,\n\t       assign(min,_),\n\t       complete,\n\t       []),\n\t...\n\n% the assignment routine\n% alternate between min and max for consecutive levels in the search\nassign(square{x:X,y:Y},Type,Type1):-\n\tswap(Type,Type1),\n\tindomain(X,Type),\n\tindomain(Y,Type).\n\nswap(max,min).\nswap(min,max).\n\n% this example shows that the choice routine may consist of several clauses\n% the idea comes from a graph coloring heuristic\n\ntop:-\n\tlength(L,N),\n\tL :: 1..100,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       assign(0,K), The In argument is the highest color used so far\n\t       complete,[]),\n\t...\n\n% assign variable X either to one of the colors 1..K \n% which have already been used, or to the new color K+1\n% we do not need to try other values K+2 etc, as this is a symmetry that\n% we can avoid\nassign(X,K,K):-\n\tX #=< K,\n\tindomain(X).\nassign(K1,K,K1):-\n\tK1 is K+1.\n\n% example showing use of the SBDS library with a user-defined choice method\n% which calls sbds_try/2.\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\t...\n\tsbds_initialise(M,SymPreds,#=,[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,sbds_indomain_max,sbds,[]).\n\nsbds_indomain_max(X):-\n\tnonvar(X).\nsbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tsbds_indomain_max(X).\n\n% Example showing use of the GAP-based SBDS library with a user-defined\n% choice method which calls sbds_try/2.  (For the GAP-based SBDD library,\n% just substitute \"sbdd\" for each occurrence of \"sbds\" below.)\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\tsbds_initialise(M,[vars],values:1..8,[symmetry(s_n,[vars])],[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,gap_sbds_indomain_max,gap_sbds,[]).\n\ngap_sbds_indomain_max(X):-\n\tnonvar(X).\ngap_sbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tgap_sbds_indomain_max(X).\n\nSee Also\n   fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, indomain / 2, fd : labeling / 1, sd : labeling / 1, ic : labeling / 1, gfd : labeling / 1, fd : deleteff / 3, sd : deleteff / 3, fd : deleteffc / 3, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_initialise / 5, ic_gap_sbdd : sbdd_try / 2, library(ic_sbds), library(fd_sbds), library(ic_gap_sbds), library(ic_gap_sbdd)"},"fd_sets:all_disjoint/1":{"prefix":"all_disjoint","body":"all_disjoint(${1:Sets})$2\n$0","description":"all_disjoint(+Sets)\n\n   Sets is a list of integers sets which are all disjoint\n\nType\n   library(fd_sets)"},"fd_sets:all_intersection/2":{"prefix":"all_intersection","body":"all_intersection(${1:Sets}, ${2:Intersection})$3\n$0","description":"all_intersection(+Sets, ?Intersection)\n\n   Intersection is the intersection of all the sets in the list Sets\n\nArguments\n   Sets    a non-empty list of sets, set variables or set expressions\n   Intersection    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:all_union/2":{"prefix":"all_union","body":"all_union(${1:Sets}, ${2:SetUnion})$3\n$0","description":"all_union(+Sets, ?SetUnion)\n\n   SetUnion is the union of all the sets in the list Sets\n\nArguments\n   Sets    a list of sets, set variables or set expressions\n   SetUnion    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:difference/3":{"prefix":"difference","body":"difference(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"difference(?Set1, ?Set2, ?Set3)\n\n   Set3 is the difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:get_set_attribute/2":{"prefix":"get_set_attribute","body":"get_set_attribute(${1:Set}, ${2:Attr})$3\n$0","description":"get_set_attribute(?Set, -Attr)\n\n   Get the set-attribute corresponding to Set\n\nArguments\n   Set    A ground set or a set variable\n   Attr    A variable, will be bound to a set-attribute structure\n\nType\n   library(fd_sets)\n\nDescription\n\n    Gets the set-attribute of a set-variable (or computes an attribute\n    structure describing a ground set as if it was a variable)."},"fd_sets:in/3":{"prefix":"in","body":"in(${1:X}, ${2:Set}, ${3:Bool})$4\n$0","description":"in(?X, ?Set, ?Bool)\n\n   Reified version of the set membership constraint\n\nArguments\n   X    an integer or an (integer) variable\n   Set    a set, set variable, or set expression\n   Bool    0, 1 or a boolean variable\n\nType\n   library(fd_sets)\n\nDescription\n\n    This is the reified version of the in/2 constraint. This means that\n    the boolean variable Bool reflects the truth of the relation X in Set.\n    If Bool is 1, then in(X,Set,Bool) is the same as X in Set.\n    If Bool is 0, then in(X,Set,Bool) is the same as X notin Set.\n    Otherwise, Bool will be bound to 0 or 1 when X in Set\n    is known to be false or true, respectively. The latter is only\n    guaranteed to be detected after X has become instantiated.\n\n    Note that if one wants to have booleans corresponding to all or most\n    of the set domain elements, it will be more efficient to use the\n    membership_booleans/2 constraint in place of many in/3 constraints.\n\nExceptions\n     4 --- Set is a free variable without set domain\n\nExamples\n   \n    ?- intset(S, 1, 9), in(E, S, B).\n    E = E{[-10000000 .. 10000000]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = B{[0, 1]}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), B = 1.\n    E = E{[1 .. 9]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = 1\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 1.\n    S = S{[3] \\/ ([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[1 .. 9]}}\n    E = 3\n    B = 1\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 0.\n    S = S{([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[0 .. 8]}}\n    E = 3\n    B = 0\n    Yes (0.00s cpu)\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S includes [2, 3, 4].\n    B = 1\n    E = 3\n    S = S{[2, 3, 4] \\/ ([] .. [1, 5, 6, 7, 8, 9]) : C{[3 .. 9]}}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S disjoint [2, 3, 4].\n    B = 0\n    E = 3\n    S = S{([] .. [1, 5, 6, 7, 8, 9]) : C{[0 .. 6]}}\n    There is 1 delayed goal.\n\n    ?- in(3, S, 1).\n    instantiation fault\n    \n\nSee Also\n   in / 2, notin / 2, membership_booleans / 2"},"fd_sets:insetdomain/4":{"prefix":"insetdomain","body":"insetdomain(${1:Set}, ${2:CardSel}, ${3:ElemSel}, ${4:Order})$5\n$0","description":"insetdomain(?Set, ?CardSel, ?ElemSel, ?Order)\n\n   Instantiate Set to a possible value\n\nArguments\n   Set    a set or set variable\n   CardSel    atom or variable\n   ElemSel    atom, structure or variable\n   Order    atom or variable\n\nType\n   library(fd_sets)\n\nDescription\n\n    This predicate instantiates a set variable to a possible value,\n    according to its domain.  The predicate backtracks over all\n    possible set instantiations.  The three option arguments allow to\n    choose between a number of different enumeration orders. Giving a\n    variable as option argument will select the default.\n\n    The CardSel argument determines whether the sets are enumerated\n    according to their cardinality. It can take the following values:\n\nany (default)\n    the sets are not enumerated in a particular cardinality order\nincreasing\n    the sets are enumerated with increasing cardinality, ie. small\n    sets are tried first\ndecreasing\n    the sets are enumerated with decreasing cardinality, ie. large\n    sets are tried first\n\n    The ElemSel argument determines which potential set elements\n    are considered first for inclusion or exclusion. It can take the\n    following values:\n\nsmall_first (default)\n    small set elements (small numbers) are considered first\nbig_first\n    big set elements (big numbers) are considered first\nrandom\n    potential set elements are considered in random order\nheavy_first(Weights)\n    heavy set elements (according to Weight array) are considered first\nlight_first(Weights)\n    light set elements (according to Weight array) are considered first\n\n    The Order argument determines whether it is first tried to make\n    the selected potential element a set member, or whether to exclude it\n    first.  The argument can take the following values:\n\nin_notin (default)\n    try inclusion first, then exclusion\nnotin_in\n    try exclusion first, then inclusion\nsbds\n    uses sbds_try/2 to include or exclude an element in or from a set\n    (this is for use in conjunction with the classic SBDS library\n    (lib(ic_sbds) or lib(fd_sbds)), and whether inclusion or exclusion is\n    tried first depends on the \"fix pred\" specified in the prior call to\n    sbds_initialise/4 or sbds_initialise/5)\ngap_sbds_in_notin\n    try inclusion first, then exclusion, using sbds_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))\ngap_sbds_notin_in\n    try exclusion first, then inclusion, using sbds_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))\ngap_sbdd_in_notin\n    try inclusion first, then exclusion, using sbdd_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))\ngap_sbdd_notin_in\n    try exclusion first, then inclusion, using sbdd_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))\n\n    Note that there are many different enumeration strategies for a set\n    variable, and insetdomain/4 only allows a limited number of them.\n    For an actual application, it might be more appropriate to choose a\n    problem-specific enumeration order. This can be programmed easily.\n    As a guideline, here is the code for insetdomain with the default\n    options:\n\n    insetdomain(Set, _, _, _) :-\n    \tnonvar(Set).\n    insetdomain(Set, any, small_first, in_notin) :-\n    \tvar(Set),\n    \tpotential_members(Set, PotentialElements),\n\tPotentialElements = [Element|_],\n\t(\n\t    Element in Set\n\t;\n\t    Element notin Set\n\t),\n\tinsetdomain(Set, any, small_first, in_notin).\n\nResatisfiable\n   yes\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n?-  X::[]..[1,2,3], insetdomain(X,_,_,_), writeln(X), fail.\n[1, 2, 3]\n[1, 2]\n[1, 3]\n[1]\n[2, 3]\n[2]\n[3]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,increasing,_,_), writeln(X), fail.\n[]\n[1]\n[2]\n[3]\n[1, 2]\n[1, 3]\n[2, 3]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,big_first,_), writeln(X), fail.\n[1, 2, 3]\n[2, 3]\n[1, 3]\n[3]\n[1, 2]\n[2]\n[1]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,_,notin_in), writeln(X), fail.\n[]\n[3]\n[2]\n[2, 3]\n[1]\n[1, 3]\n[1, 2]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3],\n\tinsetdomain(X, increasing, heavy_first([](2,9,4,7)), _),\n\twriteln(X), fail.\n[]\n[2]\n[3]\n[1]\n[2, 3]\n[1, 2]\n[1, 3]\n[1, 2, 3]\n\nno (more) solution.\n\nSee Also\n   conjunto : refine / 1, conjunto_fd_sets : refine / 1, potential_members / 2, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_try_set / 3, library(ic_gap_sbds), ic_gap_sbdd : sbdd_try_set / 3, library(ic_gap_sbdd)"},"fd_sets:int_sets/s":{"prefix":"struct","body":"struct","description":"struct int_sets(dom, off, lcard, ucard, added, removed, add, rem, card, booleans, value)\n\n   Attribute structure for set variables (and constants)\n\nFields\n   dom    set domain representation (array of booleans)\n   off    offset between set element and corresponding array index (integer)\n   lcard    lower bound cardinality (integer)\n   ucard    upper bound cardinality (integer)\n   added    notification send-port for lower bound increases\n   removed    notification send-port for upper bound decreases\n   add    suspension list woken when lower bound increases\n   rem    suspension list woken when upper bound decreases\n   card    fd/ic variable for cardinality (see #/2)\n   booleans    array of fd/ic variables (see membership_booleans/2)\n   value    set variable belonging to this attribute\n\nType\n   library(fd_sets)\n\nSee Also\n   library(notify_ports), suspend / 3, suspend / 4"},"fd_sets:intersection/3":{"prefix":"intersection","body":"intersection(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"intersection(?Set1, ?Set2, ?Set3)\n\n   Set3 is the intersection of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:intset/3":{"prefix":"intset","body":"intset(${1:Set}, ${2:Min}, ${3:Max})$4\n$0","description":"intset(?Set, +Min, +Max)\n\n   Set is a set containing numbers between Min and Max\n\nArguments\n   Set    A free variable, set variable or an integer list\n   Min    integer\n   Max    integer\n\nType\n   library(fd_sets)\n\nDescription\n\n    Unifies Set with a set variable whose lower bound is the empty set\n    and whose upper bound is the set of all integers between Min and Max.\n    Equivalent to Set::[]..[Min,Min+1,..,Max].\n\nExceptions\n     4 --- Min or Max are uninstantiated\n     5 --- Set is not a variable or list\n\nSee Also\n   intsets / 4, :: / 2"},"fd_sets:intsets/4":{"prefix":"intsets","body":"intsets(${1:Sets}, ${2:N}, ${3:Min}, ${4:Max})$5\n$0","description":"intsets(?Sets, ?N, +Min, +Max)\n\n   Sets is a list of N sets containing numbers between Min and Max\n\nType\n   library(fd_sets)\n\nExceptions\n     4 --- Min or Max are uninstantiated\n\nSee Also\n   intset / 3, :: / 2"},"fd_sets:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   Succeeds if Term is a ground set or a set variable\n\nArguments\n   Term    A term\n\nType\n   library(fd_sets)\n\nDescription\n\n    Succeeds if Term is either a set (represented as a list) or a set\n    variable. For efficiency reasons, lists are not checked for being\n    valid set representations (i.e. strictly sorted lists of integers),\n    the predicate succeeds for any list.\n\nFail Conditions\n   Set is neither a set nor a set variable"},"fd_sets:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   Succeeds if Term is a set variable\n\nArguments\n   Term    A term\n\nType\n   library(fd_sets)\n\nFail Conditions\n   Set is not a variable, or a non-set variable"},"fd_sets:fd_sets_desc":{"prefix":"lib","body":"lib(${1:fd_sets})$2\n$0","description":"lib(fd_sets)\n\n    This is a solver for constraints over the domain of finite integer sets.\n    \n    (Ground) integer sets are represented simply as sorted, duplicate-free\n    lists of integers e.g.\n    \n    \tSetOfThree = [1,3,7]\n    \tEmptySet = []\n    \n\nSet Variables\n    Set variables are variables which can eventually take a ground integer\n    set as their value. They are characterized by a lower bound (the set \n    of elements that are definitely in the set) and an upper bound (the\n    set of elements that may be in the set). A set variable can be declared\n    as follows:\n    \n    \tSetVar :: []..[1,2,3,4,5,6,7],\n    \n    Since the lower bound is the empty set, this can be written as\n    \n    \tSetVar subset [1,2,3,4,5,6,7],\n    \n    If the lower bound is the empty set and the upper bound is a set\n    of consecutive integers, you can also write\n    \n    \tintset(SetVar, 1, 7)\n    \n\nSet Constraints\n    Most of the usual set operations/relations are provided as constraints:\n    \n    membership\n    non-membership\n    inclusion (subset)\n    equality\n    intersection\n    union\n    difference\n    symmetric difference\n    disjointness\n    cardinality\n    \n    as well as a constraint on set weight.  Note that there is no\n    complement-constraint because the library has no concept of a set\n    universe and cannot represent infinite sets.\n    \n    On most argument positions where sets are expected, set expressions\n    are allowed, e.g.\n    \n    Set1 /\\ Set2       % intersection\n    Set1 \\/ Set2       % union\n    Set1 \\ Set2    % difference\n    \n    as well as references to array elements like Set[3].\n    \n\nSearch\n    The insetdomain/4 predicate can be used to enumerate all ground\n    instantiations of a set variable, much like indomain/1 in the\n    finite-domain case.\n\nCooperation with a finite domain solver\n    This library comes in two flavours: lib(fd_sets) which cooperates with\n    lib(fd), and lib(ic_sets) which cooperates with lib(ic). This is relevant\n    only for those constraints which involve integer variables, e.g. the\n    cardinality argument in #/2, the weight argument in weight/3 and the\n    booleans in membership_booleans/2. These will be represented as fd-\n    or ic-variables respectively."},"fd_sets:membership_booleans/2":{"prefix":"membership_booleans","body":"membership_booleans(${1:Set}, ${2:BoolArr})$3\n$0","description":"membership_booleans(?Set, ?BoolArr)\n\n   BoolArr is an array of booleans describing Set\n\nArguments\n   Set    a set, set variable, free variable or set expression\n   BoolArr    A variable or an array (structure) of boolean variables\n\nType\n   library(fd_sets)\n\nDescription\n\n    This constraint maintains the correspondence between a finite set and\n    an array of booleans (0/1 variables). The set is constrained to contain\n    those (and only those) integers I between 1 and N (the size of the array)\n    where the corresponding array element is 1.\n\n    Operationally, setting a array element I to 0 will exclude the element\n    I from Set's domain. Setting I to 1 will include I in Set's lower bound.\n    Adding and removing elements from Set will be reflected in the\n    corresponding boolean being instantiated to 1 or 0 respectively.\n\n    When called with BoolArr being a free variable, an array will be created\n    whose arity is at least as big as the largest potential set member.\n    Set members smaller than 1 will be excluded from the set.\n    When called with BoolArr being instantiated to an array, set members\n    smaller than 1 or bigger than the array size will be excluded from\n    the set.\n\nExamples\n   \n    ?- S::[2,4]..[1,2,3,4,5], membership_booleans(S,B).\n\n    S = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n    B = [](_{[0, 1]}, 1, _{[0, 1]}, 1, _{[0, 1]})\n\n    Delayed goals:\n\t...\n\n    ?- membership_booleans(S, [](0,1,0,1,B5)).\n\n    S = S{[2, 4] \\/ ([] .. [5]) : _{[2, 3]}}\n    B5 = B5{[0, 1]}\n\n    Delayed goals:\n\t..."},"fd_sets:potential_members/2":{"prefix":"potential_members","body":"potential_members(${1:Set}, ${2:List})$3\n$0","description":"potential_members(?Set, -List)\n\n   List is the list of elements of whose membership in Set is currently uncertain\n\nArguments\n   Set    a set or set variable\n   List    variable, will be unified with a list\n\nType\n   library(fd_sets)\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n    \t?- S :: [2,4]..[1,2,3,4,5], potential_members(S, P).\n\tS = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n\tP = [1, 3, 5]"},"fd_sets:set_range/3":{"prefix":"set_range","body":"set_range(${1:Set}, ${2:Lwb}, ${3:Upb})$4\n$0","description":"set_range(?Set, -Lwb, -Upb)\n\n   Lwb and Upb are the current lower and upper bounds on Set\n\nArguments\n   Set    A variable or an integer list\n   Lwb    List of integers\n   Upb    List of integers\n\nType\n   library(fd_sets)\n\nDescription\n\n    Returns two sorted, duplicate-free lists of integers which represent\n    the lower and upper bound of the set variable (or the ground set) Set.\n    The predicate can also be used as a test for set-variables, since it\n    fails for any other (in particular domain-less) variables.\n\nFail Conditions\n   Set is a variable, but not a set variable"},"fd_sets:symdiff/3":{"prefix":"symdiff","body":"symdiff(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"symdiff(?Set1, ?Set2, ?Set3)\n\n   Set3 is the symmetric difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:union/3":{"prefix":"union","body":"union(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"union(?Set1, ?Set2, ?Set3)\n\n   Set3 is the union of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(fd_sets)"},"fd_sets:weight/3":{"prefix":"weight","body":"weight(${1:Set}, ${2:ElementWeights}, ${3:Weight})$4\n$0","description":"weight(?Set, ++ElementWeights, ?Weight)\n\n   According to the array of element weights, the weight of set Set is Weight\n\nArguments\n   Set    a set, set variable or set expression\n   ElementWeights      an array (structure) of non-negative integers\n   Weight    an integer variable or integer\n\nType\n   library(fd_sets)\n\nDescription\n\n    Set is constrained to be a set of integers between 1 and the size of\n    the array ElementWeights. Weight is an integer domain variable which\n    is constrained to the sum of the weights of Set's elements. The weight\n    of a set element is determined by the array element in ElementWeights\n    whose index corresponds to the set element.\n\n    Changes to the set domain will affect the domain of Weight. There is currently\n    no reverse propagation. This may change in a future release."},"format:format/2":{"prefix":"format","body":"format(${1:Format}, ${2:Args})$3\n$0","description":"format(++Format, +Args)\n\n   Print formatted data\n\nArguments\n   Format    Format string (string, atom, chars or codes)\n   Args    A list of terms\n\nType\n   library(format)\n\nModes and Determinism\n   format(++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   format / 3, library(quintus)"},"format:format/3":{"prefix":"format","body":"format(${1:Stream}, ${2:Format}, ${3:Args})$4\n$0","description":"format(+Stream, ++Format, +Args)\n\n   Print formatted data\n\nArguments\n   Stream    A stream handle or alias\n   Format    Format string (string, atom, chars or codes)\n   Args    A list of terms\n\nType\n   library(format)\n\nDescription\n\r\n    \tThis is a partial implementation of the format/3 predicate as\r\n\timplemented in several Prolog systems.  It simply maps the format\r\n\tstring to ECLiPSe's printf/3 formats, and therefore supports only\r\n\tthose formats which are compatible.\r\n\nModes and Determinism\n   format(+, ++, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   printf / 3, library(quintus)"},"gap:gap_ensure_started/0":{"prefix":"gap_ensure_started","body":"gap_ensure_started","description":"gap_ensure_started\n\n   Make sure there is a GAP session active\n\nType\n   library(gap)\n\nDescription\n   Makes sure that there is a GAP session currently active, by starting GAP\n   if required.  It is normally not necessary to call this predicate\n   directly, since sending any GAP command or query will automatically start\n   GAP if GAP is not currently running.  However, there may be circumstances\n   where one wishes to force GAP to start, to avoid the start-up delay later\n   when the first command is sent.\n\nSee Also\n   gap_shutdown / 0, gap_restart / 0, gap_running / 0"},"gap:gap_command/2":{"prefix":"gap_command","body":"gap_command(${1:Format}, ${2:Args})$3\n$0","description":"gap_command(++Format, +Args)\n\n   Send a command to GAP\n\nArguments\n   Format    Format string\n   Args    List of arguments\n\nType\n   library(gap)\n\nDescription\n   Sends a command to GAP.  The command is specified using Format and Args a\n   la printf/2.  It is not necessary to terminate the GAP command with a\n   semicolon.\n\n   If there is no currently active GAP session, one is started before\n   sending the command.\n\nSee Also\n   gap_query / 3, gap_query_string / 3, printf / 2"},"gap:gap_desc":{"prefix":"lib","body":"lib(${1:gap})$2\n$0","description":"lib(gap)\n\n   This library provides an interface to the GAP computational algebra\n   system (see www.gap-system.org).  GAP must be installed and appear in the\n   user's path in order for this library to work.\n\n   Commands can be sent to GAP using the gap_command/2 predicate.  If there\n   are results that need to be returned to ECLiPSe, use gap_query/3 or\n   gap_query_string/3.  Normally GAP will be started automatically when it\n   is needed, and shut down automatically when the ECLiPSe session ends, but\n   some manual control is available through gap_ensure_started/0,\n   gap_shutdown/0 and gap_restart/0.  gap_running/0 can be used to determine\n   whether a GAP session is currently active.\n\n   The current implementation of the library only supports one GAP session\n   at a time, to be shared amongst all software components that use the\n   library.  In future we expect to allow multiple concurrent independent\n   sessions through the use of handles.\n\n   This library supports the following options (see library(config_opts)):\n   \n   gap_reporting_level\n       Controls how much reporting output the GAP interface generates.\n       Valid levels are:\n       \n       silent\n    Generate no reporting output under any circumstances.\n       error\n    Generate reporting output only when an error occurs.\n       standard\n    Generate basic reporting output.\n       verbose\n    Generate lots of reporting output, including all commands and\n    queries sent to/from GAP.\n       \n       The default is standard.  Verbose can be useful for debugging.\n\n   gap_reporting_stream\n       Specifies the stream to send reporting output to.  By default,\n       ECLiPSe's standard output stream is used.\n   \n\n   This library is still experimental and is expected to evolve.  Feedback,\n   suggestions, problem reports, etc. welcome.\n\n   Please note that this library currently does not work on Windows machines\n   since it relies on named pipes, which are currently unsupported by\n   cygwin."},"gap:gap_restart/0":{"prefix":"gap_restart","body":"gap_restart","description":"gap_restart\n\n   Restart a GAP session\n\nType\n   library(gap)\n\nDescription\n   Restarts the currently active GAP session.  This is useful if one wishes\n   to discard GAP's current state and start again with a fresh session (all\n   GAP state is lost).\n\n   This predicate is simply a short-hand for calling gap_shutdown/0 and then\n   gap_ensure_started/0.\n\nSee Also\n   gap_ensure_started / 0, gap_shutdown / 0, gap_running / 0"},"gap:gap_running/0":{"prefix":"gap_running","body":"gap_running","description":"gap_running\n\n   Query whether a GAP session is currently active\n\nType\n   library(gap)\n\nDescription\n   This predicate succeeds if there is a GAP session currently active and\n   fails if there is not.\n\nSee Also\n   gap_ensure_started / 0, gap_shutdown / 0, gap_restart / 0"},"gap:gap_shutdown/0":{"prefix":"gap_shutdown","body":"gap_shutdown","description":"gap_shutdown\n\n   Shut down a GAP session\n\nType\n   library(gap)\n\nDescription\n   Shuts down the currently active GAP session if there is one.  With recent\n   versions of ECLiPSe it is not normally necessary to call this explicitly;\n   GAP will be shut down automatically before the ECLiPSe session ends.\n   However, there may be circumstances where one wishes to force GAP to shut\n   down before the session ends, and on older versions of ECLiPSe a manual\n   shutdown is required in order to terminate the GAP process and clean up\n   the named pipes used for communication.\n\nSee Also\n   gap_ensure_started / 0, gap_restart / 0, gap_running / 0"},"gap:gap_query/3":{"prefix":"gap_query","body":"gap_query(${1:Format}, ${2:Args}, ${3:Result})$4\n$0","description":"gap_query(++Format, +Args, ?Result)\n\n   Query GAP\n\nArguments\n   Format    Format string\n   Args    List of arguments\n   Result    Result (term)\n\nType\n   library(gap)\n\nDescription\n   Evaluates an expression in GAP and returns the result as an ECLiPSe term.\n   The expression is specified using Format and Args a la printf/2, and\n   should be a valid GAP expression (no terminating semicolon).  The result\n   is returned as an ECLiPSe term in Result (it is an error if the result\n   returned from GAP is not a valid ECLiPSe term).\n\n   If there is no currently active GAP session, one is started before\n   sending the query.\n\nSee Also\n   gap_query_string / 3, gap_command / 2, printf / 2"},"gap:gap_query_string/3":{"prefix":"gap_query_string","body":"gap_query_string(${1:Format}, ${2:Args}, ${3:Result})$4\n$0","description":"gap_query_string(++Format, +Args, ?Result)\n\n   Query GAP\n\nArguments\n   Format    Format string\n   Args    List of arguments\n   Result    Result (string)\n\nType\n   library(gap)\n\nDescription\n   Evaluates an expression in GAP and returns the result as a string.  The\n   expression is specified using Format and Args a la printf/2, and should\n   be a valid GAP expression (no terminating semicolon).  The result is\n   returned as a string in Result.\n\n   If there is no currently active GAP session, one is started before\n   sending the query.\n\nSee Also\n   gap_query / 3, gap_command / 2, printf / 2"},"gfd_sbds:gfd_sbds_desc":{"prefix":"lib","body":"lib(${1:gfd_sbds})$2\n$0","description":"lib(gfd_sbds)\n\n   Symmetry Breaking During Search (SBDS) library, provides predicates to initalise symmetry breaking during search search and to perform the search, as well as utility functions for prining and unification."},"gfd_sbds:sbds_get_matrix/2":{"prefix":"sbds_get_matrix","body":"sbds_get_matrix(${1:Var}, ${2:Matrix})$3\n$0","description":"sbds_get_matrix(?Var, -Matrix)\n\n   get the matrix (array) of SBDS attributed variables\n\nArguments\n   Var    SBDS variable\n   Matrix    The matrix that Var appears in\n\nType\n   library(gfd_sbds)\n\nDescription\n\tUnifies Matrix with the matrix (array) provided to a call to\n\tsbds_initialise/4 or sbds_initialise/5 which contains Var.\n\nFail Conditions\n   Var is not an SBDS variable."},"gfd_sbds:sbds_initialise/4":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:SymPreds}, ${3:FixPred}, ${4:Options})$5\n$0","description":"sbds_initialise(+VarMatrix, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(gfd_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to, in this case a 1-dimensonal matrix, for the n-dimensonal case see \t\tsbds_initalise/5.\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation\n\ti.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), \n\tyou only need to specify the parameters that you have added. So for the above \t\tpredicate,\n\tthe entry to the list would be: symmetry_predicate(Matrix)\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a 1 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\n\t\n\tr180(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\t\n\t\n\tr270(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trx(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is Value.\n\t\n\n\t\n\try(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\n\t\n\trd1(Matrix, _N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trd2(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\t\n\t Then to initialise SBDS\n\t%If the Board is a list of variables then we change it to a matrix\t\n\tMatrix =.. [[] | Board],\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 5, sbds_try / 2"},"gfd_sbds:sbds_initialise/5":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:NDims}, ${3:SymPreds}, ${4:FixPred}, ${5:Options})$6\n$0","description":"sbds_initialise(+VarMatrix, ++NDims, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   NDims    The Dimenson of VarMatrix\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(gfd_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to.\n\t\n\t\n\tNDims is the dimenson of VarMatrix\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation i.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), you only need to specify the parameters that you have added. \t\tSo for the above predicate, the entry to the list would \t\t\t\tbe: symmetry_predicate(Matrix).\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a boolean encoding on a 2 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t\n\tr180(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\tr270(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, X],\n    \t\tSymValue is Value.\n\t\t\n\t\n\trx(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, Y],\n    \t\tSymValue is Value.\n\t\n\t\n\try(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\trd1(Matrix, _N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, X],\n    \t\tSymValue is Value.\n\t\n\t\n\trd2(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t Then to initialise SBDS\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, 2, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 4, sbds_try / 2"},"gfd_sbds:sbds_try/2":{"prefix":"sbds_try","body":"sbds_try(${1:Var}, ${2:Val})$3\n$0","description":"sbds_try(?Var, ++Val)\n\n   tries to assign a variable to a value\n\nArguments\n   Var    SBDS Variable\n   Val    Value to try and assign to Value\n\nType\n   library(gfd_sbds)\n\nDescription\nCalled for each variable, value pair tried at a decision point \t\tduring search.\n\t\n\t\n\tInitally tries to assign a variable to a value, if this is succesful then it \t\tupdates the symmetry functions to take account of any symmetries which have \t\tbeen broken by this assignment.\n\t\n\t\n\tIf this assignment is unsuccesful then it stipulates that the variable cannot \t\tbe assigned to this value, before placing constraints to eliminate the \t\t\tsymmetrical equivalent of this assgnment. If these symmetries are not already \t\tbroken\n\nExceptions\n   abort --- Var is not an sbds attributed variable\n\nExamples\n Replacement for labeling/1 which takes SBDS into account \t\t\n\t\n\tsbds_labeling(AllVars) :-\n    ( foreach(Var, AllVars) do\n\t  count_backtracks,\n    sbds_indomain(Var)    \n    ).\n    \n\tReplacement for indomain/1 which takes SBDS into account.\n\t\n\t% value ordering is input order\n\tsbds_indomain(X) :-\n\t\tnonvar(X).\n\tsbds_indomain(X) :-\n\t\tvar(X),\n\t\tmindomain(X, LWB),\n\t\t%sbds_try called here\n\t\tsbds_try(X, LWB),\n\t\tsbds_indomain(X).\n\t\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5, ic : search / 6"},"foreign:foreign_desc":{"prefix":"lib","body":"lib(${1:foreign})$2\n$0","description":"lib(foreign)\n\n   \nSimple foreign interface like SICStus or Quintus(TM). For every C function\nan interface C function is generated which converts the arguments\nfrom and to the Sepia ones. Note that this is faster (and uses more\nC code) than one generic interface procedure which dispatches all\nexternal calls like in the above systems. Use it as follows:\n\n1) load this file with lib(foreign)\n2) compile (Sepia) the file with the foreign/3 clauses\n3) call make_simple_interface/0 or /1; this will generate the file\n   e_interface.c\n4) compile (cc) e_interface.c and the other C source files\n      On a SVR4 system (e.g. Solaris 2.x) produce one .so file\n      from all the .o files that should be loaded, including\n      the file e_interface.o. On Solaris this can be done with\n      something like\n\tcc -I$ECLIPSEDIR/include -G -o myfile.so file1.c file2.c \t\t... e_interface.c\n5) call load_foreign_files/2. This assumes that the foreign/3 clauses\n   are still available.\n\nThis means that a file which contains both foreign/3 facts and\na goal :- load_foreign_files(...) must be split so that\nmake_simple_interface/0 can be called before the goal.\nHowever, once the file e_interface.c is created, this file can be used\nin the original form.\n\nThe main purpose of the interface is to port foreign files from\nSICStus or Quintus to Sepia, or to automate interfacing of\nother existing C functions. When writing new external functions,\nit is more efficient to use the Sepia external interface directly.\n\nUser-defined types and conversion can also be specified.\nIf some additional declarations and function calls are necessary\nbefore or after calling the C function, the type can be specified\nas a user type:\n\t[+-]user(Type)\n\nWhen such a type is encountered, this library will call the predicate\n\nforeign_user_type(+Type, +I, -CType, -Local, -TypeCheck, -InConv,\n\t-Call, -OutConv, -Unif)\n\nwhich is supposed to yield the data to be inserted into the\nsource of the interface file. The arguments are as follows:\nType\t- the name of the user type with + or -, e.g. +mystring\nI\t- the argument position; used to make distinction\n\t  among several args of the same type\nCType\t- the corresponding C type\nLocal\t- declaration of local variables for this type\nTypeCheck - type testing of the predicate arguments\nInConv\t- calls to be made before calling the foreign function\nCall\t- the actual argument passed to the foreign function\nOutConv\t- calls to be made after the foreign call and before\n\t  the unification of output arguments\nUnif\t- unification of the output argument\n\nThe source of the generated interface for a declaration\nforeign(funct, c, funct(+integer, +user(ut)))\nlooks as follows:\n\np_funct(val1, tag1, val2, tag2)\nvalue\tval1, val2;\ntype\ttag1, tag2;\n{\n\tLOCAL\n\n\tCheck_Integer(tag1);\n\tTYPECHECK\n\tINCONV\n\tfunct(val1.nint, CALL)\n\tOUTCONV\n\tReturn_UNIF\n}\nwhere the capitalized ids are substituted by the user definition."},"gfd_sbds:is_sbds_var/1":{"prefix":"is_sbds_var","body":"is_sbds_var(${1:Var})$2\n$0","description":"is_sbds_var(?Var)\n\n   checks whether a variable is an SBDS variable\n\nArguments\n   Var    Variable to check\n\nType\n   library(gfd_sbds)\n\nDescription\n\tSucceeds if and only if Var is a variable and has been initialised\n\tas an SBDS variable (through a call to sbds_initialise/4 or\n\tsbds_initialise/5).\n\nFail Conditions\n   Var is not a variable or not an SBDS variable.\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5"},"gfd_sbds:sbds_get_index/2":{"prefix":"sbds_get_index","body":"sbds_get_index(${1:Var}, ${2:Idx})$3\n$0","description":"sbds_get_index(?Var, -Idx)\n\n   get the index of an SBDS attributed variable\n\nArguments\n   Var    SBDS variable\n   Idx    The index of Var\n\nType\n   library(gfd_sbds)\n\nDescription\n\tUnifies Idx with the index of the SBDS variable Var.  The index of\n\tthe variable is its position in the matrix provided in the\n\tcorresponding call to sbds_initialise/4 or sbds_initialise/5\n\nFail Conditions\n   Var is not an SBDS variable."},"gfd_search:delete/5":{"prefix":"delete","body":"delete(${1:X}, ${2:List}, ${3:R}, ${4:Arg}, ${5:Select})$6\n$0","description":"delete(-X, +List, -R, ++Arg, ++Select)\n\n   Choose a domain variable from a list according to selection criterion.\n\nArguments\n   X    a free variable\n   List    a list of variables or terms \n   R    a free variable \n   Arg    an integer\n   Select    the name of the selection criterion\n\nType\n   library(gfd_search)\n\nDescription\n\nThis predicate chooses one entry in a list of variables or terms based\non some selection criterion.  The criteria are explained in detail in\nthe search/6 predicate. The selected entry is returned in X, with\nthe rest of the list without X returned in R.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   fails if the list is empty\n\nResatisfiable\n   no\n\nExamples\n   \n\nSee Also\n   search / 6"},"gfd_search:gfd_search_desc":{"prefix":"lib","body":"lib(${1:gfd_search})$2\n$0","description":"lib(gfd_search)\n\n  This library provides the generic search facilities search/6, delete/5\n  and indomain/2 for the GFD solver, compatible with the corresponding\n  versions in library(fd_search) and library(ic).\n\n  This GFD version allows the following additional variable selection\n  criteria (in addition to the generic ones) in delete/5 and search/6:\n\n  max_regret_lwb\n  max_regret_upb\n  max_weighted_degree\n  most_constrained_per_value\n  max_weighted_degree_per_value"},"gfd_search:indomain/2":{"prefix":"indomain","body":"indomain(${1:Var}, ${2:Method})$3\n$0","description":"indomain(?Var, ++Method)\n\n   a flexible way to assign values to finite domain variables\n\nArguments\n   Var    a domain variable or an integer\n   Method    one of the atoms min, max, middle, median, split, interval, random or an integer\n\nType\n   library(gfd_search)\n\nDescription\nThis predicate provides a flexible way to assign values to finite \ndomain variables.\nThe available methods are:\n\nenum Identical to indomain/1. Start enumeration from the smallest\n    value upwards, without first removing previously tried values.\n\nmin Start the enumeration from the smallest value upwards. \n    This behaves like the built-in indomain/1, except that it\n    removes previously tested values on backtracking.\n\nmax Start the enumeration from the largest value\n    downwards.\n\nreverse_min Like min, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nreverse_max Like max, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nmiddle Try the enumeration starting from the middle of the\n    domain.  On backtracking, this chooses alternatively values above and\n    below the middle value, until all alternatives have been tested.\n\nmedian Try the enumeration starting from the median value\n    of the domain.  On backtracking, this chooses alternatively values\n    above and below the median value, until all alternatives have been\n    tested.\n\nsplit Try the enumeration by splitting the domain\n    successively into halves until a ground value is reached.  This\n    sometimes can detect failure earlier than the normal enumeration\n    methods, but enumerates the values in the same order as min.\n\nreverse_split Like split, but tries the upper half of the\n    domain first.\n\ninterval If the domain consists of several intervals, then\n    we branch first on the choice of the interval.  For one interval, we\n    use domain splitting.\n\nrandom Try the enumeration in a random order.  On\n    backtracking, the previously tested value is removed.  This method\n    uses random/1 to create random numbers, use seed/1\n    before to make results reproducible.\n\nValue:integer Like middle, but start with the given integer\n    Value\n\nsbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the SBDS symmetry breaking\n    library).\n\ngap_sbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the GAP-based SBDS symmetry\n    breaking library, lib(ic_gap_sbds)).\n\ngap_sbdd_min Like min, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_max Like max, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_middle Like middle, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_median Like median, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_random Like random, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd(Value:integer) Like Value:integer, but use sbdd_try/2\n    to make choices (for use in conjunction with the GAP-based SBDD symmetry\n    breaking library, lib(ic_gap_sbdd)).\n\nOn backtracking, all methods except enum first remove the previously tested\nvalue before choosing a new one.  This sometimes can have a huge impact on the\nconstraint propagation, and normally does not cause much overhead, even if no\nadditional propagation occurs.\n\nFail Conditions\n   No\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tX :: 1..10,\n\tindomain(X,min),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,max),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 10 9 8 7 6 5 4 3 2 1\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,middle),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,median),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,3),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 3 4 2 5 1 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,split),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,random),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes for example 5 3 7 6 8 1 2 10 9 4\n\nSee Also\n   search / 6, fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, random / 1, seed / 1, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_try / 2"},"gnuplot:gnuplot_desc":{"prefix":"lib","body":"lib(${1:gnuplot})$2\n$0","description":"lib(gnuplot)\n\n This library provides an interface to the function and data\n plotting program - gnuplot.\n\n The gnuplot program is available for most platforms and can be\n downloaded from http://www.gnuplot.info/.\n This version of lib(gnuplot) officially supports gnuplot version 3.7\n and higher though it may work with earlier versions as well.\n\n The executable gnuplot on Unices, and\n pgnuplot.exe on Windows must be installed on the default\n path, or be present in the current working directory. \n NOTE: On Windows it is NOT sufficient to simply have the\n gnuplot.exe or wgnuplot.exe, you must have the\n pgnuplot.exe as well.\n\n See the various plot predicates for further example usage.\n\n For a complete description of the avilable options we refer the\n user to the excellent documentation which accompanies gnuplot.  \n Most features have an obvious analogue in this library.\n \n Syntax note: wherever gnuplot expects a string as an option value,\n use a double-quoted ECLiPSe string - unquoted or single-quoted atoms\n will not work!."},"gfd_search:nth_value/3":{"prefix":"nth_value","body":"nth_value(${1:Domain}, ${2:N}, ${3:Value})$4\n$0","description":"nth_value(+Domain, ++N, -Value)\n\n   return the nth value in a domain\n\nArguments\n   Domain    The domain list to select a value from\n   N    The position of the value to select\n   Value    The selected value\n\nType\n   library(gfd_search)\n\nDescription\nFind the nth value in a domain given by an interval or a list of\nintegers and intervals, as it is returned for example by ic's\nget_domain/2 or fd's ::/2.\n\nFail Conditions\n   N < 1 or there are less than N values in the domain.\n\nResatisfiable\n   no\n\nExamples\n   \n% a typical use\n\n\t....\n\tget_domain(X, L),\n\tnth_value(L, 2, Value),\n\t....\n\nSee Also\n   fd : :: / 2, ic : get_domain / 2"},"gnuplot:plot/1":{"prefix":"plot","body":"plot(${1:Data})$2\n$0","description":"plot(++Data)\n\n   Plot the given data using default options\n\nArguments\n   Data    The data to be plotted, array or list.\n\nType\n   library(gnuplot)\n\nDescription\n Produces an on screen plot of the data given using the default\n settings.\n\n Can either be a list or a nested list of a 1D or 2D array of y\n values or x-y points.\n\nFail Conditions\n   Data is not in a valid format\n\nResatisfiable\n   false\n\nExamples\n   \n% x-y pairs\n?- A=[1-3,5-2,9-2,8-2,5-7], plot(A).\n\n% y values\n?- A=[1,2,3,4,8,9,4,2,4,6], plot(A).\n\n% multiple y values in nested lists\n?- A=[[1,2,4,6,7,8,9],[1,4,16,36,49,64,81]], plot(A).    \n\n% multiple y values in an array\n?- A=[]([](1,2,4,6,7,8,9),[](1,4,16,36,49,64,81)), plot(A).\n\n% multiple x-y pairs\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]], plot(A).\n\nSee Also\n   plot / 2, plot / 3, plot / 4"},"gfd_search:search/6":{"prefix":"search","body":"search(${1:L}, ${2:Arg}, ${3:Select}, ${4:Choice}, ${5:Method}, ${6:Option})$7\n$0","description":"search(+L, ++Arg, ++Select, +Choice, ++Method, +Option)\n\n   A generic search routine for finite domains or IC which implements \ndifferent partial search methods (complete, credit, lds, bbs, dbs, sbds,\ngap_sbds, gap_sbdd)\n\nArguments\n   L    a collection (a la collection_to_list/2) of domain\n\t    variables (Arg = 0) or a collection of terms (Arg > 0)\n   Arg    an integer, which is 0 if the list is a list of domain\n\t    variables, or greater than 0 if the list consists of terms\n\t    with arity at least Arg (the value Arg indicating the argument\n\t    that contains the domain variables to be labeled)\n   Select    the name of a predefined selection method (input_order,\n\t    first_fail, smallest, largest, occurrence, most_constrained,\n\t    max_regret, anti_first_fail), or an atom or compound term\n\t    specifying a user-defined selection method\n   Choice    the name of a predefined choice method (indomain,\n\t    indomain_min, indomain_max, indomain_middle, indomain_reverse_min,\n\t    indomain_reverse_max, indomain_median, indomain_split,\n\t    indomain_reverse_split, indomain_random, indomain_interval),\n\t    or an atom or compound term specifying a user-defined method\n   Method    one of the following search method specifications:\n\t    complete, bbs(Steps:integer), lds(Disc:integer),\n\t    credit(Credit:integer, Extra:integer or bbs(Steps:integer)\n\t    or lds(Disc:integer)), dbs(Level:integer, Extra:integer or\n\t    bbs(Steps:integer) or lds(Disc:integer)), sbds, gap_sbds,\n\t    gap_sbdd\n   Option    a list of option terms.  Currently recognized\n\t   are backtrack(-N), node(++Call), nodes(++N)\n\nType\n   library(gfd_search)\n\nDescription\nSearch/6 provides a generic interface to a set of different search\nmethods.  It can currently be used with either the finite domains (if\nloaded via lib(fd_search)), or integer IC domains (if loaded via\nlib(ic_search)).  By changing the Method argument, different partial\nsearch algorithms (and their parameters) can be selected and\ncontrolled. The search predicate also provides a number of pre-defined\nvariable selection methods (to choose which variable will be assigned next)\nand some pre-defined value assignment methods (to try out the possible\nvalues for the selected variable in some heuristic order), but user-defined\nmethods can be used in their place as well.  In order to allow more\nstructure in the application program, it is possible to pass a collection\nof terms rather than only a collection of domain variables. In this way all\ninformation about some entity can be easily grouped together. It also\nallows more complex labeling methods which combine the assignment of\nmultiple variables (like a preference value and a decision variable).\n\nAll search methods use a stable selection method. If several entries\nhave the same heuristic value, then the first one is selected.  The rest of\nthe collection (treated as a list) is equal to the original list with the\nselected entry removed, the order of the non-selected entries does not\nchange.\n\nThe pre-defined selection methods are the following:\n\ninput_order\n\tthe first entry in the list is selected\nfirst_fail\n\tthe entry with the smallest domain size is selected\nanti_first_fail\n\tthe entry with the largest domain size is selected\nsmallest\n\tthe entry with the smallest value in the domain is selected\nlargest\n\tthe entry with the largest value in the domain is selected\noccurrence\n\tthe entry with the largest number of attached constraints is selected\nmost_constrained\n\tthe entry with the smallest domain size is selected.  If several\n\tentries have the same domain size, the entry with the largest number\n\tof attached constraints is selected.\nmax_regret\n\tthe entry with the largest difference between the smallest and second\n\tsmallest value in the domain is selected. This method is typically\n\tused if the variable represents a cost, and we are interested in\n\tthe choice which could increase overall cost the most if the best\n\tpossibility is not taken. Unfortunately, the implementation does\n\tnot always work: If two decision variables incur the same minimal\n\tcost, the regret is not calculated as zero, but as the difference\n\tfrom this minimal value to the next greater value.\n\nAny other atom will be taken as the specification of a user-defined\nselection predicate.  This will be invoked with 2 arguments (X,Criterion)\nadded and is expected to compute a selection criterion (typically a number)\nfrom a variable or value X.  E.g. if Select is 'my_select', a predicate\ndefinition like the following has to be provided:\n\n    my_select(X,Criterion) :-\n\t...\t% compute Criterion from variable X\n\nThe variable-selection will then select the variable with the lowest value\n(in standard term order) of Criterion.  If several variables have the same\nvalue, the first one is selected.  \n\nThe above selection methods use the predefined delete/5 predicate.\nIf this is not general enough, you can replace it with your own: if Select\nis given as select(my_delete), then my_delete(-SelectedVar,+List,-Rest,+Arg)\nwill be invoked for selecting a variable from List.\n\nThe pre-defined choice methods have the following meaning:\n\nindomain\n    uses the built-in indomain/1.  Values are tried in increasing order. \n    On failure, the previously tested value is not removed.\n\nindomain_min\n    Values are tried in increasing order.  On failure, the previously\n    tested value is removed.  The values are tested in the same order as\n    for indomain, but backtracking may occur earlier.\n\nindomain_max\n    Values are tried in decreasing order.  On failure, the previously\n    tested value is removed.\n\nindomain_reverse_min\n    Like indomain_min, but the alternatives are tried in reverse order.\n    I.e. the smallest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_reverse_max\n    Like indomain_max, but the alternatives are tried in reverse order.\n    I.e. the largest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_middle\n    Values are tried beginning from the middle of the domain.  On failure,\n    the previously tested value is removed.\n\nindomain_median\n    Values are tried beginning from the median value of the domain.  On\n    failure, the previously tested value is removed.\n\nindomain_split\n    Values are tried by succesive domain splitting, trying the lower half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_min, but\n    may fail earlier.\n\nindomain_reverse_split\n    Values are tried by succesive domain splitting, trying the upper half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_max, but\n    may fail earlier.\n\nindomain_random\n    Values are tried in a random order.  On backtracking, the previously\n    tried value is removed.  Using this rutine may lead to unreproducable\n    results, as another call wil create random numbers in a different\n    sequence.  This method uses the built-in random/1 to create\n    random numbers, seed/1 can be used to force the same number\n    generation sequence in another run.\n\nindomain_interval\n    If the domain consists of several intervals, we first branch on the\n    choice of the interval.  For one interval, we use domain\n    splitting.\n\nAny other name is taken as the name of a user-defined predicate of\narity 1, to which the variable to be labeled (or a whole element of\nlist L, in the Arg>0 case) is passed, e.g.\n\n    my_choice(X) :-\n\t...\t% make a choice on variable X\n\nAlternatively, a term with 2 arguments can be given as the choice-method,\ne.g. my_choice(FirstIn,LastOut). this will lead to the invocation of a\nchoice predicate with arity 3, e.g.\n\n    my_choice(X,In,Out) :-\n\t...\t% make a choice on variable X, using In-Out\n\nThis allows user-defined state to be transferred between the subsequent\ninvocations of the choice-predicate (the Out argument of a call to\nmy_choice/3 for one variable is unified with the In argument of the call to\nmy_choice/3 for the next variable, and so on).\n\nIn addition, a fixed argument can be passed: my_choice(Param) leads to\ninvocation of my_choice(X,Param), and my_choice(Param,FirstIn,LastOut)\nleads to invocation of my_choice(X,Param,In,Out).\n\nThe different search methods are\n\ncomplete\n    a complete search routine which explores all alternative choices.\n\nbbs(Steps)\n    The bounded backtracking search allows Steps\n    backtracking steps.\n\nlds(Disc)\n    A form of the  limited discrepancy search .  This method\n    iteratively tries 0, 1, 2 ..  Disc changes against the\n    heuristic (first) value.  Typical values are between 1 and 3 (which\n    already may create too many alternatives for large problems).  The\n    original LDS paper stated that the discrepancy to be tested first\n    should be at the top of the tree.  Our implementation tries the first\n    discrepancy at the bottom of the tree.  This means that solutions may\n    be found in a different order compared to the original algorithm. \n    This change is imposed by the evaluation strategy used and can not be\n    easily modified.\n\ncredit(Credit, bbs(Steps))\n    The credit based search explores the top of the search tree\n    completely.  Initially, a given number of credits (Credit) are\n    given.  At each choice point, the first alternative gets half of the\n    available credit, the second alternative half of the remaining credit,\n    and so on.  When the credit run out, the system switches to another\n    search routine, here bbs.  In each of these bounded backtracking\n    searches Steps backtracking steps are allowed before returning\n    to the top most part of the tree and choosing the next remaining\n    candidate.  A good value for Steps is 5, a value of 0 forces a\n    deterministic search using the heuristic.  Typical values for\n    Credit are either N or N*N, where N is the number of entries in\n    the collection.\n\ncredit(Credit, lds(Disc))\n    like the one above, but using lds when the credit runs out. \n    Typically, only one (perhaps 2) discrepancies should be allowed.\n\ndbs(Level, bbs(Steps))\n    The depth bounded search explores the first Level\n    choices in the search tree completely, i.e.  it tries all values for\n    the first Level selected variables.  After that, it switches to\n    another search method, here bbs.  In each of these searches,\n    Steps backtracking steps are allowed.  \n\ndbs(Level, lds(Disc))\n    like the method above, but switches to lds after the first\n    Level variables.\n\nsbds\n    A complete search routine which uses the SBDS symmetry breaking library\n    (lib(ic_sbds) or lib(fd_sbds)) to exclude symmetric parts of the search tree\n    from consideration.  The symmetry breaking must be initialised through a\n    call to sbds_initialise/4,5 before calling search/6.  Currently the only\n    pre-defined choice methods supported by this search method are\n    indomain_min, indomain_max, indomain_middle,\n    indomain_median and indomain_random.  Any user-defined choice\n    method used in conjunction with this search method must use sbds_try/2 to\n    assign/exclude values or the symmetry breaking will not work correctly.\n\ngap_sbds (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDS symmetry breaking\n    library lib(ic_gap_sbds) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbds_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbds_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\ngap_sbdd (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDD symmetry breaking\n    library lib(ic_gap_sbdd) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbdd_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbdd_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\nThe option list is used to pass additional parameters to and from the\nprocedure.  The currently recognized options are:\n\nbacktrack(-N)\n    returns the number of backtracking steps used in the search routine\n\nnodes(++N)\n    sets an upper limit on the number of nodes explored in the search.  If\n    the given limit is exceeded, the search routine stops the exploration\n    of the search tree.\n\nnode(daVinci)\n    create a drawing of the search tree using the daVinci graph drawing\n    tool.  Each node of the search tree is shown as a node in the tree. \n    The label of the node is the selected term of the collection.\n\nnode(daVinci(++Call))\n    as the previous option, it creates a drawing of the search tree using\n    the daVinci graph drawing tool.  But instead of using the complete\n    selected term as the label, it call the predicate Call/2 to\n    choose which part of the selected term to display.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if the search tree generated does not contain any solution. \nFor partial search methods, this does not mean that the problem does not \nhave a solution, but only that the part of the tree generated did not \ncontain one.\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,complete,[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,bbs(15),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,lds(2),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,credit(64,bbs(5)),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,dbs(2,lds(1)),[]).\n\n% a more complex example with different methods and heuristics\n% the list to be assigned is a list of terms queen/2\n\n:- local struct(queen(place,var)).\n\ntop:-\n\tmember(Method,[complete,lds(2),credit(64,5),bbs(1000),dbs(5,10)]),\n\tmember(Select,[first_fail,most_constrained,input_order]),\n\tmember(Choice,[indomain,\n\t    indomain_min,\n\t\t       indomain_max,\n\t\t       indomain_middle,\n\t\t       indomain_median,\n\t\t       indomain_split,\n\t\t       indomain_random]),\n\twriteln(queen(Method,Select,Choice)),\n\tonce(queen_credit(64,Select,Choice,Method,L,Back)),\n\twriteln(L),\n\twriteln(backtrack(Back)),\n\tfail.\ntop:-\n\tnl.\n\nqueen_credit(N,Select,Choice,Method,L,Back):-\n\tcreate_queens(1,N,Queens,L),\n\tsetup(L),\n\trearrange(Queens,Queens,[],[],Queens1),\n\tsearch(Queens1, var of queen, Select, Choice, Method, [backtrack(Back)]).\n\nrearrange([],Last,Last,Res,Res).\nrearrange([_],[Mid|Last],Last,Res,[Mid|Res]).\nrearrange([_,_|S],[H|T],A1,In,Res):-\n\trearrange(S,T,[A|A1],[H,A|In],Res).\n\ncreate_queens(N,M,[],[]):-\n\tN > M,\n\t!.\ncreate_queens(N,M,[queen{place:N,var:X}|T],[X|L]):-\n\tX :: 1..M,\n\tN1 is N+1,\n\tcreate_queens(N1,M,T,L).\n\nsetup([]).\nsetup([H|T]):-\n\tsetup1(H,T,1),\n\tsetup(T).\n\nsetup1(_,[],_).\nsetup1(X,[Y|R],N):-\n\tX #\\= Y,\n\tX #\\= Y + N,\n\tY #\\= X + N,\n\tN1 is N+1,\n\tsetup1(X,R,N1).\n\n% this example shows how to pass information from one assignment step \n% to the next\n% this uses a term of two arguments as the choice argument\n% The example also shows the use of the option argument:\n% the search tree generated is drawn with the daVinci graph drawing tool\n% and the search is limited to 1000 nodes.\n% The number of backtracking steps is returned in the variables Back.\n:-local struct(country(name,color)).\n\ntop:-\n\tcountries(C),\n\tcreate_countries(C,Countries,Vars),\n\tfindall(n(A,B),n(A,B),L),\n\tsetup(L,Countries),\n\tsearch(Countries,\n\t       color of country, % select based on this variable\n\t       most_constrained,\n\t       assign([1,2,3,4],Out), % this calls assign/3\n\t       complete,\n\t       [backtrack(Back),node(daVinci),nodes(1000)]),\n\twriteln(Vars),\n\twriteln(Back),\n\twriteln(Out).\n\ncreate_countries([],[],[]).\ncreate_countries([C|C1],[country{name:C, color:V}|R1],[V|V1]):-\n\tV :: 1..4,\n\tcreate_countries(C1,R1,V1).\n\nsetup([],_L).\nsetup([n(A,B)|N1],L):-\n\tmember(country{name:A, color:Av},L),\n\tmember(country{name:B, color:Bv},L),\n\tAv #\\= Bv,\n\tsetup(N1,L).\n\n% this is the choice predicate\n% the first argument is the complete selected term\n% the second is the input argument\n% the third is the output argument\n% here we pass a list of values and rotate this list from one step to the next\nassign(country{color:X},L,L1):-\n\trotate(L,L1),\n\tmember(X,L).\n\nrotate([A,B,C,D],[B,C,D,A]).\n\n% another example of argument passing \n% here each entry gets the same information\n% it is passed unchanged from one level to the next\n\ntop:-\n\t...\n\tlength(L,N),\n\tL :: 1..10,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       % pass two lists as the In argument of assign\n\t       % try the odd numbers before the even numbers\n\t       assign([1,3,5,7,9]-[2,4,6,8,10],_), \n\t       complete,[]),\n\t...\n\n% this is the assignment routine\n% the first argument is a \n% Pass the In argument as the Out argument\n% try values from list L1 before values from list L2\nassign(X,L1-L2,L1-L2):-\n\tmember(X,L1);member(X,L2).\n\n% and another example from square placement\n% alternatively try minimal and maximal values first\n\n:-local struct(square(x,y,size)).\n\ntop:-\n\tdata(L),\n\tcreate_squares(L,Squares),\n\t...\n    search(Squares,\n\t       0, % this value does not matter if input_order is chosen\n\t       input_order,\n\t       assign(min,_),\n\t       complete,\n\t       []),\n\t...\n\n% the assignment routine\n% alternate between min and max for consecutive levels in the search\nassign(square{x:X,y:Y},Type,Type1):-\n\tswap(Type,Type1),\n\tindomain(X,Type),\n\tindomain(Y,Type).\n\nswap(max,min).\nswap(min,max).\n\n% this example shows that the choice routine may consist of several clauses\n% the idea comes from a graph coloring heuristic\n\ntop:-\n\tlength(L,N),\n\tL :: 1..100,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       assign(0,K), The In argument is the highest color used so far\n\t       complete,[]),\n\t...\n\n% assign variable X either to one of the colors 1..K \n% which have already been used, or to the new color K+1\n% we do not need to try other values K+2 etc, as this is a symmetry that\n% we can avoid\nassign(X,K,K):-\n\tX #=< K,\n\tindomain(X).\nassign(K1,K,K1):-\n\tK1 is K+1.\n\n% example showing use of the SBDS library with a user-defined choice method\n% which calls sbds_try/2.\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\t...\n\tsbds_initialise(M,SymPreds,#=,[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,sbds_indomain_max,sbds,[]).\n\nsbds_indomain_max(X):-\n\tnonvar(X).\nsbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tsbds_indomain_max(X).\n\n% Example showing use of the GAP-based SBDS library with a user-defined\n% choice method which calls sbds_try/2.  (For the GAP-based SBDD library,\n% just substitute \"sbdd\" for each occurrence of \"sbds\" below.)\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\tsbds_initialise(M,[vars],values:1..8,[symmetry(s_n,[vars])],[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,gap_sbds_indomain_max,gap_sbds,[]).\n\ngap_sbds_indomain_max(X):-\n\tnonvar(X).\ngap_sbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tgap_sbds_indomain_max(X).\n\nSee Also\n   fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, indomain / 2, fd : labeling / 1, sd : labeling / 1, ic : labeling / 1, gfd : labeling / 1, fd : deleteff / 3, sd : deleteff / 3, fd : deleteffc / 3, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_initialise / 5, ic_gap_sbdd : sbdd_try / 2, library(ic_sbds), library(fd_sbds), library(ic_gap_sbds), library(ic_gap_sbdd)"},"gnuplot:plot/2":{"prefix":"plot","body":"plot(${1:Data}, ${2:Options})$3\n$0","description":"plot(++Data, +Options)\n\n   Plots the given data using the given options\n\nArguments\n   Data    The data to be plotted, array or list.\n   Options    Options list\n\nType\n   library(gnuplot)\n\nDescription\n\n Plots the given data to screen using the supplied options.\n\n Can either be a list or a nested list of a 1D or 2D array of y\n values or x-y points.\n\n The options correspond directly to the options of the gnuplot\n 'plot' command.\n\n Syntax note: wherever gnuplot expects a string as an option value,\n use a double-quoted ECLiPSe string - unquoted or single-quoted atoms\n will not work!.\n\nFail Conditions\n   Options are malformed, or data is not in a valid format.\n\nResatisfiable\n   false\n\nExamples\n   \n% x-y pairs with 'points'\n?- A=[1-3,5-2,9-2,8-2,5-7], plot(A, [with:points]).\n\n% y values with large 'smooth' lines and points\n?- A=[1,2,3,4,8,9,4,2,4,6], plot(A, [smooth: csplines,\n    with:linespoints,\n    pointsize:3]).\n\n% multiple y values in nested lists with lines, boxes and titles\n?- A=[[1,2,4,9,18,27,3],[1,4,16,36,25,16,9]],\n   plot(A, [with:[lines, boxes], title:['data 1', 'data 2']]).\n\n% multiple y values in an array, in a certain range, with impulses of\n% different widths\n?- A=[]([](1,2,4,6,7,8,9),[](1,4,16,36,49,64,81)),\n   plot(A, [ranges:(3:6), with:impulses, linewidth:[8,2]]).\n\n% multiple t-r pairs, in polar coordinates with a grid and lines\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines]).\n    \n\nSee Also\n   plot / 1, plot / 3, plot / 4"},"gnuplot:plot/3":{"prefix":"plot","body":"plot(${1:Data}, ${2:Options}, ${3:OutputFile})$4\n$0","description":"plot(++Data, +Options, +OutputFile)\n\n   Plots the given data to a file.\n\nArguments\n   Data    The data to be plotted, array or list.\n   Options    Options list\n   OutputFile    Name of file to store plot in (atom or string)\n\nType\n   library(gnuplot)\n\nDescription\n\n Plots the data to a file as Postscript (by default).\n\n Can either be a list or a nested list of a 1D or 2D array of y\n values or x-y points.\n\n The output format can be changed either by explicitly setting the\n 'terminal' variable using the 'set' option, or by calling plot/4.\n\n Syntax note: wherever gnuplot expects a string as an option value,\n use a double-quoted ECLiPSe string - unquoted or single-quoted atoms\n will not work!.\n\nFail Conditions\n   Options are malformed, or data is not in a valid format.\n\nResatisfiable\n   false\n\nExamples\n   \n% multiple t-r pairs, in polar coordinates with a grid and lines, into\n% a postscript file\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines], \"polar.ps\").\n\nSee Also\n   plot / 1, plot / 2, plot / 4"},"gnuplot:plot/4":{"prefix":"plot","body":"plot(${1:Data}, ${2:Options}, ${3:Format}, ${4:OutputFile})$5\n$0","description":"plot(++Data, +Options, +Format, +OutputFile)\n\n   Plots the given data to a file in the given format.\n\nArguments\n   Data    The data to be plotted, array or list.\n   Options    Options list\n   Format    Output file format (atom or string)\n   OutputFile    Name fo file to store plot in (atom or string)\n\nType\n   library(gnuplot)\n\nDescription\n\n Plots the data to a file in the specified format.\n\n The Data can either be a list or a nested list of a 1D or 2D array\n of y values or x-y points.\n\n The output format is defined as being the 'terminal' setting for\n gnuplot.\n\n Syntax note: wherever gnuplot expects a string as an option value,\n use a double-quoted ECLiPSe string - unquoted or single-quoted atoms\n will not work!.\n\nFail Conditions\n   Options are malformed, or data is not in a valid format.\n\nResatisfiable\n   false\n\nExamples\n   \n% multiple t-r pairs, in polar coordinates with a grid and lines, into\n% a postscript file\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines], postscript, \"polar.ps\").\n\n% multiple t-r pairs, in polar coordinates with a grid and lines, into\n% a postscript file with color\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines], \"postscript color\", \"polar.ps\").\n\n% multiple t-r pairs, in polar coordinates with a grid and lines, into\n% a PNG file\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines], png, \"polar.png\").\n\n% multiple t-r pairs, in polar coordinates with a grid and lines, into\n% a XFIG file\n?- A=[[1-3,5-2,9-2,8-2,5-7], [1-2,5-4,8-6,9-1,12-4]],\n   plot(A,[set:[polar, grid=polar], with:lines], fig, \"polar.fig\").\n\nSee Also\n   plot / 1, plot / 2, plot / 3"},"gfd:bin_packing/3":{"prefix":"bin_packing","body":"bin_packing(${1:Items}, ${2:ItemSizes}, ${3:BinLoads})$4\n$0","description":"bin_packing(+Items, ++ItemSizes, +BinLoads)\n\n   The one-dimensional bin packing constraint with loads: packing M items into N bins, each bin having a load\n\nArguments\n   Items    A collection of M (domain) variables or integers (domain/value between 1 and N)\n   ItemSizes    A collection of M non-negative integers\n   BinLoads    A collection of N (domain) variables or non-negative integers\n\nType\n   library(gfd)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack M\n   items with individual sizes into N bins, such that the sum of sizes of\n   items in each bin equals the load of that bin, as specified in BinLoads.\n   Each element of Items and its corresponding element in ItemSizes\n   represents an item, such that the i'th element of ItemSizes is the size\n   of the i'th item, and the i'th element of Item is the bin this item is\n   packed into. BinLoads represent the load of each bin, i.e. the sum\n   of the sizes of items assigned to that bin, with the j'th element \n   representing the load for bin j. An (integer finite domain) variable for \n   the load allows a constraint on the load to be specified, such as a\n   minimum and/or maximum load for the bin.\n\n    Note that the Gecode implementation of this constraint has index starting\n    from 0, i.e. the numbering for the bins starts from 0. These native \n    indices are mapped to the  ECLiPSe indices starting from 1 with an \n    additional dummy zero'th bin that is assigned a dummy item 0. A version\n    of this constraint that uses native Gecode indexing is available \n    as bin_packing_g/3.\n\n   The global constraint catalog describes this constraint as a\n   variation of their bin_packing constraint where the fixed capacity for\n   every bin is replaced by the BinLoads variables. In addition, a more\n   restricted version of this constraint is also described in the global \n   constraint catalog as bin_packing_capa, where instead of BinLoads,\n   each bin is given its own integer capacity, the maximum load that\n   bin can take, this is equivalent to giving the corresponding variable \n   for the bin in BinLoads the domain 0..Capacity. \n\n   This constraint is implemented using Gecode's binpacking() constraint.\n\nExamples\n   \n[eclipse 7]: bin_packing([3,1,3], [4,3,1], [L1,L2,L3,L4]).\n\nL1 = 3\nL2 = 0\nL3 = 5\nL4 = 0\n\nSee Also\n   bin_packing / 4, bin_packing_g / 3, ic_global : bin_packing / 3, fd_global : bin_packing / 3"},"gfd:bin_packing/4":{"prefix":"bin_packing","body":"bin_packing(${1:Items}, ${2:ItemSizes}, ${3:N}, ${4:BinSize})$5\n$0","description":"bin_packing(+Items, ++ItemSizes, +N, +BinSize)\n\n   The one-dimensional bin packing constraint: packing M items into N bins of size BinSize.\n\nArguments\n   Items    A collection of M (domain) variables or integers (domain/value between 1 and N)\n   ItemSizes    A collection of M non-negative integers\n   N    A positive Integer\n   BinSize    A non-negative integer\n\nType\n   library(gfd)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack M\n   items with individual sizes into N bins, such that the sum of sizes of \n   items in each bin does not exceed BinSize. Each element of Items and its \n   corresponding element in ItemSizes represents an item, such that the i'th \n   element of ItemSizes is the size of the i'th item, and the i'th element in\n   Items is the bin this item is packed into. \n\n   This constraint can be seen as a special case of the cumulative/4\n   constraint, where all task durations are equal to 1, each bin\n   represents a time point, and BinSize corresponds to the Resource.\n\n   This constraint is implemented using the more general \n   bin_packing/3, where each bin has its own size, represented by a domain\n   variable, as this is what is implemented by Gecode. This form of\n   the constraint with a fixed BinSize is more common. so it is\n   provided for convenience and compatibility. Note that this constraint\n   uses ECLiPSe indexing -- bins are indexed starting from 1. There is no     \n   Gecode indexing version of this constraint as it is not implemented\n   directly in Gecode.\n\n   This constraint is described in the global constraint catalog as \n   bin_packing, but with slightly different arguments: in the catalog, N\n   (the number of bins) is implicitly defined by the domains of the variables \n   in Items, and the representation of item is grouped into a single argument\n   of collection of pairs, each pair representing an item: the bin to pack \n   the item, and its size. It is implemented using Gecode's binpacking() \n   constraint, with the loads of all bins set to the domain 0..BinSize,i.e..\n   that they all have capacity of BinSize.\n\nExamples\n   \n[eclipse 4]: bin_packing([3,1,3], [4,3,1], 3, 5).  % Succeed\n\n[eclipse 5]: bin_packing([3,3,3], [4,3,1], 3, 5).  % Fails\n\nSee Also\n   bin_packing / 3, cumulative / 4, ic_global : bin_packing / 4, fd_global : bin_packing / 4"},"gfd:bin_packing_g/3":{"prefix":"bin_packing_g","body":"bin_packing_g(${1:Items}, ${2:ItemSizes}, ${3:BinLoads})$4\n$0","description":"bin_packing_g(+Items, ++ItemSizes, +BinLoads)\n\n   The one-dimensional bin packing constraint with loads, using native Gecode indexing\n\nArguments\n   Items    A collection of M (domain) variables or integers (domain/value between 0 and N-1)\n   ItemSizes    A collection of M non-negative integers\n   BinLoads    A collection of N v(domain) ariables or non-negative integers\n\nType\n   library(gfd)\n\nDescription\n  This version of the constraint uses the native Gecode indexing, which starts \n  from 0. This is different from normal ECLiPSe's indexing, which starts from 1.\n\n  This predicate maps more directly to Gecode's native implementation of \n  the constraint, without the conversion between Gecode and ECLiPSe\n  indexing of cumulatives_min/5. It may therefore be more efficient, but \n  could also be incompatible with existing ECLiPSe code. \n\n  See bin_packing/3 for a more detailed description of this predicate.\n\nSee Also\n   bin_packing / 4, bin_packing / 3"},"gfd:bin_packing_md/3":{"prefix":"bin_packing_md","body":"bin_packing_md(${1:Items}, ${2:ItemMDSizes}, ${3:BinMDLoads})$4\n$0","description":"bin_packing_md(+Items, ++ItemMDSizes, +BinMDLoads)\n\n   The multi-dimensional bin packing constraint with loads: packing M L-Dimensional items into N L-Dimensional bins, each bin having a load in each dimension\n\nArguments\n   Items    A collection of M (domain) variables or integers (domain/value between 1 and N)\n   ItemMDSizes    A 2-D collection of M*L non-negative integers\n   BinMDLoads    A 2-D collection of N*L (domai) variables or non-negative integers\n\nType\n   library(gfd)\n\nDescription\n   This constraint is for multi-dimensional bin-packing, that is, to\n   pack M L-dimensional items with individual sizes in each dimension\n   into N L-dimensional bins, such that the sum of sizes of items in\n   each dimension of each bin equals the load for that dimension of\n   that bin, as specified in BinMDLoads. The constraint is logically\n   equivalent to posting L 1-dimensional bin_packing constraints, one\n   for each dimension, with the additional constraint that the items\n   are placed in the same bin for all the constraints.\n\n   Items and Bins are L-dimensional, i.e. each Item/Bin has a\n   size/load in each dimension. Thus,ItemMDSizes and BinMDLoads are\n   2-D collections, i.e. a 2-D matrix or a list of lists, such that\n   each element is itself a collection of L sub-elements.\n\n   Each element of Items and its corresponding element in ItemMDSizes\n   represents an item, such that the i'th element of ItemMDSizes is\n   the size of the i'th item, and the i'th element of Item is the bin\n   this item is packed into. BinMDLoads represent the loads of each\n   bin, i.e. the sum of the sizes of items (in each dimension)\n   assigned to that bin, with the j'th element representing the load\n   for bin j. An (integer finite domain) variable for the load in each\n   dimension allows a constraint on the load to be specified, such as\n   a minimum and/or maximum load for the bin in that dimension.\n\n    Note that the Gecode implementation of this constraint has index\n    starting from 0, i.e. the numbering for the bins starts from\n    0. These native indices are mapped to the ECLiPSe indices starting\n    from 1 with an additional dummy zero'th bin that is assigned a\n    dummy item 0.\n\n   This constraint is implemented using Gecode's multi-dimensional\n   variant of binpacking() constraint, which requires both the maximum\n   bin size (as in bin_packing_md/4) and all the bin loads to be specified. \n   This gfd version of the constraint deduces the maximum bin size from \n   BinMDLoads.\n\nExamples\n   \n[eclipse 2]: bin_packing_md([3,1,3], [[4,2], [3,0], [1,3]], [[L11,L12],[L21,L22],[L31,L32]]).\n\nL11 = 3\nL12 = 0\nL21 = 0\nL22 = 0\nL31 = 5\nL32 = 5\n\nSee Also\n   bin_packing_md / 4, bin_packing / 4, bin_packing / 3"},"gfd:bin_packing_md/4":{"prefix":"bin_packing_md","body":"bin_packing_md(${1:Items}, ${2:ItemMDSizes}, ${3:N}, ${4:BinMDSize})$5\n$0","description":"bin_packing_md(+Items, ++ItemMDSizes, +N, +BinMDSize)\n\n   The multi-dimensional bin packing constraint: packing M L-dimensional items into N L-dimensional bins of size BinMDSize.\n\nArguments\n   Items    A collection of M (domain) variables or integers (domain/value between 1 and N)\n   ItemMDSizes    A 2-D collection of M*L non-negative integers\n   N    A positive Integer\n   BinMDSize    A collection of L non-negative integer\n\nType\n   library(gfd)\n\nDescription\n   This constraint is for multi-dimensional bin-packing, that is, to\n   pack M L-dimensional items with individual sizes into N\n   L-dimensional bins, such that the sum of sizes of items in each bin\n   does not exceed BinMDSize in any dimension.  The constraint is\n   logically equivalent to posting L 1-dimensional bin_packing\n   constraints, one for each dimension, with the additional constraint\n   that the items are placed in the same bin for all the constraints.\n\n   Items and Bins are L-dimensional, i.e. each Item/Bin has a\n   size/load in each dimension, and in this version of the constraint,\n   all the Bins have the same size, as specified by BinMDSize.\n   Thus,ItemMDSizes is a 2-D collection, i.e. a 2-D matrix or a list\n   of lists, such that each element is itself a collection of L\n   sub-elements.\n\n   Each element of Items and its corresponding element in ItemMDSizes\n   represents an item, such that the i'th element of ItemSizes is the\n   size of the i'th item, and the i'th element in Items is the bin\n   this item is packed into.\n\n    Note that the Gecode implementation of this constraint has index\n    starting from 0, i.e. the numbering for the bins starts from\n    0. These native indices are mapped to the ECLiPSe indices starting\n    from 1 with an additional dummy zero'th bin that is assigned a\n    dummy item 0.\n\n   This constraint is implemented using Gecode's multi-dimensional\n   variant of binpacking() constraint, which requires both the maximum\n   bin size and all the bin loads (as in bin_packing_md/3) to be specified. \n   This gfd version of the constraint constructs the bin loads from BinMDSize.\n\nExamples\n   \n[eclipse 4]: bin_packing_md([3,1,3], [[4,1],[3,2],[1,1]], 3, [5,4]).  % Succeed\n\n[eclipse 5]: bin_packing_md([3,3,3], [[4,1],[3,2],[1,1]], 3, [5,4]).  % Fails\n\nSee Also\n   bin_packing_md / 3, bin_packing / 3, bin_packing / 4"},"gfd:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Usages}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Usages, +ResourceLimit)\n\n   Single resource cumulative constraint on scheduling tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (non-negative integer variables or integers)\n   Usages    Collection of resource usages (positive integers)\n   ResourceLimit       Maximum amount of resource available (domain variable, array notation accepted)\n\nType\n   library(gfd)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Usages \n   are collections (a la collection_to_list/2) of equal size N representing\n   N tasks. Durations are non-negative, Usages and ResourceLimit are \n   strictly positive. The declarative meaning is:\n\n   The N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time. \n\n   A zero duration task both consume and release the resource it uses\n   at the same time-point, so effectively it does not consume any resources \n   at that time-point, but there must be sufficient resources available at \n   that time-point to allow the task to be scheduled.\n\n   Note that the constraint is implemented by different Gecode propagators,\n   depending on if Durations contains domain variables or not. If\n   Durations does have domain variables, the Gecode propagator requires\n   an extra End domain variable specifying the end time, and a constraint \n    \n     End #= Start + Duration  \n\n   for each task. These are posted as part of the constraint (the End \n   variables are not accessible by the user).\n\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n\n    This constraint is also known as cumulative in the global constraint\n    catalog, but in the catalog, tasks with zero duration have a different\n    definition of overlap with other tasks. The constraint is implemented \n    using Gecode's cumulative constraint (with extra constraints on task \n    end-times if any task duration is a domain variable).\n\nExamples\n   \n\n% success (peak consumption is 7) \n[eclipse 7]: cumulative([1,2,3,6,7], [3,9,10,6,2], [1,2,1,1,3], 8).\n\n% fail (peak consumption is 7)\n[eclipse 8]:  cumulative([1,2,3,6,7], [3,9,10,6,2], [1,2,1,1,3], 6).\n\nSee Also\n   disjunctive / 2, cumulative_optional / 5, cumulatives / 5, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4"},"gfd:cumulative_optional/5":{"prefix":"cumulative_optional","body":"cumulative_optional(${1:StartTimes}, ${2:Durations}, ${3:Usages}, ${4:ResourceLimit}, ${5:Scheduled})$6\n$0","description":"cumulative_optional(+StartTimes, +Durations, +Usages, +ResourceLimit, +Scheduled)\n\n   Single resource cumulative constraint on scheduling optional tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (non-negative integer variables or integers)\n   Usages    Collection of resource usages (positive integers)\n   ResourceLimit       Maximum amount of resource available\n    (domain variable or integer, array notation accepted)\n   Scheduled    Collection of N scheduled booleans for task (0/1 domain variables or integers)\n\nType\n   library(gfd)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations, Usages and \n   Scheduled are collections (a la collection_to_list/2) of equal size N,\n   representing N task. Durations must be non-negative, Usages and \n   ResourceLimit must be strictly positive, and Scheduled are booleans \n   (values of 0/1). The declarative meaning is:\n\n   The N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time. A task would not be scheduled \n   if its Scheduled boolean is 0, and must be scheduled if 1.\n/P>\n   A zero duration task both consume and release the resource it uses\n   at the same time-point, so effectively it does not consume any resources \n   at that time-point, but there must be sufficient resources available at \n   that time-point to allow the task to be scheduled.\n\n   Note that the constraint is implemented by different Gecode propagators,\n   depending on if Durations contains domain variables or not. If\n   Durations does have domain variables, the Gecode propagator requires\n   an extra End domain variable specifying the end time, and a constraint \n    \n     End #= Start + Duration  \n\n   for each task. These are posted as part of the constraint (the End \n   variables are not accessible by the user).\n\n   Any input variables which are not already domain variables are turned\n   into domain variables with default domain.\n\nSee Also\n   disjunctive / 2, disjunctive_optional / 3, cumulative / 4, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4"},"gfd:disjoint2/1":{"prefix":"disjoint2","body":"disjoint2(${1:Rectangles})$2\n$0","description":"disjoint2(+Rectangles)\n\n   Constrains the position (and possibly size) of the rectangles in Rectangles so that none overlaps.\n\nArguments\n   Rectangles    Collection of rect{} structures specifying\n the position and size of rectangles on a grid.\n\nType\n   library(gfd)\n\nDescription\n\n    A two dimensional disjunctive constraint that constrains the replacement\n    of a collection of rectangles specified by Rectangles to not overlap in\n    their areas. \n\n    Each rectangle is defined by a rect named structure, using the\n    following fields:\n\n      x: The x co-ordinate of the left side of the rectangle \n      y: The y co-ordinate of the bottom side of the rectangle.\n      w: The width of the rectangle\n      h: The height of the rectangle\n\n    x, y, w, h can be domain variables or integers. If w and h are\n    integers, then the rectangle is of a fixed size. Note the rect{}\n    structure has an additional 'o' field, which is ignored for this\n    constraint as it is only used for disjoint2_optional/1.\n\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if all the rectangles are of fixed size or not. If at\n    least one rectangle is not of fixed size, then the Gecode\n    propagator requires additional variables for the right and top\n    sides of the rectangles, plus additional constraints\n    \n      Xright #= Xleft + Width\n      Ytop   #= Ybot + Height\n\n    for each rectangles. These are posted as part of the constraint (the Xright \n    and Ytop variables are not accessible by the user).\n\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n\n    A version of this constraint, generalised from two to multi-\n    dimension, is known as diffn in the Global Constraint Catalog.\n\n    This constraint is implemented using Gecode's nooverlap() constraint.\n\nExamples\n   [eclipse 17]: disjoint2([rect{x:2,y:1,w:2,h:3},rect{x:4,y:3,w:4,h:3},\n    rect{x:9,w:2,y:4,h:3}]).    % succeed\n\nSee Also\n   disjoint2_optional / 1, lists : collection_to_list / 2"},"gfd:disjoint2_optional/1":{"prefix":"disjoint2_optional","body":"disjoint2_optional(${1:Rectangles})$2\n$0","description":"disjoint2_optional(+Rectangles)\n\n   Constrains the position (and possibly size) of the (possibly optional) rectangles in Rectangles so that none overlaps.\n\nArguments\n   Rectangles    Collection of rect{} structures specifying\n the position and size of rectangles on a grid.\n\nType\n   library(gfd)\n\nDescription\n\n    A two dimensional disjunctive constraint that constrains the replacement\n    of a collection of rectangles specified by Rectangles to not overlap in\n    their areas. The placement of each rectangle can be optional, i.e.\n    they may not need to be placed.\n\n    Each rectangle is defined by a rect named structure, using the\n    following fields:\n\n      x: The x co-ordinate of the left side of the rectangle \n      y: The y co-ordinate of the bottom side of the rectangle.\n      w: The width of the rectangle\n      h: The height of the rectangle\n      b: Boolean specifying if rectangle is placed or not\n\n    x, y, w, h can be domain variables or integers. If w and h are\n    integers, then the rectangle is of a fixed size. o is a 0/1\n    integer or domain variable, 1 specifies that the rectangle needs\n    to be placed, and 0 that it is not placed. \n\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if all the rectangles are of fixed size or not. If at\n    least one rectangle is not of fixed size, then the Gecode\n    propagator requires additional variables for the right and top\n    sides of the rectangles, plus additional constraints\n    \n      Xright #= Xleft + Width\n      Ytop   #= Ybot + Height\n\n    for each rectangles. These are posted as part of the constraint (the Xright \n    and Ytop variables are not accessible by the user).\n\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n\n    A version of this constraint, generalised from two to multi-\n    dimension, and without optional placement, is known as diffn in\n    the Global Constraint Catalog. It is implemented using Gecode's \n    nooverlap() constraint (variant with optional placement).\n\nSee Also\n   disjoint2 / 1, lists : collection_to_list / 2"},"gfd:disjunctive/2":{"prefix":"disjunctive","body":"disjunctive(${1:StartTimes}, ${2:Durations})$3\n$0","description":"disjunctive(+StartTimes, +Durations)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of N start times for tasks (domain variables or integers)\n   Durations    Collection of N durations for tasks (non-negative domain variables or integers)\n\nType\n   library(gfd)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers. Durations must be non-negative.\n \n    The declarative meaning is that the N tasks with the given start \n    times and durations do not overlap at any point in time, i.e. for\n    any pairs of tasks X and Y, the following holds:\n\n    (Xstart + Xduration =\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if Durations contains domain variables or not. If\n    Durations does have domain variables, the Gecode propagator requires\n    an extra End domain variable specifying the end time, and a constraint \n    \n      End #= Start + Duration  \n\n    for each task. These are posted as part of the constraint (the End \n    variables are not accessible by the user).\n\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n\n    This constraint is also known as disjunctive in the global constraint\n    catalog, but in the catalog, tasks with zero duration are allowed\n    to overlap with other tasks. The constraint is implemented using \n    Gecode's unary constraint (with extra constraints on task end times if \n    any task duration is a domain variable).\n\nExamples\n   \n[eclipse 2]: disjunctive([1,7,4],[3,2,1]).    % succeed\n\n[eclipse 3]: disjunctive([1,7,3], [3,2,1]).   % fail\n\n[eclipse 4]: disjunctive([1,4,7,4],[3,0,2,1]). % succeed \n\n[eclipse 5]: disjunctive([1,2,7,4],[3,0,2,1]). % fail \n\n[eclipse 5]: [S2,S4]::[1..9], disjunctive([1,S2,7,S4], [3,1,2,1]).\n\nS2 = S2{[4 .. 9]}\nS4 = S4{[4 .. 9]}\n\nSee Also\n   edge_finder3 : disjunctive / 2, edge_finder : disjunctive / 2, ic_edge_finder : disjunctive / 2, ic_edge_finder3 : disjunctive / 2, disjunctive_optional / 3, cumulative / 4, cumulatives / 5, lists : collection_to_list / 2"},"gfd:disjunctive_optional/3":{"prefix":"disjunctive_optional","body":"disjunctive_optional(${1:StartTimes}, ${2:Durations}, ${3:Scheduled})$4\n$0","description":"disjunctive_optional(+StartTimes, +Durations, +Scheduled)\n\n   Constrain the optional tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of N start times for tasks (domain variables or integers)\n   Durations    Collection of N durations for tasks (non-negative domain variables or integers)\n   Scheduled    Collection of N scheduled booleans for task (0/1 domain variables or integers)\n\nType\n   library(gfd)\n\nDescription\n  \n    A disjunctive scheduling constraint. StartTimes, Durations and Scheduled\n    are collections (a la collection_to_list/2) of equal size N. Durations\n    must be non-negative, and Scheduled are booleans (0/1).\n    The declarative meaning is that the scheduled tasks with the given start \n    times and durations do not overlap at any point in time. A task would not\n    be scheduled if its Scheduled boolean is 0, and must be scheduled if 1.\n\n    Note that the constraint is implemented by different Gecode propagators,\n    depending on if Durations contains domain variables or not. If\n    Durations does have domain variables, the Gecode propagator requires\n    an extra End domain variable specifying the end time, and a constraint \n    \n      End #= Start + Duration  \n\n    for each task. These are posted as part of the constraint (the End \n    variables are not accessible by the user).\n\n    Any input variables which are not already domain variables will be\n    converted into domain variables with default bounds.\n\n    This constraint is implemented using Gecode's unary() constraint (with \n    extra constraints on task end times if any task duration is a domain \n    variable).\n\nSee Also\n   disjunctive / 2, lists : collection_to_list / 2"},"gfd:exclude/2":{"prefix":"exclude","body":"exclude(${1:Var}, ${2:Excl})$3\n$0","description":"exclude(?Var, ++Excl)\n\n   Exclude the element Excl from the domain of Var.\n\nArguments\n   Var    (Domain) variable or integer\n   Excl    Integer value to exclude\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is mainly provided for compatibility with IC solver.\n   If you want to remove multiple values from the domain of one or \n   more variables, it is more efficient to use the lib(gfd) specific \n   gfd_vars_exclude/2.\n\n   Primitive for excluding an element from the domain of a variable.\n   The call may fail (when Var is the same integer as Excl),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (when Excl was one of only two domain elements left).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, exclude/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\nSee Also\n   exclude_range / 3, impose_min / 2, impose_max / 2, impose_domain / 2"},"gfd:exclude_range/3":{"prefix":"exclude_range","body":"exclude_range(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"exclude_range(?Var, ++Lo, ++Hi)\n\n   Exclude the elements Lo..Hi from the domain of Var.\n\nArguments\n   Var    Existing domain variable or integer\n   Lo    Integer lower bound of range to exclude\n   Hi    Integer upper bound of range to exclude\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is mainly provided for compatibility with IC solver.\n   If you want to exclude the same range of values from multiple variables,\n   it is more efficient to use the lib(gfd) specific gfd_vars_exclude_range/3.\n\n   Primitive for excluding the integers between Lo and Hi (inclusive) from\n   the domain of an integer variable.  The call may fail (when the domain of\n   Var has no elements outside the range Lo..Hi), succeed (possibly updating\n   the variable's domain), or instantiate the variable (in the case where\n   the domain gets restricted to a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, exclude_range/3 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\nSee Also\n   exclude / 2, impose_min / 2, impose_max / 2"},"gfd:gcc/s":{"prefix":"struct","body":"struct","description":"struct gcc(low, high, value)\n\n   Bounds specification for gcc constraint.\n\nFields\n   low    Lower bound on the cardinality of Value (integer).\n   high    Upper bound on the cardinality of Value (integer).\n   value    Value whose cardinality is being specified.\n\nType\n   library(gfd)\n\nDescription\n    This structure is used to specify the cardinality (number of occurrences)\n    of one value for the gcc constraint."},"gfd:get_bounds/3":{"prefix":"get_bounds","body":"get_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current bounds of Var.\n\nArguments\n   Var    A (domain) variable or an integer\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for retrieving the upper and lower bounds of Var.  Lo and Hi\n   return the minimum and maximum (respectively) of the variable's interval.\n   If Var has not been declared before, it will be turned into a domain\n   variable with default interval.  If Var is an integer, Lo and Hi will\n   be set to Var.\n\nModes and Determinism\n   get_bounds(?, -, -) is det\n\nSee Also\n   get_min / 2, get_max / 2, get_integer_bounds / 3, get_finite_integer_bounds / 3, get_delta / 2, get_median / 2"},"gfd:get_constraints_number/2":{"prefix":"get_constraints_number","body":"get_constraints_number(${1:Var}, ${2:Number})$3\n$0","description":"get_constraints_number(?Var, -Number)\n\n   Returns the number of propagators attached to the gecode variable representing Var.\n\nArguments\n   Var    A domain variable or a term\n   Number    Variable (instantiates to a non-negative integer)\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the number of propagators attached to the gecode variable\n   representing Var, This approximates the number of constraints attach\n   to the variables, and is known as the degree of the variable in the\n   literature. \n\n   If Var is not a variable, a very large number (1.0Inf) is returned. If\n   Var is a variable but not a domain variable, 0 will be returned.\n\n   Note that unlike a native ECLiPSe solver like IC, this is not the number \n   of suspensions on the variable, but is the number of propagators\n   attached to the Gecode variable, obtained via the degree() method\n   for IntVar. Thus, any constraints implemented at the ECLiPSe level\n   will not be included in this count.\n\nModes and Determinism\n   get_constraints_number(?, -) is det"},"gfd:get_delta/2":{"prefix":"get_delta","body":"get_delta(${1:Var}, ${2:Width})$3\n$0","description":"get_delta(?Var, -Width)\n\n   Returns the width of the interval of Var.\n\nArguments\n   Var    A domain variable or an integer \n   Width    Width of the interval\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the width (Hi - Lo) of the interval of Var. If Var is an integer,\n   0 will be returned as the width. If Var is free, then 1.0Inf is\n   returned as the width, but Var is not turned into a domain variable.\n\nModes and Determinism\n   get_delta(?, -) is det\n\nSee Also\n   get_median / 2, get_bounds / 3"},"gfd:get_domain/2":{"prefix":"get_domain","body":"get_domain(${1:Var}, ${2:Domain})$3\n$0","description":"get_domain(?Var, -Domain)\n\n   Returns a ground representation of the current GFD domain of a variable.\n\nArguments\n   Var    A domain variable or an integer.\n   Domain    A ground representation of the domain of Var.\n\nType\n   library(gfd)\n\nDescription\n\n   If Var is an integer, Domain will be unified with a singleton list\n   with that integer.\n\n   If Var is an GFD domain variable with no holes in its domain, Domain will\n   be unified with the term Lo..Hi where Lo and Hi are integers\n   corresponding to the current lower and upper bounds of Var, respectively.\n   If Var is an GFD domain variable with holes in its domain, Domain will\n   be unified with an ordered list of integers and/or terms Lo..Hi where Lo\n   and Hi are integers; in this case the elements of the domain of Var are\n   exactly those integers appearing directly in the list or falling within\n   any of the intervals Lo..Hi.\n\nModes and Determinism\n   get_domain(?, -) is det\n\nFail Conditions\n   The initial value of Domain fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither an IC variable or number.\n\nExamples\n   \n[eclipse 8]: X :: [1..5,10], get_domain(X, D).\n\nX = X{[1 .. 5, 10]}\nD = [1 .. 5, 10]\n\nSee Also\n   get_domain_as_list / 2, get_bounds / 3"},"gfd:get_domain_as_list/2":{"prefix":"get_domain_as_list","body":"get_domain_as_list(${1:Var}, ${2:DomainList})$3\n$0","description":"get_domain_as_list(?Var, -DomainList)\n\n   List of all the elements in the GFD domain of Var\n\nArguments\n   Var    A domain variable or a number \n   DomainList    The domain of Var as a list of elements.\n\nType\n   library(gfd)\n\nDescription\n\n   If Var is a GFD domain variable, DomainList will be set to an ordered\n   list containing each element in the domain of Var.  If Var is a number,\n   then DomainList will be set to a singleton list containing the number.\n\nModes and Determinism\n   get_domain_as_list(?, -) is det\n\nFail Conditions\n   The initial value of DomainList fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither a GFD variable or integer.\n\nExamples\n   \n [eclipse 9]: X :: [1..5,10], get_domain_as_list(X, D).\n\nX = X{[1 .. 5, 10]}\nD = [1, 2, 3, 4, 5, 10]\n\nSee Also\n   get_domain / 2, get_bounds / 3"},"gfd:get_domain_size/2":{"prefix":"get_domain_size","body":"get_domain_size(${1:Var}, ${2:Size})$3\n$0","description":"get_domain_size(?Var, -Size)\n\n   Size is the number of integer elements in the GFD domain for Var\n\nArguments\n   Var    A domain variable or an integer\n   Size    A variable (or integer)\n\nType\n   library(gfd)\n\nDescription\n\n   If Var is an GFD domain variable, Size will be set to the number of \n   integer values in the domain of Var.  If Var is a number, then Size \n   will be set to 1.\n\nModes and Determinism\n   get_domain_size(?, -) is det\n\nFail Conditions\n   The initial value of Size fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither a GFD variable or integer.\n\nSee Also\n   get_delta / 2"},"gfd:get_finite_integer_bounds/3":{"prefix":"get_finite_integer_bounds","body":"get_finite_integer_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_finite_integer_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current (finite, integral) bounds of Var.\n\nArguments\n   Var    A (domain) variable or an integer\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(gfd)\n\nDescription\n\n   This is provided for compatibility with IC, and is an alias for \n   get_bounds/3.\n\nModes and Determinism\n   get_finite_integer_bounds(?, -, -) is det\n\nSee Also\n   get_bounds / 3, get_integer_bounds / 3"},"gfd:get_integer_bounds/3":{"prefix":"get_integer_bounds","body":"get_integer_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_integer_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current bounds of Var.\n\nArguments\n   Var    A (domain) variable or an integer (array notation recognised)\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(gfd)\n\nDescription\n\n   This is provided for compatibility with IC, and is an alias for \n   get_bounds/3.\n\nModes and Determinism\n   get_integer_bounds(?, -, -) is det\n\nSee Also\n   get_bounds / 3, get_finite_integer_bounds / 3"},"gfd:get_max/2":{"prefix":"get_max","body":"get_max(${1:Var}, ${2:Hi})$3\n$0","description":"get_max(?Var, -Hi)\n\n   Retrieve the current upper bound of Var.\n\nArguments\n   Var    A (domain) variable or an integer\n   Hi    Upper bound\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for retrieving the upper bound of Var.  Hi returns the maximum\n   of the variable's interval. If Var has not been declared before, it\n   will be turned into a domain variable with default interval.\n\nModes and Determinism\n   get_max(?, -) is det\n\nSee Also\n   get_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3"},"gfd:get_median/2":{"prefix":"get_median","body":"get_median(${1:Var}, ${2:Median})$3\n$0","description":"get_median(?Var, -Median)\n\n   Returns the median of the domain of the GFD domain variable Var.\n\nArguments\n   Var    A (domain) variable or an integer\n   Median    The median of the domain\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the median of the domain of Var, i.e. if there are N values in\n   the domain, the N/2'th (rounded down if N is odd) value is returned.\n   If Var is not a GFD domain variable, it will be turned into one.\n   Note that this is different from the definition used in IC, where the\n   median (a float) of the interval is returned. If Var is an integer, the \n   median is unified with that number.\n\nModes and Determinism\n   get_median(?, -) is det\n\nExamples\n   [eclipse 2]: X :: 10..1000, get_median(X, M).\n\nX = X{10 .. 1000}\nM = 500\n\n[eclipse 2]: A :: [2,3,100,1000], get_median(A,M).\n\nA = A{[2, 3, 100, 1000]}\nM = 3\n\n[eclipse 2]: get_median(3, M).\n\nM = 3\n\nSee Also\n   get_delta / 2, get_bounds / 3"},"gfd:get_min/2":{"prefix":"get_min","body":"get_min(${1:Var}, ${2:Lo})$3\n$0","description":"get_min(?Var, -Lo)\n\n   Retrieve the current lower bound of Var.\n\nArguments\n   Var    A (domain) variable or an integer\n   Lo    Lower bound\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for retrieving the lower bound of Var.  Lo returns the minimum\n   of the variable's interval. If Var has not been declared before, it\n   will be turned into a domain variable with default interval.\n\nModes and Determinism\n   get_min(?, -) is det\n\nSee Also\n   get_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3"},"gfd:get_regret_upb/2":{"prefix":"get_regret_upb","body":"get_regret_upb(${1:Var}, ${2:Regret})$3\n$0","description":"get_regret_upb(?Var, -Regret)\n\n   Returns the regret value for the upper bound of Var.\n\nArguments\n   Var    A domain variable\n   Regret    Regret value\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the regret value for the upper bound of the variable, that is, \n   the magnitude of the difference between the largest and second largest \n   value in the variable's domain. This can be used in selecting a variable \n   for labelling.\n\nModes and Determinism\n   get_regret_upb(?, -) is det"},"gfd:get_weighted_degree_decay/1":{"prefix":"get_weighted_degree_decay","body":"get_weighted_degree_decay(${1:Decay})$2\n$0","description":"get_weighted_degree_decay(-Decay)\n\n   Return the current decay rate for weighted degree.\n\nArguments\n   Decay    (Domain) variable\n\nType\n   library(gfd)\n\nDescription\n\n   Return the current decay rate for weighted degree. The decay rate\n   governs how fast the weighted degree decays -- each time a failure\n   occurs during Gecode's constraint propagation, the constraint that\n   failed will have 1 added to its failure count, while\n   all other constraints' failure count is updated by multiplying its\n   old value by the decay rate. The decay rate is a floating point value\n   between 1 (no decay) and 0 (decay to 0 immediately). The weighted\n   degree for a domain variable is the sum of all the failure\n   counts of the constraints that the variable occurs in."},"gfd:get_weighted_degree/2":{"prefix":"get_weighted_degree","body":"get_weighted_degree(${1:Var}, ${2:WD})$3\n$0","description":"get_weighted_degree(?Var, -WD)\n\n   Returns the weighted degree of domain variable Var.\n\nArguments\n   Var    A domain variable\n   WD    Current wighted degree for variable\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the weighted degree for a domain variable. Weighted degree\n   is the original name used in the literature for this measure, ans is \n   known as AFC (accumulated failure count) in Gecode, and is usually\n   used as a criterion for selecting a variable for labelling.\n\n   The weighted degree is a floating point, \n   due to Gecode's extension of the basic weighted degree measure: weighted\n   degree for a variable is defined as the count of the failures so \n   far of the constraints (propagators) associated with the variable, plus\n   an initial value that is proportional to the variable's degree (number \n   of associated constraints) -- to give reasonable initial values.\n   The degree proportionality can be non-integral but is by default one \n   (i.e. the default initial value for the weighted degree of a\n   variable is its degree), but can be changed by init_weighted_degree/1. \n   In addition, the failure count for a constraint can decay if the \n   constraint was not involved in the failure. The rate of decay can be\n   set by set_weighted_degree_decay/1 (the default is 1 -- no decay).\n\nModes and Determinism\n   get_weighted_degree(?, -) is det\n\nSee Also\n   set_weighted_degree_decay / 1, init_weighted_degree / 1"},"gfd:get_regret_lwb/2":{"prefix":"get_regret_lwb","body":"get_regret_lwb(${1:Var}, ${2:Regret})$3\n$0","description":"get_regret_lwb(?Var, -Regret)\n\n   Returns the regret value for the lower bound of Var.\n\nArguments\n   Var    A domain variable\n   Regret    Regret value\n\nType\n   library(gfd)\n\nDescription\n\n   Returns the regret value for the lower bound of the variable, that is, \n   the magnitude of the difference between the lowest and second lowest value \n   in the variable's domain. This can be used in selecting a variable for \n   labelling.\n\nModes and Determinism\n   get_regret_lwb(?, -) is det"},"gfd:gfd/s":{"prefix":"struct","body":"struct","description":"struct gfd(idx, bool, prob, any, set)\n\n   Attribute for gfd domain variable (for implementation use only)\n\nFields\n   idx    index for variable in array\n   bool    index for linked boolean in C++, if any\n   prob    pointer to problem handle\n   any    any suspension list\n   set    \n\nType\n   library(gfd)\n\nDescription\nThis is the structure used for gfd's attribute, and is part of the implementation of gfd."},"gfd:gfd_desc":{"prefix":"lib","body":"lib(${1:gfd})$2\n$0","description":"lib(gfd)\n\n   The GFD library is an interface to the gecode finite domain constraint\n   solver. Gecode (www.gecode.org) is an open-source toolkit for developing\n   constraint-based systems in C++, and includes a high-performance constraint \n   solver.\n\n   This interface provides a high degree of compatibility with the finite \n   domain portion of the IC library, and to a lesser extent, with the FD\n   library as well. This means that programs originally written for the\n   IC library should run with GFD with little modifications, beyond \n   renaming any explicit calls to the ic family of modules.\n \n   The main differences from the IC library are:\n\n       Real interval arithmetic and variables are not supported.\n\n       Domain variables have finite bounds, and the maximum bounds are\n       determined by gecode. Like FD, default finite bounds are given to \n       domain variables that are not explicitly given bounds.\n\n       Constraint propagation is performed in gecode, and each propagation\n       phase is atomic at the ECLiPSe level. Posting of constraints and \n       propagation of their consequences are separate in gecode. GFD uses a\n       demon suspended goal to perform the propagation: after the posting\n       of any constraint (and other changes to the problem that needs \n       propagation), the suspended goal is scheduled and woken. When the\n       woken goal is executed, propagation is performed. The goal is suspended\n       at priority 9, so if the posting of the constraint is executed at\n       normal priority (12), the propagation will happen immediately. However,\n       if the posting is done at a priority 10 or higher, then the propagation\n       is delayed, allowing multiple constraints to be posted without\n       propagation. \n\n       GFD supports constraints that are supported by Gecode,\n       so the exact set of constraints supported is different from IC. \n       However, the same basic arithmetic operators and relations are \n       supported, allowing for very similar arithmetic expressions. Also,\n       many, if not most, of the constraints in IC are supported, along with\n       many constraints not supported by IC. See the detailed documentation\n       for more information.\n\n       All constraints can be called from the gfd module, and in\n       addition, some constraints can be called from modules that specify\n       the consistency level: gfd_gac (generalised arc consistency, aka\n       domain consistency), gfd_bc (bounds consistency), gfd_vc (value\n       consistency (naive)). The calls to gfd uses the default consistency \n       defined for the constraint by gecode. These consistency levels maps \n       directly to those defined for the constraints, so if gecode supports \n       different consistency levels for a constraint, GFD supports it as \n       well. In  particular (and unlike IC), most arithmetic operations can \n       be bounds (the default) as well as domain consistent.\n\n       gfd:search/6 interfaces to gecode's search-engines, where the\n       entire search is performed in gecode, and the whole search appears\n       atomic at the ECLiPSe level. The syntax for search/6 is designed to\n       be as compatible with IC's search/6, although there are some \n       differences. The exact equivalent to IC's search/6, where the search\n       is performed at the ECLiPSe level, is available via the gfd_search\n       module (in fact it shares the same code with IC's search/6). This\n       provides more flexibility, but is likely to be less efficient,\n       because the search is done in ECLiPSe, and also because \n       it is not optimised for use with gecode. In addition,\n       gfd also provide predicates for both variable selection and\n       value choice that are optimised for gecode, which should be more\n       efficient than those provided by gfd_search.\n\n       The suspension lists supported by GFD are different from IC.\n       Currently, only the 'any' suspension list (for any changes to the\n       variable's domain) found in FD but not IC, is supported. Not that\n       the GFD constraints are implemented in gecode directly, and therefore\n       do not use GFD's suspension lists. \n\n      \n   The following can be used inside arithmetic integer expressions:\n   \n   X\n\t    Variables.  If X is not yet a domain variable, it is turned \n\t    into one.\n\n   123\n\t    Integer constants.\n\n   -Expr\n\t    Sign change.\n\n   abs(Expr)\n\t    The absolute value of Expr.\n\n   E1+E2\n\t    Addition.\n\n   E1-E2\n\t    Subtraction.\n\n   E1*E2\n\t    Multiplication.\n\n   E1//E2\n\t    Integer division. Truncate towards zero.\n\n   E1/E2\n\t    Division, defined only where E2 evenly divides E1 (non-inlined),\n\n   E1 rem E2\n\t    Integer remainder (modulus), same sign as E1.\n\n   Expr^N\n\t    Power, Expr to the power N. N is a non-negative integer. \n    Mapped to sqr(Expr) if N = 2.\n\n   min(E1,E2)\n\t    Minimum.\n\n   max(E1,E2)\n\t    Maximum.\n\n   sqr(Expr)\n\t    Square.  Logically equivalent to Expr*Expr.\n\n   isqrt(Expr)\n\t    Integer square root. Truncated to nearest smaller integer.\n    Always non-negative\n\n   sqrt(Expr)\n\t    Square root, defined only where Expr is the square of an integer.\n    Always non-negative (non-inlined).\n\n   inroot(Expr,N)\n\t    Integer Nth root. N is a positive integer. Truncated to nearest smaller integer.\n    For even N, result is the non-negative root. \n\n   rsqr(Expr)\n\t    Reverse of the sqr function.  Negative root is not excluded (non-inlined).\n\n   rpow(E1,N)\n\t    Reverse of exponentiation. i.e. finds X in E1 = X^N. N is a\n    positive integer (non-inlined).\n\n   sum(ExprCol)\n\t    Sum of a collection of expressions.\n\n   sum(IntCol*ExprCol)\n\t    Scalar product of a collection of integers and expressions.\n    IntCol and ExprCol must be the same size.\n\n   min(ExprCol)\n\t    Minimum of a collection of expressions.\n\n   max(ExprCol)\n\t    Maximum of a collection of expressions.\n\n   element(ExprIdx, Col)\n    Element constraint, Evaluate to the ExprIdx'th element of Col.\n\t    ExprIdx can be an integer expression. \n\n   Functional/reified constraints\n    Written without last argument, which is taken as the value of\n    the expression. Only reified constraints (whose last argument\n    is the 0/1 boolean) and constraints that can be written as \n    functions (last argument is a domain variable) are allowed.\n    Expressions in relational constraints are restricted to \n    inlined expressions only.\n    (non-inlined).\n\n   eval(Expr)\n\t    Equivalent to Expr.\n  \n ConLev: Expr\n\t    Expr is passed to Gecode at constraint level ConLev.\n    ConLev can be gfd_gac, gfd_bc, gfd_vc, gfd. \n   \n\nThe following can be used inside logical constraint expressions:\n   \n   X\n\t    Boolean variables with 0..1 domain.  If X is not yet a\n    domain variable, it is turned \n\t    into one.\n\n   1/STRONG>\n\t    boolean constants. 0 for false, 1 for true.\n\n   E1 and E2\n\t    Reified constraint conjunction.  \n`    E1 and E2 are logical constraint expressions.\n\n   E1 or E2\n\t    Reified constraint disjunction.\n`    E1 and E2 are logical constraint expressions.\n\n   E1 xor E2\n\t    Reified constraint exclusive disjunction/non-equivalence. \n`    E1 and E2 are logical constraint expressions.\n\n   E1 => E2\n\t    Reified constraint implication.\n`    E1 and E2 are logical constraint expressions.\n\n   E1 <=> E2\n\t    Reified constraint equivalence.\n`    E1 and E2 are logical constraint expressions.\n\n   neg E\n\t    Reified constraint negation. \n`    E is a logical constraint expression.\n\n   element(ExprIdx, BoolCol)\n    Element constraint, Evaluate to the ExprIdx'th element of BoolCol.\n\t    ExprIdx can be an inlined integer expression. BoolCol is a\n\t    collection of boolean values or domain variable.\n\n   Reified constraints\n    Written without last argument, which is taken as the truth\n    value of the expression. Reified relational constraints\n    are supported inlined and only inlined integer expressions\n    are allowed.\n    (non-inlined except reified relational constraints).\n\n   eval(Expr)\n\t    Equivalent to Expr.\n  \n ConLev: Expr\n\t    Expr is passed to Gecode at constraint level ConLev.\n    ConLev can be gfd_gac, gfd_bc, gfd_vc, gfd."},"gfd:gfd_control/s":{"prefix":"struct","body":"struct","description":"struct gfd_control(commit_distance, adaptive_distance, threads)\n\n   Structure for passing low-level control parameters to gecode search-engines.\n\nFields\n   commit_distance     the commit recomputation distance (integer)(member c_d of Gecode::Search::Options)\n   adaptive_distance   the adaptive recomputation distance (integer)(member a_d of Gecode::Search::Options)\n   threads    number of threads to use in search (integer or float)(member threads of Gecode::Search::Options)\n\nType\n   library(gfd)\n\nDescription\n  This structure is used in search/6 predicate, which interface to gecode's\n  search-engines. The structure is used by the control option to pass values\n  for low-level parameters that control the behaviour gecode search-engine.\n  See the gecode documentation for more details explanation of the\n  parameters. For threads, if >= 1, this specifies number of threads\n  to use in search, but for < 1, this specify the number of threads in\n  relation to the number of processors on the machine, see the gecode\n  documentation for more detail."},"gfd:gfd_get_default/2":{"prefix":"gfd_get_default","body":"gfd_get_default(${1:Parameter}, ${2:DefaultValue})$3\n$0","description":"gfd_get_default(+Parameter, -DefaultValue)\n\n   Get the current default value for GFD Parameter.\n\nArguments\n   Parameter    GFD parameter (atom).\n   DefaultValue    Current default value for Parameter.\n\nType\n   library(gfd)\n\nDescription\n   Get the default value for parameters:\n \n    interval_min\n    Minimum for the default interval for domain variables. \n    Initial value: -1000000.\n    interval_max\n    Maximum for the default interval for domain variables. \n    Initial value: 1000000.\n    array_size\n    Initial size for the variable array for storing domain variables\n    Initial value: 100.\n    cloning_distance\n    This controls how often the gecode state is cloned. The smaller\n    the distance, the more frequent the cloning. Initial value: 2.\n\nSee Also\n   gfd_set_default / 2"},"gfd:gfd_prob/s":{"prefix":"struct","body":"struct","description":"struct gfd_prob(cp_stamp, nvars, nevents, vars, prop, last_anc, space, events, events_tail)\n\n   ECLiPSe level problem handle (for implementation use only)\n\nFields\n   cp_stamp    \n   nvars    current number of problem variables\n   nevents    number of events in events queue\n   vars    problem variable array\n   prop    suspension for performing propagation in Gecode\n   last_anc    ancestor to clone from\n   space    handle for Gecode space\n   events    events queue for recomputation\n   events_tail    \n\nType\n   library(gfd)\n\nDescription\nThis is the structure used to represent the Gecode computation state at the ECLiPSe level, and is part of the implementation of gfd."},"gfd:gfd_maxint/1":{"prefix":"gfd_maxint","body":"gfd_maxint(${1:Var})$2\n$0","description":"gfd_maxint(-Var)\n\n   Returns the maximum value allowed in gecode's domain.\n\nArguments\n   Var    Free variable\n\nType\n   library(gfd)\n\nDescription\n   Returns the maximum value allowed in gecode's domain. It is strongly\n   recommended that the user values used in the domain to not approach\n   this value, because propagation can easily lead to values outside\n   what gecode can support.\n\nSee Also\n   gfd_minint / 1"},"gfd:gfd_space/s":{"prefix":"struct","body":"struct","description":"struct gfd_space(handle, stamp)\n\n   Handle for Gecode solver state (for implementation use only)\n\nFields\n   handle    low level handle to current Gecode space in C++\n   stamp    \n\nType\n   library(gfd)\n\nDescription\nThe ECLiPSe level handle for the Gecode's solver state, and is part of the implementation of gfd"},"gfd:gfd_update/0":{"prefix":"gfd_update","body":"gfd_update","description":"gfd_update\n\n   Update the parent Gecode space to the current state.\n\nType\n   library(gfd)\n\nDescription\n\n   This is a low-level primitive that updates (if needed) the parent cloned\n   Gecode space to the current state. The parent clone is from where\n   recomputation is performed, so updating the parent will reduce the\n   amount of recomputation done during subsequent backtracking. Note \n   that the old parent is discarded and replaced by the updated parent\n   if possible.\n\n   GFD handles the cloning of Gecode spaces automatically, and the user\n   does not normally have to deal with cloning explicitly. However, if\n   the cloning distance is set very high, so that the system does\n   mostly recomputation instead of copying from clones, it is possible\n   for GFD performance to suffer significantly if the changes to set-up\n   a problem before the search has to be recomputed. This problem does\n   not occur in Gecode when using Gecode's search engine, because the space\n   is always cloned before the start of the search. As the search in\n   ECLiPSe is not normally distinguished from the model setup, GFD\n   cannot automatically ensure that the space is cloned before the\n   start of search (if the search is performed in ECLiPSe). \n\n   The update is only done if the current state is different from the \n   parent's, and the current Gecode state is stable (i.e. fully propagated).\n   If the computation since the parent is deterministic, the old\n   parent will be discarded and replaced by the new parent.\n\n   The intended use for this predicate is just before the search\n   starts in the user's program, if the search is performed in ECLiPSe. \n   Note that gfd_update is included in GFD's labeling/1 and labeling/3, \n   and so if you use these, you do not need to use gfd_update. Also, this \n   predicate will only be useful if the cloning distance is set very high,\n   and with default settings it should not be needed."},"gfd:gfd_minint/1":{"prefix":"gfd_minint","body":"gfd_minint(${1:Var})$2\n$0","description":"gfd_minint(-Var)\n\n   Returns the minimum value allowed in gecode's domain.\n\nArguments\n   Var    Free variable\n\nType\n   library(gfd)\n\nDescription\n   Returns the minimum value allowed in gecode's domain. It is strongly\n   recommended that the user values used in the domain to not approach\n   this value, because propagation can easily lead to values outside\n   what gecode can support.\n\nSee Also\n   gfd_minint / 1"},"gfd:gfd_stats/s":{"prefix":"struct","body":"struct","description":"struct gfd_stats(prop, fail, nodes, depth, mem)\n\n   Structure for obtaining statistics or providing stopping limits for gecode search-engines\n\nFields\n   prop    Number of propagations performed. (stats only)\n   fail    Number of failed nodes.\n   nodes    Number of nodes expanded.\n   depth    Maximum depth of search stack. (stats only)\n   mem    peak memory usage (in bytes) by gecode.\n\nType\n   library(gfd)\n\nDescription\n  This structure is used in search/6 predicate, which interface to gecode's\n  search-engines. The structure can be used to obtain statistics of the\n  search via the stats option, in this case the fields of the structure \n  should be uninstantiated, and search/6 will instantiate it when a solution\n  is returned. Secondly, the struct can be used in the limits option, to\n  specify limits for the search, such that the search will be terminated when \n  the specified limit is exceeded. In this case, the fields for which limits \n  are required should be set. Note that not all fields can be used as limits.\n  If the field cannot be used as a limit, it will be ignored."},"gfd:gfd_set_default/2":{"prefix":"gfd_set_default","body":"gfd_set_default(${1:Parameter}, ${2:DefaultValue})$3\n$0","description":"gfd_set_default(+Parameter, +DefaultValue)\n\n   Set the default value for GFD Parameter.\n\nArguments\n   Parameter    GFD parameter to set (atom).\n   DefaultValue    Default value for Parameter.\n\nType\n   library(gfd)\n\nDescription\n   Set the default value for parameters:\n \n    interval_min\n    Minimum for the default interval for domain variables. When a domain\n    variable is created implicitly in a constraint, it is given a\n    default interval, and this interval should be as small as possible.\n    as the efficiency of various propagator depends on the domain\n    size. (integer no smaller than gfd_minint).\n    interval_max\n    Maximum for the default interval for domain variables.\n\t  (integer no larger than gfd_maxint).\n    array_size\n    Initial size for the variable array for storing domain variables\n    When more variables than can be accommodated in the array is required,\n    a new array double the size is created, and the old variables copied\n    to the new. Changing the initial size can reduce or avoid this \n    copying overhead. (positive integer).\n    cloning_distance\n    This controls how often the gecode state is cloned. The smaller\n    the distance, the more frequent the cloning. Cloning is only done\n    at places where the new clone might be useful, roughly if there are\n    changes to the state since the last clone, and it is possible to \n    backtrack and make use of the new clone (i.e. there should be\n    at least one choice-point between the last clone and the current\n    one. Distance is a measure of such points, so a distance of 1 is \n    the minimal distance where a clone may be needed. (positive \n    integer).\n    events_max\n    Maximum number of events during non-search (deterministic) \n    computation before a new clone is created to replace the\n    parent (positive integer).\n\nSee Also\n   gfd_get_default / 2, gfd_minint / 1, gfd_maxint / 1"},"gfd:gfd_vars_exclude/2":{"prefix":"gfd_vars_exclude","body":"gfd_vars_exclude(${1:Vars}, ${2:Excl})$3\n$0","description":"gfd_vars_exclude(+Vars, ++Excl)\n\n   Exclude the element Excl from the domains of Vars.\n\nArguments\n   Vars    Collection of existing domain variable or integer\n   Excl    Integer value to exclude\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for excluding an element from the domains of variables in Vars.\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple exclude/2 for updating each variable in Vars,\n   because this is implementing as one rather than multiple\n   events."},"gfd:gfd_vars_exclude_domain/2":{"prefix":"gfd_vars_exclude_domain","body":"gfd_vars_exclude_domain(${1:Vars}, ${2:Domain})$3\n$0","description":"gfd_vars_exclude_domain(+Vars, ?Domain)\n\n   Exclude the values specified in Domain from the domains of Vars.\n\nArguments\n   Vars    Collection of existing domain variables or integers\n   Domain    Domain specs or existing domain variable or integer\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for excluding the values specified in Domain from the\n   domains of Vars.\n\n   Domain can be a list (note only a list is supported in this\n   primitive, and not a collection) of domain specifications, a la the\n   domain specifications of (::)/2 -- i.e. each element can be an\n   integer, or an integer range in the form Lo..Hi. Alternatively,\n   Domain can be an existing GFD domain variable, or an integer. \n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd). For Gecode, if multiple\n   values need to   be excluded from the domain of a variable, it is much more\n   efficient to do it in one go, rather than excluding each value \n   individually (e.g. using gfd_vars_exclude/2). Also, if the values\n   has to be excluded from multiple variables, it is more efficient to use\n   one primitive to do this, rather than exclude the values from each \n   variable individually, as this is done with one event.\n\nModes and Determinism\n   gfd_vars_exclude_domain(+, ?)\n   gfd_vars_exclude_domain(+, ++)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"gfd:gfd_vars_exclude_range/3":{"prefix":"gfd_vars_exclude_range","body":"gfd_vars_exclude_range(${1:Vars}, ${2:Lo}, ${3:Hi})$4\n$0","description":"gfd_vars_exclude_range(+Vars, ++Lo, ++Hi)\n\n   Exclude the elements Lo..Hi from the domains of Vars.\n\nArguments\n   Vars    Collection of existing domain variable or integer\n   Lo    Integer lower bound of range to exclude\n   Hi    Integer upper bound of range to exclude\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for excluding the integers between Lo and Hi (inclusive) from\n   the domains of variables in Vars. \n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple exclude_range/2 for updating each variable in Vars,\n   because this is implementing as one rather than multiple\n   events."},"gfd:gfd_vars_impose_domain/2":{"prefix":"gfd_vars_impose_domain","body":"gfd_vars_impose_domain(${1:Vars}, ${2:Domain})$3\n$0","description":"gfd_vars_impose_domain(+Vars, ?Domain)\n\n   Restrict (if required) the domain of Var to the domain specified  in Domain\n\nArguments\n   Vars    Collection of (domain) variables or integers\n   Domain    List of domain specs or existing domain Variable or integer\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for restricting the domains of Vars to the domain\n   specified by  Domain. \n\n   Domain can be a list (note only a list is supported in this\n   primitive, and not a collection) of domain specifications, a la the\n   domain specifications of (::)/2 -- i.e. each element can be an\n   integer, or an integer range in the form Lo..Hi. Alternatively,\n   Domain can be an existing GFD domain variable, or an integer. \n\n   The domain update on Vars may fail (when the update empties the\n   domain of any variables in Vars), succeed (possibly updating the \n   variables' domain), or instantiate the variables (in the case where the \n   domain gets restricted to a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd).\n\nModes and Determinism\n   gfd_vars_impose_domain(+, ?)\n   gfd_vars_impose_domain(+, ++)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   gfd_vars_impose_min / 2, gfd_vars_impose_max / 2, gfd_vars_impose_bounds / 3, gfd_vars_exclude / 2, gfd_vars_exclude_range / 3, gfd_vars_exclude_domain / 2"},"gfd:gfd_vars_impose_bounds/3":{"prefix":"gfd_vars_impose_bounds","body":"gfd_vars_impose_bounds(${1:Vars}, ${2:Lo}, ${3:Hi})$4\n$0","description":"gfd_vars_impose_bounds(+Vars, ++Lo, ++Hi)\n\n   Update (if required) the bounds of Vars.\n\nArguments\n   Vars    Collection of (domain) variables or integers\n   Lo    Lower bound (integer)\n   Hi    Upper bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for updating the bounds of Vars so that the Lower bounds\n   are at least Lo and the upper bounds are at most Hi.\n   A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_max/2 and impose_min/2 for updating each \n   variable in Vars. Also, unlike impose_bounds/2, this primitive does\n   not call wake, so it behaviour is consistent with the other gfd_vars\n   primitives."},"gfd:gfd_vars_impose_max/2":{"prefix":"gfd_vars_impose_max","body":"gfd_vars_impose_max(${1:Vars}, ${2:Bound})$3\n$0","description":"gfd_vars_impose_max(+Vars, ++Bound)\n\n   Update (if required) the upper bounds of Vars.\n\nArguments\n   Vars    Collection of (domain) variables or integers\n   Bound    Upper bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for updating the lower bound of Vars so that they are at least\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_max/2 for updating each variable in Vars,\n   both because this is implementing as one rather than multiple\n   events, and the Gecode rel() constraint for multiple IntVars is\n   used to implement this primitive."},"gfd:gfd_vars_impose_min/2":{"prefix":"gfd_vars_impose_min","body":"gfd_vars_impose_min(${1:Vars}, ${2:Bound})$3\n$0","description":"gfd_vars_impose_min(+Vars, ++Bound)\n\n   Update (if required) the lower bounds of Vars.\n\nArguments\n   Vars    Collection of (domain) variables or integers\n   Bound    Lower bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   Primitive for updating the upper bound of Vars so that they are at most\n   Bound.  A bound update on a variable in Vars may fail (when the\n   update empties the domain), succeed (possibly updating the variable's \n   bounds), or instantiate the variable (in the case where the domain gets \n   restricted to a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, this predicate does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\n   This predicate is specific to lib(gfd), and is more efficient than\n   using multiple impose_min/2 for updating each variable in Vars,\n   both because this is implementing as one rather than multiple\n   events, and the Gecode rel() constraint for multiple IntVars is\n   used to implement this primitive."},"gfd:impose_bounds/3":{"prefix":"impose_bounds","body":"impose_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"impose_bounds(?Var, ++Lo, ++Hi)\n\n   Update (if required) the bounds of Var.\n\nArguments\n   Var    (Domain) variable or integer\n   Lo    Lower bound (integer)\n   Hi    Upper bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same bounds on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_min/2\n   (which additionally does not call wake).\n\n   Primitive for updating the upper and lower bounds of Var, As with \n   impose_min/2 and impose_max/2, it is intended for use in implementing \n   co-operation with other solvers, and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user \n   code (use ::/2 instead).  Its semantics is essentially:\n\n       impose_min(Var, Lo), impose_max(Var, Hi), wake.\n\nSee Also\n   impose_min / 2, impose_max / 2"},"gfd:impose_domain/2":{"prefix":"impose_domain","body":"impose_domain(${1:Var}, ${2:DomVar})$3\n$0","description":"impose_domain(?Var, ?DomVar)\n\n   Restrict (if required) the domain of Var to the domain of DomVar.\n\nArguments\n   Var    (Domain) variable or integer\n   DomVar    (Domain) variable or integer\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same domain on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_domain/2,\n   which additionally offer more flexibility in allowing the domain to be\n   specified as a list.\n\n   Primitive for restricting the domain of Var to the domain of DomVar.\n   Any values in the domain of Var, which are not also in the domain of\n   DomVar, are removed.  DomVar remains unaffected.  \n   The domain update on Var may fail (when the update empties the domain),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (in the case where the domain gets restricted to a singleton\n   value).\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   The waking behaviour is the same as discussed for impose_min/2 and\n   impose_max/2.  Apart from this, the effect is similar to unifying\n   Var with a copy of DomVar.\n\nExamples\n       ?- X::1..9, Y::5..7, impose_domain(X, Y).\n    X = X{5 .. 7}\n    Y = Y{5 .. 7}\n\n    ?- X::1..9, impose_domain(X, 7).\n    X = 7\n\n    ?- X::1..3, Y::5..7, impose_domain(X, Y).\n    No (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(3, Y).\n    Y = Y{1 .. 5}\n\n    ?- Y::1..5, impose_domain(6, Y).\n    No (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(X, Y).\n    Y = Y{1 .. 5}\n    X = X{1 .. 5}\n\nSee Also\n   impose_min / 2, impose_max / 2, impose_bounds / 3, exclude / 2, exclude_range / 3"},"gfd:impose_max/2":{"prefix":"impose_max","body":"impose_max(${1:Var}, ${2:Bound})$3\n$0","description":"impose_max(?Var, ++Bound)\n\n   Update (if required) the upper bound of Var.\n\nArguments\n   Var    (Domain) variable or integer\n   Bound    Upper bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same maximum on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_max/2.\n\n   Primitive for updating the upper bound of Var so that it is at most\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).  Note that if the variable's type is integer, its\n   bounds will always be adjusted to integral values.\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, impose_max/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\nSee Also\n   impose_min / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3"},"gfd:impose_min/2":{"prefix":"impose_min","body":"impose_min(${1:Var}, ${2:Bound})$3\n$0","description":"impose_min(?Var, ++Bound)\n\n   Update (if required) the lower bound of Var.\n\nArguments\n   Var    (Domain) variable or integer\n   Bound    Lower bound (integer)\n\nType\n   library(gfd)\n\nDescription\n\n   This predicate is provided mainly for compatibility with IC solver.\n   If you intend to impose the same minimum on multiple variables, it\n   is more efficient to use the lib(gfd) specific gfd_vars_impose_min/2.\n\n   Primitive for updating the lower bound of Var so that it is at least\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   co-operation with other solvers and constraint propagators at the\n   ECLiPSe level, and should not be called from ordinary user code.\n   It differs from the usual constraint in that the propagation is not\n   performed immediately. Normally, propagation in gecode is performed by\n   a suspended goal that is scheduled and woken after each constraint is\n   posted.  However, impose_min/2 does not call the woken goal\n   scheduler (wake/0), so the propagation goal may not be executed \n   immediately. (It is possible that under some circumstances the goal \n   will be executed, if wake/0 is called indirectly - one example would be\n   by the unify handler if the variable becomes ground - but this should not\n   be relied upon.) To ensure that the goals are eventually executed, the \n   caller should arrange for wake/0 to be called at some appropriate point \n   in the subsequent execution.  Please see the \"Advanced Control Features\" \n   section of the User Manual for more information about woken goal \n   management.\n\nSee Also\n   impose_max / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3"},"gfd:indomain/1":{"prefix":"indomain","body":"indomain(${1:Var})$2\n$0","description":"indomain(?Var)\n\n   Instantiates a domain GFD variable to an element of its domain.\n\nArguments\n   Var    A domain variable or an integer\n\nType\n   library(gfd)\n\nDescription\n\n   Simple predicate for instantiating a GFD domain variable to an element\n   of its domain.  It starts with the smallest element, and upon\n   backtracking tries successive elements until the entire domain has been\n   explored, at which point the predicate fails.\n\n   If Var is already a ground integer, then this predicate simply succeeds\n   exactly once without leaving a choicepoint.\n\n   Note that this predicate is an alias for using the indomain_min method\n   of try_value/2.\n\nModes and Determinism\n   indomain(?) is nondet\n\nSee Also\n   try_value / 2, gfd_search : indomain / 2, labeling / 1, :: / 2, fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1"},"gfd:init_weighted_degree/1":{"prefix":"init_weighted_degree","body":"init_weighted_degree(${1:Factor})$2\n$0","description":"init_weighted_degree(+Factor)\n\n   Initialise weighted degree so that the initial value for a variable is Factor*degree..\n\nArguments\n   Factor    Non-negative Number.\n\nType\n   library(gfd)\n\nDescription\n\n   Initialise weighted degree by setting the initial value for \n   each constraint's failure count to Factor. The weighted degree for\n   a variable is the sum of all its constraints failure count, i.e.\n   Factor*(degree for variable).By default, the initial failure count\n   for each constraint is set to 1.0, so the initial weighted\n   degree for a domain variable is its degree (number of associated\n   constraints).\n\n   As with failure count for a constraint is automatically set, \n   init_weighted_degree/1 is only needed if the user want to erase the \n   accumulated failure counts and reset the weighted degree for \n   variables, and/or if a different value for Factor is wanted.\n\n   Changing Factor changes the relative importance of subsequent failures,\n   The smaller the Factor, the more important each failure will be in the \n   subsequent changes in the weighted degree. Note that unless Factor\n   is  set to 0, the initial  relative ordering of weighted degree\n   will not change (subject to floating point precision considerations)."},"gfd:integers/1":{"prefix":"integers","body":"integers(${1:Vars})$2\n$0","description":"integers(?Vars)\n\n   Vars' domain is the integer numbers (within default bounds).\n\nArguments\n   Vars    Variable or integer, or a collection of variables\n\nType\n   library(gfd)\n\nDescription\n\n   Constrain the variables to integer values.  If any variable is a non-domain\n   variable, a default domain will be created for it.\n\nModes and Determinism\n   integers(-) is det\n   integers(+) is semidet\n\nSee Also\n   eplex : integers / 1, ic_kernel : integers / 1, fd : integers / 1, bfs : integers / 1, ic : integers / 1, suspend : integers / 1"},"gfd:is_exact_solver_var/1":{"prefix":"is_exact_solver_var","body":"is_exact_solver_var(${1:Term})$2\n$0","description":"is_exact_solver_var(?Term)\n\n   Succeeds iff Term is an GFD domain variable.\n\nArguments\n   Term    A Term\n\nType\n   library(gfd)\n\nDescription\n\n   Test if the term Term is an GFD domain variable. This is an alias for\n   is_solver_var/1 in GFD.\n\nModes and Determinism\n   is_exact_solver_var(?) is semidet\n\nFail Conditions\n   Var is not an GFD domain variable."},"gfd:is_in_domain/2":{"prefix":"is_in_domain","body":"is_in_domain(${1:Val}, ${2:Var})$3\n$0","description":"is_in_domain(++Val, ?Var)\n\n   Succeeds iff Val is in the domain of Var\n\nArguments\n   Val    An integer\n   Var    A domain variable or an integer\n\nType\n   library(gfd)\n\nDescription\n\n   Low level predicate which succeeds when Val is in the domain of Var.\n\nModes and Determinism\n   is_in_domain(++, ?) is semidet\n\nExceptions\n     5 --- Val is not an integer\n\nSee Also\n   is_in_domain / 3"},"gfd:is_in_domain/3":{"prefix":"is_in_domain","body":"is_in_domain(${1:Val}, ${2:Var}, ${3:Result})$4\n$0","description":"is_in_domain(++Val, ?Var, -Result)\n\n   Binds Result to indicate presence of Val in domain of Var\n\nArguments\n   Val    A number\n   Var    A domain variable or an integer\n   Result    A variable\n\nType\n   library(gfd)\n\nDescription\n\n   Low level predicate which succeeds when Val is in the domain of Var with\n   Result bound to the atom 'yes'.  When Val is not in the domain of Var,\n   the predicate succeeds binding Result to the atom 'no'. \n\nModes and Determinism\n   is_in_domain(++, ?, -) is det\n\nExceptions\n     5 --- Val is not an integer\n\nSee Also\n   is_in_domain / 2"},"gfd:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   Succeeds iff Term is a GFD domain variable or an integer.\n\nArguments\n   Term    A Term\n\nType\n   library(gfd)\n\nDescription\n\n   Test if the term Term is a GFD domain variable or an integer.\n   Succeed if it is, fail otherwise.\n\nModes and Determinism\n   is_solver_type(?) is semidet\n\nFail Conditions\n   Var is not a GFD domain variable or an integer."},"gfd:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   Succeeds iff Term is an GFD domain variable.\n\nArguments\n   Term    A Term\n\nType\n   library(gfd)\n\nDescription\n\n   Test if the term Term is an GFD domain variable.  Succeed if it is, fail\n   otherwise.\n\nModes and Determinism\n   is_solver_var(?) is semidet\n\nFail Conditions\n   Var is not an GFD domain variable."},"gfd:labeling/1":{"prefix":"labeling","body":"labeling(${1:Vars})$2\n$0","description":"labeling(+Vars)\n\n   Instantiates all variables in a collection to elements of their domains.\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of integer IC variables or integers\n\nType\n   library(gfd)\n\nDescription\n\n   Simple predicate for instantiating a collection of GFD domain variables\n   to elements of their domains.  (Integers are also allowed in the\n   collection; they are effectively ignored.)  The variables are\n   instantiated in the order in which they appear in the collection; the\n   implementation is essentially:\n\n\tlabeling(Vars) :-\n\t\tcollection_to_list(Vars, List),\n    gfd_update,\n\t\t( foreach(Var,List) do\n\t\t    indomain(Var,min)\n\t\t).\n\n   Note that labeling performs the search in ECLiPSe, but it uses\n   indomain/2 with min, which is optimised for use with Gecode, and a \n   gfd_update before the labeling starts to ensure that no recomputation\n   will not be done for events before the labeling starts.\n\nModes and Determinism\n   labeling(+) is nondet\n\nSee Also\n   gfd_search : indomain / 2, fd : labeling / 1, sd : labeling / 1, ic : labeling / 1, lists : collection_to_list / 2"},"gfd:lex_eq/2":{"prefix":"lex_eq","body":"lex_eq(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_eq(+Collection1, +Collection2)\n\n   Collection1 is lexicographically equal to Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tConstrains the two collections to be lexicographically equal, i.e.\n\tthe two collections are the same length, and each\n    element is identical to its corresponding element in the\n    other collection.\n\n    This constraint is known as lex_equal in the global constraint\n    catalog, but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_EQ IntRelType.\n\nExamples\n   \n[eclipse 48]: lex_eq([1,9,1,5], [1,9,1,5]).\n\n...\nYes (0.00s cpu)\n[eclipse 49]: lex_eq([1,9,1,5], [1,9,2,5]).\n\nNo (0.00s cpu)\n[eclipse 50]: lex_eq([1,9,1,5], [1,9,0,5]).\n\nNo (0.00s cpu)\n[eclipse 51]: lex_eq([1,9,1], [1,9,1,5]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_lt / 2, lex_gt / 2, lex_ge / 2, lex_ne / 2"},"gfd:lex_ge/2":{"prefix":"lex_ge","body":"lex_ge(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_ge(+Collection1, +Collection2)\n\n   Collection1 is lexicographically greater or equal to Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly larger\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached) is strictly smaller than any existing element.\n\n    This constraint is known as lex_greatereq in the global constraint\n    catalog, but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_GQ IntRelType.\n\nExamples\n   \n[eclipse 40]: lex_ge([5,2,8,9],[5,2,6,2]).\n\n...\nYes (0.00s cpu)\n[eclipse 41]: lex_ge([5,2,3,9], [5,2,3,9]).\n\n...\nYes (0.00s cpu)\n\n[eclipse 42]: lex_ge([5,2,3,9], [5,2,3]).\n\n...\nYes (0.00s cpu)\n[eclipse 43]: lex_ge([5,2,3,9], [5,3,1]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_lt / 2, lex_gt / 2, lex_eq / 2, lex_ne / 2"},"gfd:lex_gt/2":{"prefix":"lex_gt","body":"lex_gt(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_gt(+Collection1, +Collection2)\n\n   Collection1 is lexicographically greater than  Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly greater\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This constraint is known as lex_greater in the global constraint\n    catalog, but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_GR IntRelType.\n\nExamples\n   \n[eclipse 44]: lex_gt([5,2,7,1], [5,2,6,2]).\n\n...\nYes (0.00s cpu)\n[eclipse 45]: lex_gt([5,2,7,1], [5,2,7]).\n\n...\nYes (0.00s cpu)\n[eclipse 46]: lex_gt([5,2,7,1], [5,2,7,3]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_lt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2"},"gfd:lex_le/2":{"prefix":"lex_le","body":"lex_le(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_le(+Collection1, +Collection2)\n\n   Collection1 is lexicographically less or equal to Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly smaller\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached) is strictly smaller than any existing element.\n\n    This constraint is known as lex_lesseq in the global constraint\n    catalog, but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_LQ IntRelType.\n\nExamples\n   \n[eclipse 31]: lex_le([5,2,3,1], [5,2,6,2]).\n   ...\nYes (0.00s cpu)\n[eclipse 32]: lex_le([5,2,3,9], [5,2,3,9]).\n   ...\nYes (0.00s cpu)\n[eclipse 33]: lex_le([5,2,4], [5,2,4,1]).\n  ...\nYes (0.00s cpu)\n[eclipse 34]: lex_le([5,2,4,1], [5,2,4,0]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_lt / 2, lex_gt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2, ic_global : lex_le / 2, fd_global : lex_le / 2, ic_global_gac : lex_le / 2, fd_global_gac : lex_le / 2"},"gfd:lex_lt/2":{"prefix":"lex_lt","body":"lex_lt(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_lt(+Collection1, +Collection2)\n\n   Collection1 is lexicographically less than  Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of Collection1 strictly smaller\n\tthan the first element of Collection2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This constraint is known as lex_less in the global constraint\n    catalog. but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_LE IntRelType.\n\nExamples\n   \n[eclipse 36]: lex_lt([5,2,3,9], [5,2,6,2]).\n\n ...\nYes (0.00s cpu)\n[eclipse 37]: lex_lt([5,2,3,9], [5,2,6]).\n\n ...\nYes (0.00s cpu)\n[eclipse 38]: lex_lt([5,2,3], [5,2,3,9]).\n\n ...\nYes (0.00s cpu)\n[eclipse 39]: lex_lt([5,2,3,4], [5,2,3,4]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_le / 2, lex_gt / 2, lex_ge / 2, lex_eq / 2, lex_ne / 2, ic_global : lex_lt / 2, fd_global : lex_lt / 2, ic_global_gac : lex_lt / 2, fd_global_gac : lex_lt / 2"},"gfd:lex_ne/2":{"prefix":"lex_ne","body":"lex_ne(${1:Collection1}, ${2:Collection2})$3\n$0","description":"lex_ne(+Collection1, +Collection2)\n\n   Collection1 is lexicographically not equal to Collection2\n\nArguments\n   Collection1    Collection of integers or (domain) variables\n   Collection2    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n    \tConstrains the two collections to be lexicographically different, i.e.\n\tthe two collections are either different lengths, or at least\n    one element in one collection is different from its corresponding\n    element in the other collection.\n\n    This constraint is known as lex_different in the global constraint\n    catalog, but the catalog's definition requires Collection1 and\n    Collection2 to be the same size. It is implemented using Gecode's\n    rel() constraint (variant that takes two IntVarArgs arguments),\n    with the IRT_NQ IntRelType.\n\nExamples\n   \n[eclipse 52]: lex_ne([5,2,7,1], [5,3,7,1]).\n\n...\nYes (0.00s cpu)\n[eclipse 53]: lex_ne([5,2,7,1], [5,2,7]).\n\n...\nYes (0.00s cpu)\n[eclipse 54]: lex_ne([5,2,7], [5,2,7,1]).\n\n...\nYes (0.00s cpu)\n[eclipse 55]: lex_ne([5,2,7,1], [5,2,7,1]).\n\nNo (0.00s cpu)\n\nSee Also\n   lex_lt / 2, lex_gt / 2, lex_eq / 2, lex_ge / 2"},"gfd:max_first_index/2":{"prefix":"max_first_index","body":"max_first_index(${1:Collection}, ${2:Index})$3\n$0","description":"max_first_index(+Collection,?Index)\n\n   Index is constrained to the index of the first variable with the maximum value in Collection\n\nArguments\n   Collection    A collection (a la collection_to_list/2) of integers or (domain) variables\n   Index    (Domain) variable or integer (array notation accepted)\n\nType\n   library(gfd)\n\nDescription\n    \tIndex is constrained to the index of the first (smallest index)\n    variable(s) with the maximum value in Collection. If Index is a \n    variable, it must not occur in  Collection..  \n\n    You may find it more convenient to embed max_first_index(Vars) \n    in a constraint expression.\n    \n    As with all constraints that involve indexes, the index starts\n    from 1, unlike Gecode's native indexes that starts from 0 - a\n    dummy first element is added to Collection in the constraint posted\n    to Gecode if Collection is not empty. \n    \n    This constraint is a variation of max_index in the global\n    constraint catalog, and is implemented using\n    Gecode's maxarg() constraint with tie-break set to true..\n    \n\nSee Also\n   max_index / 2, max_first_index / 2, min_index / 2, max / 2, min / 2, lists : collection_to_list / 2"},"gfd:max_first_index_g/2":{"prefix":"max_first_index_g","body":"max_first_index_g(${1:Collection}, ${2:Index})$3\n$0","description":"max_first_index_g(+Collection,?Index)\n\n   Index is constrained to the index of the first variable with the maximum value in Collection, with native gecode indexing\n\nArguments\n   Collection    A collection (a la collection_to_list/2) of integers or (domain_ variables\n   Index    (Domain) variable or integer (array notation accepted)\n\nType\n   library(gfd)\n\nDescription\n  This version of max_first_index/2 uses the native Gecode indexing,\n  which starts from 0, i.e. the first element of Collection has index 0.\n  This is different from normal ECLiPSe's indexing, which starts from 1.\n\n  This predicate maps directly to Gecode's native implementation of the\n  constraint, and may therefore be more efficient, but could also be\n  incompatible with existing ECLiPSe code. \n\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n\n  See max_first_index/2 for a more detailed description of this predicate.\n\nSee Also\n   max_first_index / 2"},"gfd:max_regret_lwb/2":{"prefix":"max_regret_lwb","body":"max_regret_lwb(${1:Var}, ${2:Criterion})$3\n$0","description":"max_regret_lwb(?Var, ?Criterion)\n\n   Generic search compatible variable selection method, returns the regret value for Var\n\nArguments\n   Var    Domain variable or integer\n   Criterion    Variable\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate is designed to be used as a variable selection method\nwith generic search (lib(gfd_search)), and should be used with \ngfd_search's delete/5 and search/6. The effect is to select the first\nvariable with the maximum regret (the largest difference between the \nsmallest and second smallest value in the domain).\n\nUnlike the built-in generic search's max_regret method, where the regret\nvalue is calculated in ECLiPSe from the variable's domain, this predicate \nobtain the regret value from Gecode.\n\nSee Also\n   gfd_search : delete / 5, gfd_search : search / 6"},"gfd:max_weighted_degree/2":{"prefix":"max_weighted_degree","body":"max_weighted_degree(${1:Var}, ${2:Criterion})$3\n$0","description":"max_weighted_degree(?Var, ?Criterion)\n\n   Generic search compatible variable selection method, returns the weighted degree for Var\n\nArguments\n   Var    Domain variable or integer\n   Criterion    Variable\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate is designed to be used as a variable selection method\nwith generic search (lib(gfd_search)), and should be used with \ngfd_search's delete/5 and search/6. The effect is to select the first\nvariable with the maximum weighted degree.\n\nThis predicate obtain the weighted degree for the variable from Gecode.\n\nSee Also\n   gfd_search : delete / 5, gfd_search : search / 6"},"gfd:max_regret_upb/2":{"prefix":"max_regret_upb","body":"max_regret_upb(${1:Var}, ${2:Criterion})$3\n$0","description":"max_regret_upb(?Var, ?Criterion)\n\n   Generic search compatible variable selection method, returns the upper-bound regret value for Var\n\nArguments\n   Var    Domain variable or integer\n   Criterion    Variable\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate is designed to be used as a variable selection method\nwith generic search (lib(gfd_search)), and should be used with \ngfd_search's delete/5 and search/6. The effect is to select the first\nvariable with the maximum regret on the upper bound (the largest\ndifference between the largest and second largest value in the domain).\n\nThis predicate obtain the regret value from Gecode.\n\nSee Also\n   gfd_search : delete / 5, gfd_search : search / 6"},"gfd:max_weighted_degree_per_value/2":{"prefix":"max_weighted_degree_per_value","body":"max_weighted_degree_per_value(${1:Var}, ${2:Criterion})$3\n$0","description":"max_weighted_degree_per_value(?Var, ?Criterion)\n\n   Generic search compatible variable selection method, returns the domain size divided by weighted degree for Var\n\nArguments\n   Var    Domain variable or integer\n   Criterion    Variable\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate is designed to be used as a variable selection method\nwith generic search (lib(gfd_search)), and should be used with \ngfd_search's delete/5 and search/6. The effect is to select the first\nvariable with the maximum (domain size)/(weighted degree). (rounded to\n the nearest integer)\n\nThis predicate obtain the weighted degree for the variable from Gecode.\n\nSee Also\n   gfd_search : delete / 5, gfd_search : search / 6"},"gfd:min_first_index/2":{"prefix":"min_first_index","body":"min_first_index(${1:Collection}, ${2:Index})$3\n$0","description":"min_first_index(+Collection,?Index)\n\n   Index is constrained to the index of the first variable with the minimum value in Collection\n\nArguments\n   Collection    A collection (a la collection_to_list/2) of integers or d(omain) variables\n   Index    (Domain) variable or integer (array notation accepted)\n\nType\n   library(gfd)\n\nDescription\n    \tIndex is constrained to the index of the first (smallest index)\n    variable(s) with the minimum value in Collection.  If Index is a\n    variable, it must not occur in  Collection..  \n  \n    You may find it more convenient to embed min_first_index(Vars) \n    in a constraint expression.\n    \n    As with all constraints that involve indexes, the index starts\n    from 1, unlike Gecode's native indexes that starts from 0 - a\n    dummy first element is added to Collection in the constraint posted\n    to Gecode if Collection is not empty. \n    \n    This constraint is a variation of min_index in the global\n    constraint catalog, and is implemented using\n    Gecode's minarg() constraint with tie-break set to true..\n    \n\nSee Also\n   min_index / 2, max_first_index / 2, max_index / 2, min / 2, max / 2, lists : collection_to_list / 2"},"gfd:min_first_index_g/2":{"prefix":"min_first_index_g","body":"min_first_index_g(${1:Collection}, ${2:Index})$3\n$0","description":"min_first_index_g(+Collection,?Index)\n\n   Index is constrained to the index of the first variable with the minimum value in Collection, with native gecode indexing\n\nArguments\n   Collection    A collection (a la collection_to_list/2) of integers or (domain) variables\n   Index    (Domain) variable or integer (array notation accepted)\n\nType\n   library(gfd)\n\nDescription\n  This version of min_first_index/2 uses the native Gecode indexing,\n  which starts from 0, i.e. the first element of Collection has index 0.\n  This is different from normal ECLiPSe's indexing, which starts from 1.\n\n  This predicate maps directly to Gecode's native implementation of the\n  constraint, and may therefore be more efficient, but could also be\n  incompatible with existing ECLiPSe code. \n\n   This constraint can be embedded in a constraint expression in its\n   functional form (without the last argument).\n\n  See min_first_index/2 for a more detailed description of this predicate.\n\nExamples\n   [eclipse 11]: min_first_index([1,2,3], I).\n\nI = 1\n\n[eclipse 12]: min_first_index([1,2,3,1,10,9,10], I).\n\nI = 1\n\n[eclipse 13]: L = [A,B,C,D,E], L :: 1..10, min_first_index(L, 3), C #> 4.\n\nL = [A{[6 .. 10]}, B{[6 .. 10]}, C{[5 .. 9]}, D{[5 .. 10]}, E{[5 .. 10]}]\nA = A{[6 .. 10]}\nB = B{[6 .. 10]}\nC = C{[5 .. 9]}\nD = D{[5 .. 10]}\nE = E{[5 .. 10]}\n[eclipse 14]: L = [A,B,C,D,E], L :: 1..10, min_first_index(L, 3), B #> 4.\n\nL = [A{[2 .. 10]}, B{[5 .. 10]}, C{[1 .. 9]}, D{[1 .. 10]}, E{[1 .. 10]}]\nA = A{[2 .. 10]}\nB = B{[5 .. 10]}\nC = C{[1 .. 9]}\nD = D{[1 .. 10]}\nE = E{[1 .. 10]}\n\n[eclipse 15]: L = [A,B,C,D,E], L :: 1..10, min_first_index(L, 3), B #< 4.\n\nL = [A{[2 .. 10]}, B{[2, 3]}, C{[1, 2]}, D{[1 .. 10]}, E{[1 .. 10]}]\nA = A{[2 .. 10]}\nB = B{[2, 3]}\nC = C{[1, 2]}\nD = D{[1 .. 10]}\nE = E{[1 .. 10]}\n\n[eclipse 16]: [A,B,D] :: 1..10, C :: 20..30, min_first_index([A,B,C,D], I).\n\nA = A{[1 .. 10]}\nB = B{[1 .. 10]}\nD = D{[1 .. 10]}\nC = C{[20 .. 30]}\nI = I{[1, 2, 4]}\n\nSee Also\n   min_first_index / 2"},"gfd:most_constrained_per_value/2":{"prefix":"most_constrained_per_value","body":"most_constrained_per_value(${1:Var}, ${2:Criterion})$3\n$0","description":"most_constrained_per_value(?Var, ?Criterion)\n\n   Generic search compatible variable selection method,\n\nArguments\n   Var    Domain variable or integer\n   Criterion    Variable\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate is designed to be used as a variable selection method\nwith generic search (lib(gfd_search)), and should be used with \ngfd_search's delete/5 and search/6. The effect is to select the first\nvariable with the the largest value of (domain size)/(number of constraints).\n(rounded to the nearest integer)\n\nSee Also\n   gfd_search : delete / 5, gfd_search : search / 6"},"gfd:msg/3":{"prefix":"msg","body":"msg(${1:Var1}, ${2:Var2}, ${3:MSG})$4\n$0","description":"msg(?Var1, ?Var2, ?MSG)\n\n   Computes the most specific generalisation of Var1 and Var2 that is expressible with GFD variables.\n\nArguments\n   Var1    A (domain) variable or number\n   Var2    A (domain) variable or number\n   MSG    Most specific generalisation (variable)\n\nType\n   library(gfd)\n\nDescription\n\n   The most specific generalisation of two intervals is computed and\n   returned as MSG.  MSG will be the union of the domains of the two\n   variables, with integers treated as a singleton domain.\n   If either Var1 or Var2 are domain-less, or have values that cannot be\n   expressed as domains, MSG remains unbound.\n\nModes and Determinism\n   msg(-, -, ?)\n   msg(++, ++, ?)"},"gfd:nvalues/3":{"prefix":"nvalues","body":"nvalues(${1:Collection}, ${2:RelOp}, ${3:Limit})$4\n$0","description":"nvalues(+Collection, +RelOp, ?Limit)\n\n   Constrains N, the number of distinct values assigned to Collection to satisfy the relation N Rel Limit.\n\nArguments\n   Collection    Collection of integers or (domain) variables.\n   RelOp    One of the atom: #>, #>=, #<, #=<, #=, #\\=\n   Limit    Variable or integer\n\nType\n   library(gfd)\n\nDescription\n  Constrains N, the number of distinct values assigned to Collection\n  to satisfy the relation N Rel Limit.\n\n  Rel can be one of #>, #>=, #<, #=<, #=, #\\= (or equivalently,\n  >, >=, <, =<, =, \\=).\n\n  Any input variables which are not already domain variable will be turned \n  into domain variables with default bounds.\n\n  This constraint can be embedded in a constraint expression in its\n  functional form (without the last argument).\n\n  This constraint is also known as nvalues in the global constraint catalog. \n  It is implemented by Gecode's nvalue() constraint.\n\nExamples\n   [eclipse 21]: nvalues([4,5,5,4,1,5], (#=), N).\n\nN = 3\n\n[eclipse 22]: nvalues([A,B,C,D], (#>), N).\n\nA = A{[-1000000 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nN = N{[-1000000 .. 3]}\n\n[eclipse 23]: nvalues([A,B,C,D], (#=), N).\n\nA = A{[-1000000 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nN = N{[1 .. 4]}"},"gfd:occ/s":{"prefix":"struct","body":"struct","description":"struct occ(occ, value)\n\n   Bounds specification for gcc constraint.\n\nFields\n   occ    Domain variable or integer specifying the cardinality of Value.\n   value    Value whose cardinality is being specified.\n\nType\n   library(gfd)\n\nDescription\n    This structure is used to specify the cardinality (number of occurrences)\n    of one value for the gcc constraint."},"gfd:precede/2":{"prefix":"precede","body":"precede(${1:Values}, ${2:Collection})$3\n$0","description":"precede(++Values, +Collection)\n\n   Constrains each value in Values to precede its succeeding\n value in Collection\n\nArguments\n   Values    Collection of integers\n   Collection    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n      Constrains the first appearance of every value of the ordered\n      collection of integers in Values to precede the first\n      appearance of the next value in Values in the ordered collection of \n      elements in Collection, i.e. the precede/3 constraint to hold\n      for every adjacent integers in Values.\n\n      This constraint is known as int_value_precede_chain in the Global\n      Constraint Catalog, and is implemented using Gecode's precede()\n      constraint (variant with IntArg argument for Values).\n\n    \n\nExamples\n   [eclipse 18]: precede([4,0,1], [4,0,6,1,0]).   % succeed\n[eclipse 19]: precede([4,0,1], [4,0,6,1,0]).  % succeed\n[eclipse 20]: precede([4,0,1], [4,1,6,1,0]).   % fail\n\n[eclipse 21]: precede([4,0,1], [A,B,C,D,E]).\n\nA = A{[-1000000 .. -1, 2 .. 1000000]}\nB = B{[-1000000 .. 0, 2 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nE = E{[-1000000 .. 1000000]}\n\nSee Also\n   precede / 3, lists : collection_to_list / 2"},"gfd:precede/3":{"prefix":"precede","body":"precede(${1:S}, ${2:T}, ${3:Collection})$4\n$0","description":"precede(+S, +T, +Collection)\n\n   Constrains S to precede T in Collection\n\nArguments\n   S    Integer\n   T    Integer\n   Collection    Collection of integers or (domain) variables\n\nType\n   library(gfd)\n\nDescription\n      Constrains the first appearance of value S to precede the first\n      appearance of value T in the ordered collection of elements in \n      Collection. S and T do not have to appear in Collection: if only\n      S appears, the constraint will succeed, and if only T appears,\n      the constraint will fail. If neither appears, the constraint will\n      succeed.\n\n      This constraint is known as int_value_precede in the Global\n      Constraint Catalog, and is implemented using Gecode's precede()\n      constraint (variant with int arguments for s and t).\n\n    \n\nExamples\n   [eclipse 14]: precede(0,1, [4,0,6,1,0]).  % succeed (0 appears before 1)\n\n[eclipse 15]: precede(0,1, [](4,0,6,1,0)). % succeed (0 appears before 1)\n\n[eclipse 16]: precede(0,1, [A,B,C,D,E]).\n\nA = A{[-1000000 .. 0, 2 .. 1000000]}\nB = B{[-1000000 .. 1000000]}\nC = C{[-1000000 .. 1000000]}\nD = D{[-1000000 .. 1000000]}\nE = E{[-1000000 .. 1000000]}\n\n[eclipse 17]:  precede(0,1, [4,1,6,0,0]).   % fail (1 appears before 0)\n\nSee Also\n   precede / 2, lists : collection_to_list / 2"},"gfd:rect/s":{"prefix":"struct","body":"struct","description":"struct rect(x, y, w, h, b)\n\n   Specification for rectangles used in disjoint2 and disjoint2_optional constraints.\n\nFields\n   x    the x co-ordinate of the left-side of the rectangle\n   y    the y co-ordinate of the bottom-side of the rectangle\n   w    the width of the rectangle\n   h    the height of the rectangle\n   b    boolean specifying if rectangle is placed (1=placed)\n\nType\n   library(gfd)\n\nDescription\nThis structure is used for specify the rectangles used\n in disjoint2 and disjoint2_optional constraints. These rectangles are\n placed on a grid."},"gfd:search/6":{"prefix":"search","body":"search(${1:L}, ${2:Arg}, ${3:Select}, ${4:Choice}, ${5:Method}, ${6:Option})$7\n$0","description":"search(+L, ++Arg, ++Select, +Choice, ++Method, +Option)\n\n   Interface to gecode search-engines to perform search in gecode.\n\nArguments\n   L    is a collection (a la collection_to_list/2) of (domain)\n\t    variables (Arg = 0) or a collection of terms (Arg > 0)\n   Arg    is an integer, which is 0 if L is a collection of\n\t    domain variables or greater than 0 if L consists of terms of\n\t    arity greater than Arg, the value Arg indicates the\n\t    selected argument of the term\n   Select    is a predefined variable selection method. Available methods are \n    input_order, first_fail, anti_first_fail, smallest, largest, \n    occurrence, anti_occurrence, most_constrained, \n    most_constrained_per_value, least_constrained_per_value, \n    max_regret, max_regret_lwb, min_regret_lwb, max_regret_upb,\n    min_regret_upb, random, random(+Seed), \n\t    max_weighted_degree, max_weighted_degree_per_value, \n\t    min_weighted_degree, min_weighted_degree_per_value, \n\t    max_activity, max_activity_per_value, \n\t    min_activity, min_activity_per_value,\n\t    max_weighted_degree(+WP), max_weighted_degree_per_value(+WP), \n\t    min_weighted_degree(+WP), min_weighted_degree_per_value(+WP), \n\t    max_activity(+AP), max_activity_per_value(+AP), \n\t    min_activity(+AP), min_activity_per_value(+AP)\n   Choice    is the name of a predefine value choice method for choosing\n    the value to try for a variable; Predefined choice methods are:\n    indomain, indomain_reverse_enum, min, max, median, split, \n    reverse_split, random, random(+Seed), interval_min, interval_max,\n    from_smaller(P,Vals), from_larger(P,Vals), from_down(P,Vals),\n    from_up(P,Vals)\n   Method    is one of the following:  complete,\n    bb_min(Cost:domain variable),\n\t    restart_min(Cost:domain variable),\n\t    restart_min(Cost:domain variable,Cutoff),\n\t    restart_min(Cost:domain variable,Cutoff,Lim),\n    restart(Cutoff), restart(Cutoff,Lim)\n   Option    is a list of option terms.  Currently recognized are:\n\t  tiebreak(+Select), stats(+Stats), limits(+Stop), \n    timeout(+Seconds), control(+Control), backtrack(-N), \n    nodes(+N), ldsb_syms(+Syms)\n\nType\n   library(gfd)\n\nDescription\nSearch/6 provides an interface to gecode's search-engine,\nallowing search to be performed by gecode. It is designed to have the same \narguments as the generic search/6 routine available for integer domain solvers.\nso that for common cases, the call will work for both search/6. The generic\nsearch/6 is available in the gfd_search module. The difference is that here\nthe search is performed by gecode, and is an atomic step when viewed from\nECLiPSe. In addition, this predicat support features of gecode's search\nengine not in generic search, such as variable selection methods based\n on propagation history, optimising and restart-based search methods, \nsymmetry breaking with LDSB and searching in parallel.  \nL, using the\nsearch method specified by Method, with variable and value selection\nmethods specified by Select and Choice,respectively. For search\nmethods that cab produce multiple solutions, backtracking into the predicate\nwill produce the next solution if it exists. The search can be controlled \nfurther via the terms specified in Options.\n\nIn order to allow more structure in the application program, L can be a\ncollection of compound terms rather than just domain variables. In this \nway all information about some entity can be easily grouped together. \nThe terms can include items that are associated with the\ndomain variable needed in some of the labelling methods. In addition, \nto allow L to reflect structures in the problem, it can be a nested\ncollection such as a matrix.\n\nSearch methods are implmeneted by gecode's search engines. These include\noptimising and restart based search methods, which are not available in\ngeneric search. The optimising search methods provide some of the \nfunctionality in.lib(branch_and_bound), and is likely to be\nfaster, but less flexible. The optimising search methods returns a\nsingle optimal solution by finding succesively better feasible solutions\nuntil no better solution can be found. If the search is terminated early, \ne.g. because of time-out, the best feasible solution, will be returned. \n\nSymmetry breaking using Lightweight Dynamic Symmetry Breaking (LDSB) can be\nspecified in the Option argument, and can be used with all search methods \nand most variable selection methods.\n\nThe variable selection and value choice methods are defined by gecode. They\nare mapped to the closest matching methods in the generic search/6 (or with\na name following the same convention if the method have no correspondence).\nNote that except for indomain and indomain_reverse_enum, the indomain style\nselection methods of generic search, are not supported. Instead, most\nvalue choice methods makes a two-way choice like the methods in try_value/2.\nAt each choice, a variable is selected, and two alternatives are\n created that reduces the variable's domain in complementary ways. \n\nFor source compatibility with code written for the IC and FD solvers, \nthe generic search's indomain style method names are also accepted,\nbut are mapped to the closest two-way choice method, e.g.indomain_min is translated to min.\n\nFor variable selection, if several entries have the same heuristic value, \nthen a tiebreak selection method, specified by the tiebreak option term, can \nbe used to chose from these entries.  \n\nSeveral of the variable selection methods makes use of one of two \ndynamic measurements of gecode's constraint propagation performed \nby the program so far: 1) Weighted degree, called AFC \n(accumulated failure count) in gecode; 2) Activity. These two measurements\nmay make better variable selection in many programs because it is based\non actual constraint propagation performed.\n\nWeighted degree is a count of the number of failures so far of\npropagators associated with the variable. By default, the starting count\nis set to the number of propagator attached to the variable,\nto give reasonable starting values for variable selection.\n\nActivity is a count of the number of domain reductions on the variable\nduring propagation so far. \n\nA decay factor (between 0 and 1) can be specified for both measure so that\nthe count for a variable can be reduced by the Factor if it is not \nincremented. \n\nThe pre-defined selection methods (with the gecode name in brackets) \nuse the following criteria:\n\ninput_order (INT_VAR_NONE) the first entry in the list is selected\nrandom (INT_VAR_RND) an entry is selected at random.\n\nrandom(+Seed) (INT_VAR_RND) an entry is selected at random,\n with the random seed Seed. Seed is a non-negative integer.\n\nanti_occurrence (INT_VAR_DEGREE_MIN) the entry whose corresponding gecode variable with the\nsmallest number of attached propagators is selected\n\noccurrence (INT_VAR_DEGREE_MAX) the entry whose corresponding gecode variable with the\nlargest number of attached propagators is selected\n\nmax_weighted_degree max_weighted_degree(+WDParams) (INT_VAR_AFC_MAX)\nthe entry with the largest weighted degree is selected. The optional WDParams\nargument is a list of parameters for initialising the weighted degree.\n\nmax_weighted_degree_per_value  max_weighted_degree_per_value(+WDParams) \n(INT_VAR_AFC_SIZE_MIN) the entry with the smallest weighted degree divided by \ndomain size is selected. The optional WDParams argument is a list of \nparameters for initialising the weighted degree. The parameters are:\n\ndecay(Decay) specify the decay factor (number between\n 0 and 1, where 1 is no decay). Default is the existing decay factor \nfor weighted degree (normally 1, unless explicitly changed).\n\ninit(Init) re-initialise the weighted degree values before\nstarting the search according to Init. Init can be:\n\ndegree(+Factor)  set the value of the weighted degree\nfor a problem variable to Factor*degree for the variable. Factor is a \nnon-negative number. If Factor is 1, then the weighted degree for each \nvariable will be its degree, the default initial value for weighted\n degree.\n\nnone no initialisation is done. This is the default.\n\n \n\nmin_weighted_degree min_weighted_degree(+WDParams) (INT_VAR_AFC_MIN) the entry with the smallest\nweighted degree is selected. The optional WDParams\nargument is a list of parameters for initialising the weighted degree.\n\nmin_weighted_degree_per_value  min_weighted_degree_per_value(+WDParams) \n(INT_VAR_AFC_SIZE_MAX) the entry with the largest weighted degree divided by \ndomain size is selected. The optional WDParams\nargument is a list of parameters for initialising the weighted degree. \n\nmax_activity max_activity(+AParams) (INT_VAR_ACTIVITY_MAX) the entry with the\n largest activity is selected. Activity for a variable  Activity is a\n measure of how much that variable was involved in constraint\n propagation. Note that activity is maintained by gecode's search engine \n for the search variables, and is not available outside.\n\nThe parameters are:\n\ndecay(Decay) specify the decay factor (number between\n 0 and 1, where 1 is no decay). Default is 1.\n\ninit(Init) set the start values for activity for the\nsearch variables according to Init. Init can be:\n\n degree(+Factor) set the start value to \nFactor*degree for the variable. Factor is a non-negative number.\n\n vals(Pos,Starts) set the start values to those specified in\nStarts. Starts is a collection of either the start values (Pos=0), or \ncompound terms containing the value, in the Pos'th argument. The number\nof start values is the same as the number of variable, and each value\nis a non-negative number. \n\n none no initialisation (default)\n\nmax_activity_per_value max_activity_per_value(+AParams) (INT_VAR_ACTIVITY_SIZE_MAX) the entry with the\nlargest activity divided by domain size is selected.\n\nmin_activity min_activity(+AParams) (INT_VAR_ACTIVITY_MIN) the entry with the\n smallest activity is selected. min_activity_per_value min_activity_per_value(+AParams) (INT_VAR_ACTIVITY_SIZE_MIN) the entry with the\nsmallest activity divided by domain size is selected.\n\nsmallest (INT_VAR_MIN_MIN) the entry with the smallest value in the domain is selected\n\nsmallest_upb (INT_VAR_MIN_MAX) the entry with the smallest\n upper bound in the domain is selected\n\nlargest_lwb (INT_VAR_MAX_MIN) the entry with the largest lower\n  bound in the domain is selected\n\nlargest (INT_VAR_MAX_MAX) the entry with the largest value in the domain is selected\n\nfirst_fail (INT_VAR_SIZE_MIN) the entry with the smallest domain size is selected\n\nanti_first_fail (INT_VAR_SIZE_MAX) the entry with the largest domain size is selected\n\nleast_constrained_per_value (INT_VAR_DEGREE_SIZE_MAX) the entry with the largest number of attached propagators divided by domain size. \n\nmost_constrained_per_value (INT_VAR_DEGREE_SIZE_MIN) the entry with the smallest \nnumber of attached propagators divided by the domain size. \n\nmin_regret_lwb (INT_VAR_REGRET_MIN_MIN) the entry with the smallest difference between the\nsmallest and second smallest value in the domain is selected.\n\nmax_regret (INT_VAR_REGRET_MIN_MAX) the entry with the largest difference between the\nsmallest and second smallest value in the domain is selected. This method is\ntypically used if the variable represents a cost, and we are interested in the\nchoice which could increase overall cost the most if the best possibility is\nnot taken. Unfortunately, the implementation sometimes does not always\nwork. If two decision variables incur the same minimal cost, the regret is not\ncalculated as zero, but as the difference from this minimal value to the next\ngreater value. Note this is an alias for max_regret_lwb\n\nmax_regret_lwb (INT_VAR_REGRET_MIN_MAX) is an alias to max_regret.\n\nmin_regret_upb (INT_VAR_REGRET_MAX_MIN) the entry with the smallest difference between the\nlargest and second largest value in the domain is selected.\n\nmax_regret_upb (INT_VAR_REGRET_MAX_MAX) the entry with the largest difference between the\nlargest and second largest value in the domain is selected.\n\nmost_constrained (INT_VAR_SIZE_MIN, INT_VAR_DEGREE_MAX) the entry with the smallest domain size is\n selected. If several entries have the same domain size, the entry with the\n largest number of attached constraints is selected. This is provided for\n compatibility, as this define a tiebreak method (occurrence). Any tiebreak\n method defined in options is ignored.\n\nThe pre-defined choice methods (with gecode name in brackets) have the following meaning:\n\nindomain (INT_VALUES_MIN) \nValues are tried in increasing order.\n\nindomain_reverse_enum (INT_VALUES_MAX)\nValues are tried in decreasing order. \n\nmin (INT_VAL_MIN)\nMinimum value in the domain (alias: indomain_min). \n\nmax (INT_VAL_MAX)\nMaximum value in the domain (alias: indomain_max). \n\nmedian(INT_VAL_MED)\nMedian value of the domain Note median is defined differently from IC (alias: indomain_median). \n\nrandom (INT_VAL_RND)\nRandom element in the domain is selected (alias: indomain_random). \n\nrandom(+Seed) (INT_VAL_RND)\nRandom element in the domain is selected  The random sequence is\ninitialised with seed Seed, which is a non-negative integer.\n \n\nsplit (INT_VAL_SPLIT_MIN)\ntry first the lower domain half, then the upper (alias: indomain_split).\n\nreverse_split (INT_VAL_SPLIT_MAX)\ntry first the upper domain half, then the lower \n(alias: indomain_reverse_split).\n\ninterval_min (INT_VAL_RANGE_MIN)\nIf the domain consists of several intervals, chose the smallest interval.\nFor one interval, split is used.\n(alias: indomain_interval)\n\ninterval_max (INT_VAL_RANGE_MAX)\nIf the domain consists of several intervals, chose the largest interval.\nthe interval, choosing the largest interval.  For one interval,\n reverse_split is used \n\nfrom_larger(+Pos,+Suggestions) (INT_VAL_NEAR_MAX)\nSuggestions is a collection containing suggested values, one for each search\n variable. For each variable, pick the domain value nearest its\ncorresponding suggested value. If there is a tie, chose the larger\n value.\n\nIf Pos is 0, then Suggestions is a collection of values. If Pos > 0,\n then Suggestions is a collection of structures, with the suggested\n value in the Pos'th argument of the structure. The idea is that the same\nstructure can be used to store both the variable and its suggested\n value, e.g. as a pair Var-2.\n\nfrom_smaller(+Pos,+Suggestions) (INT_VAL_NEAR_MAX)\nsimilar to from_larger, except chose the smaller value if there is a tie.\n\nfrom_down(+Pos,+Suggestions) (INT_VAL_NEAR_DEC)\nsimilar to from_larger, except chose values smaller than the suggested\n value first.\n\nfrom_up(+Pos,+Suggestions) (INT_VAL_NEAR_INCC)\nsimilar go from_down, except chose values larger than its suggested\nvalue first.  \n\nThe different search methods are\n\ncomplete (DFS)\na complete search routine which explores all alternative choices. Alternative\nsolutions are returned on backtracking\n\nbb_min(Cost) (BAB)\nBranch-and-bound search to find the minimal value for the cost variable Cost.\nThis should be a domain variable that is instantiated at the end of the\nsearch. The search will return an optimal solution, unless terminated early,\nin which case, the best solution found (if there is one) is returned. If Cost\nvariable is not instantiated at the end of the search, the search is aborted.\nThis provide some of the functionality of branch-and-bound search in\nlib(branch_and_bound), but is less flexible (no user defined search) but is \nlikely to be faster. Will only return one optimal solution.\n\nrestart(+Cutoff [,+Nogoodslim]) (RBS with DFS)\nRestart search will restart the search when the number of nodes searched\nexceeds the cutoff threshold. The threshold can change with successive\nrestart, and is specified by Cutoff. Nogoodslim is an optional argument, which\nif supplied, nogoods learning will be performed during the search, and\nno-good constraints learned from the old search are posted before restarting\nthe search.\n\nCutoff specifies the cutoff threshold sequence. The following are available:\n\ngeo(+S, +Base) Geometric cutoff with a scale factor S and base Base (both\nnon-negative integers). The cutoff thresholds are defined by S*(Base^N), where\nN is the Nth restart.\n\nluby(+S) the cutoff sequence is based on the Luby sequence, multiplied by \nthe scale factor S (non-negative integer). The Luby sequence is a sequence of \nrestart thresholds suggested by Luby and others in 1993.\n\nrandom(+Min,+Max,+N,+Seed) the cutoff value is chosen randomly between Min and\nMax, with only N+1 values distributed evenly in the range are available for\nselection, to make sure that values chosen are significantly different from \neach other. \n\ncon(+C) the same cutoff value C (positive integer) is used for all \nrestarts.\n\n The cutoff value is increased by S (positive integer) for each\nrestart.\n\nNogoodslim (non-negative integer) specifies the depth limit in the search-tree to which no-goods will be learned. Setting this to 0 (zero) is the same as not\nusing no-goods. \n\nrestart_min(Cost [,+Cutoff [,+Nogoodslim]]) (RBS with BAB)\nBranch-and-bound search as in bb_min, but the search is restarted after finding\na new solution and imposing the new bound. Optionally, if Cutoff is supplied,\nthe search will also restart when the number of nodes searched exceed the given\nCutoff. An additional optional argument NogoodsLim can also be supplied that\nwill use no-good learning.\n\nThe option list is used to pass additional parameters to and from the\nprocedure.  The currently recognized options are:\n\ntiebreak(+Selection)\nSelection is one of the variable selection methods, and is used as a tie-break\nif the primary selection method yields more than one candidate. Obviously not\nall combinations of selection methods makes sense (e.g. it should not be the \nsame as the primary), but no check is done, they are simply passed to gecode.\n stats(+Stats)\nStats is a named gfd_stats structure, defined as:\n\n:- export struct(gfd_stats(prop,fail,node,depth,mem)).\n\nThe fields of the structure should be uninstantiated, and the search predicate\nwill instantiate the fields with statistics obtained from gecode for the search:\nprop for the number of propagations, fail for the number of failed nodes,\nnode for number of nodes expanded, depth for maximum depth of search stack,\nmem for peak memory allocated (in bytes).\ntimeout(+Seconds)\nSpecify the number of seconds that the search will be performed before it is\nterminated. Seconds can be a real or integer number, and 0 means there is\nno timeout. For multi-solution search, the timer is reset each time a\nnew solution is obtained. For optimising search, the best feasible\nsolution found so far, if any, is returned. \n\nlimits(+Stats)\nSpecify limits to stop the search. Stats is the same gfd_stats struct used for\nobtaining statistics. To specify a limit for a particular statistics, the\ncorresponding field should be instantiated to the limit. Only the prop, node, \nfail and mem fields are significant. Entries in the other fields are ignored.\nFor optimising search, the best feasible solution found so far, if any, is \nreturned.\n\ncontrol(+Control)\n Control is a named gfd_control structure, defined as:\n \n :- export struct(gfd_control(commit_distance,adaptive_distance,threads)).\n\nThis is used to pass information to gecode to control the search. The\n corresponding field should be instantiated to the value passed to gecode. \n threads may be of most interest as if threads is set to a value >= 2,\n this will allow parallel search. See the gecode manual for more\n details on the options.\n backtrack(-N)\nProvided for compatibility with generic search/6. Returns the number of fail\n nodes (fail field of statistics. \n\nnodes(++N)\nProvided for compatibility with generic search/6. Equivalent to setting the\nnode field of limits. The node field will be unified with N\n\nldsb_syms(+Syms)\nUse Lightweight Dynamic Symmetry Breaking (LDSB) to reduce the search-space.\nThe symmetries for the problem are specified in Syms, which is a list of\nsymmetry specifications. The syntax for the symmetry specifications are\ncompatible with the ones used in \bip{ldsb_initialise/2} of lib(ldsb),\nthe LDSB library for IC.\n\nSome of the symmetry specifications expect a matrix of NRows rows by NCols \ncolumns. Such an argument should be supplied as a 2-D collection, i.e. \neither as a Matrix M with dimensions dim(M, [NRows,NCols]),\nor a list of NRows lists, where the sub-lists are all the same length of NCols \nitems.\n\nSome of the symmetry specifications can be applied to all the search variables\n(i.e. the first argument (L) of the predicate), or to a subset.\nFor such specifications, if the specification includes a collection of\nvariables, these will be used; otherwise it is applied to all search variables.\nNote that the same form is expected for variables given with the specification\nand those in L, i.e. the variables will be in the same Arg'th position\nof the items in the collection given for L and in any symmetry \nspecifications.\n\nThe following are available:\n\nvalue_interchange(+Vars) specifies that the variables in collection \nVars are interchangeable.\n\nvariable_interchange(++Vals) specifies that the values in collection\nVals are interchangeable. \n\nvariables_interchange specifies that all search variables are \ninterchangeable.\n\nparallel_variable_interchange(+Vars) Vars is a 2-D collection of\nsearch variables. This specifies that the variables\nin the sub-list or sub-vector are interchangeable, e.g. \nparallel_variable_interchange([]([](A,B),[](C,D),[](E,F))) says that the\nsequence A-B can be interchanged with the sequence C-D and E-F.\n \nparallel_value_interchange(++Vals) Vals is a 2-D collection of \nvalues. This specifies that the value sequences in each sub-vector or sub-list \nin Vals are interchangeable. \n \nvalue_reflection(+L,+U) specifies the values L..U can be reflected,\ni.e. vale L+i maps to U-1. \n \nrows_interchange rows_interchange(+MatVars) specifies that \nthe rows of the matrix is interchangeable. The matrix is either given\n in MatVars, or is all the search variables (L), and must be in \nmatrix form.\n \ncolumns_interchange columns_interchange(+MatVars) specifies that\nthe columns of matrix are interchangeable. The matrix is either given in \nMatVars, or is all the search variables L, and must be\nin matrix form.\n \nrow_reflection rows_reflection(+MatVars)  specifies that the rows\nof the matrix can be reflected around their centre. The matrix is either given in  MatVars, or is all the search variables L), and must be\nin matrix form.\n \ncolumn_reflection columns_reflection(+MatVars) specifies that the columns\nof the matrix can be reflected around their centre. The matrix must be\n a square matrix, and can be either given in  MatVars, or is all the search variables (L), and must be\nin matrix form.\n \ndiagonal_reflection diagonal_reflection(+MatVars) specifies that the \nvariables of the matrix can be reflected around the main diagonal of the\nmatrix. The matrix must be a square matrix, and is either given in  MatVars, or is all the search \nvariables (L), and must be in matrix form.\n\n \n \n\nModes and Determinism\n   search(+, ++, ++, +, ++, +) is nondet\n\nFail Conditions\n   Fails if the search engine does not find any solution.\nFor partial search methods, this does not mean that the problem does not \nhave a solution.\n\nResatisfiable\n   yes (non-optimising and non-restart searches)\n\nExamples\n   \ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,complete,[]).\n\ntop:-\n    length(L,8),\n    L::1..8,\n    L = [Cost|L],\n    search(L,0,input_order,indomain_max,bb_min(Cost),[]).\n\n:- local struct(data(var,start)).\ntop(Ds) :-\n\tlength(L, 8),\n\tL :: 1..8,\n\t(foreach(V, L),\n \t count(I, 1, _),\n\t foreach(D, Ds) do\n\t\tD = data{var:V,start:I}\n\t),\n\tsearch(Ds, var of data, input_order, \n\t       from_larger(start of data,Ds), complete, []).\n\nSee Also\n   indomain / 1, gfd_search : indomain / 2, labeling / 1, gfd_search : delete / 5, gfd_search : search / 6"},"gfd:select_var/5":{"prefix":"select_var","body":"select_var(${1:X}, ${2:Vars}, ${3:Handle}, ${4:Arg}, ${5:Select})$6\n$0","description":"select_var(-X, +Vars, +Handle, +Arg, ?Select)\n\n   Pick a domain variable from a collection according to selection criterion.\n\nArguments\n   X    a free variable\n   Vars    a collection of existing domain variables or terms, or a handle \n   Handle    free variable, will be bound to handle for remaining collection\n   Arg    an integer\n   Select    a predefined selection method.\n\nType\n   library(gfd)\n\nDescription\n\nThis predicate picks one domain variable in Vars based on some selection \ncriterion. The selected entry is returned in X. Vars is either a \ncollection of domain variables/terms containing domain variables, or \na handle representing domain variables returned in Handle from a\nprevious call to select_var/5. \n\nThis predicate provides similar functionality as delete/5 of gfd_search,\nand is designed to be used in a similar way -- the selection is done on\nthe variables represented in Vars, while Handle is then passed as the\nnext Vars argument for variable selection in the next call to select_var/5,\nas is done with Rest for delete/5. select_var/5 can thus be used as a \nreplacement for delete/5 in gfd_search:search/6.\n\nThe main difference with delete/5 is that Handle is a low-level\nrepresentation of all the domain variables in Vars, rather than the\nrest of the domain variables with the selected variable removed as in Rest\nfor delete/5. This allows select_var/5 to be used for both the 'indomain'\nstyle labelling (where a selected variable is labelled to different values on \nbacktracking), or the more Gecode-like labelling (where variable\nselection and a binary value choice is performed for each labelling step).\nUnlike delete/5, a domain variable that is instantiated will not be selected,\nand the search is complete when select_var/5 fails because all the \ndomain variables in Vars are instantiated. \n\nWhen select_var/5 is called with Vars being a collection, the domain variables\nin the collection are extracted according to Arg in the same way as\ndelete/5, i.e. the Arg'th argument of each element in the collection is the\ndomain variable for that element. In addition to creating the low-level\n handle representation of the domain variables in Handle, additional\ninitialisation is done for some selection methods that have initialisation\nparameters (i.e. those involving weighted degree or activity). When \nselect_var/5 is called with Vars being a handle created from a previous \ncall to select_var/5, then Args and any initialisation parameters given \nwith Select are ignored. \n\nSelect is one of the following predefined selection methods:\ninput_order, occurrence, anti_occurrence, \nsmallest, largest, smallest_upb, largest_lwb,\nfirst_fail, anti_first_fail, \nmost_constrained,  most_constrained_per_value, least_constrained_per_value, \nmax_regret, max_regret_lwb, min_regret_lwb, max_regret_upb.\nmax_weighted_degree, min_weighted_degree,\nmax_weighted_degree_per_value, min_weighted_degree_per_value,\nmax_activity, min_activity,\nmax_activity_per_value, min_activity_per_value\n\nThese are essentially the same selection methods supported for using\nGecode's search engine (search/6), except for random, which is not\nsupported here. For methods that uses activity or weighted degree,\nSelect can include an optional argument in the form of a list, where each \nlist item is a parameter setting. If a parameter is not specified in the\nlist, the default setting for the parameter will be used.\nThese parameters are:\n\nFor weighted degree:\n\ndecay(Decay) specify the decay factor (number between\n 0 and 1, where 1 is no decay). Default is the existing decay factor \nfor weighted degree (normally 1, unless explicitly changed).\n\ninit(Init) set the start values for activity for the\nsearch variables according to Init. Init can be:\n\n degree(+Factor) set the start value to \nFactor*degree for the variable. Factor is a non-negative number.\n\n vals(Pos,Starts) set the start values to those specified in\nStarts. Starts is a collection of either the start values (Pos=0), or \ncompound terms containing the value, in the Pos'th argument. The number\nof start values is the same as the number of variable, and each value\nis a non-negative number. Starts can be the same collection as Vars,\nwith each item in the collection storing both a variable and its\nactivity start value.\n\n none no initialisation (default)\n\nFor activity:\n\ndecay(Decay) specify the decay factor (number between\n 0 and 1, where 1 is no decay). Default is 1.\n\ninit(Init) set the initial values for activity according\n to Init. Init can be:\n\n degree\n vals(Starts) set the initial values to those specified in\n Starts.Starts is a collection of non-negative numbers, and is the\n same size as Vars, i.e. each item in Starts represents the initial\n activity value of the corresponding search variable in Vars.\n corresponding variable in Vars.\n\n none no initialisation (default)\n\nDue to the way gfd implement activity, there are some limitations to\nthe way activity can be used. Gecode requires activity to be declared\nfor a fixed set of variables -- and activity information for these variables\nwill then be collected subsequently. In gfd this is done during the\n initialisation call to select_var/5. Thus, to use selection methods\n that involve activity, it must be used in the initialisation call. In\naddition, gfd supports only one activity declaration per Gecode solver\n state, so activity can only be used as a selection method for one set\n of variable in each branch of the search.  \n \n\nModes and Determinism\n   select_var(-, +, +, +, ?) is semidet\n\nFail Conditions\n   fails if no variable can be selected\n\nExamples\n   \n% Simple labelling implemented using select_var/5 and indomain/2\nlabelling1(Vars, Select, Choice) :-\n    (select_var(V, Vars, Rest, 0, Select) ->\n    indomain(V, Choice),\n    labelling1(Rest, Select, Choice)\n    ;\n    true\n    ).\n\n% Variant using select_var/5 and try_value/2\nlabelling2(Vars, Select, Choice) :-\n    (select_var(V, Vars, Rest, 0, Select) ->\n    try_value(V, Choice),\n    labelling2(Rest, Select, Choice)\n    ;\n    true\n    ).\n\n    % A call with max_activity with parameters\n    select_var(V, Vars, Rest, 0, \n    max_activity([init(degree),\n    decay(0.9)\n    ])),\n\nSee Also\n   try_value / 2, gfd_search : indomain / 2, search / 6, gfd_search : search / 6"},"gfd:set_weighted_degree_decay/1":{"prefix":"set_weighted_degree_decay","body":"set_weighted_degree_decay(${1:Decay})$2\n$0","description":"set_weighted_degree_decay(+Decay)\n\n   Change the current decay rate for weighted degree to Decay.\n\nArguments\n   Decay    Number between 0 and 1.\n\nType\n   library(gfd)\n\nDescription\n\n   Change the current decay rate for weighted degree to Decay. The decay rate\n   governs how fast the weighted degree decays -- each time a failure\n   occurs during Gecode's constraint propagation, the constraint that\n   failed will have 1 added to its failure count, while all\n   other constraints' failure count is updated by multiplying its\n   old value by the decay rate. The decay rate is a floating point value\n   between 1 (no decay) and 0 (decay to 0 immediately). The weighted\n   degree for a domain variable is the sum of all the failure\n   counts of the constraints that the variable occurs in."},"gfd:solver_constraints_number/1":{"prefix":"solver_constraints_number","body":"solver_constraints_number(${1:NumberOfConstraints})$2\n$0","description":"solver_constraints_number(-NumberOfConstraints)\n\n   Returns the number of constraints in the gecode solver state\n\nArguments\n   NumberOfConstraints Free variable\n\nType\n   library(gfd)\n\nDescription\n  Returns the current total number of active constraints (propagators)\n  in the gecode solver state.\n\nSee Also\n   solver_vars_number / 1"},"gfd:solver_vars_number/1":{"prefix":"solver_vars_number","body":"solver_vars_number(${1:NumberOfVariables})$2\n$0","description":"solver_vars_number(-NumberOfVariables)\n\n   Returns the number of domain variables in the gecode solver state\n\nArguments\n   NumberOfVariables   Free variable\n\nType\n   library(gfd)\n\nDescription\n  Returns the current total number of domain variables in the gecode solver\n  state. This is for the variables that are created at the ECLiPSe\n  level by the program or by GFD.\n\nSee Also\n   solver_constraints_number / 1"},"gfd:trans/s":{"prefix":"struct","body":"struct","description":"struct trans(f, t, l)\n\n   Specification of s transition in the DFA for extensional/4.\n\nFields\n   f    From state\n   t    To state\n   l    label\n\nType\n   library(gfd)\n\nDescription\n\nThis is used to specify a transition in the DFA for the extensional constraint\nextensional/4. The transition trans{f:F,t:T,l:L} is a transition from state\nF to state T, and labelling the variable with the value L."},"gfd:try_value/2":{"prefix":"try_value","body":"try_value(${1:Var}, ${2:Method})$3\n$0","description":"try_value(?Var, ++Method)\n\n   Two-way and multi-way choice predicate\n\nArguments\n   Var    a domain variable or an integer\n   Method    an atom denoting the value choice method\n\nType\n   library(gfd)\n\nDescription\n\n    This search predicate makes a choice on the domain of the variable.\n    This choice can be a binary choice, or an indomain style multi-way\n    choice which branches on different values in the domain of the variable.\n\n    The binary choice methods create two search alternatives, which \n    reduce the variable domain  in complementary ways.  The details\n    are determined by the Method.\n\n    The first group of binary methods tries to set the variable to a \n    particular value, and in the alternative excludes this value from \n    the domain, logically:\n\n\t( Var = Value ; Var #\\= Value )\n\n    min\n\ttry the minimum value in the domain\n    max\n\ttry the maximum value in the domain\n    median\n\ttry the median value in the domain\n\n    The next binary group only halves the domain in each alternative (where\n    the split value is the arithmetic mean of the lower and upper domain\n    bound, rounded down):\n\n\t( Var #=< Split ; Var #> Split )\n\n    split\n\ttry first the lower domain half, then the upper\n    reverse_split\n\ttry first the upper domain half, then the lower\n\n    The indomain style group chooses an initial value from the variable's\n    domain of according to the given method, and on backtracking \n    select other values in the domain. \n\n    indomain_min\n\tValues are tried in increasing order.\n    indomain_max\n\tValues are tried in decreasing order.\n    indomain_median\n\tValues are tried starting from the median value of the \n    domain, then alternately the next larger and smaller values \n    in the domain.\n    indomain_middle\n\tValues are tried starting from  the middle of the range\n    (which does not need to be in domain), then alternately the\n    next larger and smaller values in the domain.\n    indomain_from(+Val)\n\tValues are tried starting from  Val (which does not need\n    to be in domain), then alternately the next larger and smaller \n    values in the domain.\n \n\n    As opposed to the value choice predicates indomain/1 and indomain/2,\n    the binary choice methods of try_value/2 does not necessarily \n    instantiate the variable.  If used in a tree search, this means\n    that the variable must remain available to the variable selection,\n    as it may be selected repeatedly at different depth of the search\n    tree.\n\n    The indomain style methods do instantiate the variable. If used in\n    a tree search, try_value represents a n-ary choice for all the\n    values of a variable. In this case, the maximum depth of the\n    search-tree is the number of problem variables. \n\n    This predicate should be more efficient than using generic value\n    choice predicates or explicitly writing code to do the choice. The\n    exclusion of values before a new choice is done by specialised\n    low-level primitives that are more efficient than user-level\n    constraints. This efficiency is particularly important because\n    they make recomputation more efficient. For the binary choice\n    methods, the exclusion of values are performed in every\n    recomputation of the choice; and for the indomain style methods,\n    the old values are excluded from the variable's domain to allow\n    the next value to be chosen. On recomputation, the variable is\n    directly set to the chosen value.  This reduces the amount of\n    recomputation, but any reduction in the search space resulting\n    from propagating the exclusion of old values may also be lost.\n\n    try_value/2 is best used in combination with select_var/5. Both can\n    be used to parameterise the generic gfd_search:search/6 procedure.\n\nModes and Determinism\n   try_value(?, ++) is nondet\n   try_value(+, ++) is det\n\nExamples\n   \n    % Used with generic search/6\n    gfd_search:search(Xs,0,select_var(first_fail),try_value(min),complete,[]).\n\n    % Simple labelling implemented using select_var/5 and try_value/2\n    labelling(Vars, Select, Choice) :-\n    (select_var(V, Vars, Rest, 0, Select) ->\n    try_value(V, Choice),\n    labelling(Rest, Select, Choice)\n    ;\n    true\n    )."},"graphviz:graphviz_desc":{"prefix":"lib","body":"lib(${1:graphviz})$2\n$0","description":"lib(graphviz)\n\n    This library provides an interface to the Graphviz Graph Drawing Programs\n    from AT&T (www.graphviz.org).\n\n    Graphviz itself must be downloaded and installed separately.  It is\n    readily available for most operating systems, and subject to the\n    open-source Eclipse Public Licence.\n\n    The predicates in this library take graph data structures as defined by\n    library(graph_algorithms), invoke graphviz's layout tools, and output\n    the generated drawing in various file formats (which can then be viewed\n    in a browser of dedicated viewer), or invoke a simple viewer directly."},"graphviz:view_graph/1":{"prefix":"view_graph","body":"view_graph(${1:Graph})$2\n$0","description":"view_graph(+Graph)\n\n   Display a given graph in a window (using default options)\n\nArguments\n   Graph    A graph structure\n\nType\n   library(graphviz)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- lib(graph_algorithms), lib(graphviz).\n    Yes (1.17s cpu)\n\n    ?- make_random_graph(10,30,true,true,true,G), view_graph(G).\n    G = graph(...)\n    Yes (0.03s cpu)\n    \n\nSee Also\n   view_graph / 2, library(graph_algorithms)"},"graphviz:view_graph/2":{"prefix":"view_graph","body":"view_graph(${1:Graph}, ${2:Options})$3\n$0","description":"view_graph(+Graph, +Options)\n\n   Display a given graph in a window\n\nArguments\n   Graph    A graph structure\n   Options    A list of Option:Value pairs\n\nType\n   library(graphviz)\n\nDescription\n\n    This predicate takes a graph, applies one of the graphviz layout routines\n    to it, and displays the result in a viewer window.\n    \n    The viewer is an application called grappa, which requires Java.\n    \n    Possible options are:\n    \n    graph_attrs\n\ta list of Name=Value pairs which specify the graph attributes\n    default_edge_attrs\n\ta list of Name=Value pairs which specify the default edge attributes\n    default_node_attrs\n\ta list of Name=Value pairs which specify the default node attributes\n    node_attrs_generator\n\ta partialpredicate specification pred(ExtraArgs,...) that\n\twill generate node attributes for specific nodes. This\n\tpredicate will be invoked for every node in the graph with the\n\targuments pred(ExtraArgs,...,+Graph, +Node, -AttrList). It is\n\texpected to compute an attribute list for a particular\n\tnode. If it fails, the node will be displayed using the\n\tdefault node attributes.\n\n    edge_attrs_generator\n\ta partialpredicate specification pred(ExtraArgs,...) that\n\twill generate edge attributes for specific edges. This\n\tpredicate will be invoked for every edge in the graph with the\n\targuments pred(ExtraArgs,...,+Graph, +Edge, -AttrList). It is\n\texpected to compute an attribute list for a particular\n\tedge. If it fails, the edge will be displayed using the\n\tdefault edge attributes.\n    layout\n\tOne of the atoms: none, dot, neato, twopi, force_directed, radial,\n\ttree, top_to_bottom, left_to_right.\n\tAlternatively, a list specifying a layout command (see exec/3).\n    \n    For the exact definition of graph, node and edge attributes, see the\n    specification of the DOT language in the graphviz documentation.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- lib(graph_algorithms), lib(graphviz).\n    Yes (1.17s cpu)\n\n    ?- make_random_graph(10, 30, true, true, true, G),\n       view_graph(G, [layout:left_to_right]).\n    G = graph(...)\n    Yes (0.03s cpu)\n\n    ?- make_random_graph(10, 30, true, true, true, G),\n       view_graph(G, [layout:left_to_right]).\n    G = graph(...)\n    Yes (0.03s cpu)\n\n% Sample node attribute generator\n\nnode_colour(Graph, Node, Attrs) :-\n\t( Node mod 2 =:= 0 -> Attrs = [color=red] ; Attrs = [color=green] ).\n\n% Sample run\n\n    ?- make_random_graph(10, 30, true, true, true, G),\n       view_graph(G, [node_attrs_generator:node_colour]).\n    G = graph(...)\n    Yes (0.03s cpu)\n    \n\nSee Also\n   view_graph / 1, library(graph_algorithms)"},"graphviz:view_graph/3":{"prefix":"view_graph","body":"view_graph(${1:Graph}, ${2:Options}, ${3:HandleFile})$4\n$0","description":"view_graph(+Graph, +Options, ?HandleFile)\n\n   Display a given graph in an existing window\n\nArguments\n   Graph    A graph structure\n   Options    A list of Option:Value pairs\n   HandleFile    String or variable\n\nType\n   library(graphviz)\n\nDescription\n\n    This predicate takes a graph, applies one of the graphviz layout\n    routines to it, and displays the result in a viewer window.  If\n    the HandleFile option is a variable it will be bound the name of\n    the file which the viewer is rendering.  By calling this predicate\n    again with the same file name, the viewer will re-load the file\n    WITHOUT creating a new window.\n\n    This predicate can be very useful for displaying graph structures\n    which change over time.\n\n    NOTE: This predicate will sleep for one second to give the viewer\n    a chance to notice that the file has changed and to re-read it.\n\n    \n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   view_graph / 1, view_graph / 2, library(graph_algorithms)"},"graphviz:write_graph/2":{"prefix":"write_graph","body":"write_graph(${1:Graph}, ${2:File})$3\n$0","description":"write_graph(+Graph, +File)\n\n   Write a picture of a graph as a postscript file\n\nArguments\n   Graph    A graph structure\n   File    A file name\n\nType\n   library(graphviz)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- lib(graph_algorithms), lib(graphviz).\n    Yes (1.17s cpu)\n\n    % will create a file mygraph.ps\n    ?- make_random_graph(10,30,true,true,true,G),\n       write_graph(G, \"mygraph\").\n    G = graph(...)\n    Yes (0.03s cpu)\n    \n\nSee Also\n   write_graph / 3, write_graph / 4, view_graph / 2, library(graph_algorithms)"},"graphviz:write_graph/3":{"prefix":"write_graph","body":"write_graph(${1:Graph}, ${2:File}, ${3:Format})$4\n$0","description":"write_graph(+Graph, +File, +Format)\n\n   Write a picture of a graph as a file of a given format\n\nArguments\n   Graph    A graph structure\n   File    A file name\n   Format    An atom (dot,gv,eps,gif,jpg,pdf,png,svg,...)\n\nType\n   library(graphviz)\n\nDescription\n\n    This predicate takes a graph, applies one of the graphviz layout routines\n    to it, and writes the result to a file is a given format.\n    \n    Some possible formats are:\n    \n    dot,gv,xdot\n    Graphviz own formats\n    eps\n    Encapsulated Postscript\n    gif\n    GIF bitmaps\n    jpg\n    JPEG compressed images\n    pdf\n    PDF Portable Document Format\n    plain\n    A human-readable representation\n    png\n\tPNG (Portable Network Graphics)\n    svg\n\tSVG Scalable Vector Graphics\n    \n    Many of these formats can be displayed by web browsers or by dedicated\n    viewers.  See the graphviz documentation for details and additional formats.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- lib(graph_algorithms), lib(graphviz).\n    Yes (1.17s cpu)\n\n    ?- make_random_graph(10,30,true,true,true,G),\n       write_graph(G, \"mygraph\", png).\n    G = graph(...)\n    Yes (0.03s cpu)\n\n    ?- make_random_graph(10,30,true,true,true,G),\n       write_graph(G, \"mygraph\", dot).\n    G = graph(...)\n    Yes (0.03s cpu)\n    \n\nSee Also\n   write_graph / 2, write_graph / 4, view_graph / 2, library(graph_algorithms)"},"graphviz:write_graph/4":{"prefix":"write_graph","body":"write_graph(${1:Graph}, ${2:File}, ${3:Format}, ${4:Options})$5\n$0","description":"write_graph(+Graph, +File, +Format, +Options)\n\n   Write a picture of a graph as a file of a given format\n\nArguments\n   Graph    A graph structure\n   File    A file name\n   Format    An atom (dot,gv,eps,gif,jpg,pdf,png,svg,...)\n   Options    A list of Option:Value pairs\n\nType\n   library(graphviz)\n\nDescription\n\n    This predicate takes a graph, applies one of the graphviz layout routines\n    to it, and writes the result to a file is a given format.\n    \n    Possible options are as specified in view_graph/2.\n    \n    Some possible formats are:\n    \n    dot,gv,xdot\n    Graphviz own formats\n    eps\n    Encapsulated Postscript\n    gif\n    GIF bitmaps\n    jpg\n    JPEG compressed images\n    pdf\n    PDF Portable Document Format\n    plain\n    A human-readable representation\n    png\n\tPNG (Portable Network Graphics)\n    svg\n\tSVG Scalable Vector Graphics\n    \n    Many of these formats can be displayed by web browsers or by dedicated\n    viewers.  See the graphviz documentation for details and additional formats.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- lib(graph_algorithms), lib(graphviz).\n    Yes (1.17s cpu)\n\n    ?- make_random_graph(10,30,true,true,true,G),\n       write_graph(G, \"mygraph\", png).\n    G = graph(...)\n    Yes (0.03s cpu)\n\n    ?- make_random_graph(10,30,true,true,true,G),\n       write_graph(G, \"mygraph\", dot).\n    G = graph(...)\n    Yes (0.03s cpu)\n    \n\nSee Also\n   write_graph / 2, write_graph / 3, view_graph / 2, library(graph_algorithms)"},"graph_algorithms:all_short_paths_as_edges/6":{"prefix":"all_short_paths_as_edges","body":"all_short_paths_as_edges(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Tolerance}, ${5:Lengths}, ${6:Predecessors})$7\n$0","description":"all_short_paths_as_edges(+Graph, +DistanceArg, +SourceNode, +Tolerance, -Lengths, -Predecessors)\n\n   Computes all shortest paths from a single source to every reachable node\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Lengths    array of numbers (minimum path lengths)\n   Predecessors    array of lists of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes all shortest paths from the single source node SourceNode\n    to every sink node which is reachable from it. The result is returned\n    in the form of the Predecessors array which contains all relevant edges.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    Tolerance should be zero in order to find only the shortest paths. \n    If Tolerance is greater than zero, then all paths that are within\n    this tolerance of the shortest path length will be found.\n\n    The result is returned in the form of two arrays, whose indices range\n    over the possible sink nodes.  The Lengths array indicates the length\n    of a shortest path from SourceNode to the corresponding sink node.\n    The Predecessors array is an array of edge lists, each list containing\n    the alternative edges that are part of a shortest path from SourceNode\n    to the corresponding sink node.\n\n    If there is no path from SourceNode to a sink node J, then both\n    Lengths[J] and Predecessors[J] are uninstantiated. Otherwise,\n    Lengths[J] contains the length of a shortest path from SourceNode to J.\n    Predecessors[J] is contains a list of alternative edges that lead from\n    some predecessor node to J in a shortest path from SourceNode to J.\n    Predecessors[SourceNode] is always the empty list [].\n\nAssembling Actual Paths\n\n    To generate an actual path from the Predecessors array, start from the\n    sink node J, select one of the alternative edges in Predecessors[J]\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the parameters, the following 3 cases can occur:\n    \n    Tolerance is zero, and Graph did not contain zero-length edges: in this\n    case, SubGraph is cycle-free and shortest paths can be found by simply\n    selecting arbitrary incoming edges until SourceNode is reached.\n    Tolerance is zero, and Graph did contain zero-length edges: in this case,\n    SubGraph may contain (zero-length) cycles which one may want to exclude\n    when constructing paths.\n    Tolerance is nonzero:  in this case, SubGraph may contain\n    cycles (of maximum length Tolerance).  Moreover, it may be\n    possible to use the edges in SubGraph to construct cycle-free paths\n    whose total length is greater than the shortest path length plus\n    the tolerance.  These may need to be excluded explicitly.\n    \n    The possible_path/7 predicate implements this path construction and\n    does the necesssary checks to exclude cycles and overly long paths.\n    \n\nModes and Determinism\n   all_short_paths_as_edges(+, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G), all_short_paths_as_edges(G, 0, 1, 0, L, E).\n    L = [](0, 1, 2, 3, 2, 1, 1, _326, _327, 2, 3, 3, 3)\n    E = []([], [e(1, 2, 1)], [e(7, 3, 1)], [e(5, 4, 1)],\n\t   [e(7, 5, 1), e(6, 5, 1)], [e(1, 6, 1)], [e(1, 7, 1)],\n\t   _342, _343, [e(7, 10, 1)], [e(10, 11, 1)], [e(10, 12, 1)],\n\t   [e(10, 13, 1)])\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_graph / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7"},"graph_algorithms:all_short_paths_as_graph/6":{"prefix":"all_short_paths_as_graph","body":"all_short_paths_as_graph(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Tolerance}, ${5:Lengths}, ${6:SubGraph})$7\n$0","description":"all_short_paths_as_graph(+Graph, +DistanceArg, +SourceNode, +Tolerance, -Lengths, -SubGraph)\n\n   Computes all shortest paths from a single source in form of a subgraph\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Lengths    array of numbers (minimum path lengths)\n   SubGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes all shortest paths from the single source node SourceNode\n    to every sink node which is reachable from it. The result is returned\n    in the form of a sub-graph of the input graph, which contains all\n    relevant edges.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    Tolerance should be zero in order to find only the shortest paths. \n    If Tolerance is greater than zero, then all paths that are within\n    this tolerance of the shortest path length will be found.\n\n    The result is returned in the form of SubGraph, which is a\n    sub-graph of the input Graph, containing the same nodes, but only\n    those edges that are needed to construct the shortest paths for\n    the given parameters.  SubGraph does not inherit the nodename\n    information from Graph, this can be set explicitly if required.\n\n    In addition, a Lengths array is returned, whose entries indicate\n    the length of a shortest path from SourceNode to the corresponding\n    sink node.  If there is no path from SourceNode to a sink node J,\n    then Lengths[J] is uninstantiated.\n\nProperties of the resulting SubGraph\n\n    To generate an actual path from the resulting SubGraph, start from the\n    sink node J, select one of its incoming edges (graph_get_incoming_edges/3)\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the parameters, the following 3 cases can occur:\n    \n    Tolerance is zero, and Graph did not contain zero-length edges: in this\n    case, SubGraph is cycle-free and shortest paths can be found by simply\n    selecting arbitrary incoming edges until SourceNode is reached.\n    Tolerance is zero, and Graph did contain zero-length edges: in this case,\n    SubGraph may contain (zero-length) cycles which one may want to exclude\n    when constructing paths.\n    Tolerance is nonzero:  in this case, SubGraph may contain\n    cycles (of maximum length Tolerance).  Moreover, it may be\n    possible to use the edges in SubGraph to construct cycle-free paths\n    whose total length is greater than the shortest path length plus\n    the tolerance.  These may need to be excluded explicitly.\n    \n    \n\nModes and Determinism\n   all_short_paths_as_graph(+, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G), all_short_paths_as_graph(G, 0, 1, 0, L, E).\n    G = graph(13, []([e(1, 6, 1), e(1, 2, 1), e(1, 7, 1)], [], ...)\n    L = [](0, 1, 2, 3, 2, 1, 1, _326, _327, 2, 3, 3, 3)\n    SG = graph(13, []([e(1, 7, 1), e(1, 6, 1), e(1, 2, 1)], [], ...)\n    Yes (0.00s cpu)\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7, graph_get_incoming_edges / 3, graph_set_nodenames / 2"},"graph_algorithms:articulation_points/2":{"prefix":"articulation_points","body":"articulation_points(${1:Graph}, ${2:Articulations})$3\n$0","description":"articulation_points(+Graph, -Articulations)\n\n   Finds the articulation points of the graph\n\nArguments\n   Graph    a graph structure\n   Articulations       a list of integer node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Finds the articulation points of a graph, i.e. those nodes that,\n    when deleted, would break the graph into two or more disconnected\n    components. If there are no articulation points, the graph is\n    called biconnected.\n\n    This operation is only defined for bidirected graphs.\n    \n\nModes and Determinism\n   articulation_points(+, -) is det\n\nSee Also\n   graph_is_bidirected / 1, critical_links / 2, biconnected_components / 3"},"graph_algorithms:biconnected_components/3":{"prefix":"biconnected_components","body":"biconnected_components(${1:Graph}, ${2:Articulations}, ${3:BCC})$4\n$0","description":"biconnected_components(+Graph, -Articulations, -BCC)\n\n   Finds the biconnected components of the graph\n\nArguments\n   Graph    a graph structure\n   Articulations       a list of integer node numbers\n   BCC    list of lists of integer node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes the biconnected components of a graph, i.e. maximal subsets of\n    the graph's nodes whose nodes are mutually accessible via at least two\n    distinct paths (in other words, subgraphs which have no articulation\n    points).\n\n    Also compute a list of articulation points, i.e. those nodes that\n    connect the biconnected components to each other.\n\n    This operation is only defined for bidirected graphs.\n\n    Note that by convention, isolated nodes and pairs of nodes connected\n    by a single (bidirected) edge also form biconnected components.\n    \n\nModes and Determinism\n   biconnected_components(+, -, -) is det\n\nSee Also\n   graph_is_bidirected / 1, articulation_points / 2, strong_components / 2"},"graph_algorithms:connected_components/2":{"prefix":"connected_components","body":"connected_components(${1:Graph}, ${2:ConnectedComponents})$3\n$0","description":"connected_components(+Graph, -ConnectedComponents)\n\n   Computes the connected components of graph\n\nArguments\n   Graph    a graph structure\n   ConnectedComponents a list of lists of node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes the connected components of a (bidirected) graph. Each resulting\n    connected component is represented as an (unsorted) list of nodes.\n\n    This operation is only defined on bidirected graphs.\n    The runtime complexity is O(Nnodes + Nedges).\n    \n\nModes and Determinism\n   connected_components(+, -) is det\n\nSee Also\n   graph_is_bidirected / 1, articulation_points / 2"},"graph_algorithms:critical_links/2":{"prefix":"critical_links","body":"critical_links(${1:Graph}, ${2:Links})$3\n$0","description":"critical_links(+Graph, -Links)\n\n   Finds critical links in a bidirected graph\n\nArguments\n   Graph    a graph structure\n   Links    a list of edge pairs (output)\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Finds all the critical links of a bidirected graph. We define an\n    (bidirected) link as a pair of (oppositely directed) edges between\n    two nodes. A critical link is one that, when removed, would make the\n    graph more disconnected.\n    \n    The result is returned as a list of links, where each link is a\n    hyphenated pair of e/3 edge structures like e(I,J,Dij) - e(J,I,Dji).\n    \n\nModes and Determinism\n   critical_links(+, -) is semidet\n\nFail Conditions\n   Fails if the graph is not bidirected\n\nSee Also\n   graph_is_bidirected / 1, articulation_points / 2"},"graph_algorithms:graph_adjacent_edge/3":{"prefix":"graph_adjacent_edge","body":"graph_adjacent_edge(${1:Graph}, ${2:Node}, ${3:Edge})$4\n$0","description":"graph_adjacent_edge(+Graph, +Node, ?Edge)\n\n   Succeeds if Edge is an edge adjacent to Node in Graph\n\nArguments\n   Graph    a graph structure\n   Node    an integer node number\n   Edge    an e/3 edge structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_adjacent_edge(+, +, ?) is nondet\n\nSee Also\n   graph_edge / 2, graph_get_adjacent_edges / 3"},"graph_algorithms:graph_algorithms_desc":{"prefix":"lib","body":"lib(${1:graph_algorithms})$2\n$0","description":"lib(graph_algorithms)\n\n    This library is a collection of graph algorithms.\n\n    In its simplest form, a graph consists of a (possibly empty) set of\n    nodes (numbered from 1 to NNodes), and zero or more directed edges\n    between these nodes. An edge is represented by the data structure\n\n\te(Source, Target, EdgeData)\n\n    where Source and Target are integers indicating the start and end\n    point of the edge, and EdgeData is an arbitrary data structure\n    holding additional information about the edge, e.g. capacity,\n    distance, weight, name etc.  The EdgeData field should have the\n    same structure for all edges in a graph.  If there is no\n    information attached to edges, the field should be set to 1\n    for edges between different nodes and to 0 otherwise.\n    Several library predicates inspect the EdgeData field or an argument\n    of the EdgeData field, e.g. the shortest path predicate can\n    use any numeric component of EdgeData as the distance criterion.\n\n    The most efficient way to create a graph is to use make_graph/3\n    which takes the number of nodes and a list of edges and constructs\n    the graph data structure.  For example, the 13-node graph from\n    Sedgewick, figure 32.1 can be created as follows:\n\n    make_graph( 13,\n\t[ e(1,6,1),e(1,2,1),e(1,7,1),e(3,1,1),e(4,6,1),e(5,4,1),\n\t  e(6,5,1),e(7,5,1),e(7,10,1),e(7,3,1),e(8,7,1),e(8,9,1),e(9,8,1),\n\t  e(10,11,1),e(10,12,1),e(10,13,1),e(12,7,1),e(12,13,1),e(13,12,1) ],\n    Graph).\n\n    Often, the nodes have names or other information attached.\n    This can be added to the Graph using graph_set_nodenames/2 which\n    takes an existing graph and adds an array of node information\n    (usually the node names, but any ground term can be used).\n    For the Sedgewick-graph above, we could invoke\n\n    graph_set_nodenames(Graph, [](a,b,c,d,e,f,g,h,i,j,k,l,m))\n\n    If nodes have names anyway, it can be more convenient to specify\n    the edges in terms of these node names rather than node numbers.\n    Such symbolic edges are written in the form\n\n\tedge(SourceName, TargetName, EdgeData)\n\n    where SourceName and TargetName should match an entry (usually the\n    node name) in the graph's nodename-array.  A graph can now be\n    constructed by giving a nodename-array and a list of symbolic edges\n    to make_graph_symbolic/3, e.g. to build the same graph as above, use\n\n    make_graph_symbolic(\n\t[](a,b,c,d,e,f,g,h,i,j,k,l,m),\n\t[ edge(a,f,1),edge(a,b,1),edge(a,g,1),edge(c,a,1),edge(d,f,1),edge(e,d,1),\n\t  edge(f,e,1),edge(g,e,1),edge(g,j,1),edge(g,c,1),edge(h,g,1),edge(h,i,1),edge(i,h,1),\n\t  edge(j,k,1),edge(j,l,1),edge(j,m,1),edge(l,g,1),edge(l,m,1),edge(m,l,1) ],\n\tGraph).\n\n    Note the use of the functor e/3 for the internal edge representation\n    and edge/3 for the symbolic edge representation.\n\n    There is no special data structure for undirected graphs - they can\n    be represented by having reverse edges corresponding to every edge.\n    It is allowed to have parallel edges (more than one edge from S to T)\n    as long as their EdgeData fields differ.\nVisualization\n    You can use library(graphviz) or lib(viewable) to draw these graphs.\nOverview of Shortest-Path Functionality\n    This library provides a number of different variants of shortest path\n    algorithms, of which the following table gives an overview:\n\nPredicate\n    Sinks\n    Paths\n    Determinism\n    Edge Weights\n    Tolerance\n\nshortest_paths/4\n    all\n    one\n    det\n    non-negative\n    no\n\nshortest_paths_bellman_ford/4\n    all\n    one\n    det\n    arbitrary\n    no\n\nall_short_paths_as_graph/6\n    all\n    all\n    det\n    non-negative\n    yes\n\nall_short_paths_as_edges/6 + possible_path/7\n    all\n    all\n    nondet\n    non-negative\n    yes\n\nincremental_all_shortest_paths_as_graph/6\n    all\n    all\n    det\n    positive\n    no\n\nincremental_all_shortest_paths_as_edges/6 + possible_path/7\n    all\n    all\n    nondet\n    positive\n    no\n\nsingle_pair_shortest_path/5\n    single\n    one\n    semidet\n    non-negative\n    no\n\nsingle_pair_shortest_path_bellman_ford/5\n    single\n    one\n    semidet\n    arbitrary\n    no\n\nsingle_pair_all_short_paths_as_graph/7\n    single\n    all\n    det\n    non-negative\n    yes\n\nsingle_pair_short_path/6\n    single\n    all\n    nondet\n    non-negative\n    yes\n\nincremental_single_pair_all_shortest_paths_as_graph/7\n    single\n    all\n    det\n    positive\n    no\n\nincremental_single_pair_shortest_path/6\n    single\n    all\n    nondet\n    positive\n    no\n\nTo-do list\n    The following operations should be added:\n\n    Graph modification: adding, removing, projecting\n    Matching\n    Flow\n    ..."},"graph_algorithms:graph_cycles/2":{"prefix":"graph_cycles","body":"graph_cycles(${1:Graph}, ${2:BreakingEdges})$3\n$0","description":"graph_cycles(+Graph, -BreakingEdges)\n\n   Computes a list of edges whose removal would make the graph acyclic\n\nArguments\n   Graph    a graph structure\n   BreakingEdges       a list of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes a set of edges whose removal would make the graph acyclic.\n    This set is not necessarily minimal, and it contains an arbitrary\n    edge from every cycle in the graph.\n\n    If the list is empty, the graph is already acyclic.\n    \n\nModes and Determinism\n   graph_cycles(+, -) is det\n\nSee Also\n   graph_is_acyclic / 1, top_sort / 2"},"graph_algorithms:graph_edge/2":{"prefix":"graph_edge","body":"graph_edge(${1:Graph}, ${2:Edge})$3\n$0","description":"graph_edge(+Graph, ?Edge)\n\n   Succeeds if Edge is an edge in graph\n\nArguments\n   Graph    a graph structure\n   Edge    an e/3 edge structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_edge(+, ?) is nondet\n\nSee Also\n   graph_adjacent_edge / 3, graph_get_all_edges / 2"},"graph_algorithms:graph_get_adjacent_edges/3":{"prefix":"graph_get_adjacent_edges","body":"graph_get_adjacent_edges(${1:Graph}, ${2:SourceNode}, ${3:EdgeList})$4\n$0","description":"graph_get_adjacent_edges(+Graph, +SourceNode, -EdgeList)\n\n   Returns a sorted list of all edges starting from SourceNode\n\nArguments\n   Graph    a graph structure\n   SourceNode    an integer node number\n   EdgeList    a list of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_get_adjacent_edges(+, +, -) is det\n\nSee Also\n   graph_get_all_edges / 2, graph_get_incoming_edges / 3, graph_get_maxnode / 2"},"graph_algorithms:graph_get_all_edges/2":{"prefix":"graph_get_all_edges","body":"graph_get_all_edges(${1:Graph}, ${2:EdgeList})$3\n$0","description":"graph_get_all_edges(+Graph, -EdgeList)\n\n   Returns a sorted list of all edges in the graph\n\nArguments\n   Graph    a graph structure\n   EdgeList    a list of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_get_all_edges(+, -) is det\n\nSee Also\n   graph_get_adjacent_edges / 3, graph_get_incoming_edges / 3, graph_get_maxnode / 2"},"graph_algorithms:graph_get_edge/4":{"prefix":"graph_get_edge","body":"graph_get_edge(${1:Graph}, ${2:Source}, ${3:Target}, ${4:Edge})$5\n$0","description":"graph_get_edge(+Graph, +Source, +Target, -Edge)\n\n   Finds a graph edge given source and target node\n\nArguments\n   Graph    a graph structure\n   Source    an integer node number\n   Target    an integer node number\n   Edge    an e/3 edge structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This operation is linear in the number of edges adjacent to Source.\n    \n\nModes and Determinism\n   graph_get_edge(+, +, +, -) is semidet\n\nFail Conditions\n   Fails if no matching edge exists\n\nSee Also\n   graph_get_all_edges / 2, graph_get_adjacent_edges / 3, graph_edge / 2, graph_adjacent_edge / 3, graph_get_edges / 4"},"graph_algorithms:graph_get_edges/4":{"prefix":"graph_get_edges","body":"graph_get_edges(${1:Graph}, ${2:Source}, ${3:Target}, ${4:Edges})$5\n$0","description":"graph_get_edges(+Graph, +Source, +Target, -Edges)\n\n   Finds all edges between source node and target node\n\nArguments\n   Graph    a graph structure\n   Source    an integer node number\n   Target    an integer node number\n   Edges    a list of  e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This operation is linear in the number of edges adjacent to Source.\n    \n\nModes and Determinism\n   graph_get_edges(+, +, +, -) is det\n\nSee Also\n   graph_get_all_edges / 2, graph_get_adjacent_edges / 3, graph_edge / 2, graph_adjacent_edge / 3, graph_get_edge / 4"},"graph_algorithms:graph_get_incoming_edges/3":{"prefix":"graph_get_incoming_edges","body":"graph_get_incoming_edges(${1:Graph}, ${2:TargetNode}, ${3:EdgeList})$4\n$0","description":"graph_get_incoming_edges(+Graph, +TargetNode, -EdgeList)\n\n   Returns a sorted list of all edges ending in TargetNode\n\nArguments\n   Graph    a graph structure\n   TargetNode    an integer node number\n   EdgeList    a list of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Note on performance: By default, the graph structure only stores the\n    outgoing (adjacent) edges of every node.  The incoming edge lists are\n    computed lazily when graph_get_incoming_edges/3 is called for the first\n    time (but then they are built for all nodes at once).  Therefore the\n    first call to this predicate has O(NlogN) complexity, subsequent calls\n    are only O(1). It may therefore make sense to do a dummy call to this\n    predicate before starting time critical or nondeterministic computation.\n    \n\nModes and Determinism\n   graph_get_incoming_edges(+, +, -) is det\n\nSee Also\n   graph_get_all_edges / 2, graph_get_adjacent_edges / 3"},"graph_algorithms:graph_get_maxnode/2":{"prefix":"graph_get_maxnode","body":"graph_get_maxnode(${1:Graph}, ${2:MaxNode})$3\n$0","description":"graph_get_maxnode(+Graph, -MaxNode)\n\n   Returns the highest node number in Graph\n\nArguments\n   Graph    a graph structure\n   MaxNode    an integer node number\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Note that the smallest node number in a graph is always 1.\n    \n\nModes and Determinism\n   graph_get_maxnode(+, -) is det\n\nSee Also\n   graph_get_all_edges / 2, graph_get_adjacent_edges / 3"},"graph_algorithms:graph_get_nodenames/2":{"prefix":"graph_get_nodenames","body":"graph_get_nodenames(${1:Graph}, ${2:NodeNameArray})$3\n$0","description":"graph_get_nodenames(+Graph, -NodeNameArray)\n\n   Returns the array of node names\n\nArguments\n   Graph    a graph structure\n   NodeNameArray       array of ground data, usually node names\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_get_nodenames(+, -) is semidet\n\nFail Conditions\n   Fails if no node name information is available\n\nSee Also\n   graph_set_nodenames / 2"},"graph_algorithms:graph_is_acyclic/1":{"prefix":"graph_is_acyclic","body":"graph_is_acyclic(${1:Graph})$2\n$0","description":"graph_is_acyclic(+Graph)\n\n   Succeeds iff the given graph has no cycles\n\nArguments\n   Graph    a graph structure\n\nType\n   library(graph_algorithms)\n\nModes and Determinism\n   graph_is_acyclic(+) is semidet\n\nFail Conditions\n   No topological ordering exists, i.e. the graph is cyclic\n\nSee Also\n   top_sort / 2, graph_cycles / 2"},"graph_algorithms:graph_is_bidirected/1":{"prefix":"graph_is_bidirected","body":"graph_is_bidirected(${1:Graph})$2\n$0","description":"graph_is_bidirected(+Graph)\n\n   Tests whether a graph is bidirected\n\nArguments\n   Graph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    A graph is bidirected if for every edge from S to T there is a\n    corresponding edge from T to S. In case of loops (i.e. an edge\n    from S to S) a second, different edge from S to S is required\n    to satisfy the bidirectedness condition.\n    \n\nModes and Determinism\n   graph_is_bidirected(+) is semidet\n\nSee Also\n   make_undirected_graph / 2"},"graph_algorithms:graph_node/2":{"prefix":"graph_node","body":"graph_node(${1:Graph}, ${2:Node})$3\n$0","description":"graph_node(+Graph, ?Node)\n\n   Succeeds if Node is a node of the graph\n\nArguments\n   Graph    a graph structure\n   Node    an integer node number\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_node(+, ?) is nondet\n\nSee Also\n   graph_get_maxnode / 2"},"graph_algorithms:graph_reverse_edges/2":{"prefix":"graph_reverse_edges","body":"graph_reverse_edges(${1:Graph}, ${2:RevGraph})$3\n$0","description":"graph_reverse_edges(+Graph, -RevGraph)\n\n   Makes a graph with reversed edges\n\nArguments\n   Graph    a graph structure\n   RevGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Creates a new graph RevGraph which is identical to Graph except\n    that all edges are reversed.\n    \n\nModes and Determinism\n   graph_reverse_edges(+, -) is det\n\nSee Also\n   make_graph / 3, make_graph_symbolic / 3"},"graph_algorithms:graph_set_nodenames/2":{"prefix":"graph_set_nodenames","body":"graph_set_nodenames(${1:Graph}, ${2:NodeNameArray})$3\n$0","description":"graph_set_nodenames(+Graph, ++NodeNameArray)\n\n   Add node names to an existing graph\n\nArguments\n   Graph    a graph structure\n   NodeNameArray       array of ground data, usually node names\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   graph_set_nodenames(+, ++) is det\n\nSee Also\n   make_graph_symbolic / 3, graph_get_nodenames / 2"},"graph_algorithms:graph_set_random_weights/3":{"prefix":"graph_set_random_weights","body":"graph_set_random_weights(${1:Graph}, ${2:Min}, ${3:Max})$4\n$0","description":"graph_set_random_weights(+Graph, +Min, +Max)\n\n   Unifies all the graph's edge data fields with random numbers\n\nArguments\n   Graph    a graph structure\n   Min    an integer or float\n   Max    an integer or float\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    The input Graph is assumed to be a graph with uninstantiated edge\n    data fields. These will be instantiated to random numbers between\n    Min and Max, using random/1 if Min and Max are integers, or using\n    frandom/1 if Min and Max are floats.\n    \n\nModes and Determinism\n   graph_set_random_weights(+, +, +) is det\n\nSee Also\n   make_random_graph / 6, random / 1, frandom / 1"},"graph_algorithms:incremental_all_shortest_paths_as_edges/6":{"prefix":"incremental_all_shortest_paths_as_edges","body":"incremental_all_shortest_paths_as_edges(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Modified}, ${5:Lengths}, ${6:Predecessors})$7\n$0","description":"incremental_all_shortest_paths_as_edges(+Graph, +DistanceArg, +SourceNode, +Modified, -Lengths, -Predecessors)\n\n   Incrementally computes all shortest paths from a single source to every reachable node given a list of modified edges\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   Modified    list of e/3 edge structures whose DistanceArg argument has been modified\n   Lengths    array of numbers (minimum path lengths)\n   Predecessors    array of lists of e/3 edge structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Incrementally computes all shortest paths from the single source\n    node SourceNode to every sink node which is reachable from it\n    given a list of modified edges. The result is returned in the form\n    of the Predecessors array which contains all relevant edges.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a positive number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    Modified is the list of e/3 edge structures whose DistanceArg\n    argument has been modified since the last computation for this\n    SourceNode.\n\n    The result is returned in the form of two arrays, whose indices range\n    over the possible sink nodes.  The Lengths array indicates the length\n    of a shortest path from SourceNode to the corresponding sink node.\n    The Predecessors array is an array of edge lists, each list containing\n    the alternative edges that are part of a shortest path from SourceNode\n    to the corresponding sink node.\n\n    If there is no path from SourceNode to a sink node J, then both\n    Lengths[J] and Predecessors[J] are uninstantiated. Otherwise,\n    Lengths[J] contains the length of a shortest path from SourceNode to J.\n    Predecessors[J] contains a list of alternative edges that lead from\n    some predecessor node to J in a shortest path from SourceNode to J.\n    Predecessors[SourceNode] is always the empty list [].\n\nAssembling Actual Paths\n\n    To generate an actual path from the Predecessors array, start from the\n    sink node J, select one of the alternative edges in Predecessors[J]\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the parameters, the following 3 cases can occur:\n    \n    Graph did not contain zero-length edges: in this\n    case, SubGraph is cycle-free and shortest paths can be found by simply\n    selecting arbitrary incoming edges until SourceNode is reached.\n    Graph did contain zero-length edges: in this case,\n    SubGraph may contain (zero-length) cycles which one may want to exclude\n    when constructing paths.\n    \n    The possible_path/7 predicate implements this path construction and\n    does the necesssary checks to exclude cycles.\n    \n\nModes and Determinism\n   incremental_all_shortest_paths_as_edges(+, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G), incremental_all_shortest_paths_as_edges(G, 0, 1, M, L, E).\n    L = [](0, 1, 2, 3, 2, 1, 1, _326, _327, 2, 3, 3, 3)\n    E = []([], [e(1, 2, 1)], [e(7, 3, 1)], [e(5, 4, 1)],\n\t   [e(7, 5, 1), e(6, 5, 1)], [e(1, 6, 1)], [e(1, 7, 1)],\n\t   _342, _343, [e(7, 10, 1)], [e(10, 11, 1)], [e(10, 12, 1)],\n\t   [e(10, 13, 1)])\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, incremental_all_shortest_paths_as_graph / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7"},"graph_algorithms:incremental_all_shortest_paths_as_graph/6":{"prefix":"incremental_all_shortest_paths_as_graph","body":"incremental_all_shortest_paths_as_graph(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Modified}, ${5:Lengths}, ${6:SubGraph})$7\n$0","description":"incremental_all_shortest_paths_as_graph(+Graph, +DistanceArg, +SourceNode, +Modified, -Lengths, -SubGraph)\n\n   Incrementally computes all shortest paths from a single source to every reachable node given a list of modified edges\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   Modified    list of e/3 edge structures whose DistanceArg argument has been modified\n   Lengths    array of numbers (minimum path lengths)\n   SubGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Incrementally computes all shortest paths from the single source\n    node SourceNode to every sink node which is reachable from it. The\n    result is returned in the form of a sub-graph of the input graph,\n    which contains all relevant edges.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a positive number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    Modified is the list of e/3 edge structures whose DistanceArg\n    argument has been modified since the last computation for this\n    SourceNode.\n\n    The result is returned in the form of SubGraph, which is a\n    sub-graph of the input Graph, containing the same nodes, but only\n    those edges that are needed to construct the shortest paths for\n    the given parameters.  SubGraph does not inherit the nodename\n    information from Graph, this can be set explicitly if required.\n\n    In addition, a Lengths array is returned, whose entries indicate\n    the length of a shortest path from SourceNode to the corresponding\n    sink node.  If there is no path from SourceNode to a sink node J,\n    then Lengths[J] is uninstantiated.\n\nProperties of the resulting SubGraph\n\n    To generate an actual path from the resulting SubGraph, start from the\n    sink node J, select one of its incoming edges (graph_get_incoming_edges/3)\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the parameters, the following 3 cases can occur:\n    \n    Graph did not contain zero-length edges: in this\n    case, SubGraph is cycle-free and shortest paths can be found by simply\n    selecting arbitrary incoming edges until SourceNode is reached.\n    Graph did contain zero-length edges: in this case,\n    SubGraph may contain (zero-length) cycles which one may want to exclude\n    when constructing paths.\n    \n\nModes and Determinism\n   incremental_all_shortest_paths_as_graph(+, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G), incremental_all_shortest_paths_as_graph(G, 0, 1, 0, L, E).\n    G = graph(13, []([e(1, 6, 1), e(1, 2, 1), e(1, 7, 1)], [], ...)\n    L = [](0, 1, 2, 3, 2, 1, 1, _326, _327, 2, 3, 3, 3)\n    SG = graph(13, []([e(1, 7, 1), e(1, 6, 1), e(1, 2, 1)], [], ...)\n    Yes (0.00s cpu)\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, incremental_all_shortest_paths_as_edges / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7"},"graph_algorithms:incremental_single_pair_all_shortest_paths_as_graph/7":{"prefix":"incremental_single_pair_all_shortest_paths_as_graph","body":"incremental_single_pair_all_shortest_paths_as_graph(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Modified}, ${6:Length}, ${7:SubGraph})$8\n$0","description":"incremental_single_pair_all_shortest_paths_as_graph(+Graph, +DistanceArg, +SourceNode, +SinkNode, +Modified, -Length, -SubGraph)\n\n   Computes all shortest paths from source to sink in form of a subgraph\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Modified    list of e/3 edge structures whose DistanceArg argument has been modified\n   Length    a number (minimum path length)\n   SubGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Incrementally computes all shortest paths from source node\n    SourceNode to sink node SinkNode.  The result is returned in the\n    form of a sub-graph of the input graph, which contains all\n    relevant edges. If there is no path, the predicate fails.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    Modified is the list of e/3 edge structures whose DistanceArg\n    argument has been modified since the last computation for this\n    SourceNode.\n\n    The result is returned in the form of SubGraph, which is a\n    sub-graph of the input Graph, containing the same nodes, but only\n    those edges that are needed to construct the shortest paths for\n    the given parameters.  SubGraph does not inherit the nodename\n    information from Graph, this can be set explicitly if required.\n\n    In addition, the Length of the shortest path from source to sink\n    is returned.\n\nProperties of the resulting SubGraph\n\n    To generate an actual path from the resulting SubGraph, start from the\n    sink node J, select one of its incoming edges (graph_get_incoming_edges/3)\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the input graph, the following 2 cases can occur:\n    \n    Graph did not contain zero-length edges: in this case,\n    SubGraph is cycle-free and shortest paths can be found by simply \n    selecting arbitrary incoming edges until SourceNode is reached.\n    Graph did contain zero-length edges: in this case, SubGraph\n    may contain (zero-length) cycles which one may want to exclude \n    when constructing paths.\n    \n    \n\nModes and Determinism\n   incremental_single_pair_all_shortest_paths_as_graph(+, +, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G),\n       incremental_single_pair_all_shortest_paths_as_graph(G, 0, 1, 5, M, L, E).\n    G = graph(13, []([e(1, 6, 1), e(1, 2, 1), e(1, 7, 1)], [], ...)\n    L = 2\n    SG = graph(13, []([e(1, 6, 1), e(1, 7, 1)], [], ...)\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, single_pair_short_path / 6, graph_get_incoming_edges / 3, graph_set_nodenames / 2"},"graph_algorithms:incremental_single_pair_shortest_path/6":{"prefix":"incremental_single_pair_shortest_path","body":"incremental_single_pair_shortest_path(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Modified}, ${6:Path})$7\n$0","description":"incremental_single_pair_shortest_path(+Graph, +DistanceArg, +SourceNode, +SinkNode, +Modified, -Path)\n\n   Computes short paths from a source to a sink node\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Modified    list of e/3 edge structures whose DistanceArg argument has been modified\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Incrementally computes shortest paths from SourceNode to SinkNode.\n    Alternative paths are generated on backtracking. Fails if there is\n    no path at all.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a positive number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    Modified is the list of e/3 edge structures whose DistanceArg\n    argument has been modified since the last computation for this\n    SourceNode.\n\n    All paths returned will have the same length and will be shortest\n    paths from SourceNode to SinkNode. Note that the solutions are not\n    generated in any specific order.\n\n    A resulting path is returned as a Length-EdgeList structure where\n    Length is the length of the path and EdgeList is the path in\n    reverse order, i.e. starting with the edge reaching SinkNode and\n    ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   incremental_single_pair_shortest_path(+, +, +, +, +, -) is nondet\n\nFail Conditions\n   There is no path from SourceNode to SinkNode\n\nExamples\n   \n    ?- sample_graph(G), incremental_single_pair_shortest_path(G, 0, 1, M, P).\n    P = 2 - [e(2, 3, 1), e(1, 2, 1)]\n    \n\nSee Also\n   shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, incremental_all_shortest_paths_as_edges / 6, incremental_all_shortest_paths_as_graph / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7, possible_path / 7"},"graph_algorithms:is_sub_graph/2":{"prefix":"is_sub_graph","body":"is_sub_graph(${1:SubGraph}, ${2:SuperGraph})$3\n$0","description":"is_sub_graph(+SubGraph, +SuperGraph)\n\n   Succeeds iff SubGraph is a subgraph of SuperGraph\n\nArguments\n   SubGraph    a graph structure\n   SuperGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Tests whether SubGraph is a (non-strict) subgraph of SuperGraph.\n    This is the case when the nodes and edges in SubGraph are a subset\n    of the nodes and edges of SuperGraph. Note that nodes are considered\n    identical when they have the same node numbers (rather than the same\n    node names - node name information is ignored by this predicate.).\n    \n\nModes and Determinism\n   is_sub_graph(+, +) is semidet\n\nFail Conditions\n   SubGraph is not a subgraph of SuperGraph\n\nSee Also\n   make_sub_graph / 3"},"graph_algorithms:make_graph/3":{"prefix":"make_graph","body":"make_graph(${1:NNodes}, ${2:EdgeList}, ${3:Graph})$4\n$0","description":"make_graph(+NNodes, ++EdgeList, -Graph)\n\n   Creates a graph with minimal overhead\n\nArguments\n   NNodes    the number of nodes: integer >= 0\n   EdgeList    a (possibly empty) list of e/3 structures in no particular order\n   Graph    will be bound to a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This predicate creates a graph data structure according to the given\n    information.  A graph consists of nodes that are numbered from 1 to\n    NNodes and directed edges between the nodes. An edge is represented\n    by the data structure\n\n\te(Source, Target, EdgeData)\n\n    where Source and Target are integers indicating the start and end\n    point of the edge, and EdgeData is an arbitrary data structure\n    holding additional information about the edge, e.g. capacity,\n    distance, weight, name etc.  The EdgeData field should have the\n    same structure for all edges in the graph.  If there is no\n    information attached to edges, the field should be set to 1\n    for edges between different nodes and to 0 otherwise.\n    Several library predicates inspect the EdgeData field or an argument\n    of the EdgeData field, e.g. the shortest path predicate can\n    use any numeric component of EdgeData as the distance criterion.\n    Caution: the distance arguments will be compared using general term\n    comparison (see compare/3) and should therefore have the same\n    type in all edges (e.g. all integer or all float).\n    \n\nModes and Determinism\n   make_graph(+, ++, -) is det\n\nFail Conditions\n   Edges contain nonexisting node numbers\n\nExceptions\n     6 --- NNodes is negative\n     4 --- NNodes or EdgeList are uninstantiated\n     5 --- NNodes is not integral\n\nExamples\n   \n    % the 13-node undirected graph from Sedgewick:Algorithms\n    make_graph( 13,\n\t[ e(1,6,1),e(1,2,1),e(1,7,1),e(3,1,1),e(4,6,1),e(5,4,1),\n\t  e(6,5,1),e(7,5,1),e(7,10,1),e(7,3,1),e(8,7,1),e(8,9,1),e(9,8,1),\n\t  e(10,11,1),e(10,12,1),e(10,13,1),e(12,7,1),e(12,13,1),e(13,12,1) ],\n    Graph).\n\nSee Also\n   make_graph_symbolic / 3, graph_set_nodenames / 2, library(graphviz), compare / 3"},"graph_algorithms:make_graph_symbolic/3":{"prefix":"make_graph_symbolic","body":"make_graph_symbolic(${1:NodeNameArray}, ${2:SymbolicEdgeList}, ${3:Graph})$4\n$0","description":"make_graph_symbolic(+NodeNameArray, ++SymbolicEdgeList, -Graph)\n\n   Creates a graph using node names\n\nArguments\n   NodeNameArray       array of ground data, usually node names\n   SymbolicEdgeList    (possibly empty) list of edge/3 structures in no particular order\n   Graph    will be bound to a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This predicate is similar to make_graph/3 in that it creates a\n    graph data structure according to the given information.\n    If the nodes have names, then make_graph_symbolic/3 allows to\n    specify the graph in a more readable way by using the node names\n    rather than node numbers in the edge specifications.\n    The node names are given as the array NodeNameArray, and the\n    symbolic edges are written in the form\n\n\tedge(SourceName, TargetName, EdgeData)\n\n    where SourceName and TargetName should match an entry (usually the\n    node name) in NodeNameArray.  Note the use of the functor edge/3 for\n    the symbolic edge representation as opposed to e/3 for the internal\n    edge representation.\n    \n\nModes and Determinism\n   make_graph_symbolic(+, ++, -) is det\n\nExamples\n   \n    % the 13-node undirected graph from Sedgewick:Algorithms\n    make_graph_symbolic(\n\t[](a,b,c,d,e,f,g,h,i,j,k,l,m),\n\t[ edge(a,f,1),edge(a,b,1),edge(a,g,1),edge(c,a,1),edge(d,f,1),edge(e,d,1),\n\t  edge(f,e,1),edge(g,e,1),edge(g,j,1),edge(g,c,1),edge(h,g,1),edge(h,i,1),edge(i,h,1),\n\t  edge(j,k,1),edge(j,l,1),edge(j,m,1),edge(l,g,1),edge(l,m,1),edge(m,l,1) ],\n\tGraph).\n    \n\nSee Also\n   make_graph / 3, library(graphviz)"},"graph_algorithms:make_random_graph/6":{"prefix":"make_random_graph","body":"make_random_graph(${1:NNodes}, ${2:NEdges}, ${3:AntiParallelFree}, ${4:LoopFree}, ${5:ParallelFree}, ${6:Graph})$7\n$0","description":"make_random_graph(+NNodes, +NEdges, +AntiParallelFree, +LoopFree, +ParallelFree, -Graph)\n\n   Creates a random graph with the given properties\n\nArguments\n   NNodes    integer\n   NEdges    integer\n   AntiParallelFree    one of the atoms true or false\n   LoopFree    one of the atoms true or false\n   ParallelFree    one of the atoms true or false\n   Graph    will be bound to a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Creates a random graph with NNodes nodes and NEdges edges.\n    The other 3 options mean:\n\nAntiParallelFree\n    if true, the graph will have no anti-parallel edges, i.e. if\n    there is an edge from S to T, there won't be one from T to S\nLoopFree\n    if true, the graph will have no self loops, i.e. no edges\n    that begin and end in the same node.\nParallelFree\n    if true, the graph will have no parallel edges, i.e. there\n    will be at most one edge from S to T.\n\n    The generated graph has no node name information and no edge data.\n    Node names can be added using graph_set_nodenames/2. Edge data\n    (e.g. random weights) can be added by retrieving the edges using\n    graph_get_all_edges/2 or graph_get_adjacent_edges/3 and unifying\n    the variable EdgeData field with the required information.\n    \n\nModes and Determinism\n   make_random_graph(+, +, +, +, +, -) is det\n\nExceptions\n     6 --- NEdges is too large given the chosen options and NNodes\n\nSee Also\n   graph_set_nodenames / 2, graph_get_all_edges / 2, graph_set_random_weights / 3, graph_get_adjacent_edges / 3, library(graphviz)"},"graph_algorithms:make_sub_graph/3":{"prefix":"make_sub_graph","body":"make_sub_graph(${1:Graph}, ${2:Nodes}, ${3:SubGraph})$4\n$0","description":"make_sub_graph(+Graph, ++Nodes, -SubGraph)\n\n   Creates a subgraph (projection on nodes) of a given graph\n\nArguments\n   Graph    a graph structure\n   Nodes    a list of node numbers\n   SubGraph    will be bound to a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Creates a sub-graph SubGraph of the original graph Graph. SubGraph has\n    the same set of nodes as Graph, but only those edges that begin and end\n    in the specified set of nodes Nodes.\n    \n\nModes and Determinism\n   make_sub_graph(+, ++, -) is det\n\nSee Also\n   is_sub_graph / 2"},"graph_algorithms:make_undirected_graph/2":{"prefix":"make_undirected_graph","body":"make_undirected_graph(${1:DirectedGraph}, ${2:UndirectedGraph})$3\n$0","description":"make_undirected_graph(+DirectedGraph, -UndirectedGraph)\n\n   Creates an undirected from a directed graph\n\nArguments\n   DirectedGraph       a graph structure\n   UndirectedGraph     will be bound to a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Creates an undirected graph from a directed graph by adding reverse\n    edges for every existing edge. Moreover, all loops (edges from S to S)\n    are removed from the undirected graph.\n    \n\nModes and Determinism\n   make_undirected_graph(+, -) is det\n\nSee Also\n   graph_is_bidirected / 1"},"graph_algorithms:maximum_matching_hopcroft_karp/4":{"prefix":"maximum_matching_hopcroft_karp","body":"maximum_matching_hopcroft_karp(${1:G}, ${2:A}, ${3:B}, ${4:MaximalM})$5\n$0","description":"maximum_matching_hopcroft_karp(+G, ++A, ++B, -MaximalM)\n\n   Compute the maximum matching in a bipartite graph using Hopcroft and Karp's algorithm\n\nArguments\n   G    A directed bipartite graph, with all edges starting and ending in 'A' or 'B'\n   A    List of nodes in one half of the graph\n   B    List of nodes in the other half of the graph\n   MaximalM    List of edges constituting the maximum matching\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes the maximum matching in the given bipartite graph. A\n    matching in a bipartite graph, is a set of edges from the\n    graph such that no two edges are incident to the same node.  A\n    maximum matching is a matching with the most edges possible.\n    The may be more than one maximum matching, this predicate\n    returns only one.\n\n    The implementation uses Hopcroft and Karp's algorithm which\n    has a complexity of O(Nedges*SQRT(Nnodes in A)).\n       \n\nModes and Determinism\n   maximum_matching_hopcroft_karp(+, ++, ++, -) is semidet\n\nFail Conditions\n   Graph is not bipartite\n\nExamples\n   \n\nSee Also"},"graph_algorithms:minimum_spanning_forest/5":{"prefix":"minimum_spanning_forest","body":"minimum_spanning_forest(${1:Graph}, ${2:DistanceArg}, ${3:Forest}, ${4:ForestSize}, ${5:ForestWeight})$6\n$0","description":"minimum_spanning_forest(+Graph, +DistanceArg, -Forest, -ForestSize, -ForestWeight)\n\n   Computes a minimum spanning forest, its size and weight\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   Forest    a list of e/3 edge structures\n   ForestSize    the number of edges in the Forest list\n   ForestWeight    sum of the forest's edge weights: number\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes a minimum spanning forest for the given graph. A minimum\n    spanning forest is a smallest subset of the graph's edges that still\n    connects all the graph's connected components. Such a forest is not\n    unique, but all minimum spanning forests will have the same cost.\n    As opposed to a minimum spanning tree, a forest exists also if the\n    original graph is not connnected. The forest will have the same\n    number of connected components as the original graph.\n\n    The computed forest is returned in Forest, which is simply a list of\n    the edges that form the forest. The ForestSize is the number of\n    edges that constitute the forest. The ForestWeight is the total\n    length of the forest's edges, according to DistanceArg.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number, and the\n    numeric type (integer, float, etc) must be the same in all edges.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    The direction of the graph's edges is ignored by this predicate.\n\n    The implementation uses Kruskal's algorithm which has a complexity\n    of O(Nedges*log(Nedges)).\n    \n\nModes and Determinism\n   minimum_spanning_forest(+, +, -, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G), minimum_spanning_forest(G, 0, T, S, W).\n    T = [e(2, 10, 1), e(4, 8, 1), e(9, 2, 1), e(7, 3, 2), ...]\n    S = 8\n    W = 16\n    \n\nSee Also\n   minimum_spanning_tree / 4"},"graph_algorithms:minimum_spanning_tree/4":{"prefix":"minimum_spanning_tree","body":"minimum_spanning_tree(${1:Graph}, ${2:DistanceArg}, ${3:Tree}, ${4:TreeWeight})$5\n$0","description":"minimum_spanning_tree(+Graph, +DistanceArg, -Tree, -TreeWeight)\n\n   Computes a minimum spanning tree and its weight\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   Tree    a list of e/3 edge structures\n   TreeWeight    sum of the tree's edge weights: number\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes a minimum spanning tree for the given graph. A minimum\n    spanning tree is a smallest subset of the graph's edges that still\n    connects all the graph's nodes. Such a tree is not unique and of\n    course exists only if the original graph is itself connected.\n    However, all minimum spanning trees will have the same cost.\n\n    The computed tree is returned in Tree, which is simply a list of\n    the edges that form the tree. The TreeWeight is the total length\n    of the tree's edges, according to DistanceArg.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number, and the\n    numeric type (integer, float, etc) must be the same in all edges.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    The direction of the graph's edges is ignored by this predicate.\n\n    The implementation uses Kruskal's algorithm which has a complexity\n    of O(Nedges*log(Nedges)).\n    \n\nModes and Determinism\n   minimum_spanning_tree(+, +, -, -) is semidet\n\nFail Conditions\n   No spanning tree exists, i.e. the graph is not connected.\n\nExamples\n   \n    ?- sample_graph(G), minimum_spanning_tree(G, 0, T, W).\n    T = [e(2, 10, 1), e(4, 8, 1), e(9, 2, 1), e(7, 3, 2), ...]\n    W = 16\n    \n\nSee Also\n   minimum_spanning_forest / 5"},"graph_algorithms:node_to_nodename/3":{"prefix":"node_to_nodename","body":"node_to_nodename(${1:Graph}, ${2:Node}, ${3:NodeName})$4\n$0","description":"node_to_nodename(+Graph, +Node, -NodeName)\n\n   Retrieves the name of a node\n\nArguments\n   Graph    a graph structure\n   Node    an integer node number\n   NodeName    ground data, usually node name\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   node_to_nodename(+, +, -) is semidet\n\nFail Conditions\n   Fails if no node name information is available\n\nSee Also\n   nodes_to_nodenames / 3, nodename_to_node / 3, nodenames_to_nodes / 3"},"graph_algorithms:nodename_to_node/3":{"prefix":"nodename_to_node","body":"nodename_to_node(${1:Graph}, ${2:NodeName}, ${3:Node})$4\n$0","description":"nodename_to_node(+Graph, +NodeName, -Node)\n\n   Retrieves the node number given a node name\n\nArguments\n   Graph    a graph structure\n   NodeName    ground data, usually node name\n   Node    an integer node number\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   nodename_to_node(+, +, -) is semidet\n\nFail Conditions\n   Fails if no node name information is available\n\nSee Also\n   node_to_nodename / 3, nodes_to_nodenames / 3, nodenames_to_nodes / 3"},"graph_algorithms:nodenames_to_nodes/3":{"prefix":"nodenames_to_nodes","body":"nodenames_to_nodes(${1:Graph}, ${2:NodeNames}, ${3:Nodes})$4\n$0","description":"nodenames_to_nodes(+Graph, +NodeNames, -Nodes)\n\n   Returns the names corresponding to a list of nodes\n\nArguments\n   Graph    a graph structure\n   NodeNames    a list of ground data, usually node names\n   Nodes    a list of integer node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   nodenames_to_nodes(+, +, -) is semidet\n\nFail Conditions\n   Fails if no node name information is available\n\nSee Also\n   node_to_nodename / 3, nodename_to_node / 3, nodes_to_nodenames / 3"},"graph_algorithms:nodes_to_nodenames/3":{"prefix":"nodes_to_nodenames","body":"nodes_to_nodenames(${1:Graph}, ${2:Nodes}, ${3:NodeNames})$4\n$0","description":"nodes_to_nodenames(+Graph, +Nodes, -NodeNames)\n\n   Returns the names corresponding to a list of nodes\n\nArguments\n   Graph    a graph structure\n   Nodes    a list of integer node numbers\n   NodeNames    a list of ground data, usually node names\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   nodes_to_nodenames(+, +, -) is semidet\n\nFail Conditions\n   Fails if no node name information is available\n\nSee Also\n   node_to_nodename / 3, nodename_to_node / 3, nodenames_to_nodes / 3"},"graph_algorithms:possible_path/6":{"prefix":"possible_path","body":"possible_path(${1:SourceNode}, ${2:SinkNode}, ${3:Tolerance}, ${4:Lengths}, ${5:Predecessors}, ${6:Path})$7\n$0","description":"possible_path(+SourceNode, +SinkNode, +Tolerance, +Lengths, +Predecessors, -Path)\n\n   Computes an actual path from a predecessors array\n\nArguments\n   SourceNode    source node number\n   SinkNode    sink node number\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Lengths    array of numbers\n   Predecessors    array of edge lists\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This predicate is deprecated, it is equivalent to possible_path/7 with\n    a DistanceArg of 0.\n    \n\nModes and Determinism\n   possible_path(+, +, +, +, +, -) is nondet\n\nSee Also\n   possible_path / 7"},"graph_algorithms:possible_path/7":{"prefix":"possible_path","body":"possible_path(${1:DistanceArg}, ${2:SourceNode}, ${3:SinkNode}, ${4:Tolerance}, ${5:Lengths}, ${6:Predecessors}, ${7:Path})$8\n$0","description":"possible_path(+DistanceArg, +SourceNode, +SinkNode, +Tolerance, +Lengths, +Predecessors, -Path)\n\n   Computes an actual path from a predecessors array\n\nArguments\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number\n   SinkNode    sink node number\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Lengths    array of numbers\n   Predecessors    array of edge lists\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    This predicate complements the all_short_paths_as_edges/6 predicate.\n    The intended usage is that all_short_paths_as_edges/6 is used to\n    precompute shortest path information from a single source node\n    to all possible sink nodes, and possible_path/7 uses this\n    information to enumerate actual paths to a specific sink node.\n    If paths from one source to several sinks are needed, it is more\n    efficient to use one call to all_short_paths_as_edges/6 and several\n    calls to possible_path/7, than to use several calls to\n    single_pair_all_short_paths/7.\n    \n    Note that the Lengths and Predecessors arrays must have been computed\n    with the same settings for DistanceArg, SourceNode and Tolerance that are\n    given to possible_path/7, otherwise errors or missing paths will occur.\n    \n\nModes and Determinism\n   possible_path(+, +, +, +, +, +, -) is nondet\n\nFail Conditions\n   There is no path to SinkNode\n\nExamples\n   \n    single_pair_shortest_path(Graph, Source, Sink, Path) :-\n    \tall_short_paths_as_edges(Graph, 0, Source, 0, Lengths, Preds),\n    \tpossible_path(0, Source, Sink, 0, Lengths, Preds, Path).\n    \n\nSee Also\n   all_short_paths_as_edges / 6"},"graph_algorithms:proper_graph/1":{"prefix":"proper_graph","body":"proper_graph(${1:Graph})$2\n$0","description":"proper_graph(+Graph)\n\n   Tests the integrity of the given graph data structure\n\nArguments\n   Graph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    \n\nModes and Determinism\n   proper_graph(+) is semidet\n\nSee Also"},"graph_algorithms:shortest_paths_bellman_ford/4":{"prefix":"shortest_paths_bellman_ford","body":"shortest_paths_bellman_ford(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Paths})$5\n$0","description":"shortest_paths_bellman_ford(+Graph, +DistanceArg, +SourceNode, -Paths)\n\n   Computes one shortest path from a single source to every reachable node (allowing negative distances)\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number\n   Paths    array of Length-EdgeList structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes one shortest path from the single source node SourceNode\n    to every node which is reachable from it. In case of multiple\n    shortest paths with the same length, an arbitrary one is returned.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. As opposed to the other\n    shortest path algorithms, the Bellman-Ford algorithm can handle\n    negative edge lengths, however, the implementation has currently\n    no check for negative cycles and will not terminate in that case.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    The results are returned as an array ranging over all node numbers.\n    For unreachable nodes the array element is uninstantiated.\n    For reachable nodes, the element contains a Length-EdgeList structure\n    where Length is the length of the shortest path and EdgeList is that\n    path (or one of them) in reverse order, i.e. starting with the edge\n    reaching the target and ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   shortest_paths_bellman_ford(+, +, +, -) is det\n\nExamples\n   \n    ?- sample_graph(G), shortest_paths_bellman_ford(G, 0, 1, P).\n    P = [](2 - [e(2, 1, 1), e(1, 2, 1)], 1 - [e(1, 2, 1)], ...)\n    \n\nSee Also\n   single_pair_shortest_path_bellman_ford / 5, shortest_paths / 4"},"graph_algorithms:shortest_paths/4":{"prefix":"shortest_paths","body":"shortest_paths(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:Paths})$5\n$0","description":"shortest_paths(+Graph, +DistanceArg, +SourceNode, -Paths)\n\n   Computes one shortest path from a single source to every reachable node\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number (integer)\n   Paths    array of Length-EdgeList structures\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes one shortest path from the single source node SourceNode\n    to every node which is reachable from it. In case of multiple\n    shortest paths with the same length, an arbitrary one is returned.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number, and the\n    numeric type (integer, float, etc) must be the same in all edges.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    SourceNode is the common starting point for the computed paths.\n\n    The results are returned as an array ranging over all node numbers.\n    For unreachable nodes the array element is uninstantiated.\n    For reachable nodes, the element contains a Length-EdgeList structure\n    where Length is the length of the shortest path and EdgeList is that\n    path (or one of them) in reverse order, i.e. starting with the edge\n    reaching the target and ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   shortest_paths(+, +, +, -) is det\n\nExamples\n   \n    ?- sample_graph(G), shortest_paths(G, 0, 1, P).\n    P = [](2 - [e(2, 1, 1), e(1, 2, 1)], 1 - [e(1, 2, 1)], ...)\n    \n\nSee Also\n   single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7, possible_path / 7"},"graph_algorithms:single_pair_all_short_paths_as_graph/7":{"prefix":"single_pair_all_short_paths_as_graph","body":"single_pair_all_short_paths_as_graph(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Tolerance}, ${6:Length}, ${7:SubGraph})$8\n$0","description":"single_pair_all_short_paths_as_graph(+Graph, +DistanceArg, +SourceNode, +SinkNode, +Tolerance, -Length, -SubGraph)\n\n   Computes all shortest paths from source to sink in form of a subgraph\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance (integer)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Length    a number (minimum path length)\n   SubGraph    a graph structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes all shortest paths from source node SourceNode to sink\n    node SinkNode.  The result is returned in the form of a sub-graph\n    of the input graph, which contains all relevant edges.\n    If there is no path, the predicate fails.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    Tolerance should be zero in order to find only the shortest paths. \n    If Tolerance is greater than zero, then all paths that are within\n    this tolerance of the shortest path length will be found.\n\n    The result is returned in the form of SubGraph, which is a\n    sub-graph of the input Graph, containing the same nodes, but only\n    those edges that are needed to construct the shortest paths for\n    the given parameters.  SubGraph does not inherit the nodename\n    information from Graph, this can be set explicitly if required.\n\n    In addition, the Length of the shortest path from source to sink\n    is returned.\n\nProperties of the resulting SubGraph\n\n    To generate an actual path from the resulting SubGraph, start from the\n    sink node J, select one of its incoming edges (graph_get_incoming_edges/3)\n    to find a predecessor node, and continue this process until the SourceNode\n    is reached. Depending on the parameters, the following 3 cases can occur:\n    \n    Tolerance is zero, and Graph did not contain zero-length edges: in this\n    case, SubGraph is cycle-free and shortest paths can be found by simply\n    selecting arbitrary incoming edges until SourceNode is reached.\n    Tolerance is zero, and Graph did contain zero-length edges: in this case,\n    SubGraph may contain (zero-length) cycles which one may want to exclude\n    when constructing paths.\n    Tolerance is nonzero:  in this case, SubGraph may contain\n    cycles (of maximum length Tolerance).  Moreover, it may be\n    possible to use the edges in SubGraph to construct cycle-free paths\n    whose total length is greater than the shortest path length plus\n    the tolerance.  These may need to be excluded explicitly.\n    \n    \n\nModes and Determinism\n   single_pair_all_short_paths_as_graph(+, +, +, +, +, -, -) is det\n\nExamples\n   \n    ?- sample_graph(G),\n       single_pair_all_short_paths_as_graph(G, 0, 1, 5, 0, L, E).\n    G = graph(13, []([e(1, 6, 1), e(1, 2, 1), e(1, 7, 1)], [], ...)\n    L = 2\n    SG = graph(13, []([e(1, 6, 1), e(1, 7, 1)], [], ...)\n    \n\nSee Also\n   possible_path / 7, shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, single_pair_short_path / 6, graph_get_incoming_edges / 3, graph_set_nodenames / 2"},"graph_algorithms:single_pair_shortest_path/5":{"prefix":"single_pair_shortest_path","body":"single_pair_shortest_path(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Path})$6\n$0","description":"single_pair_shortest_path(+Graph, +DistanceArg, +SourceNode, +SinkNode, -Path)\n\n   Computes one shortest path from a source to a sink node\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes one shortest path from SourceNode to SinkNode.\n    Fails if there is no path at all.  In case of multiple\n    shortest paths with the same length, an arbitrary one is returned.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number, and the\n    numeric type (integer, float, etc) must be the same in all edges.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    The shortest path is returned as a Length-EdgeList structure\n    where Length is the length of the shortest path and EdgeList is that\n    path (or one of them) in reverse order, i.e. starting with the edge\n    reaching SinkNode and ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   single_pair_shortest_path(+, +, +, +, -) is semidet\n\nFail Conditions\n   There is no path from SourceNode to SinkNode\n\nExamples\n   \n    ?- sample_graph(G), single_pair_shortest_path(G, 0, 1, 3, P).\n    P = 2 - [e(2, 3, 1), e(1, 2, 1)]\n    \n\nSee Also\n   shortest_paths / 4, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, single_pair_short_path / 6, single_pair_all_short_paths_as_graph / 7, possible_path / 7"},"graph_algorithms:single_pair_short_path/6":{"prefix":"single_pair_short_path","body":"single_pair_short_path(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Tolerance}, ${6:Path})$7\n$0","description":"single_pair_short_path(+Graph, +DistanceArg, +SourceNode, +SinkNode, +Tolerance, -Path)\n\n   Computes short paths from a source to a sink node\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Tolerance    tolerable deviation from minimal length (non-negative number)\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes shortest (or sufficiently short) paths from SourceNode to\n    SinkNode. Alternative paths are generated on backtracking.\n    Fails if there is no path at all.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. Important: the distance\n    information in EdgeData must be a non-negative number.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    If Tolerance is given as zero, all paths returned will have the same\n    length and will be shortest paths from SourceNode to SinkNode.\n    If Tolerance is nonzero, additional paths will be returned with\n    lengths up to the length of the shortest path plus the tolerance.\n    Note that the solutions are not generated in any specific order.\n\n    A resulting path is returned as a Length-EdgeList structure where\n    Length is the length of the path and EdgeList is the path in\n    reverse order, i.e. starting with the edge reaching SinkNode and\n    ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   single_pair_short_path(+, +, +, +, +, -) is nondet\n\nFail Conditions\n   There is no path from SourceNode to SinkNode\n\nExamples\n   \n    ?- sample_graph(G), single_pair_short_path(G, 0, 1, 3, P).\n    P = 2 - [e(2, 3, 1), e(1, 2, 1)]\n    \n\nSee Also\n   shortest_paths / 4, single_pair_shortest_path / 5, all_short_paths_as_edges / 6, all_short_paths_as_graph / 6, single_pair_all_short_paths_as_graph / 7, possible_path / 7"},"graph_algorithms:single_pair_shortest_path_bellman_ford/5":{"prefix":"single_pair_shortest_path_bellman_ford","body":"single_pair_shortest_path_bellman_ford(${1:Graph}, ${2:DistanceArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Path})$6\n$0","description":"single_pair_shortest_path_bellman_ford(+Graph, +DistanceArg, +SourceNode, +SinkNode, -Path)\n\n   Computes one shortest path from a source to a sink node (allowing negative distances)\n\nArguments\n   Graph    a graph structure\n   DistanceArg    which argument of EdgeData to use as distance: integer\n   SourceNode    source node number\n   SinkNode    sink node number\n   Path    Length-EdgeList structure\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes one shortest path from SourceNode to SinkNode.\n    Fails if there is no path at all.  In case of multiple\n    shortest paths with the same length, an arbitrary one is returned.\n\n    DistanceArg refers to the graph's EdgeData information that was\n    specified when the graph was constructed. If EdgeData is a simple\n    number, then DistanceArg should be 0 and EdgeData will be taken\n    as the length of the edge. If EdgeData is a compound data structure,\n    DistanceArg should be a number between 1 and the arity of that\n    structure and determines which argument of the EdgeData structure\n    will be interpreted as the edge's length. As opposed to the other\n    shortest path algorithms, the Bellman-Ford algorithm can handle\n    negative edge lengths, however, the implementation has currently\n    no check for negative cycles and will not terminate in that case.\n\n    If DistanceArg is given as -1, then any EdgeData is ignored and\n    the length of every edge is assumed to be equal to 1.\n\n    The shortest path is returned as a Length-EdgeList structure\n    where Length is the length of the shortest path and EdgeList is that\n    path (or one of them) in reverse order, i.e. starting with the edge\n    reaching SinkNode and ending with the edge starting from SourceNode.\n    \n\nModes and Determinism\n   single_pair_shortest_path_bellman_ford(+, +, +, +, -) is semidet\n\nFail Conditions\n   There is no path from SourceNode to SinkNode\n\nExamples\n   \n    ?- sample_graph(G), single_pair_shortest_path_bellman_ford(G, 0, 1, 3, P).\n    P = 2 - [e(2, 3, 1), e(1, 2, 1)]\n    \n\nSee Also\n   shortest_paths_bellman_ford / 4, single_pair_shortest_path / 5"},"graph_algorithms:strong_components/2":{"prefix":"strong_components","body":"strong_components(${1:Graph}, ${2:StrongComponents})$3\n$0","description":"strong_components(+Graph, -StrongComponents)\n\n   Computes the strongly connected components of a graph\n\nArguments\n   Graph    a graph structure\n   StrongComponents    list of lists of integer node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Computes the strongly connected components, i.e. maximal subsets\n    of the graph's nodes in which all nodes are mutually accessible.\n    The implementation essentially uses Tarjan's algorithm with a\n    complexity of O(Nnodes + Nedges).\n    \n\nModes and Determinism\n   strong_components(+, -) is det\n\nSee Also"},"graph_algorithms:top_sort/2":{"prefix":"top_sort","body":"top_sort(${1:Graph}, ${2:Sorted})$3\n$0","description":"top_sort(+Graph, -Sorted)\n\n   Finds a topological ordering of the graph if one exists\n\nArguments\n   Graph    a graph structure\n   Sorted    a list of integer node numbers\n\nType\n   library(graph_algorithms)\n\nDescription\n\n    Finds a topological ordering of the graph, i.e. an ordering of the\n    nodes such that all edges go from earlier to later nodes.\n    Such an ordering exists if and only if the graph is acyclic.\n    If the graph is cyclic, the predicate fails.\n    \n    In general, the ordering is not unique, an arbitrary one is computed.\n    The complexity is O(Nnodes + Nedges).\n    \n\nModes and Determinism\n   top_sort(+, -) is semidet\n\nFail Conditions\n   No topological ordering exists, i.e. the graph is cyclic\n\nSee Also\n   graph_is_acyclic / 1, graph_cycles / 2"},"hash:hash_add/3":{"prefix":"hash_add","body":"hash_add(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_add(+Table, ++Key, +Value)\n\n   A synonym for hash_set/3\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   Value    Any term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_add(+, ++, +) is det\n\nSee Also\n   hash_set / 3"},"hash:hash_contains/2":{"prefix":"hash_contains","body":"hash_contains(${1:Table}, ${2:Key})$3\n$0","description":"hash_contains(+Table, ++Key)\n\n   Succeeds if there is an entry stored under key Key\n\nArguments\n   Table    A hash table\n   Key    a ground term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_contains(+, ++) is semidet\n\nFail Conditions\n   No entry for Key\n\nSee Also\n   hash_get / 3, hash_list / 3"},"hash:hash_count/2":{"prefix":"hash_count","body":"hash_count(${1:Table}, ${2:Count})$3\n$0","description":"hash_count(+Table, -Count)\n\n   Returns the number of entries in the table\n\nArguments\n   Table    A hash table\n   Count    A variable or number\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_count(+, -) is det\n\nSee Also\n   hash_create / 1, hash_list / 3"},"hash:hash_create/1":{"prefix":"hash_create","body":"hash_create(${1:Table})$2\n$0","description":"hash_create(-Table)\n\n   Creates a new hash table\n\nArguments\n   Table    A variable\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_create(-) is det\n\nSee Also\n   hash_set / 3, hash_get / 3, hash_erase / 1"},"hash:hash_delete/2":{"prefix":"hash_delete","body":"hash_delete(${1:Table}, ${2:Key})$3\n$0","description":"hash_delete(+Table, ++Key)\n\n   Remove the entry with key Key (if any)\n\nArguments\n   Table    Hash table\n   Key    a ground term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_delete(+, ++) is det\n\nSee Also\n   hash_remove / 3, hash_erase / 1"},"hash:hash_entry/3":{"prefix":"hash_entry","body":"hash_entry(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_entry(+Table, ?Key, -Value)\n\n   Succeeds if Key and Value are an entry in table\n\nArguments\n   Table    A hash table\n   Key    a term\n   Value    a term\n\nType\n   library(hash)\n\nDescription\n\n\tLike hash_get/3, but allows the Key to be uninstantiated, in which\n\tcase all hash table entries will be enumerated on backtracking.\n    \n\nModes and Determinism\n   hash_entry(+, -, -) is nondet\n   hash_entry(+, ++, -) is semidet\n\nFail Conditions\n   No entry for Key\n\nSee Also\n   hash_get / 3, hash_list / 3"},"hash:hash_erase/1":{"prefix":"hash_erase","body":"hash_erase(${1:Table})$2\n$0","description":"hash_erase(+Table)\n\n   Remove all entries in the hash table\n\nArguments\n   Table    Hash table\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_erase(+) is det\n\nSee Also\n   hash_create / 1, hash_delete / 2"},"hash:hash_find/3":{"prefix":"hash_find","body":"hash_find(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_find(+Table, ++Key, -Value)\n\n   A synonym for hash_get/3\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   Value    Any term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_find(+, ++, -) is semidet\n\nFail Conditions\n   No entry for Key\n\nSee Also\n   hash_get / 3"},"hash:hash_get/3":{"prefix":"hash_get","body":"hash_get(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_get(+Table, ++Key, -Value)\n\n   Find the entry stored under key Key and return its value\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   Value    Any term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_get(+, ++, -) is semidet\n\nFail Conditions\n   No entry for Key\n\nSee Also\n   hash_create / 1, hash_set / 3, hash_list / 3, hash_contains / 2, hash_update / 4"},"hash:hash_insert_suspension/3":{"prefix":"hash_insert_suspension","body":"hash_insert_suspension(${1:Table}, ${2:Susp}, ${3:Notifications})$4\n$0","description":"hash_insert_suspension(+Table, +Susp, -Notifications)\n\n   Attach a suspension to be woken on hash table modifications\n\nArguments\n   Table    Hash table\n   Susp    A suspension\n   Notifications       A receive port, see library(notify_ports)\n\nType\n   library(hash)\n\nDescription\n\n    Attach a suspension Susp to the hash table Table such that it gets\n\twoken whenever the table changes (i.e. when entries are added, changed\n\tor removed).\n\t\n\tThe suspended goal would typically be a demon (because it is going to\n\tbe woken repeatedly, on every change). hash_insert_suspension/3 also\n\tsupplies a Notifications argument, which should be used as one of the\n\targuments of the suspended goal (see example). This is a \"receive\n\tport\" as defined by library(notify_ports), and is used to convey\n\tinformation about the changes that happened to the hash table.\n\tThe notifications are of the following form:\n\t\n\tadd(Key,Value)    if a table entry was added\n\tchg(Key,OldValue,NewValue) if a table entry was modified\n\trem(Key,OldValue)    if a table entry was removed\n\t\n\tNote that the suspensions will be always be woken after the hash\n\ttable has changed, so they will see the new state when they wake up.\n    \n\nModes and Determinism\n   hash_insert_suspension(+, +, -) is det\n\nExamples\n   \n    % Program:\n\n\thash_create_verbose(H) :-\n\t    hash_create(H),\n\t    make_suspension(report(Notifications,Susp), 2, Susp),\n\t    hash_insert_suspension(H, Susp, Notifications).\n\n\t:- demon(report/2).\n\treport(Notifications, Susp) :-\n\t    notify_ports:receive_notifications(Notifications, List, Status),\n\t    writeln(changes:List),\n\t    ( Status = closed -> kill_suspension(Susp) ; true ).\n\n    % Sample execution\n\n    ?- hash_create_verbose(H),\n       hash_set(H,k1,v1), hash_set(H,k1,v2), hash_delete(H,k1),\n       hash_terminate_suspensions(H).\n    changes : [add(k1, v1)]\n    changes : [chg(k1, v1, v2)]\n    changes : [rem(k1, v2)]\n    changes : []\n\n    H = hash(4, 0, [])\n    Yes (0.00s cpu)\n    \n\nSee Also\n   hash_terminate_suspensions / 1, notify_ports : receive_notifications / 3, notify_ports : foreachnotification / 6, library(notify_ports), demon / 1"},"hash:hash_iter/2":{"prefix":"hash_iter","body":"hash_iter(${1:Table}, ${2:Iter})$3\n$0","description":"hash_iter(+Table, -Iter)\n\n   Create an iterator to traverse the hash table\n\nArguments\n   Table    A hash table\n   Iter    Hash table iterator structure (output)\n\nType\n   library(hash)\n\nDescription\n\n\tCreate an iterator to traverse the hash table. Note that the\n\thash table should not be modified while the iterator is used,\n\totherwise the behaviour is undefined.\n\nModes and Determinism\n   hash_iter(+, -) is det\n\nSee Also\n   hash_next / 4, hash_last / 1, hash_list / 3"},"hash:hash_keys/2":{"prefix":"hash_keys","body":"hash_keys(${1:Table}, ${2:Keys})$3\n$0","description":"hash_keys(+Table, -Keys)\n\n   Retrieve the current hash table keys\n\nArguments\n   Table    A hash table\n   Keys    a variable or list\n\nType\n   library(hash)\n\nDescription\n\n\tRetrieve the hash table keys in the form of a list of Keys.\n\tThis list is cached by the hash table and only recomputed when\n\tthe table has changed.\n\nModes and Determinism\n   hash_keys(+, -) is det"},"hash:hash_last/1":{"prefix":"hash_last","body":"hash_last(${1:Iter})$2\n$0","description":"hash_last(+Iter)\n\n   Succeeds if the iterator has reached the end of the table\n\nArguments\n   Iter    Hash table iterator structure\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_last(+) is semidet\n\nFail Conditions\n   There are further table entries left in the iteration\n\nSee Also\n   hash_iter / 2, hash_next / 4, hash_list / 3"},"hash:hash_list/3":{"prefix":"hash_list","body":"hash_list(${1:Table}, ${2:Keys}, ${3:Values})$4\n$0","description":"hash_list(+Table, -Keys, -Values)\n\n   Retrieve the hash table contents\n\nArguments\n   Table    A hash table\n   Keys    a variable or list\n   Values    variable or list\n\nType\n   library(hash)\n\nDescription\n\n\tRetrieve the hash table contents in the form of a list of Keys\n\tand a list of Values. These lists are cached by the hash table\n\tand only recomputed when the table has changed.\n\nModes and Determinism\n   hash_list(+, -, -) is det"},"hash:hash_next/4":{"prefix":"hash_next","body":"hash_next(${1:Iter}, ${2:Key}, ${3:Value}, ${4:Iter})$5\n$0","description":"hash_next(+Iter, -Key, -Value, -Iter)\n\n   Get the next Key - Value pair according to the iterator\n\nArguments\n   Iter    Hash table iterator structure\n   Key    A ground term (output)\n   Value    A term (output)\n   Iter    Hash table iterator structure (output)\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_next(+, -, -, -) is semidet\n\nFail Conditions\n   No further entries left in this iteration\n\nSee Also\n   hash_iter / 2, hash_last / 1, hash_list / 3"},"hash:hash_remove/3":{"prefix":"hash_remove","body":"hash_remove(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_remove(+Table, ++Key, -Value)\n\n   Remove the entry with key Key and retrieve its value Value\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   Value    Any term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_remove(+, ++, -) is semidet\n\nFail Conditions\n   No entry for Key\n\nSee Also\n   hash_get / 3, hash_delete / 2, hash_erase / 1"},"hash:hash_stat/1":{"prefix":"hash_stat","body":"hash_stat(${1:Table})$2\n$0","description":"hash_stat(+Table)\n\n   Prints statistics about the hash table\n\nArguments\n   Table    A hash table\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_stat(+) is det\n\nSee Also\n   hash_create / 1"},"hash:hash_set/3":{"prefix":"hash_set","body":"hash_set(${1:Table}, ${2:Key}, ${3:Value})$4\n$0","description":"hash_set(+Table, ++Key, +Value)\n\n   Add an (or modify the existing) entry with key Key and value Value to the hash table\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   Value    Any term\n\nType\n   library(hash)\n\nModes and Determinism\n   hash_set(+, ++, +) is det\n\nSee Also\n   hash_get / 3, hash_update / 4"},"hash:hash_terminate_suspensions/1":{"prefix":"hash_terminate_suspensions","body":"hash_terminate_suspensions(${1:Table})$2\n$0","description":"hash_terminate_suspensions(+Table)\n\n   Wake and terminate all suspensions attached to the hash table\n\nArguments\n   Table    Hash table\n\nType\n   library(hash)\n\nDescription\nWake all suspensions attached to the hash table and close the\n    \tcorresponding notification port. This informs the suspended goals that\n\tthere will be no further notifications, and gives them the opportunity\n\tto clean themselves up.  This should normally be done once the hash\n\ttable will no longer be used (or modified).\n    \n\nModes and Determinism\n   hash_terminate_suspensions(+) is det\n\nExamples\n   see hash_insert_suspension/3\n\nSee Also\n   hash_create / 1, hash_insert_suspension / 3"},"hash:hash_update/4":{"prefix":"hash_update","body":"hash_update(${1:Table}, ${2:Key}, ${3:OldValue}, ${4:NewValue})$5\n$0","description":"hash_update(+Table, ++Key, -OldValue, +NewValue)\n\n   Lookup and replace the value stored under Key\n\nArguments\n   Table    A hash table\n   Key    a ground term\n   OldValue    Any term\n   NewValue    Any term\n\nType\n   library(hash)\n\nDescription\nA combination of hash_get/3 and hash_set/3, but more efficient\n    \tbecause there is only one hash lookup.\n\nModes and Determinism\n   hash_update(+, ++, -, +) is semidet\n\nFail Conditions\n   No entry for Key\n\nExamples\n   \n\t?- hash_create(H),\n\t   hash_set(H, k, hello),\n\t   hash_update(H, k, Old, world),\n\t   hash_get(H, k, New).\n\n\tOld = hello\n\tNew = world\n\tYes (0.00s cpu)\n\n\t% sample code based on hash_update/4:\n    \thash_inc(H, Key) :-\n\t    hash_update(H, Key, N0, N1),\n\t    N1 is N0+1.\n\n    \thash_addto(H, Key, Value) :-\n\t    hash_update(H, Key, Values, [Value|Values]).\n    \n\nSee Also\n   hash_get / 3, hash_set / 3"},"hash:list_to_hash/4":{"prefix":"list_to_hash","body":"list_to_hash(${1:KeyPos}, ${2:ValPos}, ${3:List}, ${4:Table})$5\n$0","description":"list_to_hash(+KeyPos, +ValPos, +List, ?Table)\n\n   Enter a list of items into a (new or existing) hash table\n\nArguments\n   KeyPos    Key position (non-negative integer)\n   ValPos    Value position (non-negative integer)\n   List    List of structures\n   Table    A hash table or variable\n\nType\n   library(hash)\n\nDescription\n\n    This predicate takes a list of structures, and makes an entry\n    into a hash table for every list element.  The KeyPos argument \n    determines which structure argument will be used as the key,\n    and ValPos determines which structure argument will be used as\n    the value.  KeyPos and/or ValPos can be set to 0, indicating that\n    the whole structure should be used, rather than just one argument.\n    This makes this predicate quite versatile and avoids the need\n    to construct auxiliary lists.\n    \n    The hash table itself may already exist, in which case the new\n    entries will be added to the table, possibly replacing existing\n    entries with the same key.  If Table is a free variable, a fresh\n    hash table will be implicitly created (as with hash_create/1).\n    \n    When working with struct-notation, KeyPos and ValPos can also\n    be symbolic terms like `author of book'.\n    \n    \n\nModes and Determinism\n   list_to_hash(+, +, +, -) is det\n   list_to_hash(+, +, +, +) is det\n\nExamples\n   \n    % To enter a Key-Value list, use positions 1 and 2:\n    ?- Data = [a-one,c-three,b-two],\n    list_to_hash(1, 2, Data, Hash),\n    hash_get(Hash, b, X).\n\n    X = two\n    Yes (0.00s cpu)\n\n    % To enter structures using one of their arguments as the key:\n    ?- Data = [emp(jo,12),emp(ed,7),emp(al,4)],\n    list_to_hash(2, 0, Data, Hash),\n    hash_get(Hash, 7, X).\n\n    X = emp(ed, 7)\n    Yes (0.00s cpu)\n\n    % You can incrementally add to/update an existing hash table:\n    ?- hash_create(Hash),\n    hash_set(Hash, d, four),\n    list_to_hash(1, 2, [a-one,c-three,b-two], Hash),\n    list_to_hash(1, 2, [c-new,e-five], Hash),\n    hash_list(Hash, Keys, Values).\n\n    Keys = [d, e, a, b, c]\n    Values = [four, five, one, two, new]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   hash_create / 1, hash_set / 3, struct / 1"},"heaps:add_to_heap/4":{"prefix":"add_to_heap","body":"add_to_heap(${1:OldHeap}, ${2:Key}, ${3:Datum}, ${4:NewHeap})$5\n$0","description":"add_to_heap(+OldHeap, +Key, +Datum, -NewHeap)\n\n   inserts the new Key-Datum pair into the heap\n\nType\n   library(heaps)\n\nDescription\n\n    inserts the new Key-Datum pair into the heap.  The insertion is\n    not stable, that is, if you insert several pairs with the same\n    Key it is not defined which of them will come out first, and it\n    is possible for any of them to come out first depending on the \n    history of the heap.  If you need a stable heap, you could add\n    a counter to the heap and include the counter at the time of\n    insertion in the key.  If the free list is empty, the tree will\n    be grown, otherwise one of the empty slots will be re-used.  (I\n    use imperative programming language, but the heap code is as \n    pure as the trees code, you can create any number of variants\n    starting from the same heap, and they will share what common\n    structure they can without interfering with each other.)"},"heaps:get_from_heap/4":{"prefix":"get_from_heap","body":"get_from_heap(${1:OldHeap}, ${2:Key}, ${3:Datum}, ${4:NewHeap})$5\n$0","description":"get_from_heap(+OldHeap, ?Key, ?Datum, -NewHeap)\n\n   returns the Key-Datum pair in OldHeap with the smallest Key\n\nType\n   library(heaps)\n\nDescription\n\n    returns the Key-Datum pair in OldHeap with the smallest Key, and\n    also a New Heap which is the Old Heap with that pair deleted.\n    The easy part is picking off the smallest element.  The hard part\n    is repairing the heap structure.  repair_heap/4 takes a pair of\n    heaps and returns a new heap built from their elements, and the\n    position number of the gap in the new tree.  Note that repair_heap\n    is *not* tail-recursive."},"heaps:heap_size/2":{"prefix":"heap_size","body":"heap_size(${1:Heap}, ${2:Size})$3\n$0","description":"heap_size(+Heap, ?Size)\n\n   reports the number of elements currently in the heap\n\nType\n   library(heaps)"},"heaps:heap_to_list/2":{"prefix":"heap_to_list","body":"heap_to_list(${1:Heap}, ${2:List})$3\n$0","description":"heap_to_list(+Heap, -List)\n\n   returns the current set of Key-Datum pairs in the Heap as a List.\n\nType\n   library(heaps)\n\nDescription\n\n    returns the current set of Key-Datum pairs in the Heap as a\n    List, sorted into ascending order of Keys.  This is included\n    simply because I think every data structure foo ought to have\n    a foo_to_list and list_to_foo relation (where, of course, it\n    makes sense!) so that conversion between arbitrary data\n    structures is as easy as possible.  This predicate is basically\n    just a merge sort, where we can exploit the fact that the tops\n    of the subtrees are smaller than their descendants."},"heaps:heaps_desc":{"prefix":"lib","body":"lib(${1:heaps})$2\n$0","description":"lib(heaps)\n\n    A heap is a labelled binary tree where the key of each node is less\n    than or equal to the keys of its sons.  The point of a heap is that\n    we can keep on adding new elements to the heap and we can keep on\n    taking out the minimum element.  If there are N elements total, the\n    total time is O(NlgN).  If you know all the elements in advance, you\n    are better off doing a merge-sort, but this file is for when you\n    want to do say a best-first search, and have no idea when you start\n    how many elements there will be, let alone what they are.\n\n    A heap is represented as a triple t(N, Free, Tree) where N is the\n    number of elements in the tree, Free is a list of integers which\n    specifies unused positions in the tree, and Tree is a tree made of\n\n\tt\t\t\tterms for empty subtrees and\n\tt(Key,Datum,Lson,Rson)\tterms for the rest\n\n    The nodes of the tree are notionally numbered like this:\n\n\t\t\t\t    1\n\t\t     2\t\t\t\t    3\n    4    6    5    7\n    8      12      10     14       9       13      11     15\n      ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..\n\n    The idea is that if the maximum number of elements that have been in\n    the heap so far is M, and the tree currently has K elements, the tree\n    is some subtreee of the tree of this form having exactly M elements,\n    and the Free list is a list of K-M integers saying which of the \n    positions in the M-element tree are currently unoccupied.  This free\n    list is needed to ensure that the cost of passing N elements through\n    the heap is O(NlgM) instead of O(NlgN).  For M say 100 and N say 10^4\n    this means a factor of two.  The cost of the free list is slight.\n    The storage cost of a heap in a copying Prolog (which Dec-10 Prolog is\n    not) is 2K+3M words."},"heaps:list_to_heap/2":{"prefix":"list_to_heap","body":"list_to_heap(${1:List}, ${2:Heap})$3\n$0","description":"list_to_heap(+List, -Heap)\n\n   takes a list of Key-Datum pairs and forms them into a heap\n\nType\n   library(heaps)\n\nDescription\n\n    takes a list of Key-Datum pairs (such as keysort could be used to\n    sort) and forms them into a heap.  We could do that a wee bit\n    faster by keysorting the list and building the tree directly, but\n    this algorithm makes it obvious that the result is a heap, and\n    could be adapted for use when the ordering predicate is not @<\n    and hence keysort is inapplicable."},"heaps:min_of_heap/3":{"prefix":"min_of_heap","body":"min_of_heap(${1:Heap}, ${2:Key}, ${3:Datum})$4\n$0","description":"min_of_heap(+Heap, ?Key, ?Datum)\n\n   returns the Key-Datum pair at the top of the heap\n\nType\n   library(heaps)\n\nDescription\n\n    returns the Key-Datum pair at the top of the heap (which is of\n    course the pair with the smallest Key), but does not remove it\n    from the heap.  It fails if the heap is empty."},"heaps:min_of_heap/5":{"prefix":"min_of_heap","body":"min_of_heap(${1:Heap}, ${2:Key1}, ${3:Datum1}, ${4:Key2}, ${5:Datum2})$6\n$0","description":"min_of_heap(+Heap, ?Key1, ?Datum1, ?Key2, ?Datum2)\n\n   returns the smallest and second smallest pairs in the heap\n\nType\n   library(heaps)\n\nDescription\n\n    returns the smallest (Key1) and second smallest (Key2) pairs in\n    the heap, without deleting them.  It fails if the heap does not\n    have at least two elements."},"http_client:http_client/7":{"prefix":"http_client","body":"http_client(${1:Method}, ${2:Uri}, ${3:ObjectBody}, ${4:HttpParams}, ${5:RespError}, ${6:RespParam}, ${7:RespObjectBody})$8\n$0","description":"http_client(+Method, +Uri, +ObjectBody, +HttpParams, -RespError, -RespParam, -RespObjectBody)\n\n   Used to access HTML pages, given their URI (the method GET is applied)\n\nArguments\n   Method    A string\n   Uri    A string\n   ObjectBody    A string\n   HttpParams    A list of terms as defined in the DCG grammar\n   RespError    Outputs a term error(ErrorCode, ErrorPhrase),\n\twhere ErrorCode is he error code contained in the response\n\tand ErrorPhrase is the error phrase contained in the response\n   RespParam    Outputs a list of terms as defined in the DCG grammar\n   RespObjectBody      Outputs the object body of the response\n\nType\n   library(http_client)\n\nExamples\n   \n    [eclipse 1]: use_module(http).\n    http_grammar.pl compiled traceable 25048 bytes in 0.38 seconds\n    http_client.pl compiled traceable 5916 bytes in 0.47 seconds\n    http_server.pl compiled traceable 5304 bytes in 0.07 seconds\n    http.pl    compiled traceable 0 bytes in 0.57 seconds\n\n    yes.\n    [eclipse 2]:  http_client(\"GET\", \"http://www.ecrc.de/staff/\", \"\", [],\n\t    Status, Param, Resp).\n\n    Status = error(200, \"Document follows \")\n    Param = [date, server, contentType(mt(text, html))]\n\n    Resp = \"<HTML>...</HTML>\"\n\n    yes."},"http_client:http_compile/1":{"prefix":"http_compile","body":"http_compile(${1:Url})$2\n$0","description":"http_compile(+Url)\n\n   Compile an ECLiPSe source file, given its URL\n\nArguments\n   Url    A string\n\nType\n   library(http_client)\n\nDescription\nThis utility downloads an eclipse source file (given its URL)\n    and compiles it. Note that this represents a security risk: the downloaded\n    code may contain Eclipse commands that are executed on your computer.\n    Make sure you trust the code that you download!\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    [eclipse 1]: lib(http_client).\n    yes.\n    [eclipse 2]: http_compile(\"http://icparc.ic.ac.uk/eclipse/examples/sendmore.pl\").\n    yes.\n    [eclipse 8]: sendmore1(X).\n    X = [9, 5, 6, 7, 1, 0, 8, 2]     More? (;) \n    no (more) solution."},"http_client:http_open/2":{"prefix":"http_open","body":"http_open(${1:Url}, ${2:Stream})$3\n$0","description":"http_open(+Url, -Stream)\n\n   Download a web document given its URL and open a Stream to read it\n\nArguments\n   Url    A string\n   Stream    A variable or atom\n\nType\n   library(http_client)\n\nDescription\nThis utility downloads a web document (given its URL) into a\n    string stream and returns that string stream's identifier for reading.\n\nExamples\n   \n    [eclipse 1]: lib(http_client).\n    yes.\n    [eclipse 2]: http_open(\"http://icparc.ic.ac.uk/index.html\",S),\n    read_string(S, end_of_line, _, L).\n    S = 19\n    L = \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 3.2//EN\\\">\"\n    yes."},"http_server:http_server/1":{"prefix":"http_server","body":"http_server(${1:Port})$2\n$0","description":"http_server(+Port)\n\n   Start an http server\n\nArguments\n   Method    An integer port number\n\nType\n   library(http_server)\n\nDescription\n\n    The server does: \n    \n     creation of a socket, bind it to current Host and given Port and listen \n     accept a connection on the socket \n     reception of a request \n     decoding of the request (method + url + http param init) \n     call the predicate http_method in module http_method \n     encoding of the response (depending on server function) \n     send the response on the socket \n    \n    NOTE:  The predicate http_server/1 requires that a module http_method\n    is defined that contains a predicate http_method/6.  This predicate is\n    used by the programmer to customize the server.  For instance the\n    method GET can be simply implemented.  The programmer can define its\n    own methods. \n    \n    A simple example of server is the implementation of the method\n    GET.  A module is created that contains the predicate\n    http_method/6 that implements the method GET:  a read on the file\n    identified by its URL.  The file is returned if it is found,\n    otherwise an error parameter is returned. \n    \n    This simple program can be used to test HTML pages.  Viewers such\n    as Netscape provide a view code option that signalizes syntax\n    errors in the HTML code.  This simple program can be used as a\n    light weight testing tool, possibly launched from the directory\n    where the HTML page resides. \n    \n\nExamples\n   \n    [eclipse 1]: [user].\n     \n    /********************************************************************\n     *  test (server)\n     *******************************************************************/\n\n    :- module(http_method).\n\n    :- set_error_handler(170, fail/0).\n    :- set_error_handler(171, fail/0).\n\n    /* \n    http_method(+Method, +Url, +ObjectBody, -Output, -StatusCode, -Parameter)\n    executes the method on the object and returns:\n    - the output of the method (possibly empty)\n    - a status code for the response status line\n    - a list of http parameters (in particular the length of the object body).\n\n    */\n\n    http_method(\"GET\", Url, _, Contents, 200, [contentLength(CL)]):-\n\t    append_strings(\"/\", FileName, Url),\n\t    getContents(FileName, Contents), !,\n\t    string_length(Contents, CL).\n    http_method(\"GET\", _, _, \"\", 404, []).\n\t    \n\n    getContents(Url, Contents):-\n\t    open(Url, read, S),\n\t    read_string(S, \"\", _, Contents),\n\t    close(S).\n\n    ^D\n\n    yes.\n\n    [eclipse 2]: use_module(http).\n    http_grammar.pl compiled traceable 25048 bytes in 0.27 seconds\n    http_client.pl compiled traceable 6052 bytes in 0.28 seconds\n    http_server.pl compiled traceable 5564 bytes in 0.03 seconds\n    http.pl    compiled traceable 0 bytes in 0.35 seconds\n\n    yes.\n    [eclipse 3]: use_module(http_method).\n\n    yes.\n    [eclipse 4]: http_server(8000)."},"http_server:http_server/2":{"prefix":"http_server","body":"http_server(${1:Port}, ${2:Pending})$3\n$0","description":"http_server(+Port,+Pending)\n\n   Start an http server with allows the specified number of pending connections\n\nArguments\n   Method    An integer port number\n   Pending    The number of simultaneous connections to queue up before rejecting\n\nType\n   library(http_server)\n\nDescription\nhttp_server/1 corresponds to a pending queue size of 1."},"ic_cumulative:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (fd variables or integers)\n   Durations    Collection of duration for tasks (fd variables or integers)\n   Resources    Collection of resource uages by tasks (fd variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(ic_cumulative)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of finite\n   domain variable or integers.  ResourceLimit is an integer.  The\n   declarative meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n   The (ic/fd)_edge_finder and (ic/fd)_edge_finder3 libraries implementation\n   of this predicate can provide stronger propagations.\n\nSee Also\n   profile / 4, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, gfd : cumulative / 4"},"ic_cumulative:ic_cumulative_desc":{"prefix":"lib","body":"lib(${1:ic_cumulative})$2\n$0","description":"lib(ic_cumulative)\n\n       This library implements the cumulative scheduling constraint for the\n    IC solver.  It provides weaker propagation than the two edge finder\n    libraries: ic_edge_finder and ic_edge_finder3."},"ic_cumulative:profile/4":{"prefix":"profile","body":"profile(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Profile})$5\n$0","description":"profile(+StartTimes, +Durations, +Resources, ?Profile)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (fd variables or integers)\n   Durations    Collection of duration for tasks (fd variables or integers)\n   Resources    Collection of resource usages by tasks (fd variables or integers)\n   Profile    List of resource usage at the start of each task\n\nType\n   library(ic_cumulative)\n\nDescription\n\n   StartTimes, Durations and Resources are collections (a la\n   collection_to_list/2) of equal size N of finite domain variable or\n   integers, with the same meaning as in cumulative/4.\n   Profile is unified with a list of length N of finite domain variables or\n   integers indicating the level of resource usage at the starting point of\n   each task.\n\nSee Also\n   cumulative / 4, lists : collection_to_list / 2"},"ic_edge_finder:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    List of start times for tasks (integer variables or integers)\n   Durations    List of duration for tasks (integer variables or integers)\n   Resources    List of resource uages by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(ic_edge_finder)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of integer\n   variables or integers.  ResourceLimit is an integer. The declarative\n   meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\n   This constraint can propagate more information than the implementation\n   in library(ic_cumulative) and library(cumulative).\n\nSee Also\n   disjunctive / 2, cumulative / 5, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"ic_edge_finder:cumulative/5":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Areas}, ${5:ResourceLimit})$6\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, +Areas, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   Resources    Collection of resource usages by tasks (integer variables or integers)\n   Areas    Collection of areas covered by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(ic_edge_finder)\n\nDescription\n\n   In this variant, an area (the product of duration and resource usage of\n   a task) can be specified, e.g. if duration or reource usage are not\n   known in advance. The edge-finder algorithm can make use of this information\n   to derive bound updates.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive / 2, cumulative / 4, lists : collection_to_list / 2, edge_finder3 : cumulative / 5, edge_finder : cumulative / 5, ic_edge_finder3 : cumulative / 5"},"ic_edge_finder:disjunctive_bools/3":{"prefix":"disjunctive_bools","body":"disjunctive_bools(${1:StartTimes}, ${2:Durations}, ${3:OrderingBools})$4\n$0","description":"disjunctive_bools(+StartTimes, +Durations, ?OrderingBools)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   OrderingBools       Variable, or list of ordering Booleans (variable or 0 or 1)\n\nType\n   library(ic_edge_finder)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    OrderingBools is a list of ordering Booleans. For each possible pair of\n    tasks, there is one Boolean which describes the order of these two tasks.\n    If the Tasks are numbered 1..N, and the Booleans are numbered\n    1..N*(N-1)//2, then the Boolean corresponding to the task pair I,J\n    (with I>J) has the index (I-1)(I-2)//2 + J.  In other words, the\n    OrderingBools list is a flattened version of a strictly lower\n    triangular matrix of ordering Booleans, i.e.\n    \n    I\\J|  1    2    3    4    5\n    ---+--------------------------\n    1  |  .    .    .    .    .\n    2  | B[1]  .    .    .    .\n    3  | B[2] B[3]  .    .    .\n    4  | B[4] B[5] B[6]  .    .\n    5  | B[7] B[8] B[9] B[10] .\n    \n    The Boolean being set to 1 indicates that task I is before task J,\n    a value of 0 indicates that task J is before task I. If uninstantiated,\n    the order is not (yet) determined. Operationally, the constraint will\n    both infer start time bounds from the setting of the Booleans, and\n    infer Boolean settings from the start times and durations.\n\n    The Booleans should be used for making search choices, typically by\n    setting them such that a task is chosen to be first (or last) among\n    a group of tasks.\n\n    Any Start and Duration variables which do not already have finite bounds\n    will be given default bounds of -10000000 to 10000000. The Booleans on\n    the other hand can be domainless variables, and the only way in which\n    the constraint will affect them is by instantiation to 0 or 1.\n\nModes and Determinism\n   disjunctive_bools(+, +, +)\n   disjunctive_bools(+, +, -)\n\nSee Also\n   disjunctive / 2, lists : collection_to_list / 2, edge_finder3 : disjunctive_bools / 3, edge_finder : disjunctive_bools / 3, ic_edge_finder3 : disjunctive_bools / 3"},"ic_edge_finder:disjunctive/2":{"prefix":"disjunctive","body":"disjunctive(${1:StartTimes}, ${2:Durations})$3\n$0","description":"disjunctive(+StartTimes, +Durations)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n\nType\n   library(ic_edge_finder)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    Any input variables which do not already have finite bounds will be\n    given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive_bools / 3, lists : collection_to_list / 2, edge_finder3 : disjunctive / 2, edge_finder : disjunctive / 2, ic_edge_finder3 : disjunctive / 2, gfd : disjunctive / 2"},"ic_edge_finder:ic_edge_finder_desc":{"prefix":"lib","body":"lib(${1:ic_edge_finder})$2\n$0","description":"lib(ic_edge_finder)\n\n   \n    This library implements the quadratic edge-finder algorithm for the\n    disjunctive and cumulative scheduling constraints for the IC solver.\n    It provides stronger propagation than the ic_cumulative library, but\n    weaker than the cubic ic_edge_finder3 library for cumulative\n    constraints.  It is however computationally cheaper than the\n    ic_edge_finder3 library.\n\n    Note that the same predicates are implemented in both ic_edge_finder\n    and ic_edge_finder3 libraries."},"http:http_desc":{"prefix":"lib","body":"lib(${1:http})$2\n$0","description":"lib(http)\n\n    The HTTP library contains an extensible server and a client for the\n    Hyper Text Transfer Protocol.  The library is entirely written in ECLiPSe. \n    \n    Typical use of the client is for building WWW \"Worms\", WWW\n    \"Robots\" or customized WWW browsers.  Typical use of the server is\n    for building customized servers, e.g.  dynamic generation of HTML\n    pages.  The server and the client can typically be used together\n    to build proxy servers. \n    \n    Limitations and Bugs: \n    \n     The current version of the server is sequential. \n     The MIME and HTTP grammar is not complete and may fail\n\tparsing some sentences generated by existing browsers and servers. \n    \n    The library consists of two sub-modules, http_client and http_server,\n    which can also be loaded separately.\n    \n    The structure of the HTTP messages is precisely described in the\n    specification document (http://www.w3.org/pub/WWW/Protocols/).  An\n    augmented BNF is provided for each component of the header.  We\n    have used the DCG (Definite Clause Grammar) mechanism of ECLiPSe\n    to encode the grammar, that we use for both parsing (from HTTP\n    messages into Prolog terms) and pretty printing (from prolog terms\n    into HTTP messages). \n    \n    This DCG grammar may have to be modified with the evolutions of\n    the HTTP protocol (standard modification and available client or\n    server implementations)."},"ic:EL/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX =< ?ExprY)\n\n   ExprX is less than or equal to ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX to be less than or equal to ExprY.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   < / 2, =:= / 2, >= / 2, > / 2, =\\= / 2, #=< / 2, =< / 3, =< / 2, eplex : =< / 2, iso_strict : =< / 2, iso_light : =< / 2, suspend : =< / 2"},"ic:ENE/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX =:= ?ExprY)\n\n   ExprX is equal to ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX and ExprY to be equal.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   < / 2, =< / 2, >= / 2, > / 2, =\\= / 2, #= / 2, =:= / 3, =:= / 2, eplex : =:= / 2, iso_strict : =:= / 2, iso_light : =:= / 2, suspend : =:= / 2"},"ic:ERE/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX =\\= ?ExprY)\n\n   ExprX is not equal to ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX and ExprY to be different.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   < / 2, =< / 2, >= / 2, > / 2, =:= / 2, #\\= / 2, =\\= / 3, =\\= / 2, iso_strict : =\\= / 2, iso_light : =\\= / 2, suspend : =\\= / 2"},"ic:G/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX > ?ExprY)\n\n   ExprX is strictly greater than ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX to be strictly greater than ExprY.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   < / 2, =< / 2, =:= / 2, >= / 2, =\\= / 2, #> / 2, > / 3, > / 2, iso_strict : > / 2, iso_light : > / 2, suspend : > / 2"},"ic:GE/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX >= ?ExprY)\n\n   ExprX is greater than or equal to ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX to be greater than or equal to ExprY.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   < / 2, =< / 2, =:= / 2, > / 2, =\\= / 2, #>= / 2, >= / 3, >= / 2, eplex : >= / 2, iso_strict : >= / 2, iso_light : >= / 2, suspend : >= / 2"},"ic:L/2":{"prefix":"ic","body":"ic","description":"ic:(?ExprX < ?ExprY)\n\n   ExprX is strictly less than ExprY.\n\nArguments\n   ExprX    Arithmetic expression\n   ExprY    Arithmetic expression\n\nType\n   library(ic)\n\nDescription\n\n   Constrains ExprX to be strictly less than ExprY.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   =< / 2, =:= / 2, >= / 2, > / 2, =\\= / 2, #< / 2, < / 3, < / 2, iso_strict : < / 2, iso_light : < / 2, suspend : < / 2"},"ic:ac_eq/3":{"prefix":"ac_eq","body":"ac_eq(${1:X}, ${2:Y}, ${3:C})$4\n$0","description":"ac_eq(?X, ?Y, ++C)\n\n   Arc-consistent implementation of X #= Y + C.\n\nArguments\n   X    Variable or integer\n   Y    Variable or integer\n   C    Integer constant\n\nType\n   library(ic)\n\nDescription\n\n   This constraint implements an arc-consistent version of X #= Y + C (i.e.\n   any \"holes\" in the domain of X are propagated to Y and vice-versa).\n\n   A range error is thrown if X and Y do not have \"reasonable\" bounds\n   (roughly +/- 2^30 on a 32-bit machine, roughly +/- 2^52 on a 64-bit\n   machine: note that even much smaller bounds than this can lead to\n   available memory being exhausted very rapidly, if not immediately).\n\nSee Also\n   #= / 2"},"ic:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:Vars})$2\n$0","description":"alldifferent(+Vars)\n\n   Constrains all elements of a list to be pairwise different.\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n\nType\n   library(ic)\n\nDescription\n\n   Constrains all elements of a collection to be pairwise different (and\n   integral).  Effectively imposes #\\= constraints on every pair of\n   elements from Vars.\n\nSee Also\n   #\\= / 2, fd : alldifferent / 1, ic_global : alldifferent / 1, ic_symbolic : alldifferent / 1, sd : alldifferent / 1, gfd : alldifferent / 1, fd_global : alldifferent / 1, ic_global_gac : alldifferent / 1, fd_global_gac : alldifferent / 1, lists : collection_to_list / 2"},"ic:alldifferent_cst/2":{"prefix":"alldifferent_cst","body":"alldifferent_cst(${1:Vars}, ${2:Offsets})$3\n$0","description":"alldifferent_cst(+Vars, ++Offsets)\n\n   The values of each element plus corresponding offset are pair-wise different.\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n   Offsets    A collection (a la collection_to_list/2) of integers, with the same cardinality as Vars.\n\nType\n   library(ic)\n\nDescription\n\n   Constrains all elements of Vars plus their corresponding offset value in\n   Offset to be different. That is,\n\n    Vari + Offseti #\\= Varj + Offsetj  % if i \\= j\n\n   where Vari, Offseti are the i'th element of Vars and Offsets, and\n   Varj, Offsetj are the j'th element.\n\nSee Also\n   alldifferent / 1, lists : collection_to_list / 2"},"ic:and/3":{"prefix":"and","body":"and(${1:ConX}, ${2:ConY}, ${3:Bool})$4\n$0","description":"and(+ConX,+ConY,Bool)\n\n   Bool is the reified truth of both constraints ConX and ConY being true.\n\nArguments\n   ConX    Constraint\n   ConY    Constraint\n   Bool    Reified truth value of the constraint\n\nType\n   library(ic)\n\nDescription\n\n   Equivalent to BX $= (ConX), BY $= (ConY), Bool #= (BX + BY #= 2)\n   \n   The two constraints are reified in such a way that Bool reflects the\n   truth of both being true.  ConX and ConY must be constraints that have a\n   corresponding reified form.\n\nSee Also\n   and / 2, neg / 1, neg / 2, or / 2, or / 3, => / 2, => / 3, =:= / 3, =< / 3, =\\= / 3, >= / 3, > / 3, < / 3"},"ic:delayed_goals_number/2":{"prefix":"delayed_goals_number","body":"delayed_goals_number(${1:Var}, ${2:Number})$3\n$0","description":"delayed_goals_number(?Var, -Number)\n\n   Returns the number of goals delayed on the ic attribute of Var.\n\nArguments\n   Var    Variable or term\n   Number    Number of goals delayed on the ic attribute of Var.\n\nType\n   library(ic)\n\nDescription\n   N is the number of constraints and suspended goals currently attached to\n   the IC attribute of the variable Var.  Note that this number may not\n   correspond to the exact number of different constraints attached to Var,\n   as goals in different suspension lists are counted separately, and a\n   constraint may decompose into more than one suspension.  This predicate\n   is often used when looking for the most or least constrained variable\n   from a set of domain variables.  If Var is not a variable, N is bound to\n   1.0Inf; otherwise if Var is not an IC variable, N is zero.\n\n   Note that this predicate only counts goals attached to the IC attribute;\n   if you want to count all goals attached to a variable, use the generic\n   delayed_goals_number/2.\n\nModes and Determinism\n   delayed_goals_number(?, -) is det\n\nSee Also\n   delayed_goals_number / 2, ic_kernel : delayed_goals_number / 2"},"ic:delete/5":{"prefix":"delete","body":"delete(${1:X}, ${2:List}, ${3:R}, ${4:Arg}, ${5:Select})$6\n$0","description":"delete(-X, +List, -R, ++Arg, ++Select)\n\n   Choose a domain variable from a list according to selection criterion.\n\nArguments\n   X    a free variable\n   List    a list of variables or terms \n   R    a free variable \n   Arg    an integer\n   Select    the name of the selection criterion\n\nType\n   library(ic)\n\nDescription\n\nThis predicate chooses one entry in a list of variables or terms based\non some selection criterion.  The criteria are explained in detail in\nthe search/6 predicate. The selected entry is returned in X, with\nthe rest of the list without X returned in R.\n\nFail Conditions\n   fails if the list is empty\n\nResatisfiable\n   no\n\nExamples\n   \n\nSee Also\n   search / 6"},"ic:element/3":{"prefix":"element","body":"element(${1:Index}, ${2:List}, ${3:Value})$4\n$0","description":"element(?Index, ++List, ?Value)\n\n   Value is the Index'th element of the integer list List.\n\nArguments\n   ?Index    A variable or an integer.\n   ++List    A non-empty list or array of integers.\n   ?Value    A variable or an integer.\n\nType\n   library(ic)\n\nDescription\nThis constraint can be used in a variety of programs to state a\n   relation between two domain variables.  List is a list of integers and\n   the constraint states that its Index'th element is equal to Value, i.e.\n\n\t\t\t     List_Index = Value\n\n   Every time Index or Value is updated, this constraint is activated and\n   the domain of the other variable is updated accordingly.\n\nFail Conditions\n   Fails if Value is not the Index'th element of List.\n\nResatisfiable\n   No.\n\nExamples\n   \n   [eclipse 13]: element(I, [1,3,6,3], V).\n   I = I{1 .. 4}\n   V = V{[1, 3, 6]}\n   Delayed goals:\n   element(I{1 .. 4}, [1, 3, 6, 3], V{[1, 3, 6]})\n   yes.\n   [eclipse 14]: element(I, [1,3,6,3], V), V #\\= 3.\n   I = I{[1, 3]}\n   V = V{[1, 6]}\n   Delayed goals:\n   element(I{[1, 3]}, [1, 3, 6, 3], V{[1, 6]})\n   yes.\n\nSee Also\n   :: / 2"},"ic:get_bounds/3":{"prefix":"get_bounds","body":"get_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current bounds of Var.\n\nArguments\n   Var    A variable or a number\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the upper and lower bounds of Var.  Lo and Hi\n   return the minimum and maximum (respectively) of the variable's interval.\n   If the variable is integer and a bound is finite, then that bound will be\n   returned as an integer; in all other cases it will be returned as a\n   float.  If Var has not been declared before, it will be turned into an\n   unrestricted real variable.  If Var is a ground number, Lo and Hi will\n   give appropriate bounds based on the type and value of Var: exact bounds\n   for floats, bounded reals and integers, and best safe approximations for\n   rationals.\n\nModes and Determinism\n   get_bounds(?, -, -) is det\n\nSee Also\n   get_min / 2, get_max / 2, get_float_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3, get_delta / 2, get_median / 2"},"ic:get_delta/2":{"prefix":"get_delta","body":"get_delta(${1:Var}, ${2:Width})$3\n$0","description":"get_delta(?Var, -Width)\n\n   Returns the width of the interval of Var.\n\nArguments\n   Var    A variable or a number\n   Width    Width of the interval\n\nType\n   library(ic)\n\nDescription\n\n   Returns the width (Hi - Lo) of the interval of Var.  If Var has not been\n   declared before, it will be turned into an unrestricted real variable.\n   If Var is a ground number, the width will be calculated appropriately\n   based on its type.\n\nModes and Determinism\n   get_delta(?, -) is det\n\nSee Also\n   get_median / 2, get_bounds / 3"},"ic:get_domain/2":{"prefix":"get_domain","body":"get_domain(${1:Var}, ${2:Domain})$3\n$0","description":"get_domain(?Var, -Domain)\n\n   Returns a ground representation of the current IC domain of a variable.\n\nArguments\n   Var    An IC variable or a number.\n   Domain    A ground representation of the domain of Var.\n\nType\n   library(ic)\n\nDescription\n\n   If Var is a number, Domain will be unified with that number.\n\n   If Var is a real IC variable, Domain will be unified with the term\n   Lo..Hi where Lo and Hi are floats corresponding to the current lower\n   and upper bounds of Var, respectively.\n\n   If Var is an integer IC variable with no holes in its domain, Domain will\n   be unified with the term Lo..Hi where Lo and Hi are integers\n   corresponding to the current lower and upper bounds of Var, respectively.\n\n   If Var is an integer IC variable with holes in its domain, Domain will\n   be unified with an ordered list of integers and/or terms Lo..Hi where Lo\n   and Hi are integers; in this case the elements of the domain of Var are\n   exactly those integers appearing directly in the list or falling within\n   any of the intervals Lo..Hi.\n\nModes and Determinism\n   get_domain(?, -) is det\n\nFail Conditions\n   The initial value of DomainList fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither an IC variable or number.\n\nSee Also\n   get_domain_as_list / 2, get_bounds / 3"},"ic:get_domain_as_list/2":{"prefix":"get_domain_as_list","body":"get_domain_as_list(${1:Var}, ${2:DomainList})$3\n$0","description":"get_domain_as_list(?Var, -DomainList)\n\n   List of all the elements in the IC domain of Var\n\nArguments\n   Var    An IC variable or a number\n   DomainList    The domain of Var as a list of elements.\n\nType\n   library(ic)\n\nDescription\n\n   If Var is an integer IC variable, DomainList will be set to an ordered\n   list containing each element in the domain of Var.  If Var is a number,\n   then DomainList will be set to a singleton list containing the number.\n\n   Currently, an out of range exception would be raised if Var is an IC \n   variable of type real.  This may change in the future.\n\nModes and Determinism\n   get_domain_as_list(?, -) is det\n\nFail Conditions\n   The initial value of DomainList fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither an IC variable or number.\n     6 --- Var is a IC variable of type real.\n\nSee Also\n   get_domain / 2, get_bounds / 3"},"ic:get_domain_size/2":{"prefix":"get_domain_size","body":"get_domain_size(${1:Var}, ${2:Size})$3\n$0","description":"get_domain_size(?Var, -Size)\n\n   Size is the number of integer elements in the IC domain for Var\n\nArguments\n   Var    An IC variable or a number\n   Size    A variable (or integer)\n\nType\n   library(ic)\n\nDescription\n\n   If Var is an integer IC variable, Size will be set to the number of \n   integer values in the domain of Var.  If Var is a number, then Size \n   will be set to 1.\n\n   Currently, an out of range exception would be raised if Var is an IC \n   variable of type real.  This may change in the future.\n\nModes and Determinism\n   get_domain_size(?, -) is det\n\nFail Conditions\n   The initial value of Size fails to unify with the returned value.\n\nExceptions\n     5 --- Var is neither an IC variable or number.\n     6 --- Var is a IC variable of type real.\n\nSee Also\n   get_delta / 2"},"ic:get_finite_integer_bounds/3":{"prefix":"get_finite_integer_bounds","body":"get_finite_integer_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_finite_integer_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current (finite, integral) bounds of Var.\n\nArguments\n   Var    A variable or a number\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the (finite, integral) upper and lower bounds of\n   Var.  Lo and Hi return the minimum and maximum (respectively) of the\n   variable's interval.  If Var has not been declared before, it will be\n   turned into an integer variable.  If Var is a real IC variable, it will\n   be constrained to be integral.  If any bound is infinite, it has a\n   default bound imposed to make it finite (-10000000 for lower bounds,\n   10000000 for upper bounds).  (These changes may cause propagation.)\n   Bounds are always returned as integers.  If Var is a ground integer, Lo\n   and Hi will unified with that integer.  All other cases result in a type\n   error.\n\nModes and Determinism\n   get_finite_integer_bounds(?, -, -) is det\n\nSee Also\n   get_bounds / 3, get_integer_bounds / 3, get_float_bounds / 3"},"ic:get_float_bounds/3":{"prefix":"get_float_bounds","body":"get_float_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_float_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current bounds of Var as floats.\n\nArguments\n   Var    A variable or a number\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the upper and lower bounds of Var.  Lo and Hi\n   return the minimum and maximum (respectively) of the variable's interval\n   in floating point format (regardless of the variable's type).  If Var has\n   not been declared before, it will be turned into an unrestricted real\n   variable.  If Var is a ground number, Lo and Hi will give appropriate\n   bounds based on the type and value of Var: exact bounds for floats,\n   bounded reals and exactly representable integers, and best safe\n   approximations for large integers and rationals.\n\nModes and Determinism\n   get_float_bounds(?, -, -) is det\n\nSee Also\n   get_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3, get_delta / 2, get_median / 2"},"ic:get_integer_bounds/3":{"prefix":"get_integer_bounds","body":"get_integer_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"get_integer_bounds(?Var, -Lo, -Hi)\n\n   Retrieve the current bounds of (integral) Var.\n\nArguments\n   Var    A variable or a number\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the upper and lower bounds of (integral) Var.\n   Lo and Hi return the minimum and maximum (respectively) of the variable's\n   interval.  If Var has not been declared before, it will be turned into an\n   unrestricted integer variable.  If Var is a real IC variable, it will be\n   constrained to be integral.  (These changes may cause propagation.)\n   Infinite bounds are returned as floating point numbers; all others are\n   returned as integers.  If Var is a ground integer, Lo and Hi will unified\n   with that integer.  All other cases result in a type error.\n\nModes and Determinism\n   get_integer_bounds(?, -, -) is det\n\nSee Also\n   get_bounds / 3, get_finite_integer_bounds / 3, get_float_bounds / 3"},"ic:get_max/2":{"prefix":"get_max","body":"get_max(${1:Var}, ${2:Hi})$3\n$0","description":"get_max(?Var, -Hi)\n\n   Retrieve the current upper bound of Var.\n\nArguments\n   Var    A variable or a number\n   Hi    Upper bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the upper bound of Var.  Hi returns the maximum\n   of the variable's interval.  If the variable is integer and the bound is\n   finite, then the bound will be returned as an integer; in all other cases\n   it will be returned as a float.  If Var has not been declared before, it\n   will be turned into an unrestricted real variable.  If Var is a ground\n   number, Hi will give an appropriate bound based on the type and value of\n   Var: an exact bound for floats, bounded reals and integers, and a best\n   safe approximation for rationals.\n\nModes and Determinism\n   get_max(?, -) is det\n\nSee Also\n   get_bounds / 3, get_float_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3"},"ic:get_min/2":{"prefix":"get_min","body":"get_min(${1:Var}, ${2:Lo})$3\n$0","description":"get_min(?Var, -Lo)\n\n   Retrieve the current lower bound of Var.\n\nArguments\n   Var    A variable or a number\n   Lo    Lower bound\n\nType\n   library(ic)\n\nDescription\n\n   Primitive for retrieving the lower bound of Var.  Lo returns the minimum\n   of the variable's interval.  If the variable is integer and the bound is\n   finite, then the bound will be returned as an integer; in all other cases\n   it will be returned as a float.  If Var has not been declared before, it\n   will be turned into an unrestricted real variable.  If Var is a ground\n   number, Lo will give an appropriate bound based on the type and value of\n   Var: an exact bound for floats, bounded reals and integers, and a best\n   safe approximation for rationals.\n\nModes and Determinism\n   get_min(?, -) is det\n\nSee Also\n   get_bounds / 3, get_float_bounds / 3, get_integer_bounds / 3, get_finite_integer_bounds / 3"},"ic:get_median/2":{"prefix":"get_median","body":"get_median(${1:Var}, ${2:Median})$3\n$0","description":"get_median(?Var, -Median)\n\n   Returns the median of the interval of the IC variable Var.\n\nArguments\n   Var    A variable or a number\n   Median    The median of the interval (float)\n\nType\n   library(ic)\n\nDescription\n\n   Returns the median of the interval of Var (usually so that the interval\n   can be split) as a float value.  If Var has not been declared before,\n   it will be turned into an unrestricted real variable as a side effect.\n   If Var is a ground number, the median is a float equal or near that\n   number.\n\n   Generally, the median splits the interval logarithmically so that the\n   two subintervals have roughly the same number of representable floats.\n   Only in the vicinity of zero, splitting is linear to prevent the sub-\n   intervals from getting too small.\n\nModes and Determinism\n   get_median(?, -) is det\n\nExamples\n   [eclipse 2]: X :: 10..1000, get_median(X, M).\nX = X{10 .. 1000}\nM = 100.0\nYes (0.00s cpu)\n\n[eclipse 3]: X :: -1..1000, get_median(X, M).\nX = X{-1 .. 1000}\nM = 11.633369384516794\nYes (0.00s cpu)\n\n[eclipse 4]: get_median(3, M).\nM = 3.0\nYes (0.00s cpu)\n\nSee Also\n   get_delta / 2, get_bounds / 3, get_float_bounds / 3"},"ic:get_solver_type/2":{"prefix":"get_solver_type","body":"get_solver_type(${1:Var}, ${2:Type})$3\n$0","description":"get_solver_type(?Var, -Type)\n\n   Retrieve the type of a variable.\n\nArguments\n   Var    A variable or a number\n   Type    Type of Var (real or integer)\n\nType\n   library(ic)\n\nDescription\n\n   Retrieve the type (the atom 'real' or the atom 'integer') of a variable\n   (or number).  If Var has not been declared before, it will be turned into\n   an unrestricted real variable.  If Var is a ground number, the type\n   returned will be appropriate for its type (i.e. if it's not an integer,\n   the type returned will be real).\n\nModes and Determinism\n   get_solver_type(?, -) is semidet\n\nFail Conditions\n   Var is not a variable or a number."},"ic:get_threshold/1":{"prefix":"get_threshold","body":"get_threshold(${1:Threshold})$2\n$0","description":"get_threshold(-Threshold)\n\n   Returns the current propagation threshold.\n\nArguments\n   Threshold    Current threshold\n\nType\n   library(ic)\n\nDescription\n\n   Returns the current threshold.  For non-integer variables, bounds are\n   only changed if the absolute and relative changes of the bound exceed the\n   threshold.  This means that constraints over real variables are only\n   guaranteed to be consistent up to the current threshold (over and above\n   any normal widening which occurs).\n\n   Limiting the amount of propagation is important for efficiency.  A higher\n   threshold speeds up computations, but reduces precision and may in the\n   extreme case prevent the system from being able to locate individual\n   solutions.\n\nModes and Determinism\n   get_threshold(-) is det\n\nSee Also\n   set_threshold / 1, set_threshold / 2"},"ic:ic_desc":{"prefix":"lib","body":"lib(${1:ic})$2\n$0","description":"lib(ic)\n\n   The IC (Interval Constraint) library is a hybrid integer/real interval\n   arithmetic constraint solver.  Its aim is to make it convenient for\n   programmers to write hybrid solutions to problems, mixing together\n   integer and real constraints and variables.\n\n   The integer constraints and variables are similar to those available in\n   the old finite domain library `fd'.  The real constraints are similar to\n   those that were available in the old real interval arithmetic library\n   `ria'.  Constraints which are not specifically integer constraints can be\n   applied to either real or integer variables (or a mix) seamlessly, and\n   any real variable can be converted to an integer variable at any time by\n   imposing an integrality constraint on it.\n\n   The IC library replaces the `fd', `ria' and `range' libraries (with a new\n   symbolic solver library providing the non-numeric functionality of `fd').\n   \n   For more information, see the IC section of the constraint library manual\n   or the documentation for the individual IC predicates.\n\n   The IC library solves constraint problems over the reals.  It is not\n   limited to linear constraints, so it can be used to solve general\n   problems like:\n   \n   [eclipse 2]: ln(X) $>= sin(X).\n\n   X = X{0.36787944117144228 .. 1.0Inf}\n   yes.\n   \n   \n   The IC library handles linear and non-linear, reified constraints and\n   user defined functions. \n   \n   User-defined functions/constraints are treated in a similar manner to\n   user defined functions found in expressions handled by is/2.  Note,\n   however, that user defined constraints/functions, when used in IC, should\n   be (semi-)deterministic.  User defined constraints/functions which leave\n   choice points may not behave as expected.\n   \n   Linear constraints are handled by a single propagator, whereas non-linear\n   constraints are broken down into simpler ternary/binary/unary\n   propagators.  The value of any constraint found in an expression is its\n   reified truth value (0..1).\n   \n   Variables appearing in arithmetic IC constraints at compile-time are\n   assumed to be IC variables unless they are wrapped in an eval/1\n   term.  The eval/1 wrapper inside arithmetic constraints is used to\n   indicate that a variable will be bound to an expression at run-time.\n   This feature will only be used by programs which generate their\n   constraints dynamically at run-time, for example.\n   \n   broken_sum(Xs,Sum):-\n       (\n\t   foreach(X,Xs),\n\t   fromto(Expr,S1,S2,0)\n       do\n\t   S1 = X + S2\n       ),\n       Sum $= Expr.\n   \n   \n   The above implementation of a summation constraint will not work as\n   intended because the variable Expr will be treated like an IC\n   variable when it is in fact the term +(X1,+(X2,+(...))) which is\n   constructed in the for-loop.  In order to get the desired functionality,\n   one must wrap the variable Expr in an eval/1.\n   \n   \n   working_sum(Xs,Sum):-\n       (\n\t   foreach(X,Xs),\n\t   fromto(Expr,S1,S2,0)\n       do\n\t   S1 = X + S2\n       ),\n       Sum $= eval(Expr).\n   \n   \n   The following arithmetic expression can be used inside the constraints:\n   \n   X\n\t    Variables.  If X is not yet an interval variable, it is turned \n\t    into one.\n\n   123\n\t    Integer constants.\n\n   0.1\n\t    Floating point constants.  These are assumed to be exact and\n\t    are converted to zero-width bounded reals.\n\n   0.1__0.2\n\t    Bounded real constants.\n\n   pi, e\n\t    Intervals enclosing the constants pi and e respectively.\n\n   inf\n\t    Floating point infinity.\n\n   +Expr\n\t    Identity.\n\n   -Expr\n\t    Sign change.\n\n   +-Expr\n\t    Expr or -Expr.  The result is an interval enclosing both.\n\n   abs(Expr)\n\t    The absolute value of Expr.\n\n   E1+E2\n\t    Addition.\n\n   E1-E2\n\t    Subtraction.\n\n   E1*E2\n\t    Multiplication.\n\n   E1/E2\n\t    Division.\n\n   E1^E2\n\t    Exponentiation.\n\n   min(E1,E2)\n\t    Minimum.\n\n   max(E1,E2)\n\t    Maximum.\n\n   sqr(Expr)\n\t    Square.  Logically equivalent to Expr*Expr, but with better \n\t    operational behaviour.\n\n   sqrt(Expr)\n\t    Square root (always positive).\n\n   exp(Expr)\n\t    Same as e^Expr.\n\n   ln(Expr)\n\t    Natural logarithm, the reverse of the exp function.\n\n   sin(Expr)\n\t    Sine.\n\n   cos(Expr)\n\t    Cosine.\n\n   atan(Expr)\n\t    Arcus tangens.  (Returns value between -pi/2 and pi/2.)\n\n   rsqr(Expr)\n\t    Reverse of the sqr function.  The same as +-sqrt(Expr).\n\n   rpow(E1,E2)\n\t    Reverse of exponentiation. i.e. finds X in E1 = X^E2.\n\n   sub(Expr)\n\t    A subinterval of Expr.\n\n   sum(ExprList)\n\t    Sum of a list of expressions.\n\n   min(ExprList)\n\t    Minimum of a list of expressions.\n\n   max(ExprList)\n\t    Maximum of a list of expressions.\n\n   and\n\t    Reified constraint conjunction.  e.g. X>3 and Y<8\n\n   or\n\t    Reified constraint disjunction.  e.g. X>3 or Y<8\n\n   =>\n\t    Reified constraint implication.  e.g. X>3 => Y<8\n\n   neg\n\t    Reified constraint negation.  e.g. neg X>3\n\n   $=, $\\=, $>, $>=, $<, $=<, #=, #\\=, #>, #>=, #<, #=<,\n   =:=, =\\=, >, >=, <, =<, and, or, =>, neg\n\t    Constraints whose value is taken as their reified truth value\n\t    (0..1).\n\n   foo(Arg1, Arg2 ... ArgN), module:foo(Arg1, Arg2 ...  ArgN)\n\t    Call user-defined constraint/function foo.\n\n   eval(Var)\n\t    Var will be an expression at run-time."},"ic:indomain/1":{"prefix":"indomain","body":"indomain(${1:Var})$2\n$0","description":"indomain(?Var)\n\n   Instantiates an integer IC variable to an element of its domain.\n\nArguments\n   Var    An integer IC variable or an integer\n\nType\n   library(ic)\n\nDescription\n\n   Simple predicate for instantiating an integer IC variable to an element\n   of its domain.  It starts with the smallest element, and upon\n   backtracking tries successive elements until the entire domain has been\n   explored, at which point the predicate fails.\n\n   If Var is already a ground integer, then this predicate simply succeeds\n   exactly once without leaving a choicepoint.\n\nResatisfiable\n   Yes.\n\nSee Also\n   labeling / 1, :: / 2, fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, gfd : indomain / 1"},"ic:indomain/2":{"prefix":"indomain","body":"indomain(${1:Var}, ${2:Method})$3\n$0","description":"indomain(?Var, ++Method)\n\n   a flexible way to assign values to finite domain variables\n\nArguments\n   Var    a domain variable or an integer\n   Method    one of the atoms min, max, middle, median, split, interval, random or an integer\n\nType\n   library(ic)\n\nDescription\nThis predicate provides a flexible way to assign values to finite \ndomain variables.\nThe available methods are:\n\nenum Identical to indomain/1. Start enumeration from the smallest\n    value upwards, without first removing previously tried values.\n\nmin Start the enumeration from the smallest value upwards. \n    This behaves like the built-in indomain/1, except that it\n    removes previously tested values on backtracking.\n\nmax Start the enumeration from the largest value\n    downwards.\n\nreverse_min Like min, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nreverse_max Like max, but tries the alternatives in opposite\n    order, i.e. values are excluded first, then assigned.\n\nmiddle Try the enumeration starting from the middle of the\n    domain.  On backtracking, this chooses alternatively values above and\n    below the middle value, until all alternatives have been tested.\n\nmedian Try the enumeration starting from the median value\n    of the domain.  On backtracking, this chooses alternatively values\n    above and below the median value, until all alternatives have been\n    tested.\n\nsplit Try the enumeration by splitting the domain\n    successively into halves until a ground value is reached.  This\n    sometimes can detect failure earlier than the normal enumeration\n    methods, but enumerates the values in the same order as min.\n\nreverse_split Like split, but tries the upper half of the\n    domain first.\n\ninterval If the domain consists of several intervals, then\n    we branch first on the choice of the interval.  For one interval, we\n    use domain splitting.\n\nrandom Try the enumeration in a random order.  On\n    backtracking, the previously tested value is removed.  This method\n    uses random/1 to create random numbers, use seed/1\n    before to make results reproducible.\n\nValue:integer Like middle, but start with the given integer\n    Value\n\nsbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the SBDS symmetry breaking library).\n\nsbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the SBDS symmetry breaking library).\n\nsbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the SBDS symmetry breaking\n    library).\n\ngap_sbds_min Like min, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_max Like max, but use sbds_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDS symmetry breaking library,\n    lib(ic_gap_sbds)).\n\ngap_sbds_middle Like middle, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_median Like median, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds_random Like random, but use sbds_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDS symmetry breaking\n    library, lib(ic_gap_sbds)).\n\ngap_sbds(Value:integer) Like Value:integer, but use sbds_try/2\n    to make choices (for use in conjunction with the GAP-based SBDS symmetry\n    breaking library, lib(ic_gap_sbds)).\n\ngap_sbdd_min Like min, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_max Like max, but use sbdd_try/2 to make choices (for\n    use in conjunction with the GAP-based SBDD symmetry breaking library,\n    lib(ic_gap_sbdd)).\n\ngap_sbdd_middle Like middle, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_median Like median, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd_random Like random, but use sbdd_try/2 to make choices\n    (for use in conjunction with the GAP-based SBDD symmetry breaking\n    library, lib(ic_gap_sbdd)).\n\ngap_sbdd(Value:integer) Like Value:integer, but use sbdd_try/2\n    to make choices (for use in conjunction with the GAP-based SBDD symmetry\n    breaking library, lib(ic_gap_sbdd)).\n\nOn backtracking, all methods except enum first remove the previously tested\nvalue before choosing a new one.  This sometimes can have a huge impact on the\nconstraint propagation, and normally does not cause much overhead, even if no\nadditional propagation occurs.\n\nFail Conditions\n   No\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tX :: 1..10,\n\tindomain(X,min),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,max),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 10 9 8 7 6 5 4 3 2 1\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,middle),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,median),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 5 6 4 7 3 8 2 9 1 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,3),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 3 4 2 5 1 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,split),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes 1 2 3 4 5 6 7 8 9 10\n\ntop:-\n\tX :: 1..10,\n\tindomain(X,random),\n\twrite(X),put(32),\n\tfail.\ntop.\n\n% writes for example 5 3 7 6 8 1 2 10 9 4\n\nSee Also\n   search / 6, indomain / 1, random / 1, seed / 1, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_try / 2"},"ic:integers/1":{"prefix":"integers","body":"integers(${1:Vars})$2\n$0","description":"integers(?Vars)\n\n   Vars' domain is the integer numbers.\n\nArguments\n   Vars    Variable or integer, or a list or submatrix of variables/integers\n\nType\n   library(ic)\n\nDescription\n\n   Constrain the variables to integer values.  Note that this declaration is\n   implicit when specifiying an integer interval, e.g. in Y :: 0..99.\n\nModes and Determinism\n   integers(-) is det\n   integers(+) is semidet\n\nSee Also\n   reals / 1, eplex : integers / 1, ic_kernel : integers / 1, fd : integers / 1, bfs : integers / 1, suspend : integers / 1, gfd : integers / 1"},"ic:is_exact_solver_var/1":{"prefix":"is_exact_solver_var","body":"is_exact_solver_var(${1:Term})$2\n$0","description":"is_exact_solver_var(?Term)\n\n   Succeeds iff Term is an IC integer variable.\n\nArguments\n   Term    A Term\n\nType\n   library(ic)\n\nDescription\n\n   Test if the term Term is an IC integer variable.\n   \n\nModes and Determinism\n   is_exact_solver_var(?) is semidet\n\nFail Conditions\n   Var is not an IC integer variable."},"ic:is_in_domain/2":{"prefix":"is_in_domain","body":"is_in_domain(${1:Val}, ${2:Var})$3\n$0","description":"is_in_domain(++Val, ?Var)\n\n   Succeeds iff Val is in the domain of Var\n\nArguments\n   Val    A number\n   Var    An IC variable or a number\n\nType\n   library(ic)\n\nDescription\n\n   Low level predicate which succeeds when Val is in the domain of Var.  If\n   Var is a number, this predicate will succeed iff Var $= Val would succeed\n   WITHOUT leaving a delayed goal.\n\nModes and Determinism\n   is_in_domain(++, ?) is semidet\n\nExceptions\n     4 --- Val is not ground\n     5 --- either Val or Var is not a numeric type\n   undecidable comparison of bounded reals --- Val was a bounded real which overlapped a bound of Var\n\nSee Also\n   is_in_domain / 3"},"ic:is_in_domain/3":{"prefix":"is_in_domain","body":"is_in_domain(${1:Val}, ${2:Var}, ${3:Result})$4\n$0","description":"is_in_domain(++Val, ?Var, -Result)\n\n   Binds Result to indicate presence of Val in domain of Var\n\nArguments\n   Val    A number\n   Var    An IC variable or a number\n   Result    An atom\n\nType\n   library(ic)\n\nDescription\n\n   Low level predicate which succeeds when Val is in the domain of Var with\n   Result bound to the atom 'yes'.  When Val is not in the domain of Var,\n   the predicate succeeds binding Result to the atom 'no'.  Should the\n   result be undecidable (as can be the case with bounded reals), the\n   predicate will succeed binding Result to the atom 'maybe'.  If Var is a\n   number, this predicate will succeed with Result bound to 'yes' iff\n   Var $= Val would succeed WITHOUT leaving a delayed goal.  If Var $= Val\n   would have left a delayed goal then Result gets bound to 'maybe'.\n\nModes and Determinism\n   is_in_domain(++, ?, -) is det\n\nExceptions\n     4 --- Val is not ground\n     5 --- either Val or Var is not a numeric type\n\nSee Also\n   is_in_domain / 2"},"ic:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   Succeeds iff Term is an IC variable or a number.\n\nArguments\n   Term    A Term\n\nType\n   library(ic)\n\nDescription\n\n   Test if the term Term is an IC variable or a numeric type supported by\n   the solver (any ground number).  Succeed if it is, fail otherwise.\n\nModes and Determinism\n   is_solver_type(?) is semidet\n\nFail Conditions\n   Var is not an IC variable or a number."},"ic:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   Succeeds iff Term is an IC variable.\n\nArguments\n   Term    A Term\n\nType\n   library(ic)\n\nDescription\n\n   Test if the term Term is an IC variable.  Succeed if it is, fail\n   otherwise.\n\nModes and Determinism\n   is_solver_var(?) is semidet\n\nFail Conditions\n   Var is not an IC variable."},"ic:labeling/1":{"prefix":"labeling","body":"labeling(${1:Vars})$2\n$0","description":"labeling(+Vars)\n\n   Instantiates all variables in a collection to elements of their domains.\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of integer IC variables or integers\n\nType\n   library(ic)\n\nDescription\n\n   Simple predicate for instantiating a collection of integer IC variables\n   to elements of their domains.  (Integers are also allowed in the\n   collection; they are effectively ignored.)  The variables are\n   instantiated in the order in which they appear in the collection; the\n   implementation is essentially:\n\n\tlabeling(Vars) :-\n\t\tcollection_to_list(Vars, List),\n\t\t( foreach(Var,List) do\n\t\t    indomain(Var)\n\t\t).\n\nResatisfiable\n   Yes.\n\nSee Also\n   indomain / 1, fd : labeling / 1, sd : labeling / 1, gfd : labeling / 1, lists : collection_to_list / 2"},"ic:locate/3":{"prefix":"locate","body":"locate(${1:Vars}, ${2:Precision}, ${3:LinLog})$4\n$0","description":"locate(+Vars, ++Precision, ++LinLog)\n\n   Locate solution intervals for Vars by splitting and search.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables\n   Precision    Minimum required precision (float)\n   LinLog    Domain splitting method (lin or log)\n\nType\n   library(ic)\n\nDescription\n\n   Locate solution intervals for the given variables with the required\n   precision.  This works well if the problem has a finite number of\n   solutions.  locate/2,3 work by nondeterministically splitting the\n   intervals of the variables until they are narrower than Precision (in\n   either absolute or relative terms).\n\n   The LinLog parameter guides the way domains are split.  If it is set to\n   lin then the split is linear (i.e. the arithmetic mean of the bounds is\n   used).  If it is set to log, the split is logarithmic (i.e. the geometric\n   mean of the bounds is used).  Note that if log is used, there will be\n   roughly the same number of representable floating point numbers on either\n   side of the split, due to the logarithmic distribution of these numbers.\n\n   locate/3 is defined in terms of locate/4 as follows:\n    \n    locate(Vars, Precision, LinLog) :- locate(Vars, [], Precision, LinLog).\n    \n\nSee Also\n   locate / 2, locate / 4, squash / 3, lists : collection_to_list / 2"},"ic:locate/2":{"prefix":"locate","body":"locate(${1:Vars}, ${2:Precision})$3\n$0","description":"locate(+Vars, ++Precision)\n\n   Locate solution intervals for Vars by splitting and search.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables\n   Precision    Minimum required precision (float)\n\nType\n   library(ic)\n\nDescription\n\n   Locate solution intervals for the given variables with the required\n   precision.  This works well if the problem has a finite number of\n   solutions.  locate/2,3 work by nondeterministically splitting the\n   intervals of the variables until they are narrower than Precision (in\n   either absolute or relative terms).\n\n   locate/2 is defined in terms of locate/3 as follows:\n    \n    locate(Vars, Precision) :- locate(Vars, Precision, log).\n    \n\nSee Also\n   locate / 3, locate / 4, squash / 3, lists : collection_to_list / 2"},"ic:locate/4":{"prefix":"locate","body":"locate(${1:LocateVars}, ${2:SquashVars}, ${3:Precision}, ${4:LinLog})$5\n$0","description":"locate(+LocateVars, +SquashVars, ++Precision, ++LinLog)\n\n   Locate solution intervals for LocateVars, interleaving search with squashing.\n\nArguments\n   LocateVars    Collection (a la collection_to_list/2) of variables\n   SquashVars    Collection of variables\n   Precision    Minimum required precision (float)\n   LinLog    Domain splitting method (lin or log)\n\nType\n   library(ic)\n\nDescription\n\n   A variant of locate/2,3 with interleaved squashing.  The squash algorithm\n   is applied once to the SquashVars initially, and then again after each\n   splitting step (i.e. each time one of the LocateVars has been split\n   nondeterministically during the search).  A variable may occur in both\n   LocateVars and SquashVars.\n\n   The LinLog parameter guides the way domains are split.  If it is set to\n   lin then the split is linear (i.e. the arithmetic mean of the bounds is\n   used).  If it is set to log, the split is logarithmic (i.e. the geometric\n   mean of the bounds is used).  Note that if log is used, there will be\n   roughly the same number of representable floating point numbers on either\n   side of the split, due to the logarithmic distribution of these numbers.\n\nSee Also\n   locate / 2, locate / 3, squash / 3, lists : collection_to_list / 2"},"ic:max/2":{"prefix":"max","body":"max(${1:Vars}, ${2:Max})$3\n$0","description":"max(+Vars, ?Max)\n\n   Constrains Max to be the largest element in Vars.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables or numbers (NOT arbitrary expressions)\n   Max    Maximum element of Vars\n\nType\n   library(ic)\n\nDescription\n\n   Constrains Max to be the largest element in the collection of variables\n   or numbers Vars.\n\n   You may find it more convenient to embed max(Vars) in a\n   constraint.\n\nSee Also\n   min / 2, lists : collection_to_list / 2"},"ic:maxlist/2":{"prefix":"maxlist","body":"maxlist(${1:Vars}, ${2:Max})$3\n$0","description":"maxlist(+Vars, ?Max)\n\n   Constrains Max to be the largest element in Vars.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables or numbers (NOT arbitrary expressions)\n   Max    Maximum element of Vars\n\nType\n   library(ic)\n\nDescription\n\n   This predicate is obsolete.  Use max/2 instead.\n\nSee Also\n   max / 2, min / 2, lists : collection_to_list / 2"},"ic:min/2":{"prefix":"min","body":"min(${1:Vars}, ${2:Min})$3\n$0","description":"min(+Vars, ?Min)\n\n   Constrains Min to be the smallest element in Vars.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables or numbers (NOT arbitrary expressions)\n   Min    Minimum element of Vars\n\nType\n   library(ic)\n\nDescription\n\n   Constrains Max to be the smallest element in the collection of variables\n   or numbers Vars.\n\n   You may find it more convenient to embed min(Vars) in a\n   constraint.\n\nSee Also\n   max / 2, lists : collection_to_list / 2"},"ic:neg/1":{"prefix":"neg","body":"neg(${1:Con})$2\n$0","description":"neg(+Con)\n\n   Constraints Con is negated.\n\nArguments\n   Con    Constraint\n\nType\n   library(ic)\n\nDescription\n\n   Equivalent to 0 $= (Con)\n   \n   The reified constraint Con is negated.  Con must be a constraint that has\n   a corresponding reified form.\n\nSee Also\n   and / 2, and / 3, neg / 2, or / 2, or / 3, => / 2, => / 3, =:= / 3, =< / 3, =\\= / 3, >= / 3, > / 3, < / 3"},"ic:minlist/2":{"prefix":"minlist","body":"minlist(${1:Vars}, ${2:Min})$3\n$0","description":"minlist(+Vars, ?Min)\n\n   Constrains Min to be the smallest element in Vars.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables or numbers (NOT arbitrary expressions)\n   Min    Minimum element of Vars\n\nType\n   library(ic)\n\nDescription\n\n   This predicate is obsolete.  Use min/2 instead.\n\nSee Also\n   min / 2, max / 2, lists : collection_to_list / 2"},"ic:neg/2":{"prefix":"neg","body":"neg(${1:Con}, ${2:Bool})$3\n$0","description":"neg(+Con,Bool)\n\n   Bool is the logical negation of the reified truth constraints Con.\n\nArguments\n   Con    Constraint\n   Bool    Reified truth value of the constraint\n\nType\n   library(ic)\n\nDescription\n\n   Equivalent to B $= (Con), Bool #= 1-B\n   \n   Bool is the logical negation of the reified truth constraint Con.  Con\n   must be a constraint that has a corresponding reified form.\n\nSee Also\n   and / 2, and / 3, neg / 1, or / 2, or / 3, => / 2, => / 3, =:= / 3, =< / 3, =\\= / 3, >= / 3, > / 3, < / 3"},"ic:nth_value/3":{"prefix":"nth_value","body":"nth_value(${1:Domain}, ${2:N}, ${3:Value})$4\n$0","description":"nth_value(+Domain, ++N, -Value)\n\n   return the nth value in a domain\n\nArguments\n   Domain    The domain list to select a value from\n   N    The position of the value to select\n   Value    The selected value\n\nType\n   library(ic)\n\nDescription\nFind the nth value in a domain given by an interval or a list of\nintegers and intervals, as it is returned for example by ic's\nget_domain/2 or fd's ::/2.\n\nFail Conditions\n   N < 1 or there are less than N values in the domain.\n\nResatisfiable\n   no\n\nExamples\n   \n% a typical use\n\n\t....\n\tget_domain(X, L),\n\tnth_value(L, 2, Value),\n\t....\n\nSee Also\n   fd : :: / 2, get_domain / 2"},"ic:or/3":{"prefix":"or","body":"or(${1:ConX}, ${2:ConY}, ${3:Bool})$4\n$0","description":"or(+ConX,+ConY,Bool)\n\n   Bool is the reified truth of at least one of the constraints ConX or ConY being true.\n\nArguments\n   ConX    Constraint\n   ConY    Constraint\n   Bool    Reified truth value of the constraint\n\nType\n   library(ic)\n\nDescription\n\n   Equivalent to BX $= (ConX), BY $= (ConY), Bool #= (BX + BY #>= 1)\n   \n   The two constraints are reified in such a way that Bool reflects the\n   truth of at least one being true.  ConX and ConY must be constraints that\n   have a corresponding reified form.\n\nSee Also\n   or / 2, neg / 1, neg / 2, and / 2, and / 3, => / 2, => / 3, =:= / 3, =< / 3, =\\= / 3, >= / 3, > / 3, < / 3"},"ic:piecewise_linear/3":{"prefix":"piecewise_linear","body":"piecewise_linear(${1:X}, ${2:Points}, ${3:Y})$4\n$0","description":"piecewise_linear(?X, ++Points, ?Y)\n\n   Relates X and Y according to a piecewise linear function.\n\nArguments\n   X    Parameter/domain of the piecewise function\n   Points    Collection (a la collection_to_list/2) of points defining the piecewise function\n   Y    Result/interval of piecewise the function\n\nType\n   library(ic)\n\nDescription\n\n   This predicate imposes the constraint Y = f(X), where f is a piecewise\n   linear function defined by Points.  Points must be (after processing by\n   collection_to_list/2) a list of elements of the form (X, Y), sorted by\n   increasing X values.  The function is constructed by performing linear\n   interpolation between consecutive points, and extrapolating the first and\n   last linear segments to infinity.\n\n   Discontinuities are allowed, by specifying more than one point with the\n   same X coordinate.  However, since the constraint is a function, one must\n   specify which of the given Y values is the true value of the function at\n   that point.  This is done by annotating which of the adjacent line\n   segments is ``open'' at that end (i.e. does not include the end point).\n   There are three allowed forms of discontinuity:\n\n\t(X1, Y1), (X2, Y2a), (>(X2), Y2b), (X3, Y3) \n\t(X1, Y1), (<(X2), Y2a), (X2, Y2b), (X3, Y3) \n\t(X1, Y1), (<(X2), Y2a), (X2, Y2b), (>(X2), Y2c), (X3, Y3)\n\n   In the first form, the segment specified by the first two points is\n   defined over the interval [X1 .. X2] while that specified by the last two\n   is defined over the interval (X2 .. X3].  That is, the first interval is\n   closed at X2, the second is open at X2 (i.e. only includes points\n   strictly greater than X2), and thus the value of the function at X2 is\n   Y2a.\n\n   In the second form, the reverse is true.  The first segment is over the\n   interval [X1 .. X2) (points less than X2), the second is over the\n   interval [X2 .. X3], and the value of the function at X2 is Y2b.\n\n   The final form is a double discontinuity.  Both adjacent segments are\n   open - [X1 .. X2), (X2 .. X3] - and at X2 the value of the function is\n   Y2b, taken from neither segment.\n\n   Note that a segment can be open at both ends, if it has discontinuities\n   at both ends.  For example, if the list of points is\n\n\t[(0, 0), (10, 0), (>(10), 1), (<(20), 1), (20, 2), (30, 2)]\n\n   then the function has value 0 for all values of X up to and including 10,\n   it has value 2 for all values of X from 20 onwards, and has value 1 in\n   between.\n\n   Other notes:\n\n   A piecewise linear constraint is expected to have at least two points\n   (though if it only has two, then a standard linear constraint would do,\n   and likely be more efficient).  If there is only one point, then there is\n   no way to determine the gradient to use to extend the function to other\n   values of X.  As a result, the value of the function is not defined for\n   all other values of X.  Similarly, if the first or last points in the\n   specification of the piecewise constraint are involved in\n   discontinuities, then the corresponding extensions to infinity are\n   undefined; it is recommended that the user either provide a valid\n   extension by supplying an extra point, or exclude those values of X by\n   imposing an appropriate bound.  (In any event, the first and last points\n   must be closed; an open discontinuity is not permitted at either end.)\n\n   Whilst the piecewise constraint accepts bounded reals in its arguments,\n   the current implementation does not fully support bounded reals of\n   non-zero width (i.e. those which do not correspond to a single floating\n   point value).  As a result, use of such bounded reals is not recommended\n   at this time.\n\nSee Also\n   eplex : piecewise_linear_hull / 3, lists : collection_to_list / 2"},"ic:print_solver_var/2":{"prefix":"print_solver_var","body":"print_solver_var(${1:Var}, ${2:Printed})$3\n$0","description":"print_solver_var(?Var, -Printed)\n\n   Returns a representation of the IC variable Var suitable for printing.\n\nArguments\n   Var    An IC variable (or IC attribute)\n   Printed    A printable representation of Var\n\nType\n   library(ic)\n\nDescription\n\n   The print handler for the IC attribute.  Returns a representation of the\n   IC variable (or attribute) Var suitable for printing, encoding the type\n   of the variable, the bounds, and any holes in the domain.\n\nModes and Determinism\n   print_solver_var(?, -) is det\n\nFail Conditions\n   Var is not an IC variable or attribute"},"ic:search/6":{"prefix":"search","body":"search(${1:L}, ${2:Arg}, ${3:Select}, ${4:Choice}, ${5:Method}, ${6:Option})$7\n$0","description":"search(+L, ++Arg, ++Select, +Choice, ++Method, +Option)\n\n   A generic search routine for finite domains or IC which implements \ndifferent partial search methods (complete, credit, lds, bbs, dbs, sbds,\ngap_sbds, gap_sbdd)\n\nArguments\n   L    a collection (a la collection_to_list/2) of domain\n\t    variables (Arg = 0) or a collection of terms (Arg > 0)\n   Arg    an integer, which is 0 if the list is a list of domain\n\t    variables, or greater than 0 if the list consists of terms\n\t    with arity at least Arg (the value Arg indicating the argument\n\t    that contains the domain variables to be labeled)\n   Select    the name of a predefined selection method (input_order,\n\t    first_fail, smallest, largest, occurrence, most_constrained,\n\t    max_regret, anti_first_fail), or an atom or compound term\n\t    specifying a user-defined selection method\n   Choice    the name of a predefined choice method (indomain,\n\t    indomain_min, indomain_max, indomain_middle, indomain_reverse_min,\n\t    indomain_reverse_max, indomain_median, indomain_split,\n\t    indomain_reverse_split, indomain_random, indomain_interval),\n\t    or an atom or compound term specifying a user-defined method\n   Method    one of the following search method specifications:\n\t    complete, bbs(Steps:integer), lds(Disc:integer),\n\t    credit(Credit:integer, Extra:integer or bbs(Steps:integer)\n\t    or lds(Disc:integer)), dbs(Level:integer, Extra:integer or\n\t    bbs(Steps:integer) or lds(Disc:integer)), sbds, gap_sbds,\n\t    gap_sbdd\n   Option    a list of option terms.  Currently recognized\n\t   are backtrack(-N), node(++Call), nodes(++N)\n\nType\n   library(ic)\n\nDescription\nSearch/6 provides a generic interface to a set of different search\nmethods.  It can currently be used with either the finite domains (if\nloaded via lib(fd_search)), or integer IC domains (if loaded via\nlib(ic_search)).  By changing the Method argument, different partial\nsearch algorithms (and their parameters) can be selected and\ncontrolled. The search predicate also provides a number of pre-defined\nvariable selection methods (to choose which variable will be assigned next)\nand some pre-defined value assignment methods (to try out the possible\nvalues for the selected variable in some heuristic order), but user-defined\nmethods can be used in their place as well.  In order to allow more\nstructure in the application program, it is possible to pass a collection\nof terms rather than only a collection of domain variables. In this way all\ninformation about some entity can be easily grouped together. It also\nallows more complex labeling methods which combine the assignment of\nmultiple variables (like a preference value and a decision variable).\n\nAll search methods use a stable selection method. If several entries\nhave the same heuristic value, then the first one is selected.  The rest of\nthe collection (treated as a list) is equal to the original list with the\nselected entry removed, the order of the non-selected entries does not\nchange.\n\nThe pre-defined selection methods are the following:\n\ninput_order\n\tthe first entry in the list is selected\nfirst_fail\n\tthe entry with the smallest domain size is selected\nanti_first_fail\n\tthe entry with the largest domain size is selected\nsmallest\n\tthe entry with the smallest value in the domain is selected\nlargest\n\tthe entry with the largest value in the domain is selected\noccurrence\n\tthe entry with the largest number of attached constraints is selected\nmost_constrained\n\tthe entry with the smallest domain size is selected.  If several\n\tentries have the same domain size, the entry with the largest number\n\tof attached constraints is selected.\nmax_regret\n\tthe entry with the largest difference between the smallest and second\n\tsmallest value in the domain is selected. This method is typically\n\tused if the variable represents a cost, and we are interested in\n\tthe choice which could increase overall cost the most if the best\n\tpossibility is not taken. Unfortunately, the implementation does\n\tnot always work: If two decision variables incur the same minimal\n\tcost, the regret is not calculated as zero, but as the difference\n\tfrom this minimal value to the next greater value.\n\nAny other atom will be taken as the specification of a user-defined\nselection predicate.  This will be invoked with 2 arguments (X,Criterion)\nadded and is expected to compute a selection criterion (typically a number)\nfrom a variable or value X.  E.g. if Select is 'my_select', a predicate\ndefinition like the following has to be provided:\n\n    my_select(X,Criterion) :-\n\t...\t% compute Criterion from variable X\n\nThe variable-selection will then select the variable with the lowest value\n(in standard term order) of Criterion.  If several variables have the same\nvalue, the first one is selected.  \n\nThe above selection methods use the predefined delete/5 predicate.\nIf this is not general enough, you can replace it with your own: if Select\nis given as select(my_delete), then my_delete(-SelectedVar,+List,-Rest,+Arg)\nwill be invoked for selecting a variable from List.\n\nThe pre-defined choice methods have the following meaning:\n\nindomain\n    uses the built-in indomain/1.  Values are tried in increasing order. \n    On failure, the previously tested value is not removed.\n\nindomain_min\n    Values are tried in increasing order.  On failure, the previously\n    tested value is removed.  The values are tested in the same order as\n    for indomain, but backtracking may occur earlier.\n\nindomain_max\n    Values are tried in decreasing order.  On failure, the previously\n    tested value is removed.\n\nindomain_reverse_min\n    Like indomain_min, but the alternatives are tried in reverse order.\n    I.e. the smallest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_reverse_max\n    Like indomain_max, but the alternatives are tried in reverse order.\n    I.e. the largest value is first removed from the domain, and only\n    if that fails, the value is assigned.\n\nindomain_middle\n    Values are tried beginning from the middle of the domain.  On failure,\n    the previously tested value is removed.\n\nindomain_median\n    Values are tried beginning from the median value of the domain.  On\n    failure, the previously tested value is removed.\n\nindomain_split\n    Values are tried by succesive domain splitting, trying the lower half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_min, but\n    may fail earlier.\n\nindomain_reverse_split\n    Values are tried by succesive domain splitting, trying the upper half\n    of the domain first.  On failure, the tried interval is removed.  This\n    enumerates values in the same order as indomain or indomain_max, but\n    may fail earlier.\n\nindomain_random\n    Values are tried in a random order.  On backtracking, the previously\n    tried value is removed.  Using this rutine may lead to unreproducable\n    results, as another call wil create random numbers in a different\n    sequence.  This method uses the built-in random/1 to create\n    random numbers, seed/1 can be used to force the same number\n    generation sequence in another run.\n\nindomain_interval\n    If the domain consists of several intervals, we first branch on the\n    choice of the interval.  For one interval, we use domain\n    splitting.\n\nAny other name is taken as the name of a user-defined predicate of\narity 1, to which the variable to be labeled (or a whole element of\nlist L, in the Arg>0 case) is passed, e.g.\n\n    my_choice(X) :-\n\t...\t% make a choice on variable X\n\nAlternatively, a term with 2 arguments can be given as the choice-method,\ne.g. my_choice(FirstIn,LastOut). this will lead to the invocation of a\nchoice predicate with arity 3, e.g.\n\n    my_choice(X,In,Out) :-\n\t...\t% make a choice on variable X, using In-Out\n\nThis allows user-defined state to be transferred between the subsequent\ninvocations of the choice-predicate (the Out argument of a call to\nmy_choice/3 for one variable is unified with the In argument of the call to\nmy_choice/3 for the next variable, and so on).\n\nIn addition, a fixed argument can be passed: my_choice(Param) leads to\ninvocation of my_choice(X,Param), and my_choice(Param,FirstIn,LastOut)\nleads to invocation of my_choice(X,Param,In,Out).\n\nThe different search methods are\n\ncomplete\n    a complete search routine which explores all alternative choices.\n\nbbs(Steps)\n    The bounded backtracking search allows Steps\n    backtracking steps.\n\nlds(Disc)\n    A form of the  limited discrepancy search .  This method\n    iteratively tries 0, 1, 2 ..  Disc changes against the\n    heuristic (first) value.  Typical values are between 1 and 3 (which\n    already may create too many alternatives for large problems).  The\n    original LDS paper stated that the discrepancy to be tested first\n    should be at the top of the tree.  Our implementation tries the first\n    discrepancy at the bottom of the tree.  This means that solutions may\n    be found in a different order compared to the original algorithm. \n    This change is imposed by the evaluation strategy used and can not be\n    easily modified.\n\ncredit(Credit, bbs(Steps))\n    The credit based search explores the top of the search tree\n    completely.  Initially, a given number of credits (Credit) are\n    given.  At each choice point, the first alternative gets half of the\n    available credit, the second alternative half of the remaining credit,\n    and so on.  When the credit run out, the system switches to another\n    search routine, here bbs.  In each of these bounded backtracking\n    searches Steps backtracking steps are allowed before returning\n    to the top most part of the tree and choosing the next remaining\n    candidate.  A good value for Steps is 5, a value of 0 forces a\n    deterministic search using the heuristic.  Typical values for\n    Credit are either N or N*N, where N is the number of entries in\n    the collection.\n\ncredit(Credit, lds(Disc))\n    like the one above, but using lds when the credit runs out. \n    Typically, only one (perhaps 2) discrepancies should be allowed.\n\ndbs(Level, bbs(Steps))\n    The depth bounded search explores the first Level\n    choices in the search tree completely, i.e.  it tries all values for\n    the first Level selected variables.  After that, it switches to\n    another search method, here bbs.  In each of these searches,\n    Steps backtracking steps are allowed.  \n\ndbs(Level, lds(Disc))\n    like the method above, but switches to lds after the first\n    Level variables.\n\nsbds\n    A complete search routine which uses the SBDS symmetry breaking library\n    (lib(ic_sbds) or lib(fd_sbds)) to exclude symmetric parts of the search tree\n    from consideration.  The symmetry breaking must be initialised through a\n    call to sbds_initialise/4,5 before calling search/6.  Currently the only\n    pre-defined choice methods supported by this search method are\n    indomain_min, indomain_max, indomain_middle,\n    indomain_median and indomain_random.  Any user-defined choice\n    method used in conjunction with this search method must use sbds_try/2 to\n    assign/exclude values or the symmetry breaking will not work correctly.\n\ngap_sbds (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDS symmetry breaking\n    library lib(ic_gap_sbds) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbds_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbds_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\ngap_sbdd (Not available for FD.)\n    A complete search routine which uses the GAP-based SBDD symmetry breaking\n    library lib(ic_gap_sbdd) to exclude symmetric parts of the search tree from\n    consideration.  The symmetry breaking must be initialised through a call to\n    sbdd_initialise/5 before calling search/6.  Currently the only pre-defined\n    choice methods supported by this search method are indomain_min,\n    indomain_max, indomain_middle, indomain_median and\n    indomain_random.  Any user-defined choice method used in conjunction\n    with this search method must use sbdd_try/2 to assign/exclude values or the\n    symmetry breaking will not work correctly.\n\nThe option list is used to pass additional parameters to and from the\nprocedure.  The currently recognized options are:\n\nbacktrack(-N)\n    returns the number of backtracking steps used in the search routine\n\nnodes(++N)\n    sets an upper limit on the number of nodes explored in the search.  If\n    the given limit is exceeded, the search routine stops the exploration\n    of the search tree.\n\nnode(daVinci)\n    create a drawing of the search tree using the daVinci graph drawing\n    tool.  Each node of the search tree is shown as a node in the tree. \n    The label of the node is the selected term of the collection.\n\nnode(daVinci(++Call))\n    as the previous option, it creates a drawing of the search tree using\n    the daVinci graph drawing tool.  But instead of using the complete\n    selected term as the label, it call the predicate Call/2 to\n    choose which part of the selected term to display.\n\nFail Conditions\n   Fails if the search tree generated does not contain any solution. \nFor partial search methods, this does not mean that the problem does not \nhave a solution, but only that the part of the tree generated did not \ncontain one.\n\nResatisfiable\n   yes\n\nExamples\n   \ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,complete,[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,bbs(15),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,lds(2),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,credit(64,bbs(5)),[]).\n\ntop:-\n\tlength(L,8),\n\tL :: 1..8,\n\tsearch(L,0,input_order,indomain,dbs(2,lds(1)),[]).\n\n% a more complex example with different methods and heuristics\n% the list to be assigned is a list of terms queen/2\n\n:- local struct(queen(place,var)).\n\ntop:-\n\tmember(Method,[complete,lds(2),credit(64,5),bbs(1000),dbs(5,10)]),\n\tmember(Select,[first_fail,most_constrained,input_order]),\n\tmember(Choice,[indomain,\n\t    indomain_min,\n\t\t       indomain_max,\n\t\t       indomain_middle,\n\t\t       indomain_median,\n\t\t       indomain_split,\n\t\t       indomain_random]),\n\twriteln(queen(Method,Select,Choice)),\n\tonce(queen_credit(64,Select,Choice,Method,L,Back)),\n\twriteln(L),\n\twriteln(backtrack(Back)),\n\tfail.\ntop:-\n\tnl.\n\nqueen_credit(N,Select,Choice,Method,L,Back):-\n\tcreate_queens(1,N,Queens,L),\n\tsetup(L),\n\trearrange(Queens,Queens,[],[],Queens1),\n\tsearch(Queens1, var of queen, Select, Choice, Method, [backtrack(Back)]).\n\nrearrange([],Last,Last,Res,Res).\nrearrange([_],[Mid|Last],Last,Res,[Mid|Res]).\nrearrange([_,_|S],[H|T],A1,In,Res):-\n\trearrange(S,T,[A|A1],[H,A|In],Res).\n\ncreate_queens(N,M,[],[]):-\n\tN > M,\n\t!.\ncreate_queens(N,M,[queen{place:N,var:X}|T],[X|L]):-\n\tX :: 1..M,\n\tN1 is N+1,\n\tcreate_queens(N1,M,T,L).\n\nsetup([]).\nsetup([H|T]):-\n\tsetup1(H,T,1),\n\tsetup(T).\n\nsetup1(_,[],_).\nsetup1(X,[Y|R],N):-\n\tX #\\= Y,\n\tX #\\= Y + N,\n\tY #\\= X + N,\n\tN1 is N+1,\n\tsetup1(X,R,N1).\n\n% this example shows how to pass information from one assignment step \n% to the next\n% this uses a term of two arguments as the choice argument\n% The example also shows the use of the option argument:\n% the search tree generated is drawn with the daVinci graph drawing tool\n% and the search is limited to 1000 nodes.\n% The number of backtracking steps is returned in the variables Back.\n:-local struct(country(name,color)).\n\ntop:-\n\tcountries(C),\n\tcreate_countries(C,Countries,Vars),\n\tfindall(n(A,B),n(A,B),L),\n\tsetup(L,Countries),\n\tsearch(Countries,\n\t       color of country, % select based on this variable\n\t       most_constrained,\n\t       assign([1,2,3,4],Out), % this calls assign/3\n\t       complete,\n\t       [backtrack(Back),node(daVinci),nodes(1000)]),\n\twriteln(Vars),\n\twriteln(Back),\n\twriteln(Out).\n\ncreate_countries([],[],[]).\ncreate_countries([C|C1],[country{name:C, color:V}|R1],[V|V1]):-\n\tV :: 1..4,\n\tcreate_countries(C1,R1,V1).\n\nsetup([],_L).\nsetup([n(A,B)|N1],L):-\n\tmember(country{name:A, color:Av},L),\n\tmember(country{name:B, color:Bv},L),\n\tAv #\\= Bv,\n\tsetup(N1,L).\n\n% this is the choice predicate\n% the first argument is the complete selected term\n% the second is the input argument\n% the third is the output argument\n% here we pass a list of values and rotate this list from one step to the next\nassign(country{color:X},L,L1):-\n\trotate(L,L1),\n\tmember(X,L).\n\nrotate([A,B,C,D],[B,C,D,A]).\n\n% another example of argument passing \n% here each entry gets the same information\n% it is passed unchanged from one level to the next\n\ntop:-\n\t...\n\tlength(L,N),\n\tL :: 1..10,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       % pass two lists as the In argument of assign\n\t       % try the odd numbers before the even numbers\n\t       assign([1,3,5,7,9]-[2,4,6,8,10],_), \n\t       complete,[]),\n\t...\n\n% this is the assignment routine\n% the first argument is a \n% Pass the In argument as the Out argument\n% try values from list L1 before values from list L2\nassign(X,L1-L2,L1-L2):-\n\tmember(X,L1);member(X,L2).\n\n% and another example from square placement\n% alternatively try minimal and maximal values first\n\n:-local struct(square(x,y,size)).\n\ntop:-\n\tdata(L),\n\tcreate_squares(L,Squares),\n\t...\n    search(Squares,\n\t       0, % this value does not matter if input_order is chosen\n\t       input_order,\n\t       assign(min,_),\n\t       complete,\n\t       []),\n\t...\n\n% the assignment routine\n% alternate between min and max for consecutive levels in the search\nassign(square{x:X,y:Y},Type,Type1):-\n\tswap(Type,Type1),\n\tindomain(X,Type),\n\tindomain(Y,Type).\n\nswap(max,min).\nswap(min,max).\n\n% this example shows that the choice routine may consist of several clauses\n% the idea comes from a graph coloring heuristic\n\ntop:-\n\tlength(L,N),\n\tL :: 1..100,\n\t...\n    search(L,\n\t       0,\n\t       most_constrained,\n\t       assign(0,K), The In argument is the highest color used so far\n\t       complete,[]),\n\t...\n\n% assign variable X either to one of the colors 1..K \n% which have already been used, or to the new color K+1\n% we do not need to try other values K+2 etc, as this is a symmetry that\n% we can avoid\nassign(X,K,K):-\n\tX #=< K,\n\tindomain(X).\nassign(K1,K,K1):-\n\tK1 is K+1.\n\n% example showing use of the SBDS library with a user-defined choice method\n% which calls sbds_try/2.\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\t...\n\tsbds_initialise(M,SymPreds,#=,[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,sbds_indomain_max,sbds,[]).\n\nsbds_indomain_max(X):-\n\tnonvar(X).\nsbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tsbds_indomain_max(X).\n\n% Example showing use of the GAP-based SBDS library with a user-defined\n% choice method which calls sbds_try/2.  (For the GAP-based SBDD library,\n% just substitute \"sbdd\" for each occurrence of \"sbds\" below.)\n\ntop:-\n\tdim(M, [8]),\n\tM[1..8] :: 1..8,\n\tsbds_initialise(M,[vars],values:1..8,[symmetry(s_n,[vars])],[]),\n\tM =.. [_|L],\t% get list of variables for search routine\n\tsearch(L,0,first_fail,gap_sbds_indomain_max,gap_sbds,[]).\n\ngap_sbds_indomain_max(X):-\n\tnonvar(X).\ngap_sbds_indomain_max(X):-\n\tvar(X),\n\tget_max(X,Max),\n\tsbds_try(X,Max),\n\tgap_sbds_indomain_max(X).\n\nSee Also\n   indomain / 1, indomain / 2, labeling / 1, fd : deleteff / 3, sd : deleteff / 3, fd : deleteffc / 3, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, ic_gap_sbdd : sbdd_initialise / 5, ic_gap_sbdd : sbdd_try / 2, library(ic_sbds), library(fd_sbds), library(ic_gap_sbds), library(ic_gap_sbdd)"},"ic:reals/1":{"prefix":"reals","body":"reals(${1:Vars})$2\n$0","description":"reals(?Vars)\n\n   Vars' domain is the real numbers.\n\nArguments\n   Vars    Variable or number, or a list or submatrix of variables/numbers\n\nType\n   library(ic)\n\nDescription\n\n   Constrain the domain of the variables to be the real numbers.  This is\n   the default, so the declaration is optional.\n\n   Note that the notion of real numbers is used here in the pure\n   mathematical sense, where real numbers subsume the integers.  A variable\n   of type real can therefore be instantated to either a real number (floating\n   point or bounded real) or an integer number.  If the variables are already\n   instantiated, this call checks that the variable is instantiated to a\n   number.\n\nModes and Determinism\n   reals(-) is det\n   reals(+) is det\n\nSee Also\n   integers / 1, eplex : reals / 1, ic_kernel : reals / 1, suspend : reals / 1"},"ic:set_threshold/1":{"prefix":"set_threshold","body":"set_threshold(${1:Threshold})$2\n$0","description":"set_threshold(++Threshold)\n\n   Sets the propagation threshold.\n\nArguments\n   Threshold    New threshold (float)\n\nType\n   library(ic)\n\nDescription\n\n   Set the threshold to Threshold, which is a small floating-point number.\n   Subsequent to this, bounds updates to non-integer variables are only\n   performed if the change in the bounds exceeds this threshold (in both\n   absolute and relative terms).\n\n   The default threshold is 1e-8.\n\n   Limiting the amount of propagation is important for efficiency.  A higher\n   threshold speeds up computations, but reduces precision and may in the\n   extreme case prevent the system from being able to locate individual\n   solutions.\n\n   Note that if the threshold is reduced using this predicate (requiring a\n   higher level of precision), the current state of the system may not be\n   consistent with respect to the new threshold.  If it is important that\n   the new level of precision be realised for all or part of the system\n   before computation proceeds, use set_threshold/2 instead.\n\nModes and Determinism\n   set_threshold(++) is det\n\nSee Also\n   get_threshold / 1, set_threshold / 2"},"ic:set_threshold/2":{"prefix":"set_threshold","body":"set_threshold(${1:Threshold}, ${2:WakeVars})$3\n$0","description":"set_threshold(++Threshold, +WakeVars)\n\n   Sets the propagation threshold with recomputation.\n\nArguments\n   Threshold    New threshold (float)\n   WakeVars    Collection (a la collection_to_list/2) of IC variables to \"wake\"\n\nType\n   library(ic)\n\nDescription\n\n   Set the threshold to Threshold, which is a small floating-point number,\n   and then if the threshold has been reduced, wake all constraints\n   suspended on the bounds of the variables in the collection WakeVars.\n   Subsequent to the setting of the new threshold, bounds updates to\n   non-integer variables are only performed if the change in the bounds\n   exceeds this threshold (in both absolute and relative terms).  The waking\n   of the constraints when the threshold is reduced allows part or all of\n   the system to be re-propagated in order to ensure the higher level of\n   precision is achieved before the rest of the computation proceeds.\n\n   The default threshold is 1e-8.\n\n   Limiting the amount of propagation is important for efficiency.  A higher\n   threshold speeds up computations, but reduces precision and may in the\n   extreme case prevent the system from being able to locate individual\n   solutions.\n\nModes and Determinism\n   set_threshold(++, +) is semidet\n\nSee Also\n   get_threshold / 1, set_threshold / 1, lists : collection_to_list / 2"},"ic:squash/3":{"prefix":"squash","body":"squash(${1:Vars}, ${2:Precision}, ${3:LinLog})$4\n$0","description":"squash(+Vars, ++Precision, ++LinLog)\n\n   Refine the intervals of Vars by the squashing algorithm.\n\nArguments\n   Vars    Collection (a la collection_to_list/2) of variables\n   Precision    Minimum required precision (float)\n   LinLog    Domain splitting method (lin or log)\n\nType\n   library(ic)\n\nDescription\n\n   Use the squash algorithm on Vars.  This is a deterministic reduction of\n   the intervals of variables, done by searching for domain restrictions\n   which cause failure, and then reducing the domain to the complement of\n   that which caused the failure.  This algorithm is appropriate when the\n   problem has continuous solution intervals (where locate would return many\n   adjacent solutions).\n\n   Precision is the minimum required precision, i.e. the maximum size of the\n   resulting intervals (in either absolute or relative terms).  Note that\n   the arc-propagation threshold (set by set_threshold/1,2), needs to be one\n   or several orders of magnitude smaller than Precision, otherwise the\n   solver may not be able to achieve the required precision.\n\n   The LinLog parameter guides the way domains are split.  If it is set to\n   lin then the split is linear (i.e. the arithmetic mean of the bounds is\n   used).  If it is set to log, the split is logarithmic (i.e. the geometric\n   mean of the bounds is used).  Note that if log is used, there will be\n   roughly the same number of representable floating point numbers on either\n   side of the split, due to the logarithmic distribution of these numbers.\n\n   If the intervals of variables at the start of the squashing algorithm are\n   known not to span several orders of magnitude, the somewhat cheaper\n   linear splitting may be used.  In general, log splitting is recommended.\n\nSee Also\n   locate / 2, locate / 3, locate / 4, set_threshold / 1, get_threshold / 1, lists : collection_to_list / 2"},"ic_edge_finder3:cumulative/4":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:ResourceLimit})$5\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    List of start times for tasks (integer variables or integers)\n   Durations    List of duration for tasks (integer variables or integers)\n   Resources    List of resource uages by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(ic_edge_finder3)\n\nDescription\n\n   A cumulative scheduling constraint. StartTimes, Durations and Resources\n   are collections (a la collection_to_list/2) of equal size N of integer\n   variables or integers.  ResourceLimit is an integer. The declarative\n   meaning is:\n   If there are N tasks, each starting at a certain start time, having\n   a certain duration and consuming a certain (constant) amount of\n   resource, then the sum of resource usage of all the tasks does not\n   exceed ResourceLimit at any time.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\n   This constraint can propagate more information than the implementation\n   in library(ic_cumulative) and library(cumulative).\n\nSee Also\n   disjunctive / 2, cumulative / 5, lists : collection_to_list / 2, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"ic_edge_finder3:disjunctive_bools/3":{"prefix":"disjunctive_bools","body":"disjunctive_bools(${1:StartTimes}, ${2:Durations}, ${3:OrderingBools})$4\n$0","description":"disjunctive_bools(+StartTimes, +Durations, ?OrderingBools)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   OrderingBools       Variable, or list of ordering Booleans (variable or 0 or 1)\n\nType\n   library(ic_edge_finder3)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    OrderingBools is a list of ordering Booleans. For each possible pair of\n    tasks, there is one Boolean which describes the order of these two tasks.\n    If the Tasks are numbered 1..N, and the Booleans are numbered\n    1..N*(N-1)//2, then the Boolean corresponding to the task pair I,J\n    (with I>J) has the index (I-1)(I-2)//2 + J.  In other words, the\n    OrderingBools list is a flattened version of a strictly lower\n    triangular matrix of ordering Booleans, i.e.\n    \n    I\\J|  1    2    3    4    5\n    ---+--------------------------\n    1  |  .    .    .    .    .\n    2  | B[1]  .    .    .    .\n    3  | B[2] B[3]  .    .    .\n    4  | B[4] B[5] B[6]  .    .\n    5  | B[7] B[8] B[9] B[10] .\n    \n    The Boolean being set to 1 indicates that task I is before task J,\n    a value of 0 indicates that task J is before task I. If uninstantiated,\n    the order is not (yet) determined. Operationally, the constraint will\n    both infer start time bounds from the setting of the Booleans, and\n    infer Boolean settings from the start times and durations.\n\n    The Booleans should be used for making search choices, typically by\n    setting them such that a task is chosen to be first (or last) among\n    a group of tasks.\n\n    Any Start and Duration variables which do not already have finite bounds\n    will be given default bounds of -10000000 to 10000000. The Booleans on\n    the other hand can be domainless variables, and the only way in which\n    the constraint will affect them is by instantiation to 0 or 1.\n\nModes and Determinism\n   disjunctive_bools(+, +, +)\n   disjunctive_bools(+, +, -)\n\nSee Also\n   disjunctive / 2, lists : collection_to_list / 2, edge_finder3 : disjunctive_bools / 3, edge_finder : disjunctive_bools / 3, ic_edge_finder : disjunctive_bools / 3"},"ic_edge_finder3:cumulative/5":{"prefix":"cumulative","body":"cumulative(${1:StartTimes}, ${2:Durations}, ${3:Resources}, ${4:Areas}, ${5:ResourceLimit})$6\n$0","description":"cumulative(+StartTimes, +Durations, +Resources, +Areas, ++ResourceLimit)\n\n   Cumulative constraint on specified tasks.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n   Resources    Collection of resource usages by tasks (integer variables or integers)\n   Areas    Collection of areas covered by tasks (integer variables or integers)\n   ResourceLimit       Maximum amount of resource available (integer)\n\nType\n   library(ic_edge_finder3)\n\nDescription\n\n   In this variant, an area (the product of duration and resource usage of\n   a task) can be specified, e.g. if duration or reource usage are not\n   known in advance. The edge-finder algorithm can make use of this information\n   to derive bound updates.\n\n   Any input variables which do not already have finite bounds will be\n   given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive / 2, cumulative / 4, lists : collection_to_list / 2, edge_finder3 : cumulative / 5, edge_finder : cumulative / 5, ic_edge_finder : cumulative / 5"},"ic_edge_finder3:ic_edge_finder3_desc":{"prefix":"lib","body":"lib(${1:ic_edge_finder3})$2\n$0","description":"lib(ic_edge_finder3)\n\n   \n    This library implements the cubic edge-finder algorithm for the\n    disjunctive and cumulative scheduling constraints for the IC solver.\n    It provides the strongest propagation of the three libraries for\n    cumulative constraints: ic_cumulative, ic_edge_finder and\n    ic_edge_finder3.  It is also computationally the most expensive.\n\n    Note that the same predicates are implemented in both ic_edge_finder\n    and ic_edge_finder3 libraries."},"ic_edge_finder3:disjunctive/2":{"prefix":"disjunctive","body":"disjunctive(${1:StartTimes}, ${2:Durations})$3\n$0","description":"disjunctive(+StartTimes, +Durations)\n\n   Constrain the tasks with specified start times and durations to not overlap in time.\n\nArguments\n   StartTimes    Collection of start times for tasks (integer variables or integers)\n   Durations    Collection of duration for tasks (integer variables or integers)\n\nType\n   library(ic_edge_finder3)\n\nDescription\n\n    A disjunctive scheduling constraint. StartTimes and Durations are\n    collections (a la collection_to_list/2) of equal size N of integer\n    variables or integers.  The declarative meaning is that the N tasks with\n    the given start times and durations do not overlap at any point in time.\n\n    Any input variables which do not already have finite bounds will be\n    given default bounds of -10000000 to 10000000.\n\nSee Also\n   disjunctive_bools / 3, lists : collection_to_list / 2, edge_finder3 : disjunctive / 2, edge_finder : disjunctive / 2, ic_edge_finder : disjunctive / 2, gfd : disjunctive / 2"},"ic_gap_sbdd:all_solutions/1":{"prefix":"all_solutions","body":"all_solutions(${1:Goal})$2\n$0","description":"all_solutions(+Goal)\n\n   Find all solutions to the given goal\n\nArguments\n   Goal    The goal to execute\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Finds all solutions for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of dominance checks\n   performed, etc.).\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 2, first_solution / 1"},"ic_gap_sbdd:all_solutions/2":{"prefix":"all_solutions","body":"all_solutions(${1:Goal}, ${2:NSols})$3\n$0","description":"all_solutions(+Goal, ?NSols)\n\n   Find all solutions to the given goal\n\nArguments\n   Goal    The goal to execute\n   NSols    The number of solutions found\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Finds all solutions for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of dominance checks\n   performed, etc.).  The number of solutions found is unified with NSols.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 1, first_solution / 1"},"ic_gap_sbdd:first_solution/1":{"prefix":"first_solution","body":"first_solution(${1:Goal})$2\n$0","description":"first_solution(+Goal)\n\n   Find the first solution to the given goal\n\nArguments\n   Goal    The goal to execute\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Finds the first solution for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of dominance checks\n   performed, etc.).\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 1, all_solutions / 2"},"ic_gap_sbdd:ic_gap_sbdd_desc":{"prefix":"lib","body":"lib(${1:ic_gap_sbdd})$2\n$0","description":"lib(ic_gap_sbdd)\n\n   This library provides a GAP-based Symmetry Breaking via Dominance\n   Detection (SBDD) library, as described in:\n\n   Ian P. Gent, Warwick Harvey, Tom Kelsey and Steve Linton.  \"Generic SBDD\n   using Computational Group Theory\".  In Francesca Rossi, editor,\n   Proceedings of the Ninth International Conference on Principles and\n   Practice of Constraint Programming - CP 2003, LNCS 2833, pages\n   333-347.  Springer-Verlag, 2003.\n\n   It has been enhanced by (amongst other things) being integrated with the\n   symmetry expression library described in:\n\n   Warwick Harvey, Tom Kelsey and Karen Petrie.  \"Symmetry Group Expression\n   for CSPs.\"  In Barbara Smith et al., editors, Proceedings of\n   SymCon'03: Third International Workshop on Symmetry in Constraint\n   Satisfaction Problems, a workshop of CP 2003, pages 86-96.\n   September, 2003.\n\n   This library is still being developed and is expected to evolve.\n   Feedback, suggestions, problem reports, etc. welcome.\n\n   Please note that this library currently does not work on Windows machines\n   due to its dependence on the GAP interface library."},"ic_gap_sbdd:is_sbdd_var/1":{"prefix":"is_sbdd_var","body":"is_sbdd_var(${1:Var})$2\n$0","description":"is_sbdd_var(?Var)\n\n   Checks whether a variable is an SBDD variable\n\nArguments\n   Var    The variable to check\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Succeeds iff Var is an SBDD variable (i.e. has been initialised through\n   a call to sbdd_initialise/5)."},"ic_gap_sbdd:sbdd_indomain/1":{"prefix":"sbdd_indomain","body":"sbdd_indomain(${1:Var})$2\n$0","description":"sbdd_indomain(?Var)\n\n   Instantiate an integer SBDD variable to an element of its domain\n\nArguments\n   Var    The (integer) SBDD variable to instantiate, or an integer\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Like indomain/1, but uses sbdd_try/2 to do the instantiation so that the\n   SBDD dominance checks are performed appropriately.\n\nSee Also\n   fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, sbdd_try / 2, sbdd_labeling / 1"},"ic_gap_sbdd:sbdd_initialise/5":{"prefix":"sbdd_initialise","body":"sbdd_initialise(${1:Array}, ${2:VarDimNames}, ${3:ValueDimSpec}, ${4:SymSpecs}, ${5:Options})$6\n$0","description":"sbdd_initialise(+Array, ++VarDimNames, ++ValueDimSpec, +SymSpecs, +Options)\n\n   Initialises the data structures required by the SBDD algorithm\n\nArguments\n   Array    Array of (integer) decision variables\n   VarDimNames    Names for the dimensions of Array\n   ValueDimSpec    Name of the value dimension and its range\n   SymSpecs    List of symmetry specifiers\n   Options    List of extra options\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Sets up the data structures required to perform an SBDD search.  Array is\n   an array containing the (integer) search variables, SymSpecs defines the\n   symmetries of the problem, with VarDimNames and ValueDimSpec providing\n   some extra required information; these four arguments are the same as the\n   first four arguments of construct_group/8: please see the documentation\n   for that predicate for a complete description of these arguments and\n   details of the supported symmetry specifiers.\n\n   Options is a list of options which modify the way the search progresses.\n   Currently only one option is supported: throttle(ThrottlePred).  This\n   option can be used to control whether or not the SBDD dominance check is\n   invoked at any given node.  At each node, before performing the dominance\n   check, ThrottlePred is called with an extra argument appended, and if the\n   call fails, the dominance check is skipped.  The extra argument is the\n   sbdd_shared data structure, which holds the current state of the SBDD\n   search; its fields can be examined (e.g. the current search depth) in\n   order to decide whether to proceed with the dominance check or not.\n\n   During search, use sbdd_try/2 or sbdd_try/3 on variables from Array when\n   making search decisions.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   sbdd_initialise_set / 5, sym_expr : construct_group / 8, struct(sbdd_shared), sbdd_try / 2, sbdd_try / 3"},"ic_gap_sbdd:sbdd_initialise_set/5":{"prefix":"sbdd_initialise_set","body":"sbdd_initialise_set(${1:Array}, ${2:VarDimNames}, ${3:ValueDimSpec}, ${4:SymSpecs}, ${5:Options})$6\n$0","description":"sbdd_initialise_set(+Array, ++VarDimNames, ++ValueDimSpec, +SymSpecs, +Options)\n\n   Initialises the data structures required by the SBDD algorithm (set version)\n\nArguments\n   Array    Array of integer set decision variables\n   VarDimNames    Names for the dimensions of Array\n   ValueDimSpec    Name of the value dimension and its range\n   SymSpecs    List of symmetry specifiers\n   Options    List of extra options\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Like sbdd_initialise/5, but for set models (i.e. Array should be an array\n   of integer set variables).  The \"value\" dimension is the values that can \n   appear in the set, so that, for example, a range of 1..5 indicates that\n   the upper bound of the set variables is [1,2,3,4,5].\n\n   See the documentation for sbdd_initialise/5 for more details.\n\n   During search, use sbdd_try_set/3 or sbdd_try_set/4 on variables from\n   Array when making search decisions.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   sbdd_initialise / 5, sbdd_try_set / 3, sbdd_try_set / 4"},"ic_gap_sbdd:sbdd_labeling/1":{"prefix":"sbdd_labeling","body":"sbdd_labeling(${1:List})$2\n$0","description":"sbdd_labeling(?List)\n\n   Instantiate all integer SBDD variables in a list to elements of their domains\n\nArguments\n   List    A list of integer SBDD variables or integers\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Like labeling/1, but uses sbdd_indomain/1 to do the instantiation so that\n   the SBDD dominance checks are performed appropriately.\n\nSee Also\n   fd : labeling / 1, sd : labeling / 1, ic : labeling / 1, gfd : labeling / 1, sbdd_indomain / 1"},"ic_gap_sbdd:sbdd_shared/s":{"prefix":"struct","body":"struct","description":"struct sbdd_shared(array, depth, dec_info_list, dim_factors, val_offset, ground_points, throttle_pred, module)\n\n   Structure containing information for GAP-SBDD search\n\nFields\n   array    Array of decision variables\n   depth    Current depth of search tree\n   dec_info_list       \n   dim_factors    \n   val_offset    \n   ground_points       \n   throttle_pred       \n   module    \n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Most of the contents of this structure are subject to change in future\n   versions of the library and thus should not be accessed by user-level\n   code.  The user should also not change the contents of this structure!"},"ic_gap_sbdd:sbdd_try/2":{"prefix":"sbdd_try","body":"sbdd_try(${1:Var}, ${2:Value})$3\n$0","description":"sbdd_try(+Var, ++Value)\n\n   Try assigning a value to an SBDD search variable\n\nArguments\n   Var    The variable to use\n   Value    The value to try\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Make an SBDD search choice.  Specifically, try assigning the (integer)\n   value Value to the variable Var; on backtracking exclude the value Value\n   from the domain of Var.\n\n   Var should be an element of an array previously initialised using\n   sbdd_initialise/5.\n\n   Use sbdd_try/3 if you wish to know which is the currently successful\n   branch (Var #= Value or Var #\\= Value).\n\nSee Also\n   sbdd_initialise / 5, sbdd_try / 3"},"ic_gap_sbdd:sbdd_try/3":{"prefix":"sbdd_try","body":"sbdd_try(${1:Var}, ${2:Value}, ${3:Success})$4\n$0","description":"sbdd_try(+Var, ++Value, ?Success)\n\n   Try assigning a value to an SBDD search variable\n\nArguments\n   Var    The variable to use\n   Value    The value to try\n   Success    Whether the assignment succeeded or not\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Like sbdd_try/2, but assign 1 to Success if we have set Var #= Value, and\n   assign 0 if we have set Var #\\= Value (effectively, Success reflects the\n   truth of Var #= Value when the predicate succeeds).\n\n   See the documentation for sbdd_try/2 for more details.\n\nSee Also\n   sbdd_initialise / 5, sbdd_try / 2"},"ic_gap_sbdd:sbdd_try_set/3":{"prefix":"sbdd_try_set","body":"sbdd_try_set(${1:Var}, ${2:Value}, ${3:Bool})$4\n$0","description":"sbdd_try_set(+Var, ++Value, ++Bool)\n\n   Try adding/excluding a value to/from an SBDD set search variable\n\nArguments\n   Var    The set variable to use\n   Value    The value to try\n   Bool    Whether to add or exclude the value first\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Make an SBDD (set) search choice.  Specifically, if Bool is 1, try adding\n   the (integer) value Value to the (set) variable Var; on backtracking\n   exclude it.  If Bool is 0, try excluding Value first and try adding it on\n   backtracking.\n\n   Var should be an element of an array previously initialised using\n   sbdd_initialise_set/5.\n\n   Use sbdd_try_set/4 if you wish to know which is the currently successful\n   branch (Value in Var or Value notin Var).\n\nSee Also\n   sbdd_initialise_set / 5, sbdd_try_set / 4, sbdd_try / 2"},"ic_gap_sbdd:sbdd_try_set/4":{"prefix":"sbdd_try_set","body":"sbdd_try_set(${1:Var}, ${2:Value}, ${3:Bool}, ${4:Success})$5\n$0","description":"sbdd_try_set(+Var, ++Value, ++Bool, ?Success)\n\n   Try adding/excluding a value to/from an SBDD set search variable\n\nArguments\n   Var    The set variable to use\n   Value    The value to try\n   Bool    Whether to add or exclude the value first\n   Success    Whether the assignment succeeded or not\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Like sbdd_try_set/3, but assign 1 to Success if we have Value in Var, and\n   assign 0 if we have Value notin Var (effectively, Success reflects the\n   truth of Value in Var when the predicate succeeds).\n\n   See the documentation for sbdd_try_set/3 for more details.\n\nSee Also\n   sbdd_initialise_set / 5, sbdd_try_set / 3, sbdd_try / 3"},"ic_gap_sbdd:throttle_default/1":{"prefix":"throttle_default","body":"throttle_default(${1:SBDDInfo})$2\n$0","description":"throttle_default(+SBDDInfo)\n\n   Default throttling predicate\n\nArguments\n   SBDDInfo    The sbdd_shared data structure\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Default throttling predicate used if none is given to sbdd_initialise/5\n   or sbdd_initialise_set/5.  This predicate simply succeeds, meaning that\n   a dominance check is performed at every node in the search tree.\n\nSee Also\n   sbdd_initialise / 5, sbdd_initialise_set / 5, throttle_depth_unique / 2, throttle_depth_non_unique / 2, throttle_depth_mod_unique / 2, throttle_depth_mod_non_unique / 2"},"ic_gap_sbdd:throttle_depth_mod_non_unique/2":{"prefix":"throttle_depth_mod_non_unique","body":"throttle_depth_mod_non_unique(${1:DepthModulus}, ${2:SBDDInfo})$3\n$0","description":"throttle_depth_mod_non_unique(++DepthModulus, +SBDDInfo)\n\n   Example throttling predicate\n\nArguments\n   DepthModulus    Depth modulus\n   SBDDInfo    The sbdd_shared data structure\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Throttling predicate for use as an option to sbdd_initialise/5\n   or sbdd_initialise_set/5.  This predicate succeeds if the search depth is\n   a multiple of DepthModulus.  Note that this means that solutions found\n   are not guaranteed to be unique.\n\nSee Also\n   sbdd_initialise / 5, sbdd_initialise_set / 5, throttle_default / 1, throttle_depth_unique / 2, throttle_depth_non_unique / 2, throttle_depth_mod_unique / 2"},"ic_gap_sbdd:throttle_depth_mod_unique/2":{"prefix":"throttle_depth_mod_unique","body":"throttle_depth_mod_unique(${1:DepthModulus}, ${2:SBDDInfo})$3\n$0","description":"throttle_depth_mod_unique(++DepthModulus, +SBDDInfo)\n\n   Example throttling predicate\n\nArguments\n   DepthModulus    Depth modulus\n   SBDDInfo    The sbdd_shared data structure\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Throttling predicate for use as an option to sbdd_initialise/5\n   or sbdd_initialise_set/5.  This predicate succeeds if the search depth is\n   a multiple of DepthModulus, or if the variable array is ground (ensuring\n   solutions are guaranteed to be unique).\n\nSee Also\n   sbdd_initialise / 5, sbdd_initialise_set / 5, throttle_default / 1, throttle_depth_unique / 2, throttle_depth_non_unique / 2, throttle_depth_mod_non_unique / 2"},"ic_gap_sbdd:throttle_depth_non_unique/2":{"prefix":"throttle_depth_non_unique","body":"throttle_depth_non_unique(${1:MaxDepth}, ${2:SBDDInfo})$3\n$0","description":"throttle_depth_non_unique(++MaxDepth, +SBDDInfo)\n\n   Example throttling predicate\n\nArguments\n   MaxDepth    Cut-off depth\n   SBDDInfo    The sbdd_shared data structure\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Throttling predicate for use as an option to sbdd_initialise/5\n   or sbdd_initialise_set/5.  This predicate succeeds if the search depth\n   does not exceed MaxDepth.  Note that this means that solutions found are\n   not guaranteed to be unique.\n\nSee Also\n   sbdd_initialise / 5, sbdd_initialise_set / 5, throttle_default / 1, throttle_depth_unique / 2, throttle_depth_mod_unique / 2, throttle_depth_mod_non_unique / 2"},"ic_gap_sbdd:throttle_depth_unique/2":{"prefix":"throttle_depth_unique","body":"throttle_depth_unique(${1:MaxDepth}, ${2:SBDDInfo})$3\n$0","description":"throttle_depth_unique(++MaxDepth, +SBDDInfo)\n\n   Example throttling predicate\n\nArguments\n   MaxDepth    Cut-off depth\n   SBDDInfo    The sbdd_shared data structure\n\nType\n   library(ic_gap_sbdd)\n\nDescription\n   Throttling predicate for use as an option to sbdd_initialise/5\n   or sbdd_initialise_set/5.  This predicate succeeds if the search depth\n   does not exceed MaxDepth, or if the variable array is ground (ensuring\n   solutions are guaranteed to be unique).\n\nSee Also\n   sbdd_initialise / 5, sbdd_initialise_set / 5, throttle_default / 1, throttle_depth_non_unique / 2, throttle_depth_mod_unique / 2, throttle_depth_mod_non_unique / 2"},"ic_gap_sbds:all_solutions/1":{"prefix":"all_solutions","body":"all_solutions(${1:Goal})$2\n$0","description":"all_solutions(+Goal)\n\n   Find all solutions to the given goal\n\nArguments\n   Goal    The goal to execute\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Finds all solutions for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of backtracks, etc.).\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 2, first_solution / 1"},"ic_gap_sbds:all_solutions/2":{"prefix":"all_solutions","body":"all_solutions(${1:Goal}, ${2:NSols})$3\n$0","description":"all_solutions(+Goal, ?NSols)\n\n   Find all solutions to the given goal\n\nArguments\n   Goal    The goal to execute\n   NSols    The number of solutions found\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Finds all solutions for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of backtracks, etc.).  The\n   number of solutions found is unified with NSols.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 1, first_solution / 1"},"ic_gap_sbds:first_solution/1":{"prefix":"first_solution","body":"first_solution(${1:Goal})$2\n$0","description":"first_solution(+Goal)\n\n   Find the first solution to the given goal\n\nArguments\n   Goal    The goal to execute\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Finds the first solution for the goal Goal, and prints various statistics\n   about the computation (CPU time taken, number of backtracks, etc.).\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   all_solutions / 1, all_solutions / 2"},"ic_gap_sbds:ic_gap_sbds_desc":{"prefix":"lib","body":"lib(${1:ic_gap_sbds})$2\n$0","description":"lib(ic_gap_sbds)\n\n   This library provides a GAP-based Symmetry Breaking During Search (SBDS)\n   library, as described in:\n\n   Ian P. Gent, Warwick Harvey and Tom Kelsey.  \"Groups and Constraints:\n   Symmetry Breaking during Search.\".  In P. Van Hentenryck, editor,\n   Proceedings of the Eighth International Conference on Principles and\n   Practice of Constraint Programming - CP 2002, LNCS 2470, pages\n   415-430.  Springer-Verlag, 2002.\n\n   It has been enhanced by (amongst other things) being integrated with the\n   symmetry expression library described in:\n\n   Warwick Harvey, Tom Kelsey and Karen Petrie.  \"Symmetry Group Expression\n   for CSPs.\"  In Barbara Smith et al., editors, Proceedings of\n   SymCon'03: Third International Workshop on Symmetry in Constraint\n   Satisfaction Problems, a workshop of CP 2003, pages 86-96.\n   September, 2003.\n\n   This library is still being developed and is expected to evolve.\n   Feedback, suggestions, problem reports, etc. welcome.\n\n   Please note that this library currently does not work on Windows machines\n   due to its dependence on the GAP interface library."},"ic_gap_sbds:is_sbds_var/1":{"prefix":"is_sbds_var","body":"is_sbds_var(${1:Var})$2\n$0","description":"is_sbds_var(?Var)\n\n   Checks whether a variable is an SBDS variable\n\nArguments\n   Var    The variable to check\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Succeeds iff Var is an SBDS variable (i.e. has been initialised through\n   a call to sbds_initialise/5)."},"ic_gap_sbds:sbds_indomain/1":{"prefix":"sbds_indomain","body":"sbds_indomain(${1:Var})$2\n$0","description":"sbds_indomain(?Var)\n\n   Instantiate an integer SBDS variable to an element of its domain\n\nArguments\n   Var    The (integer) SBDS variable to instantiate, or an integer\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Like indomain/1, but uses sbds_try/2 to do the instantiation so that the\n   SBDS algorithms are invoked appropriately.\n\nSee Also\n   fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, sbds_try / 2, sbds_labeling / 1"},"ic_gap_sbds:sbds_initialise/5":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:Array}, ${2:VarDimNames}, ${3:ValueDimSpec}, ${4:SymSpecs}, ${5:Options})$6\n$0","description":"sbds_initialise(+Array, ++VarDimNames, ++ValueDimSpec, +SymSpecs, +Options)\n\n   Initialises the data structures required by the SBDS algorithm\n\nArguments\n   Array    Array of (integer) decision variables\n   VarDimNames    Names for the dimensions of Array\n   ValueDimSpec    Name of the value dimension and its range\n   SymSpecs    List of symmetry specifiers\n   Options    List of extra options\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Sets up the data structures required to perform an SBDS search.  Array is\n   an array containing the (integer) search variables, SymSpecs defines the\n   symmetries of the problem, with VarDimNames and ValueDimSpec providing\n   some extra required information; these four arguments are the same as the\n   first four arguments of construct_group/8: please see the documentation\n   for that predicate for a complete description of these arguments and\n   details of the supported symmetry specifiers.\n\n   Options is a list of options which modify the way the search progresses.\n   Currently no options are supported.\n\n   During search, use sbds_try/2 or sbds_try/3 on variables from Array when\n   making search decisions.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   sbds_initialise_set / 5, sym_expr : construct_group / 8, sbds_try / 2, sbds_try / 3"},"ic_gap_sbds:sbds_initialise_set/5":{"prefix":"sbds_initialise_set","body":"sbds_initialise_set(${1:Array}, ${2:VarDimNames}, ${3:ValueDimSpec}, ${4:SymSpecs}, ${5:Options})$6\n$0","description":"sbds_initialise_set(+Array, ++VarDimNames, ++ValueDimSpec, +SymSpecs, +Options)\n\n   Initialises the data structures required by the SBDS algorithm (set version)\n\nArguments\n   Array    Array of integer set decision variables\n   VarDimNames    Names for the dimensions of Array\n   ValueDimSpec    Name of the value dimension and its range\n   SymSpecs    List of symmetry specifiers\n   Options    List of extra options\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Like sbds_initialise/5, but for set models (i.e. Array should be an array\n   of integer set variables).  The \"value\" dimension is the values that can \n   appear in the set, so that, for example, a range of 1..5 indicates that\n   the upper bound of the set variables is [1,2,3,4,5].\n\n   See the documentation for sbds_initialise/5 for more details.\n\n   During search, use sbds_try_set/3 or sbds_try_set/4 on variables from\n   Array when making search decisions.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   sbds_initialise / 5, sbds_try_set / 3, sbds_try_set / 4"},"ic_gap_sbds:sbds_labeling/1":{"prefix":"sbds_labeling","body":"sbds_labeling(${1:List})$2\n$0","description":"sbds_labeling(?List)\n\n   Instantiate all integer SBDS variables in a list to elements of their domains\n\nArguments\n   List    A list of integer SBDS variables or integers\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Like labeling/1, but uses sbds_indomain/1 to do the instantiation so that\n   the SBDS algorithms are invoked appropriately.\n\nSee Also\n   fd : labeling / 1, sd : labeling / 1, ic : labeling / 1, gfd : labeling / 1, sbds_indomain / 1"},"ic_gap_sbds:sbds_try/2":{"prefix":"sbds_try","body":"sbds_try(${1:Var}, ${2:Value})$3\n$0","description":"sbds_try(+Var, ++Value)\n\n   Try assigning a value to an SBDS search variable\n\nArguments\n   Var    The variable to use\n   Value    The value to try\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Make an SBDS search choice.  Specifically, try assigning the (integer)\n   value Value to the variable Var; on backtracking exclude the value Value\n   from the domain of Var.\n\n   Var should be an element of an array previously initialised using\n   sbds_initialise/5.\n\n   Use sbds_try/3 if you wish to know which is the currently successful\n   branch (Var #= Value or Var #\\= Value).\n\nSee Also\n   sbds_initialise / 5, sbds_try / 3"},"ic_gap_sbds:sbds_try/3":{"prefix":"sbds_try","body":"sbds_try(${1:Var}, ${2:Value}, ${3:Success})$4\n$0","description":"sbds_try(+Var, ++Value, ?Success)\n\n   Try assigning a value to an SBDS search variable\n\nArguments\n   Var    The variable to use\n   Value    The value to try\n   Success    Whether the assignment succeeded or not\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Like sbds_try/2, but assign 1 to Success if we have set Var #= Value, and\n   assign 0 if we have set Var #\\= Value (effectively, Success reflects the\n   truth of Var #= Value when the predicate succeeds).\n\n   See the documentation for sbds_try/2 for more details.\n\nSee Also\n   sbds_initialise / 5, sbds_try / 2"},"ic_gap_sbds:sbds_try_set/3":{"prefix":"sbds_try_set","body":"sbds_try_set(${1:Var}, ${2:Value}, ${3:Bool})$4\n$0","description":"sbds_try_set(+Var, ++Value, ++Bool)\n\n   Try adding/excluding a value to/from an SBDS set search variable\n\nArguments\n   Var    The set variable to use\n   Value    The value to try\n   Bool    Whether to add or exclude the value first\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Make an SBDS (set) search choice.  Specifically, if Bool is 1, try adding\n   the (integer) value Value to the (set) variable Var; on backtracking\n   exclude it.  If Bool is 0, try excluding Value first and try adding it on\n   backtracking.\n\n   Var should be an element of an array previously initialised using\n   sbds_initialise_set/5.\n\n   Use sbds_try_set/4 if you wish to know which is the currently successful\n   branch (Value in Var or Value notin Var).\n\nSee Also\n   sbds_initialise_set / 5, sbds_try_set / 4, sbds_try / 2"},"ic_gap_sbds:sbds_try_set/4":{"prefix":"sbds_try_set","body":"sbds_try_set(${1:Var}, ${2:Value}, ${3:Bool}, ${4:Success})$5\n$0","description":"sbds_try_set(+Var, ++Value, ++Bool, ?Success)\n\n   Try adding/excluding a value to/from an SBDS set search variable\n\nArguments\n   Var    The set variable to use\n   Value    The value to try\n   Bool    Whether to add or exclude the value first\n   Success    Whether the assignment succeeded or not\n\nType\n   library(ic_gap_sbds)\n\nDescription\n   Like sbds_try_set/3, but assign 1 to Success if we have Value in Var, and\n   assign 0 if we have Value notin Var (effectively, Success reflects the\n   truth of Value in Var when the predicate succeeds).\n\n   See the documentation for sbds_try_set/3 for more details.\n\nSee Also\n   sbds_initialise_set / 5, sbds_try_set / 3, sbds_try / 3"},"ic_global:alldifferent/2":{"prefix":"alldifferent","body":"alldifferent(${1:Vars}, ${2:Capacity})$3\n$0","description":"alldifferent(+Vars, ++Capacity)\n\n   Vars contains at most Capacity elements of each value\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n   Capacity    Maximum number of times a value can appear in Vars\n\nType\n   library(ic_global)\n\nDescription\n    This is a generalization of alldifferent/1.  It allows repeated elements\n    in the collection, but there can be no more than Capacity elements with\n    a particular value.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nSee Also\n   alldifferent / 1, lists : collection_to_list / 2"},"ic_global:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:Vars})$2\n$0","description":"alldifferent(+Vars)\n\n   All members of Vars are different\n\nArguments\n   Vars    A collection (a la collection_to_list/2) of variables or integers\n\nType\n   library(ic_global)\n\nDescription\n    Constrains all elements of a collection to be pairwise different (and\n    integral).  This is an implementation with the same semantics as the\n    standard alldifferent/1 constraint, but with stronger propagation\n    behaviour.  It checks for exhaustion of all sub-ranges of possible\n    values.\n    \n    The algorithm is based roughly on: Jean Francois Puget, A fast algorithm\n    for the bound consistency of the alldiff constraint, AAAI 1998, but\n    makes some additional inferences based on domain size.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nExamples\n   \n    ?- length(Xs,5), Xs::1..4, alldifferent(Xs).\n    no (more) solution.\n\n    ?- [X1,X2]::1..2, [X3,X4,X5]::1..5, alldifferent([X1,X2,X3,X4,X5]).\n\n    X1 = X1{[1, 2]}\n    X2 = X2{[1, 2]}\n    X3 = X3{[3..5]}\n    X4 = X4{[3..5]}\n    X5 = X5{[3..5]}\n\n    Delayed goals:\n    alldifferent([X1{[1, 2]}, X2{[1, 2]}], 1)\n    alldifferent([X3{[3..5]}, X4{[3..5]}, X5{[3..5]}], 1)\n    \n\nSee Also\n   fd : alldifferent / 1, ic_symbolic : alldifferent / 1, sd : alldifferent / 1, ic : alldifferent / 1, gfd : alldifferent / 1, fd_global : alldifferent / 1, ic_global_gac : alldifferent / 1, fd_global_gac : alldifferent / 1, alldifferent / 2, lists : collection_to_list / 2"},"ic_global:alldifferent_matrix/1":{"prefix":"alldifferent_matrix","body":"alldifferent_matrix(${1:Matrix})$2\n$0","description":"alldifferent_matrix(+Matrix)\n\n   Constrain the rows and columns of Matrix to be different values\n\nArguments\n   Matrix    A two dimensional square matrix of Variables or integer\n\nType\n   library(ic_global)\n\nDescription\n\n    This constraint is a matrix version of alldifferent. Matrix is a two\n    dimensional square (NxN) matrix, and the constraint ensures that the \n    elements in each row and column of the matrix are different. The same\n    value can occur in different rows and columns. It is logically \n    equivalent to imposing 2N alldifferent constraints, on each row and column,\n    but it allows more reasoning because it considers the rows and columns \n    together. The alldifferent constraint used is the lib(ic_global) version.\n    The maximum propagation occurs when the variables' domains also\n    have N values\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   alldifferent / 1, fd_global : alldifferent_matrix / 1, ic_global_gac : alldifferent_matrix / 1, fd_global_gac : alldifferent_matrix / 1"},"ic_global:atleast/3":{"prefix":"atleast","body":"atleast(${1:N}, ${2:Vars}, ${3:V})$4\n$0","description":"atleast(+N, ?Vars, +V)\n\n   At least N elements of Vars have the value V.\n\nArguments\n   +N    An integer\n   ?Vars    A collection (a la collection_to_list/2) of domain variables or integers\n   +V    An integer\n\nType\n   library(ic_global)\n\nDescription\n   This constraint ensures that at least N element of Vars have the value V.\n   As soon as some domain variable from the collection is updated, this\n   constraint is woken and it checks if the constraint is still satisfiable\n   and if so, if it is already satisfied or not.\n\nFail Conditions\n      Fails if less than N elements of Vars can take value V.\n\nSee Also\n   atmost / 3, occurrences / 3, lists : collection_to_list / 2"},"ic_global:atmost/3":{"prefix":"atmost","body":"atmost(${1:N}, ${2:Vars}, ${3:V})$4\n$0","description":"atmost(+N, ?Vars, +V)\n\n   At most N elements of Vars have the value V.\n\nArguments\n   +N    An integer\n   ?Vars    A collection (a la collection_to_list/2) of domain variables or integers\n   +V    An integer\n\nType\n   library(ic_global)\n\nDescription\n   This constraint ensures that at most N element of Vars have the value V.\n   As soon as some domain variable from the collection is updated, this\n   constraint is woken and it checks if the constraint is still satisfiable\n   and if so, if it is already satisfied or not.\n\nFail Conditions\n      Fails if more than N elements of Vars are instantiated to V.\n\nSee Also\n   atleast / 3, occurrences / 3, lists : collection_to_list / 2"},"ic_global:bin_packing/3":{"prefix":"bin_packing","body":"bin_packing(${1:ItemBins}, ${2:ItemSizes}, ${3:BinLoads})$4\n$0","description":"bin_packing(+ItemBins, ++ItemSizes, +BinLoads)\n\n   The one-dimensional bin packing constraint with loads: packing N items into M bins, each bin having a load\n\nArguments\n   ItemBins    A collection of N variables or integers (domain/value between 1 and M)\n   ItemSizes    A collection of N non-negative integers\n   BinLoads    A collection of M variables or non-negative integers\n\nType\n   library(ic_global)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack N\n   items with individual sizes into M bins, such that the sum of sizes of\n   items in each bin equals the load of that bin, as specified in BinLoads.\n   Each element of ItemBins and its corresponding element in ItemSizes\n   represents an item, such that the i'th element of ItemSizes is the size\n   of the i'th item, and the i'th element of Item is the bin this item is\n   packed into. BinLoads represent the load of each bin, i.e. the sum\n   of the sizes of items assigned to that bin, with the j'th element \n   representing the load for bin j. An (integer finite domain) variable for \n   the load allows a constraint on the load to be specified, such as a\n   minimum and/or maximum load for the bin.\n\n   This constraint and the algorithm used to implement it is described in\n   P. Shaw, 'A Constraint for Bin Packing', CP'2004, and is described in\n   the global constraint catalog as bin_packing_capa, where the CAPACITY\n   parameter is replaced by a collection of domain variables\n   \n\nSee Also\n   bin_packing / 4"},"ic_global:bin_packing/4":{"prefix":"bin_packing","body":"bin_packing(${1:ItemBins}, ${2:ItemSizes}, ${3:M}, ${4:BinSize})$5\n$0","description":"bin_packing(+ItemBins, ++ItemSizes, +M, +BinSize)\n\n   The one-dimensional bin packing constraint: packing N items into M bins\n\nArguments\n   ItemBins    A collection of N variables or integers (domain/value between 1 and M)\n   ItemSizes    A collection of N non-negative integers\n   M    A non-negative Integer, the number of bins\n   BinSize    A non-negative integer\n\nType\n   library(ic_global)\n\nDescription\n   This constraint is for one-dimensional bin-packing, that is, to pack N\n   items with individual sizes into M bins, such that the sum of sizes of \n   items in each bin does not exceed BinSize. Each element of ItemBins and its \n   corresponding element in ItemSizes represents an item, such that the i'th \n   element of ItemSizes is the size of the i'th item, and the i'th element in\n   ItemBins is the bin this item is packed into. \n\n   This constraint can be seen as a special case of the cumulative/4\n   constraint, where all task durations are equal to 1, each bin\n   represents a time point, and BinSize corresponds to the Resource.\n\n   This constraint and the algorithm used to implement it is described in\n   P. Shaw, 'A Constraint for Bin Packing', CP'2004, with a fixed size for \n   the bins. It is also described in the global constraint catalog as \n   bin_packing, but with slightly different arguments: in the catalog, M\n   (the number of bins) is implicitly defined by the domain of the variables \n   in ItemBins, and the representation of item is grouped into a single\n   argument of collection of pairs, each pair representing an item:\n   the bin to pack the item, and its size.\n\nSee Also\n   bin_packing / 3, cumulative : cumulative / 4, edge_finder3 : cumulative / 4, edge_finder : cumulative / 4, ic_edge_finder : cumulative / 4, ic_edge_finder3 : cumulative / 4, ic_cumulative : cumulative / 4, gfd : cumulative / 4"},"ic_global:bool_channeling/3":{"prefix":"bool_channeling","body":"bool_channeling(${1:Var}, ${2:DomainBools}, ${3:Min})$4\n$0","description":"bool_channeling(?Var, +DomainBools, +Min)\n\n   Channel the domain values of Vars to the 0/1 boolean variables in DomainBools\n\nArguments\n   Var    An integer domain variable\n   DomainBools    A collection of N 0/1 domain variables or integers\n   Min    An integer\n\nType\n   library(ic_global)\n\nDescription\n\n    Var is an integer domain variable whose initial interval is Min..(Min+N),\n    and this constraint links the domain values of Var with the N 0/1\n    variables in DomainBools such that the i'th variable in DomainBools\n    represents the value Min+i, and its value is 0 if the value is not in\n    Var's domain, and 1 if Var is assigned the value [Thus, only one variable\n    in DomainBools can take the value 1].\n\n    A variant of this constraint, called 'domain_constraint' is in the global \n    constraint catalog. There, instead of having DomainBools and Min, there\n    is a collection of Value-Bool pairs, representing a possible domain value\n    and its associated 0/1 variable. The implementation here is described in\n    the graph model for the domain_constraint in the catalog, and is \n    generalised arc-consistent."},"ic_global:element/3":{"prefix":"element","body":"element(${1:Index}, ${2:List}, ${3:Value})$4\n$0","description":"element(?Index, ++List, ?Value)\n\n   Value is the Index'th element of the integer list List.\n\nArguments\n   ?Index    A variable or an integer.\n   ++List    A non-empty list of integers.\n   ?Value    A variable or an integer.\n\nType\n   library(ic_global)\n\nDescription\nDeprecated (should never have been included in this module: it's not a\n   global constraint).  Use ic:element/3 instead.\n\nFail Conditions\n   Fails if Value is not the Index'th element of List.\n\nResatisfiable\n   No.\n\nSee Also\n   ic : element / 3"},"ic_global:inverse/2":{"prefix":"inverse","body":"inverse(${1:Succ}, ${2:Pred})$3\n$0","description":"inverse(+Succ, +Pred)\n\n   Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph\n\nArguments\n   Succ    A collection of N different variables or integers\n   Pred    A collection  of N different variables or integers\n\nType\n   library(ic_global)\n\nDescription\n\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predessor node, and\n     that if node y is the successor of node x, then node x is the\n     predecessor of node y.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensive and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list."},"ic_global:lex_lt/2":{"prefix":"lex_lt","body":"lex_lt(${1:List1}, ${2:List2})$3\n$0","description":"lex_lt(+List1, +List2)\n\n   List1 is lexicographically less than  List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(ic_global)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached) is strictly smaller than any existing element.\n\nSee Also\n   ordered / 2, gfd : lex_lt / 2, fd_global : lex_lt / 2, ic_global_gac : lex_lt / 2, fd_global_gac : lex_lt / 2, lex_le / 2"},"ic_global:lex_le/2":{"prefix":"lex_le","body":"lex_le(${1:List1}, ${2:List2})$3\n$0","description":"lex_le(+List1, +List2)\n\n   List1 is lexicographically less or equal to List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(ic_global)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails.\n\nExamples\n       L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]).\t\t% X::0..2\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X=2.\t% Y::0..3\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X#>2.\t% fail\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), X#<2.\t% true\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y=3.\t% X::0..2\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y#>3.\t% X::0..1\n    L=[X, Y, Z], L :: 0..9, lex_le(L, [2, 3, 1]), Y#<3.\t% X::0..2\n    lex_le([2, 3, 1], [3]).\t\t\t\t\t% true\n    \n\nSee Also\n   ordered / 2, gfd : lex_le / 2, fd_global : lex_le / 2, ic_global_gac : lex_le / 2, fd_global_gac : lex_le / 2, lex_lt / 2"},"ic_global:maxlist/2":{"prefix":"maxlist","body":"maxlist(${1:List}, ${2:Max})$3\n$0","description":"maxlist(+List, ?Max)\n\n   Max is the maximum of the values in List\n\nArguments\n   List    Collection of integers or domain variables\n   Max    Variable or integer\n\nType\n   library(ic_global)\n\nDescription\n\tMax is the maximum of the values in List.  Operationally: \n\tMax gets updated to reflect the current range of the maximum\n\tof variables and values in List.  Likewise, the list\n\telements get constrained to the maximum given.\n\nSee Also\n   minlist / 2, sumlist / 2, lists : collection_to_list / 2"},"ic_global:minlist/2":{"prefix":"minlist","body":"minlist(${1:List}, ${2:Min})$3\n$0","description":"minlist(+List, ?Min)\n\n   Min is the minimum of the values in List\n\nArguments\n   List    Collection of integers or domain variables\n   Min    Variable or integer\n\nType\n   library(ic_global)\n\nDescription\n    \tMin is the minimum of the values in List.  Operationally: \n\tMin gets updated to reflect the current range of the minimum\n\tof variables and values in List.  Likewise, the list\n\telements get constrained to the minimum given\n\nSee Also\n   maxlist / 2, sumlist / 2, lists : collection_to_list / 2"},"ic_global:occurrences/3":{"prefix":"occurrences","body":"occurrences(${1:Value}, ${2:Vars}, ${3:N})$4\n$0","description":"occurrences(++Value, +Vars, ?N)\n\n   The value Value occurs in Vars N times\n\nArguments\n   Value    Atomic term\n   Vars    Collection (a la collection_to_list/2) of atomic terms or domain variables\n   N    Variable or integer\n\nType\n   library(ic_global)\n\nDescription\n    \t  The value Value occurs in Vars N times.  Operationally:  N\n\t  gets updated to reflect the number of possible occurrences in the\n\t  collection.  Collection elements may get instantiated to Value, or\n\t  Value may be removed from their domain if required by N.\n\nSee Also\n   atleast / 3, atmost / 3, lists : collection_to_list / 2"},"ic_global:ordered/2":{"prefix":"ordered","body":"ordered(${1:Relation}, ${2:List})$3\n$0","description":"ordered(++Relation, +List)\n\n   Constrains List to be ordered according to Relation\n\nArguments\n   Relation    One of the atoms <, =<, >, >=, =\n   List    Collection of integers or domain variables\n\nType\n   library(ic_global)\n\nSee Also\n   lex_le / 2, ordered_sum / 2, sorted / 2, lists : collection_to_list / 2"},"ic_global:ordered_sum/2":{"prefix":"ordered_sum","body":"ordered_sum(${1:List}, ${2:Sum})$3\n$0","description":"ordered_sum(+List, ?Sum)\n\n   The list elements are ordered and their sum is Sum\n\nArguments\n   List    List of integers or domain variables\n   Sum    Variable or integer\n\nType\n   library(ic_global)\n\nDescription\n    This constraint is declaratively equivalent to:\n\n\tordered_sum(List, Sum) :-\n\t    ordered(=\n    However, additional propagation is performed.\n    \n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n\nSee Also\n   ordered / 2, sumlist / 2"},"ic_global:sequence_total/6":{"prefix":"sequence_total","body":"sequence_total(${1:Min}, ${2:Max}, ${3:Low}, ${4:High}, ${5:K}, ${6:ZeroOnes})$7\n$0","description":"sequence_total(+Min, +Max, +Low, +High, +K, +ZeroOnes)\n\n   The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes, and the total occurrences of 1 in ZeroOnes is between Min and Max\n\nArguments\n   Min    Non-negative integer\n   Max    Positive integer\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   ZeroOnes    A list of 0/1 variables or integers\n\nType\n   library(ic_global)\n\nDescription\n\n    This constraint ensures that the number of occurrences of the value 1 is \n    at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes, and at least Min and at most Max in total \n    for all ZeroOnes. ZeroOnes are 0/1 variables (or integers), i.e. they \n    have the domain [0,1].\n\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. For example,\n    sequence_total/7 is implemented by linking the N ZeroOnes variables to  \n    a matching collection of N finite domain `original' variables using \n    element/3 constraints to constrain the ZeroOnes to be 1 if the \n    corresponding original value takes one of the specified values. The\n    ZeroOnes can then be used in further constraint reasoning.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence_total / 7, ic : element / 3, ic_global_gac : sequence / 4, ic_global_gac : sequence / 5"},"ic_global:sequence_total/7":{"prefix":"sequence_total","body":"sequence_total(${1:Min}, ${2:Max}, ${3:Low}, ${4:High}, ${5:K}, ${6:Vars}, ${7:Values})$8\n$0","description":"sequence_total(+Min, +Max, +Low, +High, +K, +Vars, ++Values)\n\n   The number of values taken from Values is between Low and High for all sequences of K variables in Vars, and the total occurrence of each value in Vars is between Min and Max\n\nArguments\n   Min    Non-negative integer\n   Max    Positive integer\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   Vars    A list of variables or integers\n   Values    A list of (different) integers\n\nType\n   library(ic_global)\n\nDescription\n\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars, and at least Min and at most\n    Max in total for all Vars.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence_total / 6, ic : element / 3, ic_global_gac : sequence / 4, ic_global_gac : sequence / 5"},"ic_global:sorted/2":{"prefix":"sorted","body":"sorted(${1:List}, ${2:Sorted})$3\n$0","description":"sorted(?List, ?Sorted)\n\n   Sorted is a sorted permutation of List\n\nArguments\n   List    List of domain variables or integers\n   Sorted    List of domain variables or integers\n\nType\n   library(ic_global)\n\nDescription\n    Declaratively: The two lists have the same length and Sorted is a\n    sorted permutation of List.\n\n    Operationally:  the elements in both lists are constrained such\n    that their domains are consistent with the assumption that the\n    list Sorted is the sorted version of the list List.\n\n    One of the two arguments can be uninstantiated or partial lists\n    at call time.\n\n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n    \n\nModes and Determinism\n   sorted(+, +)\n   sorted(+, -)\n   sorted(-, +)\n\nExamples\n   \n    ?- length(Xs,4), Xs::0..100, sorted(Xs,Ys), Xs = [8,20|_].\n\n    Xs = [8, 20, _340{[0..100]}, _353{[0..100]}]\n    Ys = [_431{[0..8]}, _413{[0..20]}, _523{[8..100]}, _621{[20..100]}]\n\n    ?- length(Ys,4), Ys::0..100, sorted(Xs,Ys), Ys = [8,20|_].\n\n    Xs = [_464{[8..100]}, _477{[8..100]}, _490{[8..100]}, _503{[8..100]}]\n    Ys = [8, 20, _340{[20..100]}, _353{[20..100]}]\n    \n\nSee Also\n   sorted / 3, ordered / 2"},"ic_global:sorted/3":{"prefix":"sorted","body":"sorted(${1:List}, ${2:Sorted}, ${3:Positions})$4\n$0","description":"sorted(?List, ?Sorted, ?Positions)\n\n   Sorted is a sorted permutation (described by Positions) of List\n\nArguments\n   List    List of domain variables or integers\n   Sorted    List of domain variables or integers\n   Positions    List of domain variables or integers\n\nType\n   library(ic_global)\n\nDescription\n    Declaratively:  Sorted is a sorted permutation of List.  Positions\n    is a list whose elements range from 1 to N (where N is the length\n    of the lists) indicating the position of each unsorted list\n    element within the sorted list.  The positions are all different. \n    The three lists are constrained to have the same length.\n\n    Operationally:  the elements in all three lists are constrained\n    such that their domains are consistent with the declarative\n    meaning.\n\n    Two of the three arguments can be uninstantiated or partial lists\n    at call time.\n\n    Any input variables which do not already have finite bounds will\n    be given default bounds of -10000000 to 10000000.\n    \n\nModes and Determinism\n   sorted(+, ?, ?)\n   sorted(?, +, ?)\n   sorted(?, ?, +)\n\nExamples\n   \n    ?- length(Xs,4), Xs::0..100, sorted(Xs,Ys,Ps), Xs = [8,20|_].\n\n    Xs = [8, 20, _346{[0..100]}, _359{[0..100]}]\n    Ys = [_445{[0..8]}, _427{[0..20]}, _537{[8..100]}, _635{[20..100]}]\n    Ps = [_882{[1..3]}, _895{[2..4]}, _908{[1..4]}, _921{[1..4]}]\n    \n\nSee Also\n   sorted / 2, ordered / 2"},"ic_global:sumlist/2":{"prefix":"sumlist","body":"sumlist(${1:List}, ${2:Sum})$3\n$0","description":"sumlist(+List, ?Sum)\n\n   The sum of the list elements is Sum\n\nArguments\n   List    List of integers or domain variables\n   Sum    Variable or integer\n\nType\n   library(ic_global)\n\nDescription\n    \t  The sum of the list elements is Sum.  This constraint is\n\t  more efficient than the general arithmetic constraint if\n\t  the list is long and Sum is not constrained frequently.\n\t  \n\t  Any input variables which do not already have finite bounds will\n\t  be given default bounds of -10000000 to 10000000.\n\nSee Also\n   ordered / 2, ordered_sum / 2, fd : #= / 2, ic : #= / 2, suspend : #= / 2, gfd : #= / 2"},"ic_hybrid_sets:all_disjoint/1":{"prefix":"all_disjoint","body":"all_disjoint(${1:Sets})$2\n$0","description":"all_disjoint(+Sets)\n\n   Sets is a list of integers sets which are all disjoint\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:all_intersection/2":{"prefix":"all_intersection","body":"all_intersection(${1:Sets}, ${2:Intersection})$3\n$0","description":"all_intersection(+Sets, ?Intersection)\n\n   Intersection is the intersection of all the sets in the list Sets\n\nArguments\n   Sets    a non-empty list of sets, set variables or set expressions\n   Intersection    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:all_union/2":{"prefix":"all_union","body":"all_union(${1:Sets}, ${2:SetUnion})$3\n$0","description":"all_union(+Sets, ?SetUnion)\n\n   SetUnion is the union of all the sets in the list Sets\n\nArguments\n   Sets    a list of sets, set variables or set expressions\n   SetUnion    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:difference/3":{"prefix":"difference","body":"difference(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"difference(?Set1, ?Set2, ?Set3)\n\n   Set3 is the difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:get_set_attribute/2":{"prefix":"get_set_attribute","body":"get_set_attribute(${1:Set}, ${2:Attr})$3\n$0","description":"get_set_attribute(?Set, -Attr)\n\n   Get the set-attribute corresponding to Set\n\nArguments\n   Set    A ground set or a set variable\n   Attr    A variable, will be bound to a set-attribute structure\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    Gets the set-attribute of a set-variable (or computes an attribute\n    structure describing a ground set as if it was a variable)."},"ic_hybrid_sets:ic_hybrid_sets_desc":{"prefix":"lib","body":"lib(${1:ic_hybrid_sets})$2\n$0","description":"lib(ic_hybrid_sets)\n\n    This is a solver for constraints over the domain of finite integer sets.\n    \n    (Ground) integer sets are represented simply as sorted, duplicate-free\n    lists of integers e.g.\n    \n    \tSetOfThree = [1,3,7]\n    \tEmptySet = []\n    \n\nSet Variables\n    Set variables are variables which can eventually take a ground integer\n    set as their value. They are characterized by a lower bound (the set \n    of elements that are definitely in the set) and an upper bound (the\n    set of elements that may be in the set). A set variable can be declared\n    as follows:\n    \n    \tSetVar :: []..[1,2,3,4,5,6,7],\n    \n    Since the lower bound is the empty set, this can be written as\n    \n    \tSetVar subset [1,2,3,4,5,6,7],\n    \n    If the lower bound is the empty set and the upper bound is a set\n    of consecutive integers, you can also write\n    \n    \tintset(SetVar, 1, 7)\n    \n\nSet Constraints\n    Most of the usual set operations/relations are provided as constraints:\n    \n    membership\n    non-membership\n    inclusion (subset)\n    equality\n    intersection\n    union\n    difference\n    symmetric difference\n    disjointness\n    cardinality\n    \n    as well as a constraint on set weight.  Note that there is no\n    complement-constraint because the library has no concept of a set\n    universe and cannot represent infinite sets.\n    \n    On most argument positions where sets are expected, set expressions\n    are allowed, e.g.\n    \n    Set1 /\\ Set2       % intersection\n    Set1 \\/ Set2       % union\n    Set1 \\ Set2    % difference\n    \n    as well as references to array elements like Set[3].\n    \n\nSearch\n    The insetdomain/4 predicate can be used to enumerate all ground\n    instantiations of a set variable, much like indomain/1 in the\n    finite-domain case.\n\nCooperation with a finite domain solver\n    This library comes in two flavours: lib(fd_sets) which cooperates with\n    lib(fd), and lib(ic_sets) which cooperates with lib(ic). This is relevant\n    only for those constraints which involve integer variables, e.g. the\n    cardinality argument in #/2, the weight argument in weight/3 and the\n    booleans in membership_booleans/2. These will be represented as fd-\n    or ic-variables respectively."},"ic_hybrid_sets:in/3":{"prefix":"in","body":"in(${1:X}, ${2:Set}, ${3:Bool})$4\n$0","description":"in(?X, ?Set, ?Bool)\n\n   Reified version of the set membership constraint\n\nArguments\n   X    an integer or an (integer) variable\n   Set    a set, set variable, or set expression\n   Bool    0, 1 or a boolean variable\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    This is the reified version of the in/2 constraint. This means that\n    the boolean variable Bool reflects the truth of the relation X in Set.\n    If Bool is 1, then in(X,Set,Bool) is the same as X in Set.\n    If Bool is 0, then in(X,Set,Bool) is the same as X notin Set.\n    Otherwise, Bool will be bound to 0 or 1 when X in Set\n    is known to be false or true, respectively. The latter is only\n    guaranteed to be detected after X has become instantiated.\n\n    Note that if one wants to have booleans corresponding to all or most\n    of the set domain elements, it will be more efficient to use the\n    membership_booleans/2 constraint in place of many in/3 constraints.\n\nExceptions\n     4 --- Set is a free variable without set domain\n\nExamples\n   \n    ?- intset(S, 1, 9), in(E, S, B).\n    E = E{[-10000000 .. 10000000]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = B{[0, 1]}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), B = 1.\n    E = E{[1 .. 9]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = 1\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 1.\n    S = S{[3] \\/ ([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[1 .. 9]}}\n    E = 3\n    B = 1\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 0.\n    S = S{([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[0 .. 8]}}\n    E = 3\n    B = 0\n    Yes (0.00s cpu)\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S includes [2, 3, 4].\n    B = 1\n    E = 3\n    S = S{[2, 3, 4] \\/ ([] .. [1, 5, 6, 7, 8, 9]) : C{[3 .. 9]}}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S disjoint [2, 3, 4].\n    B = 0\n    E = 3\n    S = S{([] .. [1, 5, 6, 7, 8, 9]) : C{[0 .. 6]}}\n    There is 1 delayed goal.\n\n    ?- in(3, S, 1).\n    instantiation fault\n    \n\nSee Also\n   in / 2, notin / 2, membership_booleans / 2"},"ic_hybrid_sets:insetdomain/4":{"prefix":"insetdomain","body":"insetdomain(${1:Set}, ${2:CardSel}, ${3:ElemSel}, ${4:Order})$5\n$0","description":"insetdomain(?Set, ?CardSel, ?ElemSel, ?Order)\n\n   Instantiate Set to a possible value\n\nArguments\n   Set    a set or set variable\n   CardSel    atom or variable\n   ElemSel    atom, structure or variable\n   Order    atom or variable\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    This predicate instantiates a set variable to a possible value,\n    according to its domain.  The predicate backtracks over all\n    possible set instantiations.  The three option arguments allow to\n    choose between a number of different enumeration orders. Giving a\n    variable as option argument will select the default.\n\n    The CardSel argument determines whether the sets are enumerated\n    according to their cardinality. It can take the following values:\n\nany (default)\n    the sets are not enumerated in a particular cardinality order\nincreasing\n    the sets are enumerated with increasing cardinality, ie. small\n    sets are tried first\ndecreasing\n    the sets are enumerated with decreasing cardinality, ie. large\n    sets are tried first\n\n    The ElemSel argument determines which potential set elements\n    are considered first for inclusion or exclusion. It can take the\n    following values:\n\nsmall_first (default)\n    small set elements (small numbers) are considered first\nbig_first\n    big set elements (big numbers) are considered first\nrandom\n    potential set elements are considered in random order\nheavy_first(Weights)\n    heavy set elements (according to Weight array) are considered first\nlight_first(Weights)\n    light set elements (according to Weight array) are considered first\n\n    The Order argument determines whether it is first tried to make\n    the selected potential element a set member, or whether to exclude it\n    first.  The argument can take the following values:\n\nin_notin (default)\n    try inclusion first, then exclusion\nnotin_in\n    try exclusion first, then inclusion\nsbds\n    uses sbds_try/2 to include or exclude an element in or from a set\n    (this is for use in conjunction with the SBDS library, and whether\n    inclusion or exclusion is tried first depends on the \"fix pred\"\n    specified in the prior call to sbds_initialise/4 or sbds_initialise/5)\n\n    Note that there are many different enumeration strategies for a set\n    variable, and insetdomain/4 only allows a limited number of them.\n    For an actual application, it might be more appropriate to choose a\n    problem-specific enumeration order. This can be programmed easily.\n    As a guideline, here is the code for insetdomain with the default\n    options:\n\n    insetdomain(Set, _, _, _) :-\n    \tnonvar(Set).\n    insetdomain(Set, any, small_first, in_notin) :-\n    \tvar(Set),\n    \tpotential_members(Set, PotentialElements),\n\tPotentialElements = [Element|_],\n\t(\n\t    Element in Set\n\t;\n\t    Element notin Set\n\t),\n\tinsetdomain(Set, any, small_first, in_notin).\n\nResatisfiable\n   yes\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n?-  X::[]..[1,2,3], insetdomain(X,_,_,_), writeln(X), fail.\n[1, 2, 3]\n[1, 2]\n[1, 3]\n[1]\n[2, 3]\n[2]\n[3]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,increasing,_,_), writeln(X), fail.\n[]\n[1]\n[2]\n[3]\n[1, 2]\n[1, 3]\n[2, 3]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,big_first,_), writeln(X), fail.\n[1, 2, 3]\n[2, 3]\n[1, 3]\n[3]\n[1, 2]\n[2]\n[1]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,_,notin_in), writeln(X), fail.\n[]\n[3]\n[2]\n[2, 3]\n[1]\n[1, 3]\n[1, 2]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3],\n\tinsetdomain(X, increasing, heavy_first([](2,9,4,7)), _),\n\twriteln(X), fail.\n[]\n[2]\n[3]\n[1]\n[2, 3]\n[1, 2]\n[1, 3]\n[1, 2, 3]\n\nno (more) solution.\n\nSee Also\n   conjunto : refine / 1, conjunto_fd_sets : refine / 1, potential_members / 2, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5"},"ic_hybrid_sets:int_sets/s":{"prefix":"struct","body":"struct","description":"struct int_sets(dom, lex_min, lex_max, lex_glb, lex_lub, lex_dirty, off, lcard, ucard, added, removed, add, rem, min_susp, max_susp, card, booleans, value)\n\n   Attribute structure for set variables (and constants)\n\nFields\n   dom    set domain representation (array of booleans)\n   lex_min    lexicographicaly least valid instantiation\n   lex_max    lexicographicaly greatest valid instantiation\n   lex_glb    lex ordered GLB\n   lex_lub    lex ordered GLB\n   lex_dirty    flag which when set will result in lex_glb\n   off    offset between set element and corresponding array index (integer)\n   lcard    lower bound cardinality (integer)\n   ucard    upper bound cardinality (integer)\n   added    notification send-port for lower bound increases\n   removed    notification send-port for upper bound decreases\n   add    suspension list woken when lower bound increases\n   rem    suspension list woken when upper bound decreases\n   min_susp    suspension list woken when lex_min changes\n   max_susp    suspension list woken when lex_max changes\n   card    fd/ic variable for cardinality (see #/2)\n   booleans    array of fd/ic variables (see membership_booleans/2)\n   value    set variable belonging to this attribute\n\nType\n   library(ic_hybrid_sets)\n\nSee Also\n   library(notify_ports), suspend / 3, suspend / 4"},"ic_hybrid_sets:intersection/3":{"prefix":"intersection","body":"intersection(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"intersection(?Set1, ?Set2, ?Set3)\n\n   Set3 is the intersection of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:intset/3":{"prefix":"intset","body":"intset(${1:Set}, ${2:Min}, ${3:Max})$4\n$0","description":"intset(?Set, +Min, +Max)\n\n   Set is a set containing numbers between Min and Max\n\nArguments\n   Set    A free variable, set variable or an integer list\n   Min    integer\n   Max    integer\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    Unifies Set with a set variable whose lower bound is the empty set\n    and whose upper bound is the set of all integers between Min and Max.\n    Equivalent to Set::[]..[Min,Min+1,..,Max].\n\nExceptions\n     4 --- Min or Max are uninstantiated\n     5 --- Set is not a variable or list\n\nSee Also\n   intsets / 4, :: / 2"},"ic_hybrid_sets:intsets/4":{"prefix":"intsets","body":"intsets(${1:Sets}, ${2:N}, ${3:Min}, ${4:Max})$5\n$0","description":"intsets(?Sets, ?N, +Min, +Max)\n\n   Sets is a list of N sets containing numbers between Min and Max\n\nType\n   library(ic_hybrid_sets)\n\nExceptions\n     4 --- Min or Max are uninstantiated\n\nSee Also\n   intset / 3, :: / 2"},"ic_hybrid_sets:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   Succeeds if Term is a ground set or a set variable\n\nArguments\n   Term    A term\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    Succeeds if Term is either a set (represented as a list) or a set\n    variable. For efficiency reasons, lists are not checked for being\n    valid set representations (i.e. strictly sorted lists of integers),\n    the predicate succeeds for any list.\n\nFail Conditions\n   Set is neither a set nor a set variable"},"ic_hybrid_sets:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   Succeeds if Term is a set variable\n\nArguments\n   Term    A term\n\nType\n   library(ic_hybrid_sets)\n\nFail Conditions\n   Set is not a variable, or a non-set variable"},"ic_hybrid_sets:membership_booleans/2":{"prefix":"membership_booleans","body":"membership_booleans(${1:Set}, ${2:BoolArr})$3\n$0","description":"membership_booleans(?Set, ?BoolArr)\n\n   BoolArr is an array of booleans describing Set\n\nArguments\n   Set    a set, set variable, free variable or set expression\n   BoolArr    A variable or an array (structure) of boolean variables\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    This constraint maintains the correspondence between a finite set and\n    an array of booleans (0/1 variables). The set is constrained to contain\n    those (and only those) integers I between 1 and N (the size of the array)\n    where the corresponding array element is 1.\n\n    Operationally, setting a array element I to 0 will exclude the element\n    I from Set's domain. Setting I to 1 will include I in Set's lower bound.\n    Adding and removing elements from Set will be reflected in the\n    corresponding boolean being instantiated to 1 or 0 respectively.\n\n    When called with BoolArr being a free variable, an array will be created\n    whose arity is at least as big as the largest potential set member.\n    Set members smaller than 1 will be excluded from the set.\n    When called with BoolArr being instantiated to an array, set members\n    smaller than 1 or bigger than the array size will be excluded from\n    the set.\n\nExamples\n   \n    ?- S::[2,4]..[1,2,3,4,5], membership_booleans(S,B).\n\n    S = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n    B = [](_{[0, 1]}, 1, _{[0, 1]}, 1, _{[0, 1]})\n\n    Delayed goals:\n\t...\n\n    ?- membership_booleans(S, [](0,1,0,1,B5)).\n\n    S = S{[2, 4] \\/ ([] .. [5]) : _{[2, 3]}}\n    B5 = B5{[0, 1]}\n\n    Delayed goals:\n\t..."},"ic_hybrid_sets:potential_members/2":{"prefix":"potential_members","body":"potential_members(${1:Set}, ${2:List})$3\n$0","description":"potential_members(?Set, -List)\n\n   List is the list of elements of whose membership in Set is currently uncertain\n\nArguments\n   Set    a set or set variable\n   List    variable, will be unified with a list\n\nType\n   library(ic_hybrid_sets)\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n    \t?- S :: [2,4]..[1,2,3,4,5], potential_members(S, P).\n\tS = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n\tP = [1, 3, 5]"},"ic_hybrid_sets:set_range/3":{"prefix":"set_range","body":"set_range(${1:Set}, ${2:Lwb}, ${3:Upb})$4\n$0","description":"set_range(?Set, -Lwb, -Upb)\n\n   Lwb and Upb are the current lower and upper bounds on Set\n\nArguments\n   Set    A variable or an integer list\n   Lwb    List of integers\n   Upb    List of integers\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    Returns two sorted, duplicate-free lists of integers which represent\n    the lower and upper bound of the set variable (or the ground set) Set.\n    The predicate can also be used as a test for set-variables, since it\n    fails for any other (in particular domain-less) variables.\n\nFail Conditions\n   Set is a variable, but not a set variable"},"ic_hybrid_sets:symdiff/3":{"prefix":"symdiff","body":"symdiff(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"symdiff(?Set1, ?Set2, ?Set3)\n\n   Set3 is the symmetric difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_hybrid_sets:weight/3":{"prefix":"weight","body":"weight(${1:Set}, ${2:ElementWeights}, ${3:Weight})$4\n$0","description":"weight(?Set, ++ElementWeights, ?Weight)\n\n   According to the array of element weights, the weight of set Set is Weight\n\nArguments\n   Set    a set, set variable or set expression\n   ElementWeights      an array (structure) of non-negative integers\n   Weight    an integer variable or integer\n\nType\n   library(ic_hybrid_sets)\n\nDescription\n\n    Set is constrained to be a set of integers between 1 and the size of\n    the array ElementWeights. Weight is an integer domain variable which\n    is constrained to the sum of the weights of Set's elements. The weight\n    of a set element is determined by the array element in ElementWeights\n    whose index corresponds to the set element.\n\n    Changes to the set domain will affect the domain of Weight. There is currently\n    no reverse propagation. This may change in a future release."},"ic_kernel:exclude/2":{"prefix":"exclude","body":"exclude(${1:Var}, ${2:Excl})$3\n$0","description":"exclude(?Var, ++Excl)\n\n   Exclude the element Excl from the domain of Var.\n\nArguments\n   Var    Integer variable or integer\n   Excl    Integer value to exclude\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for excluding an element from the domain of an integer\n   variable.  The call may fail (when Var is the same integer as Excl),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (when Excl was one of only two domain elements left).\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code\n   (use ic:(Var =\\= Excl) instead).  It differs from the usual constraint\n   predicates with respect to the execution of delayed goals.  If the call\n   to exclude/2 results in a domain change, any delayed goals suspended on\n   that change will be scheduled for execution, as normal.  However,\n   exclude/2 does not call the woken goal scheduler (wake/0), so these goals\n   may not be executed immediately.  (It is possible that under some\n   circumstances the goals will be executed, if wake/0 is called indirectly\n   - one example would be by the unify handler if the variable becomes\n   ground - but this should not be relied upon.)  To ensure that the goals\n   are eventually executed, the caller should arrange for wake/0 to be\n   called at some appropriate point in the subsequent execution.  Please see\n   the \"Advanced Control Features\" section of the User Manual for more\n   information about woken goal management.\n\nExamples\n   [eclipse 3]: X :: 0..10, exclude(X, 4).\nX = X{[0 .. 3, 5 .. 10]}\nYes (0.00s cpu)\n\n[eclipse 4]: X :: [4, 6], exclude(X, 4).\nX = 6\nYes (0.00s cpu)\n\nSee Also\n   exclude_range / 3, impose_min / 2, impose_max / 2, impose_domain / 2"},"ic_kernel:ic_event/1":{"prefix":"ic_event","body":"ic_event(${1:Event})$2\n$0","description":"ic_event(++Event)\n\n   Indicates that the specified event has occured.\n\nArguments\n   Event    The short name of the event to record\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Indicates that the specified event has occured.  Can be left in\n   production code as the call succeeds very quickly when stats gathering is\n   not turned on.\n\nSee Also\n   ic_stat / 1, ic_stat_get / 1, ic_stat_register_event / 2"},"ic_kernel:exclude_range/3":{"prefix":"exclude_range","body":"exclude_range(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"exclude_range(?Var, ++Lo, ++Hi)\n\n   Exclude the elements Lo..Hi from the domain of Var.\n\nArguments\n   Var    Integer variable or integer\n   Lo    Integer lower bound of range to exclude\n   Hi    Integer upper bound of range to exclude\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for excluding the integers between Lo and Hi (inclusive) from\n   the domain of an integer variable.  The call may fail (when the domain of\n   Var has no elements outside the range Lo..Hi), succeed (possibly updating\n   the variable's domain), or instantiate the variable (in the case where\n   the domain gets restricted to a singleton value).\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   It differs from the usual constraint predicates with respect to the\n   execution of delayed goals.  If the call to exclude_range/3 results in a\n   domain change, any delayed goals suspended on that change will be\n   scheduled for execution, as normal.  However, exclude_range/3 does not\n   call the woken goal scheduler (wake/0), so these goals may not be\n   executed immediately.  (It is possible that under some circumstances the\n   goals will be executed, if wake/0 is called indirectly - one example\n   would be by the unify handler if the variable becomes ground - but this\n   should not be relied upon.)  To ensure that the goals are eventually\n   executed, the caller should arrange for wake/0 to be called at some\n   appropriate point in the subsequent execution.  Please see the \"Advanced\n   Control Features\" section of the User Manual for more information about\n   woken goal management.\n\nExamples\n   [eclipse 3]: X :: 0..10, exclude_range(X, 4, 7).\nX = X{[0 .. 3, 8 .. 10]}\nYes (0.00s cpu)\n\n[eclipse 4]: X :: 0..10, exclude_range(X, 9, 20).\nX = X{0 .. 8}\nYes (0.00s cpu)\n\n[eclipse 5]: X :: [2, 4, 6 .. 10], exclude_range(X, 4, 12).\nX = 2\nYes (0.00s cpu)\n\nSee Also\n   exclude / 2, impose_min / 2, impose_max / 2, impose_domain / 2"},"ic_kernel:get_ic_attr/2":{"prefix":"get_ic_attr","body":"get_ic_attr(${1:X}, ${2:Attr})$3\n$0","description":"get_ic_attr(?X, -Attr)\n\n   Returns the IC attribute of a variable, creating a new attribute if necessary.\n\nArguments\n   X    A variable\n   Attr    The IC attribute of <TT>X</TT>\n\nType\n   library(ic_kernel)\n\nDescription\n\n   If X is a variable and does not already have an IC attribute, it is given\n   a new one.  Attr is then bound to this attribute (new or old).  Attr must\n   be a fresh variable.  Fails if X is not a variable.\n\nFail Conditions\n   X is not a variable"},"ic_hybrid_sets:union/3":{"prefix":"union","body":"union(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"union(?Set1, ?Set2, ?Set3)\n\n   Set3 is the union of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_hybrid_sets)"},"ic_kernel:ic_stat/1":{"prefix":"ic_stat","body":"ic_stat(${1:Command})$2\n$0","description":"ic_stat(++Command)\n\n   Enables/disables/resets/prints stats gathering information\n\nArguments\n   Command    Statistics related command (eg. turn on, print)\n\nType\n   library(ic_kernel)\n\nDescription\n\n   The available commands for controlling statistics gathering are...\n\n\ton    Enables the recording of stats events.\n\toff   Disables the recording of stats events.\n\treset Zero's all stats event counters.\n\tprint Prints, on standard output, the value of all registered\n\t      stats event counters.\n\n   User programs may register their own events to be recorded by calling\n   ic_stat_register_event/2.\n\nSee Also\n   ic_stat_register_event / 2, ic_stat_get / 1, ic_event / 1"},"ic_kernel:ic_kernel_desc":{"prefix":"lib","body":"lib(${1:ic_kernel})$2\n$0","description":"lib(ic_kernel)\n\nThis module provides a low-level interface to the core of the IC solver;\nthat is, a set of predicates for accessing and manipulating IC variables.\nIt is not intended for use by general user code (use the interface provided\nby the `ic' module for that), but rather for those wishing to implement\ntheir own constraints which use IC variables.  This could either be to\naugment IC by providing new constraints or functionality, or to build a\ncomplete constraint solver capable of cooperating with any other solver\nwhich also uses the common numeric variable format provided by IC."},"ic_kernel:impose_bounds/3":{"prefix":"impose_bounds","body":"impose_bounds(${1:Var}, ${2:Lo}, ${3:Hi})$4\n$0","description":"impose_bounds(?Var, ++Lo, ++Hi)\n\n   Update (if required) the bounds of Var.\n\nArguments\n   Var    Variable or number\n   Lo    Lower bound\n   Hi    Upper bound\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for updating the upper and lower bounds of Var, also used as\n   the set_bounds handler for the IC attribute.  As with impose_min/2 and\n   impose_max/2, it is intended for use in implementing constraint\n   propagators, and should not be called from ordinary user code (use $::/2\n   or ::/2 instead).  Its semantics is essentially:\n\n       impose_min(Var, Lo), impose_max(Var, Hi), wake.\n\n   Please see the documentation for impose_min/2 and impose_max/2 for more\n   details.\n\nSee Also\n   impose_min / 2, impose_max / 2, ic : $:: / 2, ic : :: / 2"},"ic_kernel:ic_stat_get/1":{"prefix":"ic_stat_get","body":"ic_stat_get(${1:StatsList})$2\n$0","description":"ic_stat_get(-StatsList)\n\n   Returns the list of stats events description=value pairs\n\nArguments\n   StatsList    The list of stats events description=value pairs\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Returns the list of stats events description=value pairs.\n\n   IC records the following statistics by default.  Please note that since\n   these depend on the internals of IC, they are subject to change without\n   notice, and should be used as a guide only.\n\n\tic_lin_create\n\t    Number of linear constraints set up.\n\tic_lin_prop\n\t    Number of times a linear constraint is propagated.\n\tic_uni_prop/ic_bin_prop/ic_tern_prop\n\t    Number of times a non-linear (unary/binary/ternary) operator is\n\t    propagated.\n\tic_split\n\t    Number of domain splits in locate/2,3,4.\n\tic_squash\n\t    Number of squash attempts in squash/3 or locate/4.\n\nSee Also\n   ic_stat / 1, ic_stat_get / 1, ic_event / 1"},"ic_kernel:impose_max/2":{"prefix":"impose_max","body":"impose_max(${1:Var}, ${2:Bound})$3\n$0","description":"impose_max(?Var, ++Bound)\n\n   Update (if required) the upper bound of Var.\n\nArguments\n   Var    Variable or number\n   Bound    Upper bound (number)\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for updating the upper bound of Var so that it is at most\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).  Note that if the variable's type is integer, its\n   bounds will always be adjusted to integral values.\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code\n   (use ic:(Var =\n\n   The final and most important difference relates to the execution of\n   delayed goals.  If the call to impose_max/2 results in a bound change,\n   any delayed goals suspended on that bound will be scheduled for\n   execution, as normal.  However, impose_max/2 does not call the woken goal\n   scheduler (wake/0), so these goals may not be executed immediately.  (It\n   is possible that under some circumstances the goals will be executed, if\n   wake/0 is called indirectly - one example would be by the unify handler\n   if the variable becomes ground - but this should not be relied upon.)  To\n   ensure that the goals are eventually executed, the caller should arrange\n   for wake/0 to be called at some appropriate point in the subsequent\n   execution.  Please see the \"Advanced Control Features\" section of the\n   User Manual for more information about woken goal management.\n\nExamples\n   [eclipse 3]: X $:: 0..10, impose_min(X, 4.5).\nX = X{4.5 .. 10.0}\nYes (0.00s cpu)\n\n[eclipse 4]: X $:: 0..10, impose_min(X, 4.5), integers([X]).\nX = X{5 .. 10}\nYes (0.00s cpu)\n\n[eclipse 5]: X $:: 0..10, impose_min(X, 4.5), integers([X]), impose_max(X, 5.9).\nX = 5\nYes (0.00s cpu)\n\n[eclipse 6]: X $:: 0..10, impose_min(X, 4.5), impose_max(X, 4.3).\nNo (0.00s cpu)\n\nSee Also\n   impose_min / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3"},"ic_kernel:ic_stat_register_event/2":{"prefix":"ic_stat_register_event","body":"ic_stat_register_event(${1:Event}, ${2:Description})$3\n$0","description":"ic_stat_register_event(++Event, ++Description)\n\n   Registers a new stats event to be collected\n\nArguments\n   Event    The short name of the event\n   Description    The long name of the event\n\nType\n   library(ic_kernel)\n\nDescription\n\n   When a program wishes to record events of interest throughout its runtime\n   it can do so by first registering the event type with the stats logger at\n   the beginning of the program.  E.g.\n\n\tic_stat_register_event('myevent','My really important event').\n\n   Calls to ic_event/1 can then be inserted in the appropriate places\n   throughout the code.  E.g.\n\n\tfoo:-\n\t\tic_event('myevent'),\n\t\tbar(X).\t\n\n   While stats gathering is not enabled (i.e. without the program explicitly\n   calling ic_stat(on)) these events are processed very efficiently, and so\n   can be left in code without incurring any significant overhead.\n\nSee Also\n   ic_stat / 1, ic_stat_get / 1, ic_event / 1"},"ic_kernel:impose_domain/2":{"prefix":"impose_domain","body":"impose_domain(${1:Var}, ${2:DomVar})$3\n$0","description":"impose_domain(?Var, ?DomVar)\n\n   Restrict (if required) the domain of Var t othe domain of DomVar.\n\nArguments\n   Var    Variable or number\n   DomVar    Variable or number\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for restricting the domain of Var to the domain of DomVar.\n   Any values in the domain of Var, which are not also in the domain of\n   DomVar, are removed.  DomVar remains unaffected.  \n   The domain update on Var may fail (when the update empties the domain),\n   succeed (possibly updating the variable's domain), or instantiate the\n   variable (in the case where the domain gets restricted to a singleton\n   value).  Note that if DomVar's type is integer, the integrality will\n   be imposed on Var as well as the domain values.\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code.\n   The waking behaviour is the same as discussed for impose_min/2 and\n   impose_max/2.  Apart from this, the effect is similar to unifying\n   Var with a copy of DomVar.\n   \n\nExamples\n       ?- X::1..9, Y::5..7, impose_domain(X, Y).\n    X = X{5 .. 7}\n    Y = Y{5 .. 7}\n    Yes (0.00s cpu)\n\n    ?- X::1..9, impose_domain(X, 7).\n    X = 7\n    Yes (0.00s cpu)\n\n    ?- X::1..9, Y::4.1..7.5, impose_domain(X, Y).\n    X = X{5 .. 7}\n    Y = Y{4.1 .. 7.5}\n    Yes (0.00s cpu)\n\n    ?- X::1.0..9.0, Y::5..7, impose_domain(X, Y).\n    X = X{5 .. 7}\n    Y = Y{5 .. 7}\n    Yes (0.00s cpu)\n\n    ?- X::1..3, Y::5..7, impose_domain(X, Y).\n    No (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(3, Y).\n    Y = Y{1 .. 5}\n    Yes (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(6, Y).\n    No (0.00s cpu)\n\n    ?- Y::1..5, impose_domain(X, Y).\n    Y = Y{1 .. 5}\n    X = X{1 .. 5}\n    Yes (0.00s cpu)\n\nSee Also\n   impose_min / 2, impose_max / 2, impose_bounds / 3, exclude / 2, exclude_range / 3"},"ic_kernel:set_var_type/2":{"prefix":"set_var_type","body":"set_var_type(${1:Var}, ${2:Type})$3\n$0","description":"set_var_type(?Var, ++Type)\n\n   Sets the type of the given variable to the given type.\n\nArguments\n   Var    Variable to set type of\n   Type    Type to be set 'real' or 'integer'\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Typically not called directly but indirectly through reals/1 and\n   integers/1.\n\nSee Also\n   set_vars_type / 2, reals / 1, integers / 1"},"ic_make_overlap_bivs:make_overlap_bivs/5":{"prefix":"make_overlap_bivs","body":"make_overlap_bivs(${1:Tasks}, ${2:BivLists}, ${3:BivSums}, ${4:Resource}, ${5:Options})$6\n$0","description":"make_overlap_bivs(+Tasks, -BivLists, -BivSums, ++Resource, ++Options)\n\n   Make a set of overlap bivalued variables for a set of tasks.\nIntroduce a set of 'bivalued sum' variables, equal to the sum of the binaries at\nan overlap.  The bivalued sum variables represent the total resources needed\n\nArguments\n   Tasks    A list of task structures - see library(ic_probe_support)\n   BivLists    A list of lists of integer variables\n   BivSums    A list of integer variables, each one the sum of a list \n    of binaries\n   Resource    An integer quantity of resource available\n   Options    An options structure\n\nType\n   library(ic_make_overlap_bivs)\n\nDescription\n\n    Based on the tentative assignments, probe_search finds a task\n    start time where the resources are not sufficient to make the\n    tentative assignment feasible.  In case a bottleneck task has a\n    variable resource requirement, this is reduced to its minimum\n    possible value. Otherwise, probe_search chooses a bivalued\n    'overlap' variable at this bottleneck and using add_con it adds \n    a constraint trying to eliminate the overlap.\n\nResatisfiable\n   no\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, probe : add_con / 3, ic_probe : add_con / 3"},"ic_kernel:impose_min/2":{"prefix":"impose_min","body":"impose_min(${1:Var}, ${2:Bound})$3\n$0","description":"impose_min(?Var, ++Bound)\n\n   Update (if required) the lower bound of Var.\n\nArguments\n   Var    Variable or number\n   Bound    Lower bound (number)\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Primitive for updating the lower bound of Var so that it is at least\n   Bound.  A bound update on a variable may fail (when the update empties\n   the domain), succeed (possibly updating the variable's bounds), or\n   instantiate the variable (in the case where the domain gets restricted to\n   a singleton value).  Note that if the variable's type is integer, its\n   bounds will always be adjusted to integral values.\n\n   Note that this predicate is intended for use only in implementing\n   constraint propagators, and should not be called from ordinary user code\n   (use ic:(Var >= Bound) instead).  It differs from the usual constraint\n   predicates in several ways.  First, Bound is assumed to be exact (i.e.\n   if it's a float, it's not widened).  Second, if Bound is a bounded real,\n   only its lower bound is significant, and it is this which is imposed on\n   Var.\n\n   The final and most important difference relates to the execution of\n   delayed goals.  If the call to impose_min/2 results in a bound change,\n   any delayed goals suspended on that bound will be scheduled for\n   execution, as normal.  However, impose_min/2 does not call the woken goal\n   scheduler (wake/0), so these goals may not be executed immediately.  (It\n   is possible that under some circumstances the goals will be executed, if\n   wake/0 is called indirectly - one example would be by the unify handler\n   if the variable becomes ground - but this should not be relied upon.) To\n   ensure that the goals are eventually executed, the caller should arrange\n   for wake/0 to be called at some appropriate point in the subsequent\n   execution.  Please see the \"Advanced Control Features\" section of the\n   User Manual for more information about woken goal management.\n\nExamples\n   [eclipse 2]: X $:: 0..10, impose_min(X, 4.5).\nX = X{4.5 .. 10.0}\nYes (0.00s cpu)\n\n[eclipse 3]: X $:: 0..10, impose_min(X, 4.5), integers([X]).\nX = X{5 .. 10}\nYes (0.00s cpu)\n\n[eclipse 4]: X $:: 0..10, impose_min(X, 4.5), integers([X]), impose_max(X, 5.9).\nX = 5\nYes (0.00s cpu)\n\n[eclipse 5]: X $:: 0..10, impose_min(X, 4.5), impose_max(X, 4.3).\nNo (0.00s cpu)\n\nSee Also\n   impose_max / 2, impose_bounds / 3, impose_domain / 2, exclude / 2, exclude_range / 3"},"ic_kernel:set_vars_type/2":{"prefix":"set_vars_type","body":"set_vars_type(${1:Vars}, ${2:Type})$3\n$0","description":"set_vars_type(?Vars, ++Type)\n\n   Sets the type of the given variables to the given type.\n\nArguments\n   Vars    Var/list/matrix\n   Type    Type to be set 'real' or 'integer'\n\nType\n   library(ic_kernel)\n\nDescription\n\n   Typically not called directly but indirectly through reals/1 and\n   integers/1.\n\nExceptions\n     4 --- Type is un-instantiated.\n\nSee Also\n   set_var_type / 2, reals / 1, integers / 1"},"ic_kernel:msg/3":{"prefix":"msg","body":"msg(${1:Var1}, ${2:Var2}, ${3:MSG})$4\n$0","description":"msg(?Var1, ?Var2, ?MSG)\n\n   Computes the most specific generalisation of Var1 and Var2 that is expressible with ic variables.\n\nArguments\n   Var1    A variable or number\n   Var2    A variable or number\n   MSG    Most specific generalisation (variable)\n\nType\n   library(ic_kernel)\n\nDescription\n\n   The most specific generalisation of two intervals is computed and\n   returned as MSG.  MSG will interval over the smallest interval enclosing\n   the input intervals, and have the more general type of the input types.\n   If either Var1 or Var2 are domain-less, or have values that cannot be\n   expressed as ic-domains, MSG remains unbound.\n\nModes and Determinism\n   msg(-, -, ?)\n   msg(++, ++, ?)"},"ic_probe:ic_probe_desc":{"prefix":"lib","body":"lib(${1:ic_probe})$2\n$0","description":"lib(ic_probe)\n\n    This implementation of probing is a call to an external linear solver, \n    whose optimal solution is assigned to the problem variables as tentative \n    variables.\n\nA counter is created an initialised to zero.  At every probe it is incremented.\nThe counter can be set using set_probect(N), and can be read using \nget_probect(N)"},"ic_probe_search:ic_probe_search_desc":{"prefix":"lib","body":"lib(${1:ic_probe_search})$2\n$0","description":"lib(ic_probe_search)\n\n    A search routine which fixes resource bottlenecks by forcing tasks not to overlap."},"ic_probe:add_con/3":{"prefix":"add_con","body":"add_con(${1:Constraint}, ${2:Options}, ${3:Handle})$4\n$0","description":"add_con(+Constraint, ++Options, +Handle)\n\n   Add a constraint to the ic and linear solvers\n\nArguments\n   Constraint    A numerical constraint, with functor \n    '=:=', '>=', '=<', '>' or '<'\n   Options    An options structure\n   Handle    A linear solver handle\n\nType\n   library(ic_probe)\n\nDescription\n \nIf the inequality is strict, X>Y or X', then the granularity \n specified in the options is added to the smaller term to create a non-strict \n inequality, which can be passed to the linear solver.  Thus if the granularity\n is 3, then for X>Y the constraint X>=Y+3 is added to the \n linear  solver and  X#>=Y+3  is added to the ic solver.\n\nResatisfiable\n   no\n\nSee Also\n   set_up_probe / 5"},"ic_probe_search:probe_search/5":{"prefix":"probe_search","body":"probe_search(${1:Bivs}, ${2:BivSums}, ${3:Resource}, ${4:Options}, ${5:Handle})$6\n$0","description":"probe_search(+Bivs, +BivSums, ++Resource, ++Options, +Handle)\n\n   Add alternative constraints to try and repair infeasible probes\n\nArguments\n   Bivs    A list of lists of binary integer variables\n   BivSums    A list of integer variables, each one the sum of a list \n    of binaries\n   Resource    An integer quantity of resource available\n   Options    An options structure\n   Handle    A linear solver handle\n\nType\n   library(ic_probe_search)\n\nDescription\n\n    Based on the tentative assignments, probe_search finds a task\n    start time where the resources are not sufficient to make the\n    tentative assignment feasible.  In case a bottleneck task has a\n    variable resource requirement, this is reduced to its minimum\n    possible value. Otherwise, probe_search chooses a binary\n    'overlap' variable at this bottleneck and using add_con it adds \n    a constraint trying to eliminate the overlap.\n\nResatisfiable\n   no\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, probe : add_con / 3, ic_probe : add_con / 3"},"ic_probe:set_up_probe/5":{"prefix":"set_up_probe","body":"set_up_probe(${1:Tasks}, ${2:Constraints}, ${3:Cost}, ${4:Options}, ${5:Handle})$6\n$0","description":"set_up_probe(+Tasks, +Constraints, -Cost, ++Options, -Handle)\n\n   Sets up a linear probe for a set of constraints\n\nArguments\n   Tasks    A term containing some variables\n   Constraints    A list of numerical constraints\n   Cost    A cost variable\n   Options    An options structure\n   Handle    A variable which will record the handle of the matrix \nused by the linear solver\n\nType\n   library(ic_probe)\n\nDescription\n\nThe constraints are passed to add_con, which adds them to both the \nic and linear solvers.  The cost is declared to be an integer.  All the \nfinite domain variables in the term Tasks are associated with a demon \nwhich forwards their bounds to the linear solver.  (The priority of this \ndemon is one higher than that of the probe.)\n\nlp_demon_setup is then invoked to set up the linear solver, with the \npriority specified in the Options parameter.  Solutions returned\nby the linear solver are automatically used to update the tentative values  \nof all the variables.\n\nResatisfiable\n   no\n\nExamples\n   \n?- Options = options{granularity:3,priority:5},\n   Cost=X1,\n   set_up_probe([X1,X2,X3],[X1>X2,X2>X3],Cost,Options,H).\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, add_con / 3, eplex : lp_demon_setup / 5"},"ic_probing_for_scheduling:fun_to_cons_var/3":{"prefix":"fun_to_cons_var","body":"fun_to_cons_var(${1:CostFun}, ${2:ConsList}, ${3:CostVar})$4\n$0","description":"fun_to_cons_var(+CostFun, -ConsList, -CostVar)\n\n   Convert a cost expression to a variable and a list of constraints, \nsuitable to pass into probe_cstr_sched/7\n\nArguments\n   CostFun    a cost function of the form accepted by probe_sched/5\n   ConsList    a variable which will be instantiated to a list of constraints, \nsuitable to pass into probe_cstr_sched/7\n   CostVar    a variable constrained to take a value greater than or equal to \nthe cost function\n\nType\n   library(ic_probing_for_scheduling)\n\nDescription\n\nIf the user needs to use probe_cstr_sched instead of probe_sched, this predicate can be used to convert the cost function to a list of constraints and a cost variable suitable for passing to probe_cstr_sched\n\nResatisfiable\n   no\n\nExamples\n   \nfun_to_cons_var(abs(X-10)+abs(Y-3),ConsList,Var)\n\nSee Also\n   probe_sched / 5, probe_cstr_sched / 7"},"ic_probe_support:ic_probe_support_desc":{"prefix":"lib","body":"lib(${1:ic_probe_support})$2\n$0","description":"lib(ic_probe_support)\n\n    A library exporting structures and predicates used in probing for scheduling.\n\nThe following two structures are exported:\n\ntask(start,duration,resource)\noptions(granularity,priority)"},"ic_probing_for_scheduling:probe_cstr_sched/7":{"prefix":"probe_cstr_sched","body":"probe_cstr_sched(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:MaxResource}, ${5:Constraints}, ${6:Cost}, ${7:Options})$8\n$0","description":"probe_cstr_sched(+Starts, +Durations, +Resources, ++MaxResource, +Constraints, -Cost, ++Options)\n\n   Find a resource-feasible schedule that minimises the\ncost, subject to the constraints\n\nArguments\n   Starts    A list of (n) task start times (integers or\nfinite domain variables)\n   Durations    A list of (n) task durations (integers or\nfinite domain variables)\n   Resources    A list of (n) task resource needs (integers)\n   MaxResource    The available resource, not to be exceeded\n   Constraints    A list of numeric equations and inequations, \nusing functors '=:=', '>=', '>', '=<' and '<'.\n   Cost    A numeric variable which will be minimised during search\n   Options    A list, '[granularity(G),priority(P)]',\n    where\n    'G' is an integer specifying the time granularity, and\n    'P' is the priority of the probe demon.\n\nType\n   library(ic_probing_for_scheduling)\n\nDescription\n \nThis offers the same functionality as probe_sched/5, but with added \nflexibility, and a more complex user interface.  The extra arguments offer \nthe user  more control.  \n\nThe Cost argument is a variable, and it must be linked to the task \nvariables by the list of linear constraints.  The user can add not only \nlinear constraints on the cost function, but also constraints between the \ntask variables.  Only constraints made explicit in this list are 'seen' by \nthe probe.   probe_cstr_sched also posts them to the ic solver.\n\nThe options offer user control over\nthe temporal granularity, and the priority of the probe.\n\nThe algorithm uses min_max, but directs the search using a probe\nwhich focusses the search on the optimum.  The probe is a procedure\nthat finds optimal solutions to a relaxed problem ignoring resource\nlimits.  For details see setup_probe.  Additionally the algorithm\nsets up a binary variable between each pair of tasks, see\nmake_overlap_bivs.  Whenever the probe returns tentative start\ntimes, these are propagated to the overlap binary variables yielding a\ntotal resource usage which reveals any bottlenecks, where needed\nresources exceed thos available.  probe_search then\nnon-deterministically introduces a new constraint which reduces the\nbottleneck.\nThe probe_sched call:\n\nprobe_sched(Ss,Ds,Rs,MaxR,abs(X-X1)+Y)\n\ntranslates into the probe_cstr_sched call:\n\nprobe_cstr_sched(Ss,Ds,Rs,MaxR,[Cost=:=E1+Y,E1>=X-X1,E1>=X1-X],Cost,\n[granularity(1),priority(5)])\n\nThus making the default granularity '1' and the default priority '5'.\n\nResatisfiable\n   no\n\nSee Also\n   probe_sched / 5, fd : min_max / 2, probe : set_up_probe / 5, ic_probe : set_up_probe / 5, ic_make_overlap_bivs : make_overlap_bivs / 5, make_overlap_bivs : make_overlap_bivs / 5, probe_search : probe_search / 5, ic_probe_search : probe_search / 5"},"ic_probing_for_scheduling:ic_probing_for_scheduling_desc":{"prefix":"lib","body":"lib(${1:ic_probing_for_scheduling})$2\n$0","description":"lib(ic_probing_for_scheduling)\n\n    This is a complete search method for resource-constrained scheduling \n    problems\n    \n    The user interface is similar to the cumulative constraint, with a \n    list of task start times, durations and resources; and a maximum \n    resource limit.  There is one extra argument, a cost function which \n    is to be minimised. \n    \n    Probing for scheduling differs radically from the cumulative constraint\n    because it includes a search routine.  In its behaviour it is an\n    optimisation procedure and not simply a constraint which enforces \n    consistency. \n    \n    The search is focussed towards an optimal vlaue of the cost function."},"ic_probing_for_scheduling:probe_sched/5":{"prefix":"probe_sched","body":"probe_sched(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:MaxResource}, ${5:CostFun})$6\n$0","description":"probe_sched(+Starts, +Durations, +Resources, +MaxResource, ?CostFun)\n\n   Find a resource-feasible schedule that minimises the\ncost function\n\nArguments\n   Starts    a list of (n) task start times (integers or\nfinite domain variables)\n   Durations    a list of (n) task durations (integers or\nfinite domain variables)\n   Resources    a list of (n) task resource needs (integers or \nfinite domain variables)\n   MaxResource    The available resource, not to be exceeded (integer)\n   CostFun    An expression involving start times and durations\nto be minimised\n\nType\n   library(ic_probing_for_scheduling)\n\nDescription\n\n\tThis predicate finds start times for a set of tasks, which\nminimise the value of a given cost function.\n\nThe cost function is the only information the search algorithm can use to\nfocus on the optimum.  It cannot guide the search if the cost is a variable, \nonly linked to the tasks start times by constraints.  For this reason the \ncost function admits the special functions abs and maxlist.\n\nThe syntax for cost functions is:\n\nCostFunction ::- PosExpr | PosExpr + PosExpr | Integer * PosExpr\nPosExpr ::- abs(LinearExpr) | maxlist([LinearExpr]) | LinearExpr.\n\nThe algorithm is described in more detail in the documentation of \nprobe_cstr_sched/7. \n\nResatisfiable\n   no\n\nExamples\n   \nprobe_schedule(Starts,CostFun) :-\n\tStarts=[X,Y,Z],\n    ic:(Starts::1..10),\n    Durations=[10,5,5],\n    Resources=[R1,R2,R3],\n    ic:(R1::1..2), R2=2, R3=1,\n    MaxResource=2,\n    [OldX,OldY,OldZ]=[1,5,5],\n    CostFun= abs(X-OldX)+abs(Y-OldY)+abs(Z-OldZ),\n\tprobe_sched(Starts,Durations,Resources,MaxResource,CostFun).\n\nSee Also\n   probe_cstr_sched / 7, fd : min_max / 2, probe : set_up_probe / 5, ic_probe : set_up_probe / 5, ic_make_overlap_bivs : make_overlap_bivs / 5, make_overlap_bivs : make_overlap_bivs / 5, probe_search : probe_search / 5, ic_probe_search : probe_search / 5, ic_global : maxlist / 2, ic : maxlist / 2, fd_global : maxlist / 2"},"ic_prop_test_util:make_n_random_variables/4":{"prefix":"make_n_random_variables","body":"make_n_random_variables(${1:NVars}, ${2:Min}, ${3:Max}, ${4:Vars})$5\n$0","description":"make_n_random_variables(+NVars, +Min, +Max, -Vars)\n\n   Create random domain variables\n\nArguments\n   NVars    Number of variables to create (integer)\n   Min    Minimum lower domain bound (integer)\n   Max    Maximum upper domain bound (integer)\n   Vars    List of variables (output)\n\nType\n   library(ic_prop_test_util)\n\nModes and Determinism\n   make_n_random_variables(+, +, +, -) is det"},"ic_prop_test_util:make_n_random_seeds/2":{"prefix":"make_n_random_seeds","body":"make_n_random_seeds(${1:NSeeds}, ${2:Seeds})$3\n$0","description":"make_n_random_seeds(+NSeeds, -Seeds)\n\n   Create random seeds for seed/1\n\nArguments\n   NSeeds    Number of seeds (integer)\n   Seeds    List of seeds (output)\n\nType\n   library(ic_prop_test_util)\n\nModes and Determinism\n   make_n_random_seeds(+, -) is det"},"ic_prop_test_util:random_bound_reduction_test/2":{"prefix":"random_bound_reduction_test","body":"random_bound_reduction_test(${1:Out}, ${2:Goal})$3\n$0","description":"random_bound_reduction_test(+Out, +Goal)\n\n   Run and keep waking a constraint until ground\n\nArguments\n   Out    An output stream for printing the execution protocol\n   Goal    A goal, usually a constraint with domain variables\n\nType\n   library(ic_prop_test_util)\n\nDescription\n\n    This utility shows constraint propagation at work.  Goal should be\n    a constraint involving domain variables.  The Goal is first called,\n    i.e. the constraint is being set up.  Then (if it does not fail),\n    some of its variables are reduced in their domains, which may lead\n    to the Goal waking up and propagating the domain changes.  This\n    process is repeated until either the Goal fails, or all variables\n    are instantiated and the goal succeeds.\n\n    Throughout the process, a protocol is printed to the Out stream.\n    Output lines are marked with C (initial call), P (propagation result)\n    or L (imposed domain reduction, or labeling), and display the\n    corresponding state of the constraint with its variable domains.\n\n    Domain reductions are chosen randomly: in each step, 1 to 3 variables\n    are selected randomly, and each receives a random domain reduction\n    (upper and/or lower bound).  To create a reproducible sequence, it\n    is recommended to invoke seed/1 beforehand.\n\nModes and Determinism\n   random_bound_reduction_test(+, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- [X,Y]::1..3, random_bound_reduction_test(output, alldifferent([X,Y])).\n    C alldifferent([_{1 .. 3}, _{1 .. 3}])\n    P alldifferent([_{1 .. 3}, _{1 .. 3}])\n    L alldifferent([_{1 .. 3}, _{[1, 2]}])\n    L alldifferent([_{[1, 2]}, 1])\n    P alldifferent([2, 1])\n    yes.\n\nSee Also\n   random_bound_reduction_test / 3"},"ic_sbds:ic_sbds_desc":{"prefix":"lib","body":"lib(${1:ic_sbds})$2\n$0","description":"lib(ic_sbds)\n\n   Symmetry Breaking During Search (SBDS) library, provides predicates to initalise symmetry breaking during search search and to perform the search, as well as utility functions for prining and unification."},"ic_prop_test_util:random_int_between/3":{"prefix":"random_int_between","body":"random_int_between(${1:Min}, ${2:Max}, ${3:X})$4\n$0","description":"random_int_between(+Min, +Max, -X)\n\n   Create random integer\n\nArguments\n   Min    Minimum value (integer)\n   Max    Maximum value (integer)\n   X    Random value (output integer)\n\nType\n   library(ic_prop_test_util)\n\nModes and Determinism\n   random_int_between(+, +, -) is det"},"ic_sbds:sbds_get_index/2":{"prefix":"sbds_get_index","body":"sbds_get_index(${1:Var}, ${2:Idx})$3\n$0","description":"sbds_get_index(?Var, -Idx)\n\n   get the index of an SBDS attributed variable\n\nArguments\n   Var    SBDS variable\n   Idx    The index of Var\n\nType\n   library(ic_sbds)\n\nDescription\n\tUnifies Idx with the index of the SBDS variable Var.  The index of\n\tthe variable is its position in the matrix provided in the\n\tcorresponding call to sbds_initialise/4 or sbds_initialise/5\n\nFail Conditions\n   Var is not an SBDS variable."},"ic_prop_test_util:random_bound_reduction_test/3":{"prefix":"random_bound_reduction_test","body":"random_bound_reduction_test(${1:Out}, ${2:Goal}, ${3:Vars})$4\n$0","description":"random_bound_reduction_test(+Out, +Goal, +Vars)\n\n   Run and keep waking a constraint until ground\n\nArguments\n   Out    An output stream for printing the execution protocol\n   Goal    A goal, usually a constraint with domain variables\n   Vars    Subset of Goal's variables to be domain-reduced\n\nType\n   library(ic_prop_test_util)\n\nModes and Determinism\n   random_bound_reduction_test(+, +, +) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   random_bound_reduction_test / 2"},"ic_sbds:is_sbds_var/1":{"prefix":"is_sbds_var","body":"is_sbds_var(${1:Var})$2\n$0","description":"is_sbds_var(?Var)\n\n   checks whether a variable is an SBDS variable\n\nArguments\n   Var    Variable to check\n\nType\n   library(ic_sbds)\n\nDescription\n\tSucceeds if and only if Var is a variable and has been initialised\n\tas an SBDS variable (through a call to sbds_initialise/4 or\n\tsbds_initialise/5).\n\nFail Conditions\n   Var is not a variable or not an SBDS variable.\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5"},"ic_sbds:sbds_get_matrix/2":{"prefix":"sbds_get_matrix","body":"sbds_get_matrix(${1:Var}, ${2:Matrix})$3\n$0","description":"sbds_get_matrix(?Var, -Matrix)\n\n   get the matrix (array) of SBDS attributed variables\n\nArguments\n   Var    SBDS variable\n   Matrix    The matrix that Var appears in\n\nType\n   library(ic_sbds)\n\nDescription\n\tUnifies Matrix with the matrix (array) provided to a call to\n\tsbds_initialise/4 or sbds_initialise/5 which contains Var.\n\nFail Conditions\n   Var is not an SBDS variable."},"ic_sbds:sbds_initialise/4":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:SymPreds}, ${3:FixPred}, ${4:Options})$5\n$0","description":"sbds_initialise(+VarMatrix, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(ic_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to, in this case a 1-dimensonal matrix, for the n-dimensonal case see \t\tsbds_initalise/5.\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation\n\ti.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), \n\tyou only need to specify the parameters that you have added. So for the above \t\tpredicate,\n\tthe entry to the list would be: symmetry_predicate(Matrix)\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a 1 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\n\t\n\tr180(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\t\n\t\n\tr270(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trx(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Index],\n\t\tSymValue is Value.\n\t\n\n\t\n\try(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Index],\n\t\tSymValue is N + 1 - Value.\n\t\n\n\t\n\trd1(Matrix, _N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[Value],\n\t\tSymValue is Index.\n\t\n\n\t\n\trd2(Matrix, N, Index, Value, SymVar, SymValue) :-\n\t\tSymVar is Matrix[N + 1 - Value],\n\t\tSymValue is N + 1 - Index.\n\t\n\t\t\n\t Then to initialise SBDS\n\t%If the Board is a list of variables then we change it to a matrix\t\n\tMatrix =.. [[] | Board],\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 5, sbds_try / 2"},"ic_sbds:sbds_initialise/5":{"prefix":"sbds_initialise","body":"sbds_initialise(${1:VarMatrix}, ${2:NDims}, ${3:SymPreds}, ${4:FixPred}, ${5:Options})$6\n$0","description":"sbds_initialise(+VarMatrix, ++NDims, +SymPreds, ++FixPred, +Options)\n\n   Initialises the data needed for sbds\n\nArguments\n   VarMatrix    Matrix of Search Variables\n   NDims    The Dimenson of VarMatrix\n   SymPreds    List of symmetry predicates\n   FixPred    Predicate to assign a variable to a value\n   Options    List of Options to use during search\n\nType\n   library(ic_sbds)\n\nDescription\n Symmetry Predicates \n\tVarMatrix, is the matrix of variables, which are searched over to allocate \t\tvalues to.\n\t\n\t\n\tNDims is the dimenson of VarMatrix\n\t\n\t\n\tThe symmetry predicates should transform a variable and value to their \n\tsymmetrical equivalent. The last four arguments of these predicates should \n\ttherefore be the original variable, the original value (which are input) then \t\tthe symmetrical variable and the symmetrical value (which are output). Before \t\tthese parameters you can give any other parameters which are useful in your \t\timplementation i.e. the matrix of variables. So my symmetry predicate might be:\n\tsymmetry_predicate(Matrix, Var, Val, SymVar, SymVal).\n\t\n\t\n\tWhen creating the list of symmetry predicates (the parameter given to \t\t\tsbds_initalise), you only need to specify the parameters that you have added. \t\tSo for the above predicate, the entry to the list would \t\t\t\tbe: symmetry_predicate(Matrix).\n\tThis is shown below in the N-Queens model.\n\t\n\t\n\tThe FixPred is the predicate which will fix and exclude a variable to a value \t\tat decision points in the search tree, it must have three parameters the first \t\ttwo will be the variable and the value, and the third will be a boolean which \t\tspecifies whether the variable is being fixed or excluded i.e. is this \t\t\tconstraint true or false. #= / 3, is usually used for thse purposes.\n\t\n\t\n\tThe Options list, will be a list of options which can be used during search \t\ti.e. whether SBDS should be used at every node of the search tree. None of \t\tthese options are implemented as yet, so it should always be an empty list.\n\t What SBDS initialise does: \n\tCalled before search commences. Sets up the symmetries to indicate that \t\t\n\tthey are all unbroken initally and initalises all the variables etc. that will \t\tbe utilised during search.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n   abort --- Options is not an empty list\n\nExamples\nNqueens using a boolean encoding on a 2 dimensonal array\n\t The Symmetry Predicates for Nqueens Symmetries:\n\t\n\tr90(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t\n\tr180(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\tr270(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, X],\n    \t\tSymValue is Value.\n\t\t\n\t\n\trx(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - X, Y],\n    \t\tSymValue is Value.\n\t\n\t\n\try(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[X, N + 1 - Y],\n    \t\tSymValue is Value.\n\t\n\t\n\trd1(Matrix, _N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[Y, X],\n    \t\tSymValue is Value.\n\t\n\t\n\trd2(Matrix, N, [X,Y], Value, SymVar, SymValue) :-\n    \t\tSymVar is Matrix[N + 1 - Y, N + 1 - X],\n    \t\tSymValue is Value.\n\t\n\t Then to initialise SBDS\n\t%The list of symmetry predicates,\n\tSyms = [\n\t\tr90(Matrix, N),\n\t\tr180(Matrix, N),\n\t\tr270(Matrix, N),\n\t\trx(Matrix, N),\n\t\try(Matrix, N),\n\t\trd1(Matrix, N),\n\t\trd2(Matrix, N)\n\t],\n\t%the call to sbds_initalise,\n\tsbds_initialise(Matrix, 2, Syms, #=, []). \n\nSee Also\n   sbds_initialise / 4, sbds_try / 2"},"ic_sbds:sbds_try/2":{"prefix":"sbds_try","body":"sbds_try(${1:Var}, ${2:Val})$3\n$0","description":"sbds_try(?Var, ++Val)\n\n   tries to assign a variable to a value\n\nArguments\n   Var    SBDS Variable\n   Val    Value to try and assign to Value\n\nType\n   library(ic_sbds)\n\nDescription\nCalled for each variable, value pair tried at a decision point \t\tduring search.\n\t\n\t\n\tInitally tries to assign a variable to a value, if this is succesful then it \t\tupdates the symmetry functions to take account of any symmetries which have \t\tbeen broken by this assignment.\n\t\n\t\n\tIf this assignment is unsuccesful then it stipulates that the variable cannot \t\tbe assigned to this value, before placing constraints to eliminate the \t\t\tsymmetrical equivalent of this assgnment. If these symmetries are not already \t\tbroken\n\nExceptions\n   abort --- Var is not an sbds attributed variable\n\nExamples\n Replacement for labeling/1 which takes SBDS into account \t\t\n\t\n\tsbds_labeling(AllVars) :-\n    ( foreach(Var, AllVars) do\n\t  count_backtracks,\n    sbds_indomain(Var)    \n    ).\n    \n\tReplacement for indomain/1 which takes SBDS into account.\n\t\n\t% value ordering is input order\n\tsbds_indomain(X) :-\n\t\tnonvar(X).\n\tsbds_indomain(X) :-\n\t\tvar(X),\n\t\tmindomain(X, LWB),\n\t\t%sbds_try called here\n\t\tsbds_try(X, LWB),\n\t\tsbds_indomain(X).\n\t\n\nSee Also\n   sbds_initialise / 4, sbds_initialise / 5, ic : search / 6"},"ic_sets:all_disjoint/1":{"prefix":"all_disjoint","body":"all_disjoint(${1:Sets})$2\n$0","description":"all_disjoint(+Sets)\n\n   Sets is a list of integers sets which are all disjoint\n\nType\n   library(ic_sets)"},"ic_sets:difference/3":{"prefix":"difference","body":"difference(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"difference(?Set1, ?Set2, ?Set3)\n\n   Set3 is the difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_sets:all_intersection/2":{"prefix":"all_intersection","body":"all_intersection(${1:Sets}, ${2:Intersection})$3\n$0","description":"all_intersection(+Sets, ?Intersection)\n\n   Intersection is the intersection of all the sets in the list Sets\n\nArguments\n   Sets    a non-empty list of sets, set variables or set expressions\n   Intersection    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_sets:all_union/2":{"prefix":"all_union","body":"all_union(${1:Sets}, ${2:SetUnion})$3\n$0","description":"all_union(+Sets, ?SetUnion)\n\n   SetUnion is the union of all the sets in the list Sets\n\nArguments\n   Sets    a list of sets, set variables or set expressions\n   SetUnion    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_sets:get_set_attribute/2":{"prefix":"get_set_attribute","body":"get_set_attribute(${1:Set}, ${2:Attr})$3\n$0","description":"get_set_attribute(?Set, -Attr)\n\n   Get the set-attribute corresponding to Set\n\nArguments\n   Set    A ground set or a set variable\n   Attr    A variable, will be bound to a set-attribute structure\n\nType\n   library(ic_sets)\n\nDescription\n\n    Gets the set-attribute of a set-variable (or computes an attribute\n    structure describing a ground set as if it was a variable)."},"ic_sets:ic_sets_desc":{"prefix":"lib","body":"lib(${1:ic_sets})$2\n$0","description":"lib(ic_sets)\n\n    This is a solver for constraints over the domain of finite integer sets.\n    \n    (Ground) integer sets are represented simply as sorted, duplicate-free\n    lists of integers e.g.\n    \n    \tSetOfThree = [1,3,7]\n    \tEmptySet = []\n    \n\nSet Variables\n    Set variables are variables which can eventually take a ground integer\n    set as their value. They are characterized by a lower bound (the set \n    of elements that are definitely in the set) and an upper bound (the\n    set of elements that may be in the set). A set variable can be declared\n    as follows:\n    \n    \tSetVar :: []..[1,2,3,4,5,6,7],\n    \n    Since the lower bound is the empty set, this can be written as\n    \n    \tSetVar subset [1,2,3,4,5,6,7],\n    \n    If the lower bound is the empty set and the upper bound is a set\n    of consecutive integers, you can also write\n    \n    \tintset(SetVar, 1, 7)\n    \n\nSet Constraints\n    Most of the usual set operations/relations are provided as constraints:\n    \n    membership\n    non-membership\n    inclusion (subset)\n    equality\n    intersection\n    union\n    difference\n    symmetric difference\n    disjointness\n    cardinality\n    \n    as well as a constraint on set weight.  Note that there is no\n    complement-constraint because the library has no concept of a set\n    universe and cannot represent infinite sets.\n    \n    On most argument positions where sets are expected, set expressions\n    are allowed, e.g.\n    \n    Set1 /\\ Set2       % intersection\n    Set1 \\/ Set2       % union\n    Set1 \\ Set2    % difference\n    \n    as well as references to array elements like Set[3].\n    \n\nSearch\n    The insetdomain/4 predicate can be used to enumerate all ground\n    instantiations of a set variable, much like indomain/1 in the\n    finite-domain case.\n\nCooperation with a finite domain solver\n    This library comes in two flavours: lib(fd_sets) which cooperates with\n    lib(fd), and lib(ic_sets) which cooperates with lib(ic). This is relevant\n    only for those constraints which involve integer variables, e.g. the\n    cardinality argument in #/2, the weight argument in weight/3 and the\n    booleans in membership_booleans/2. These will be represented as fd-\n    or ic-variables respectively."},"ic_sets:in/3":{"prefix":"in","body":"in(${1:X}, ${2:Set}, ${3:Bool})$4\n$0","description":"in(?X, ?Set, ?Bool)\n\n   Reified version of the set membership constraint\n\nArguments\n   X    an integer or an (integer) variable\n   Set    a set, set variable, or set expression\n   Bool    0, 1 or a boolean variable\n\nType\n   library(ic_sets)\n\nDescription\n\n    This is the reified version of the in/2 constraint. This means that\n    the boolean variable Bool reflects the truth of the relation X in Set.\n    If Bool is 1, then in(X,Set,Bool) is the same as X in Set.\n    If Bool is 0, then in(X,Set,Bool) is the same as X notin Set.\n    Otherwise, Bool will be bound to 0 or 1 when X in Set\n    is known to be false or true, respectively. The latter is only\n    guaranteed to be detected after X has become instantiated.\n\n    Note that if one wants to have booleans corresponding to all or most\n    of the set domain elements, it will be more efficient to use the\n    membership_booleans/2 constraint in place of many in/3 constraints.\n\nExceptions\n     4 --- Set is a free variable without set domain\n\nExamples\n   \n    ?- intset(S, 1, 9), in(E, S, B).\n    E = E{[-10000000 .. 10000000]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = B{[0, 1]}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), B = 1.\n    E = E{[1 .. 9]}\n    S = S{([] .. [1, 2, 3, 4, 5, 6, 7, 8, 9]) : C{[0 .. 9]}}\n    B = 1\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 1.\n    S = S{[3] \\/ ([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[1 .. 9]}}\n    E = 3\n    B = 1\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, B = 0.\n    S = S{([] .. [1, 2, 4, 5, 6, 7, 8, 9]) : C{[0 .. 8]}}\n    E = 3\n    B = 0\n    Yes (0.00s cpu)\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S includes [2, 3, 4].\n    B = 1\n    E = 3\n    S = S{[2, 3, 4] \\/ ([] .. [1, 5, 6, 7, 8, 9]) : C{[3 .. 9]}}\n    There is 1 delayed goal.\n\n    ?- intset(S, 1, 9), in(E, S, B), E = 3, S disjoint [2, 3, 4].\n    B = 0\n    E = 3\n    S = S{([] .. [1, 5, 6, 7, 8, 9]) : C{[0 .. 6]}}\n    There is 1 delayed goal.\n\n    ?- in(3, S, 1).\n    instantiation fault\n    \n\nSee Also\n   in / 2, notin / 2, membership_booleans / 2"},"ic_sets:insetdomain/4":{"prefix":"insetdomain","body":"insetdomain(${1:Set}, ${2:CardSel}, ${3:ElemSel}, ${4:Order})$5\n$0","description":"insetdomain(?Set, ?CardSel, ?ElemSel, ?Order)\n\n   Instantiate Set to a possible value\n\nArguments\n   Set    a set or set variable\n   CardSel    atom or variable\n   ElemSel    atom, structure or variable\n   Order    atom or variable\n\nType\n   library(ic_sets)\n\nDescription\n\n    This predicate instantiates a set variable to a possible value,\n    according to its domain.  The predicate backtracks over all\n    possible set instantiations.  The three option arguments allow to\n    choose between a number of different enumeration orders. Giving a\n    variable as option argument will select the default.\n\n    The CardSel argument determines whether the sets are enumerated\n    according to their cardinality. It can take the following values:\n\nany (default)\n    the sets are not enumerated in a particular cardinality order\nincreasing\n    the sets are enumerated with increasing cardinality, ie. small\n    sets are tried first\ndecreasing\n    the sets are enumerated with decreasing cardinality, ie. large\n    sets are tried first\n\n    The ElemSel argument determines which potential set elements\n    are considered first for inclusion or exclusion. It can take the\n    following values:\n\nsmall_first (default)\n    small set elements (small numbers) are considered first\nbig_first\n    big set elements (big numbers) are considered first\nrandom\n    potential set elements are considered in random order\nheavy_first(Weights)\n    heavy set elements (according to Weight array) are considered first\nlight_first(Weights)\n    light set elements (according to Weight array) are considered first\n\n    The Order argument determines whether it is first tried to make\n    the selected potential element a set member, or whether to exclude it\n    first.  The argument can take the following values:\n\nin_notin (default)\n    try inclusion first, then exclusion\nnotin_in\n    try exclusion first, then inclusion\nsbds\n    uses sbds_try/2 to include or exclude an element in or from a set\n    (this is for use in conjunction with the classic SBDS library\n    (lib(ic_sbds) or lib(fd_sbds)), and whether inclusion or exclusion is\n    tried first depends on the \"fix pred\" specified in the prior call to\n    sbds_initialise/4 or sbds_initialise/5)\ngap_sbds_in_notin\n    try inclusion first, then exclusion, using sbds_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))\ngap_sbds_notin_in\n    try exclusion first, then inclusion, using sbds_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDS library lib(ic_gap_sbds))\ngap_sbdd_in_notin\n    try inclusion first, then exclusion, using sbdd_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))\ngap_sbdd_notin_in\n    try exclusion first, then inclusion, using sbdd_try_set/3 (this is\n    for use in conjunction with the GAP-based SBDD library lib(ic_gap_sbdd))\n\n    Note that there are many different enumeration strategies for a set\n    variable, and insetdomain/4 only allows a limited number of them.\n    For an actual application, it might be more appropriate to choose a\n    problem-specific enumeration order. This can be programmed easily.\n    As a guideline, here is the code for insetdomain with the default\n    options:\n\n    insetdomain(Set, _, _, _) :-\n    \tnonvar(Set).\n    insetdomain(Set, any, small_first, in_notin) :-\n    \tvar(Set),\n    \tpotential_members(Set, PotentialElements),\n\tPotentialElements = [Element|_],\n\t(\n\t    Element in Set\n\t;\n\t    Element notin Set\n\t),\n\tinsetdomain(Set, any, small_first, in_notin).\n\nResatisfiable\n   yes\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n?-  X::[]..[1,2,3], insetdomain(X,_,_,_), writeln(X), fail.\n[1, 2, 3]\n[1, 2]\n[1, 3]\n[1]\n[2, 3]\n[2]\n[3]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,increasing,_,_), writeln(X), fail.\n[]\n[1]\n[2]\n[3]\n[1, 2]\n[1, 3]\n[2, 3]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,big_first,_), writeln(X), fail.\n[1, 2, 3]\n[2, 3]\n[1, 3]\n[3]\n[1, 2]\n[2]\n[1]\n[]\n\nno (more) solution.\n?-  X::[]..[1,2,3], insetdomain(X,_,_,notin_in), writeln(X), fail.\n[]\n[3]\n[2]\n[2, 3]\n[1]\n[1, 3]\n[1, 2]\n[1, 2, 3]\n\nno (more) solution.\n?-  X::[]..[1,2,3],\n\tinsetdomain(X, increasing, heavy_first([](2,9,4,7)), _),\n\twriteln(X), fail.\n[]\n[2]\n[3]\n[1]\n[2, 3]\n[1, 2]\n[1, 3]\n[1, 2, 3]\n\nno (more) solution.\n\nSee Also\n   conjunto : refine / 1, conjunto_fd_sets : refine / 1, potential_members / 2, fd_sbds : sbds_try / 2, ic_gap_sbds : sbds_try / 2, ic_sbds : sbds_try / 2, gfd_sbds : sbds_try / 2, fd_sbds : sbds_initialise / 4, ic_sbds : sbds_initialise / 4, gfd_sbds : sbds_initialise / 4, fd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_initialise / 5, ic_sbds : sbds_initialise / 5, gfd_sbds : sbds_initialise / 5, ic_gap_sbds : sbds_try_set / 3, library(ic_gap_sbds), ic_gap_sbdd : sbdd_try_set / 3, library(ic_gap_sbdd)"},"ic_sets:int_sets/s":{"prefix":"struct","body":"struct","description":"struct int_sets(dom, off, lcard, ucard, added, removed, add, rem, card, booleans, value)\n\n   Attribute structure for set variables (and constants)\n\nFields\n   dom    set domain representation (array of booleans)\n   off    offset between set element and corresponding array index (integer)\n   lcard    lower bound cardinality (integer)\n   ucard    upper bound cardinality (integer)\n   added    notification send-port for lower bound increases\n   removed    notification send-port for upper bound decreases\n   add    suspension list woken when lower bound increases\n   rem    suspension list woken when upper bound decreases\n   card    fd/ic variable for cardinality (see #/2)\n   booleans    array of fd/ic variables (see membership_booleans/2)\n   value    set variable belonging to this attribute\n\nType\n   library(ic_sets)\n\nSee Also\n   library(notify_ports), suspend / 3, suspend / 4"},"ic_sets:intersection/3":{"prefix":"intersection","body":"intersection(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"intersection(?Set1, ?Set2, ?Set3)\n\n   Set3 is the intersection of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_sets:intset/3":{"prefix":"intset","body":"intset(${1:Set}, ${2:Min}, ${3:Max})$4\n$0","description":"intset(?Set, +Min, +Max)\n\n   Set is a set containing numbers between Min and Max\n\nArguments\n   Set    A free variable, set variable or an integer list\n   Min    integer\n   Max    integer\n\nType\n   library(ic_sets)\n\nDescription\n\n    Unifies Set with a set variable whose lower bound is the empty set\n    and whose upper bound is the set of all integers between Min and Max.\n    Equivalent to Set::[]..[Min,Min+1,..,Max].\n\nExceptions\n     4 --- Min or Max are uninstantiated\n     5 --- Set is not a variable or list\n\nSee Also\n   intsets / 4, :: / 2"},"ic_sets:intsets/4":{"prefix":"intsets","body":"intsets(${1:Sets}, ${2:N}, ${3:Min}, ${4:Max})$5\n$0","description":"intsets(?Sets, ?N, +Min, +Max)\n\n   Sets is a list of N sets containing numbers between Min and Max\n\nType\n   library(ic_sets)\n\nExceptions\n     4 --- Min or Max are uninstantiated\n\nSee Also\n   intset / 3, :: / 2"},"ic_sets:membership_booleans/2":{"prefix":"membership_booleans","body":"membership_booleans(${1:Set}, ${2:BoolArr})$3\n$0","description":"membership_booleans(?Set, ?BoolArr)\n\n   BoolArr is an array of booleans describing Set\n\nArguments\n   Set    a set, set variable, free variable or set expression\n   BoolArr    A variable or an array (structure) of boolean variables\n\nType\n   library(ic_sets)\n\nDescription\n\n    This constraint maintains the correspondence between a finite set and\n    an array of booleans (0/1 variables). The set is constrained to contain\n    those (and only those) integers I between 1 and N (the size of the array)\n    where the corresponding array element is 1.\n\n    Operationally, setting a array element I to 0 will exclude the element\n    I from Set's domain. Setting I to 1 will include I in Set's lower bound.\n    Adding and removing elements from Set will be reflected in the\n    corresponding boolean being instantiated to 1 or 0 respectively.\n\n    When called with BoolArr being a free variable, an array will be created\n    whose arity is at least as big as the largest potential set member.\n    Set members smaller than 1 will be excluded from the set.\n    When called with BoolArr being instantiated to an array, set members\n    smaller than 1 or bigger than the array size will be excluded from\n    the set.\n\nExamples\n   \n    ?- S::[2,4]..[1,2,3,4,5], membership_booleans(S,B).\n\n    S = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n    B = [](_{[0, 1]}, 1, _{[0, 1]}, 1, _{[0, 1]})\n\n    Delayed goals:\n\t...\n\n    ?- membership_booleans(S, [](0,1,0,1,B5)).\n\n    S = S{[2, 4] \\/ ([] .. [5]) : _{[2, 3]}}\n    B5 = B5{[0, 1]}\n\n    Delayed goals:\n\t..."},"ic_sets:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   Succeeds if Term is a ground set or a set variable\n\nArguments\n   Term    A term\n\nType\n   library(ic_sets)\n\nDescription\n\n    Succeeds if Term is either a set (represented as a list) or a set\n    variable. For efficiency reasons, lists are not checked for being\n    valid set representations (i.e. strictly sorted lists of integers),\n    the predicate succeeds for any list.\n\nFail Conditions\n   Set is neither a set nor a set variable"},"ic_sets:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   Succeeds if Term is a set variable\n\nArguments\n   Term    A term\n\nType\n   library(ic_sets)\n\nFail Conditions\n   Set is not a variable, or a non-set variable"},"ic_sets:potential_members/2":{"prefix":"potential_members","body":"potential_members(${1:Set}, ${2:List})$3\n$0","description":"potential_members(?Set, -List)\n\n   List is the list of elements of whose membership in Set is currently uncertain\n\nArguments\n   Set    a set or set variable\n   List    variable, will be unified with a list\n\nType\n   library(ic_sets)\n\nExceptions\n     4 --- Set is a variable, but not a set variable\n\nExamples\n   \n    \t?- S :: [2,4]..[1,2,3,4,5], potential_members(S, P).\n\tS = S{[2, 4] \\/ ([] .. [1, 3, 5]) : _{[2 .. 5]}}\n\tP = [1, 3, 5]"},"ic_sets:set_range/3":{"prefix":"set_range","body":"set_range(${1:Set}, ${2:Lwb}, ${3:Upb})$4\n$0","description":"set_range(?Set, -Lwb, -Upb)\n\n   Lwb and Upb are the current lower and upper bounds on Set\n\nArguments\n   Set    A variable or an integer list\n   Lwb    List of integers\n   Upb    List of integers\n\nType\n   library(ic_sets)\n\nDescription\n\n    Returns two sorted, duplicate-free lists of integers which represent\n    the lower and upper bound of the set variable (or the ground set) Set.\n    The predicate can also be used as a test for set-variables, since it\n    fails for any other (in particular domain-less) variables.\n\nFail Conditions\n   Set is a variable, but not a set variable"},"ic_sets:symdiff/3":{"prefix":"symdiff","body":"symdiff(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"symdiff(?Set1, ?Set2, ?Set3)\n\n   Set3 is the symmetric difference of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_sets:weight/3":{"prefix":"weight","body":"weight(${1:Set}, ${2:ElementWeights}, ${3:Weight})$4\n$0","description":"weight(?Set, ++ElementWeights, ?Weight)\n\n   According to the array of element weights, the weight of set Set is Weight\n\nArguments\n   Set    a set, set variable or set expression\n   ElementWeights      an array (structure) of non-negative integers\n   Weight    an integer variable or integer\n\nType\n   library(ic_sets)\n\nDescription\n\n    Set is constrained to be a set of integers between 1 and the size of\n    the array ElementWeights. Weight is an integer domain variable which\n    is constrained to the sum of the weights of Set's elements. The weight\n    of a set element is determined by the array element in ElementWeights\n    whose index corresponds to the set element.\n\n    Changes to the set domain will affect the domain of Weight. There is currently\n    no reverse propagation. This may change in a future release."},"ic_sets:union/3":{"prefix":"union","body":"union(${1:Set1}, ${2:Set2}, ${3:Set3})$4\n$0","description":"union(?Set1, ?Set2, ?Set3)\n\n   Set3 is the union of the integer sets Set1 and Set2\n\nArguments\n   Set1    a set, set variable or set expression\n   Set2    a set, set variable or set expression\n   Set3    a set, set variable, free variable or set expression\n\nType\n   library(ic_sets)"},"ic_symbolic:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:List})$2\n$0","description":"alldifferent(?List)\n\n   All elements of List are different\n\nArguments\n   List    list of variables or domain values\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains all list elements to be different values of the same domain.\n\tThis is implemented by mapping onto ic_global:alldifferent/1.\n\tAll list elements must be variables or values of the same domain.\n\tIf one or more of them are domain-less, they will be given the same\n\tdomain as the others.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ic_global : alldifferent / 1"},"ic_symbolic:atmost/3":{"prefix":"atmost","body":"atmost(${1:N}, ${2:List}, ${3:Value})$4\n$0","description":"atmost(++N, +List, ++Value)\n\n   Value occurs N times in List\n\nArguments\n   N    integer\n   List    list of variables or domain values\n   Value    domain value\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains its arguments such that Value occurs at most N times\n\tin List.\n\tThis is implemented by mapping onto ic_global:atmost/3.\n\tAll list elements and Value must be variables or values of the\n\tsame domain.  If one or more of them are domain-less, they will\n\tbe given the same domain as the others.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ic_global : atmost / 3"},"ic_symbolic:alldifferent/2":{"prefix":"alldifferent","body":"alldifferent(${1:List}, ${2:Cap})$3\n$0","description":"alldifferent(?List, ?Cap)\n\n   No domain value occurs more than Cap times in List\n\nArguments\n   List    list of variables or domain values\n   Cap    integer or integer variable\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains the list so that no more than Cap elements can have the\n\tsame value.\n\tThis is implemented by mapping onto ic_global:alldifferent/2.\n\tAll list elements must be variables or values of the same domain.\n\tIf one or more of them are domain-less, they will be given the same\n\tdomain as the others.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ic_global : alldifferent / 2"},"ic_symbolic:ic_symbolic_desc":{"prefix":"lib","body":"lib(${1:ic_symbolic})$2\n$0","description":"lib(ic_symbolic)\n\n    Overview\n    \n    This library is an add-on to library(ic) and implements variables\n    over ordered symbolic domains, and constraints over such variables.\n    This is in contrast to the basic library(ic), which implements only\n    variables over numeric domains.\n    Domains\n    The library uses the domain feature provided by the ECLiPSe kernel.\n    I.e. domains need to be declared. The declaration specifies the domain\n    values and their order. For example:\n    \n    \t?- local domain(weekday(mo,tu,we,th,fr,sa,su)).\n    \n    declares a domain with name 'weekday' and values 'mo', 'tu' etc.\n    The domain values are implicitly ordered, with 'mo' corresponding to 1,\n    until 'su' corresponding to 7.\n    Domain values must be unique within one ECLiPSe module, i.e. a symbolic\n    value can belong to at most one domain.\n    Variables\n    A variable of a declared domain can then be created using\n    \n\t?- X &:: weekday.\n\tX = X{[mo, tu, we, th, fr, sa, su]}\n\tYes (0.00s cpu)\n    \n    or multiple variables using &:: /2.\n    Basic Constraints\n    The following constraints implement the basic relationships between\n    two domain values. The constraints require their arguments to come from\n    identical domains, otherwise an error is raised.\n    \n    X &= YX is the same as Y\n    X &\\= YX is different from Y\n    X &X is strictly before Y in the domain order\n    X &> YX is strictly after Y in the domain order\n    X &=X is the same as Y, or before Y in the domain order\n    X &>= YX is the same as Y, or after Y in the domain order\n    shift(X,C,Y)Y is C places after X in the domain order\n    rotate(X,C,Y)like shift/3 but wraps at domain boundary\n    element(Index,List,Value)Value occurs List at position Index\n    \n    For example\n    \n\t?- [X, Y] &:: weekday, X &\n    Global Constraints\n    A number of global constraints are available which directly correspond\n    (and are in fact implemented via) their counterparts in lib(ic_global):\n    \n    alldifferent(List)All list elements are different\n    occurrences(Value,List,N)Value occurs N times in List\n    atmost(N,List,Value)Value occurs at most N times in List\n    \n    \n    Internals\n    \n    Internally, symbolic domains are mapped to integer ranges from 1 up to\n    the number of domain elements. The first value in the domain declaration\n    corresponds to 1, the second to 2 and so on. Similarly, symbolic domain\n    variables can be mapped to a corresponding IC integer variable.\n    This mapping is accessible through the predicate symbol_domain_index/3:\n    \n    ?- symbol_domain_index(fr, D, I).\n    D = weekday\n    I = 5\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday, symbol_domain_index(X, D, I).\n    X = X{[mo, tu, we, th, fr, sa, su]}\n    D = weekday\n    I = I{1 .. 7}\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday, X &\\= we, symbol_domain_index(X, D, I).\n    X = X{[mo, tu, th, fr, sa, su]}\n    D = weekday\n    I = I{[1, 2, 4 .. 7]}\n    Yes (0.00s cpu)\n    \n    The integer variable I mirrors the domain of the symbolic variable\n    X and vice versa.\n    \n    Extending and Interfacing this Library\n    \n    Because of the mapping of symbols to integers, new constraints over\n    symbolic variables can be implemented simply by placing numeric (IC)\n    constraints on the corresponding integer variables.\n    \n    Similarly, the facilities of the ic_search library can be exploited\n    when working with symbolic variables. Instead of labeling the symbolic\n    variables, one can use the various facilities of ic_search to label\n    the corresponding integer variables instead.\n    \n    Known Problems\n    \n    For efficiency reasons, the 'constrained' suspension list of the symbolic\n    variable does not automatically get woken every time the domain changes\n    (although it does get woken when the domain is initially attached, and\n    when the variable gets instantiated). There are two solutions: (1) instead\n    of suspending goals on the constrained-list of the symbolic variable,\n    suspend them on the constrained-list of the corresponding integer variable.\n    (2) Use a forwarding demon that suspends on the constrained-list of the\n    integer variable and wakes the constrained-list of the symbolic variable:\n    \n\tsymbol_domain_index(X, Domain, X_ic),\n    \tsuspend(notify_constrained(X), 2, X_ic->constrained)"},"ic_symbolic:element/3":{"prefix":"element","body":"element(${1:Index}, ${2:List}, ${3:Value})$4\n$0","description":"element(?Index, ++List, ?Value)\n\n   Value is the Index'th element of List\n\nArguments\n   Index    integer variable or integer\n   List    list of domain values\n   Value    domain variable or value\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains its arguments such that Value is the Index'th member\n\tof List.  This is implemented by mapping onto ic:element/3.\n\tAll list elements and Value must be variables or values of the\n\tsame domain.  If one or more of them are domain-less, they will\n\tbe given the same domain as the others.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ic : element / 3"},"ic_symbolic:indomain/1":{"prefix":"indomain","body":"indomain(${1:X})$2\n$0","description":"indomain(?X)\n\n   Nondeterministically instantiate to domain values\n\nArguments\n   X    domain variable or value\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tInstantiates a domain variable to its domain values. The order of\n\tenumeration is in increasing domain order.\n    \n\nExamples\n   \n    ?- local domain(weekday(mo, tu, we, th, fr, sa, su)).\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday.\n    X = X{[mo, tu, th, fr, sa, su]}\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday, indomain(X).\n    X = mo\n    More (0.00s cpu)\n    X = tu\n    More (0.01s cpu)\n    X = we\n    More (0.02s cpu)\n    X = th\n    More (0.03s cpu)\n    X = fr\n    More (0.05s cpu)\n    X = sa\n    More (0.06s cpu)\n    X = su\n    Yes (0.06s cpu)\n\n    ?- indomain(we).\n    Yes (0.00s cpu)\n    \n\nSee Also\n   &:: / 2, domain / 1"},"ic_symbolic:occurrences/3":{"prefix":"occurrences","body":"occurrences(${1:Value}, ${2:List}, ${3:N})$4\n$0","description":"occurrences(+Value, +List, ?N)\n\n   Value occurs N times in List\n\nArguments\n   Value    domain value\n   List    list of variables or domain values\n   N    integer variable or integer\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains its arguments such that Value occurs exactly N times\n\tin List.\n\tThis is implemented by mapping onto ic_global:occurrences/3.\n\tAll list elements and Value must be variables or values of the\n\tsame domain.  If one or more of them are domain-less, they will\n\tbe given the same domain as the others.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   ic_global : occurrences / 3"},"ic_symbolic:msg/3":{"prefix":"msg","body":"msg(${1:X}, ${2:Y}, ${3:MSG})$4\n$0","description":"msg(?X, ?Y, -MSG)\n\n   MSG is the most specific generalisation of X and Y representable with ic-symbolic domain variables\n\nArguments\n   X    Any term or variable\n   Y    Any term or variable\n   MSG    A domain variable or constant (output)\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tThis predicate computes the most specific generalisation of X and Y\n\twhich can be represented using ic-symbolic's domains and domain\n\tvariables.\n\t\n\tIf X and Y are domain variables (or constants) from the same domain,\n\tthen MSG will be unified with a new domain variable whose domain\n\tconsists of the union of the domain elements of X and Y.\n\t\n\tIf X and Y are domain variables or constants with incompatible\n\tdomains, then the result will be a free (unconstrained) variable.\n\t\n\tIf X or Y are free (unconstrained) variables, then the result will\n\talso be a free (unconstrained) variable.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   None\n\nExamples\n   \n    ?- local domain(weekday(mo, tu, we, th, fr, sa, su)).\n    Yes (0.00s cpu)\n\n    ?- msg(we, fr, Z).\n    Z = Z{[we, fr]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], msg(X, we, Z).\n    X = X{[sa, su]}\n    Z = Z{[we, sa, su]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], Y &:: [mo, tu, we], msg(X, Y, Z).\n    X = X{[sa, su]}\n    Y = Y{[mo, tu, we]}\n    Z = Z{[mo, tu, we, sa, su]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], msg(X, _, Z).\n    X = X{[sa, su]}\n    Z = Z\n    Yes (0.01s cpu)\n\n    % in the following, the result is not precisely representable\n    ?- X &:: [sa, su], msg(X, foo, Z).\n    X = X{[sa, su]}\n    Z = Z\n    Yes (0.01s cpu)\n    \n\nSee Also\n   ic_kernel : msg / 3, fd : msg / 3, ic_sets : msg / 3, fd_sets : msg / 3, sd : msg / 3, gfd : msg / 3, library(propia), &:: / 2, domain / 1"},"ic_symbolic:rotate/3":{"prefix":"rotate","body":"rotate(${1:X}, ${2:C}, ${3:Y})$4\n$0","description":"rotate(?X, ?C, ?Y)\n\n   Y is C places after X in the (cyclic) domain order\n\nArguments\n   X    variable or domain value\n   C    variable or integer\n   Y    variable or domain value\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains X and Y such that Y is C positions after X in the domain\n\torder, where the order is considered cyclic, i.e. the first domain\n\telement follows the last one. Because of the cyclic order, for each\n\tpair of X and Y there are infinitely many solutions for C (which\n\tare identical modulo the domain size).\n\tX and Y must be variables or values of the same domain. If one of\n\tthem is domain-less, it will be given the same domain as the other.\n\t\n\tThe implementation currently achieves only bounds-consistency.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- [X,Y] &:: weekday, rotate(X,1,Y).\n    X = X{[mo, tu, we, th, fr, sa, su]}\n    Y = Y{[mo, tu, we, th, fr, sa, su]}\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n\n    ?- rotate(th,1,fr).\n    Yes (0.00s cpu)\n\n    ?- rotate(su,2,tu).\n    Yes (0.00s cpu)\n\n    ?- rotate(su,9,tu).\n    Yes (0.00s cpu)\n\n    ?- rotate(X,1,fr).\n    X = th\n    Yes (0.00s cpu)\n\n    ?- rotate(su,50,X).\n    X = mo\n    Yes (0.00s cpu)\n\n    ?- rotate(su,-1,X).\n    X = sa\n    Yes (0.00s cpu)\n\n    ?- rotate(tu,1,th).\n    No (0.00s cpu)\n\n    ?- ic:(X::0..7), rotate(tu,X,fr).\n    X = 3\n    Yes (0.00s cpu)\n\n    ?- ic:(X::2..4), rotate(tu,X,Y).\n    X = X{2 .. 4}\n    Y = Y{[th, fr, sa]}\n    Delayed goals: ...\n\n    ?- rotate(X,1,Y).\n    Arguments have no domains in rotate(X, 1, Y) in module eclipse\n    Abort\n\n    ?- X &:: weekday, rotate(X, 1, red).\n    Arguments have different domains (weekday,colour) in rotate(X, 1, red) ...\n    Abort\n    \n\nSee Also\n   rotate / 4, &< / 2, &> / 2, &=< / 2, &>= / 2, &= / 2, &\\= / 2, shift / 3, domain / 1"},"ic_symbolic:shift/3":{"prefix":"shift","body":"shift(${1:X}, ${2:C}, ${3:Y})$4\n$0","description":"shift(?X, ?C, ?Y)\n\n   Y is C places after X in the domain order\n\nArguments\n   X    variable or domain value\n   C    variable or integer\n   Y    variable or domain value\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tConstrains X and Y such that Y is C positions after X in the domain\n\torder. C must be an integer or integer variable, and its range is\n\t-(S-1)..S-1 where S is the size of the symbolic domain.\n\tX and Y must be variables or values of the same domain. If one of\n\tthem is domain-less, it will be given the same domain as the other.\n\t\n\tThe implementation achieves domain consistency iff C is instantiated\n\tat call time, otherwise only bounds consistency.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- [X,Y] &:: weekday, shift(X, 1, Y).\n    X = X{[mo, tu, we, th, fr, sa]}\n    Y = Y{[tu, we, th, fr, sa, su]}\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n\n    [eclipse 4]: [X,Y]&::weekday, shift(X,C,Y). \n    X = X{[mo, tu, we, th, fr, sa, su]}\n    C = C{-6 .. 6}\n    Y = Y{[mo, tu, we, th, fr, sa, su]}\n    There are 3 delayed goals.\n    Yes (0.00s cpu)\n\n    ?- shift(we, 1, th).\n    Yes (0.00s cpu)\n\n    ?- shift(we, 2, fr).\n    Yes (0.00s cpu)\n\n    ?- shift(X, -1, th).\n    X = fr\n    Yes (0.00s cpu)\n\n    ?- shift(tu, X, fr).\n    X = 3\n    Yes (0.00s cpu)\n\n    ?- shift(tu,X,Y).\n    X = X{-1 .. 5}\n    Y = Y{[mo, tu, we, th, fr, sa, su]}\n    Delayed goals: ...\n\n    ?- shift(tu, 1, th).\n    No (0.00s cpu)\n\n    ?- shift(X, 1, Y).\n    Arguments have no domains in shift(X, 1, Y) in module eclipse\n    Abort\n\n    ?- X &:: weekday, shift(X, 1, red).\n    Arguments have different domains (weekday,colour) in shift(X, 1, red) ...\n    Abort\n    \n\nSee Also\n   shift / 4, &< / 2, &> / 2, &=< / 2, &>= / 2, &= / 2, &\\= / 2, rotate / 3, domain / 1"},"ic_symbolic:rotate/4":{"prefix":"rotate","body":"rotate(${1:X}, ${2:C}, ${3:Y}, ${4:Bool})$5\n$0","description":"rotate(?X, ?C, ?Y, ?Bool)\n\n   Reified version of rotate(X,C,Y)\n\nArguments\n   X    variable or domain value\n   C    variable or integer\n   Y    variable or domain value\n   Bool    0, 1, or boolean variable\n\nType\n   library(ic_symbolic)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   rotate / 3"},"ic_symbolic:shift/4":{"prefix":"shift","body":"shift(${1:X}, ${2:C}, ${3:Y}, ${4:Bool})$5\n$0","description":"shift(?X, ?C, ?Y, ?Bool)\n\n   Reified version of shift(X,C,Y)\n\nArguments\n   X    variable or domain value\n   C    variable or integer\n   Y    variable or domain value\n   Bool    0, 1, or boolean variable\n\nType\n   library(ic_symbolic)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   shift / 3"},"instprofile:close_delta_file/0":{"prefix":"close_delta_file","body":"close_delta_file","description":"close_delta_file\n\n   Close the instrumentation profiler's delta results file.\n\nArguments\n\nType\n   library(instprofile)\n\nDescription\n    \n   Close the file that the instrumentation profiler writes delta values to.\n   The file must previously have been opened using open_delta_file/1. \n   \n   Delta values are the instrumentation profiling results for the single\n   execution (as opposed to aggregated) of a profiled code fragment.\n   \n   For performance reasons, the results are written to the file using \n   buffered I/O - each result is not flushed to the file as it is emitted. \n   As a result to ensure all results are flushed to the disk file,\n   close_delta_file must be executed.\n   \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nSee Also\n   open_delta_file / 1, statprofile / 3, statistics / 2, library(instprofile)"},"ic_symbolic:symbols_domain_indices/3":{"prefix":"symbols_domain_indices","body":"symbols_domain_indices(${1:Xs}, ${2:Domain}, ${3:Is})$4\n$0","description":"symbols_domain_indices(+Xs, ?Domain, -Is)\n\n   Map symbolic domain variables/values to integer variables/values\n\nArguments\n   Xs    list of domain variables or values\n   Domain    Variable or domain name\n   Is    Variable, will be bound to list of integers or integer variables\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tLow-level primitive:\n\tFor a list of domain variables or domain values, return the\n\tdomain name and a list of integers or integer variables reflecting\n\tthe corresponding integer index within the domain order.\n\tIf the domain name is instantiated at call time, the list elements\n\twill be checked to be all from this domain.\n\t\n\tAn error will be reported if not all list elements come from the same\n\tdomain. If the list contained domain-less variables, then, as a side\n\teffect, these will be given a domain to be compatible with the other\n\tlist elements.\n\t\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   X is neither a symbolic domain variable nor a domain constant\n\nExamples\n   \n    ?- symbols_domain_indices([we], D, Is).\n    D = eclipse:weekday\n    Is = [3]\n    Yes (0.00s cpu)\n    \n    ?- X &:: weekday, symbols_domain_indices([X], D, Is).\n    X = X{[mo, tu, we, th, fr, sa, su]}\n    D = weekday\n    Is = [X_ic{1 .. 7}]\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday, symbols_domain_indices([X, Y, we], D, Is).\n    X = X{[mo, tu, we, th, fr, sa, su]}\n    Y = Y{[mo, tu, we, th, fr, sa, su]}\n    D = eclipse:weekday\n    Is = [X_ic{1 .. 7}, X_ic{1 .. 7}, 3]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   symbol_domain_index / 3, &:: / 2, domain / 1"},"ic_symbolic:symbol_domain_index/3":{"prefix":"symbol_domain_index","body":"symbol_domain_index(${1:X}, ${2:Domain}, ${3:Index})$4\n$0","description":"symbol_domain_index(?X, -Domain, -Index)\n\n   Map a symbolic domain variable/value to integer variable/value\n\nArguments\n   X    domain variable or value\n   Domain    Variable, will be bound to a pair Module:DomainName\n   Index    Variable, will be bound to integer or integer variable\n\nType\n   library(ic_symbolic)\n\nDescription\n\n\tLow-level primitive:\n\tFor a domain variable or domain value, return the corresponding\n\tdomain name and an integer or integer variable reflecting the\n\tcorresponding integer index within the domain order.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   X is neither a symbolic domain variable nor a domain constant\n\nExamples\n   \n    ?- symbol_domain_index(we, D, I).\n    D = eclipse:weekday\n    I = 3\n    Yes (0.00s cpu)\n\n    ?- X &:: weekday, X &\\= we, symbol_domain_index(X, D, I).\n    X = X{[mo, tu, th, fr, sa, su]}\n    D = eclipse:weekday\n    I = I{[1, 2, 4 .. 7]}\n    Yes (0.00s cpu)\n    \n\nSee Also\n   symbols_domain_indices / 3, &:: / 2, domain / 1, domain_index / 3"},"instprofile:aggregate_result/1":{"prefix":"aggregate_result","body":"aggregate_result(${1:File})$2\n$0","description":"aggregate_result(+File)\n\n   Write the aggregated instrument profiling results to\n   a named file.\n\nArguments\n   File    Atom or string\n\nType\n   library(instprofile)\n\nDescription\n    \n   This will write the aggregated results of instrumentation profiling \n   for all source files that have been compiled into the calling module \n   context and profiled with the instrument profiler.\n   \n   NOTE: Memory related statistics are displayed in kilobytes not bytes.\n   \n   This predicate should be executed before result/0 predicate, since\n   result/0 also invokes reset/0 which resets the statistics.\n   \n   The use of this predicate is only meaningful if the module has\n   previously been compiled for instrumentation profiling using \n   instprofile:statprofile/2,3, and the code has been\n   run in order to obtain profiling results.\n   \n   The predicate is a tool and the profiling results of a\n   module other than the current calling module context can be obtained\n   by invoking aggregate_result@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The calling context module has not been profiled.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- File is not instantiated\n     5 --- File is not an atom or string\n\nSee Also\n   statprofile / 2, statprofile / 3, aggregate_result / 1, open_delta_file / 1, close_delta_file / 0, reset / 0, statistics / 2, library(instprofile)"},"instprofile:result/0":{"prefix":"result","body":"result","description":"result\n\n   Pretty-print the instrument profiled source with\n   aggregated results.\n\nArguments\n\nType\n   library(instprofile)\n\nDescription\n    \n   This will pretty-print all source files in the calling module context,\n   annotated with the aggregated results of instrumentation profiling.  \n   The resulting .html files are placed in a sub-directory called\n   'instprofile', relative to the files that were compiled into the file.\n   \n   NOTE: Memory related statistics are displayed in kilobytes not bytes.\n   \n   The use of this predicate is only meaningful if the module has\n   previously been compiled for instrumentation profiling using \n   instprofile:statprofile/2,3, and the code has been\n   run in order to obtain profiling results.\n   \n   The predicate is a tool and the profiling results of a\n   module other than the current calling module context can be obtained\n   by invoking result@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The calling context module has not been profiled.\n\nResatisfiable\n   no\n\nSee Also\n   statprofile / 2, statprofile / 3, aggregate_result / 1, open_delta_file / 1, close_delta_file / 0, reset / 0, statistics / 2, library(instprofile)"},"instprofile:instprofile_desc":{"prefix":"lib","body":"lib(${1:instprofile})$2\n$0","description":"lib(instprofile)\n\n   The instprofile library provides two complimentary mechanisms for\n   the profiling of ECLiPSe code with the metrics provided by the\n   statistics/2 predicate:\n   \n   Instrumentation based, where metric measuring code is\n   inserted directly into the user program in order to accurately\n   determine how its constituent pieces of code perform. The\n   mechanism for the insertion of instrumentation code is based upon \n   the facilities of the instrument library. As such, the statistic \n   measurements may be inserted at the beginning and end of clause or block \n   definitions, and around subgoals and/or predicate calls.  \n   Sample driven, where metric measuring code is executed at a user\n   defined interval as the user program runs. The sample based profiler is \n   implemented using after events and is therefore less intrusive in its\n   effect on the performance of the executing code. \n   \n   \n   While the performance overhead of the sampling profiler is lower, it \n   cannot be used to determine the exact cost of a piece of code for a \n   particular statistic. It merely provides snapshots with respect to time \n   not code location. The instrumentation based profiler does however\n   provide the means for the measurement of both the aggregated cost for \n   all executions of a piece of code and also the cost for each individual \n   execution.\n   \n   The usage of the instrumentation based profiler is as follows:\n   \n   Load the instprofile library\n   \n   ?- lib(instprofile).\n   \n   Compile your program with instrumentation profiling:\n   \n   ?- instprofile:statprofile(my_program, [global_stack_used,\n    trail_stack_used]).\n   \n   Run the query for which you wish to generate mode analysis data\n   \n   ?- my_query(X,Y,Z).\n   \n   Generate the results for the module into which the program\n       was compiled.\n   \n   ?- instprofile:result@my_program_module.\n   \n   \n   The usage of the sampling profiler is as follows:\n   \n   Load the instprofile library\n   \n   ?- lib(instprofile).\n   \n   Define a sampling profile\n   \n   ?- instprofile:statsample(memory, 5, [global_stack_used,\n    trail_stack_used], 'memory_sample.dat').\n   \n   Prior to running the queries for which you wish to gather \n   sampling data, enable the sampling profiler for the named profile\n   \n   ?- instprofile:statsample_control(memory, on)\n   \n   Run the query for which you wish to generate sampling data\n   \n   ?- my_query(X,Y,Z).\n   \n   Disable the sampling profiler for the named profile. The results\n   file specified in statsample/4 contains the sampling data.    \n   \n   ?- instprofile:statsample_control(memory, off)\n   \n   \n   \n   Limitations to be resolved shortly: \n   \n   \n   Results are currently produced per module, not for individual files\n   within a module (i.e. results must be retrieved for all files within \n   a module).\n   \n   When multiple statistics are specified, the order in which the\n   statistics will appear in the results (pretty-printed source and results\n   file) is displayed during the invocation of the statsample predicate,\n   not the result predicate.\n   \n   Results are produced to a file or annotated on pretty-printed\n   source and these results to be viewed offline. Additional facilities \n   are to be provided that allow for the real time visualisation of results.\n   \n   The model that accounts for the cost of inserted instrumentation is \n   fairly rudimentary (especially for the 'global_stack_used' statistic.\n   \n   A future enhancement will enable the insertion of user defined metrics\n   not just those available via statistics/2."},"instprofile:reset/0":{"prefix":"reset","body":"reset","description":"reset\n\n   Reset the profiling statistics for the calling context\n   module.\n\nArguments\n\nType\n   library(instprofile)\n\nDescription\n    \n   This will reset the currently stored aggregated profiling results for \n   the calling context module.\n   \n   The use of this predicate is only meaningful if the module has\n   previously been compiled for instrumentation profiling using \n   instprofile:statprofile/2,3, and the code has been\n   run in order to obtain profiling results.\n   \n   The predicate is a tool and the profiling results of a\n   module other than the current calling module context can be obtained\n   by invoking reset@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The calling context module has not been profiled.\n\nResatisfiable\n   no\n\nSee Also\n   statprofile / 2, statprofile / 3, open_delta_file / 1, close_delta_file / 0, result / 0, aggregate_result / 1, statistics / 2, library(instprofile)"},"instprofile:open_delta_file/1":{"prefix":"open_delta_file","body":"open_delta_file(${1:DeltaFile})$2\n$0","description":"open_delta_file(+DeltaFile)\n\n   Open the instrumentation profiler's delta results file.\n\nArguments\n   DeltaFile    Atom or string\n\nType\n   library(instprofile)\n\nDescription\n    \n   Open the file that the instrumentation profiler writes delta values to.\n   If a file has been previously opened using open_delta_file/1 it is shut\n   before the specified file is opened. \n   \n   Delta values are the instrumentation profiling results for the single\n   execution (as opposed to aggregated) of a profiled code fragment.\n   \n   NOTE: Memory related statistics are displayed in bytes.\n   \n   For performance reasons, the results are written to the file using \n   buffered I/O - each result is not flushed to the file as it is emitted. \n   As a result to ensure all results are flushed to the disk file,\n   close_delta_file must be executed.\n   \n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExceptions\n     4 --- File is not instantiated\n     5 --- File is not an atom or string\n\nSee Also\n   close_delta_file / 0, statprofile / 3, statistics / 2, library(instprofile)"},"instprofile:statprofile/2":{"prefix":"statprofile","body":"statprofile(${1:File}, ${2:Statistics})$3\n$0","description":"statprofile(+File, +Statistics)\n\n   Instrument a file with statistics profiling code.\n\nArguments\n   File    Atom or string\n   Statistics    List of statistic keywords\n\nType\n   library(instprofile)\n\nDescription\n    \n   The predicate inserts into the user code of File, instrumentation \n   for the collection of the statistics (statistics/2 metric keywords) \n   specified in Statistics. The instrumentation is inserted at clause \n   entry and exit points (i.e. the start, end, fail and redo ports of \n   the conceptual predicate box model) and aggregates the cost for each \n   of the metrics as the program executes. The source code can be annotated \n   with these aggregated results using the result/0 predicate. Additionally, \n   the results may be dumped to a file in a format suitable for offline \n   analysis and graphing.\n   \n   statprofile/3 should be used for instrumentation profiling of code at a\n   finer granularity than the clause definition. statprofile/3 provides \n   options to prevent the profiling of recursive predicates. It also, \n   provides an option to produce the results for a single execution of a \n   profiled piece of code, in addition to the aggregated results.\n   \n   The instrumentation profiler places an overhead on the execution of the \n   code undergoing profiling due to the insertion of the profiling code.\n   The sample based profiler is implemented using after events and is\n   therefore less intrusive in its effect on the performance of the \n   executing code than the instrumentation profiler. However, it is used to\n   indicate the trend of resource usage over time of a running program not to\n   attribute specific costs of a statistic to a specific piece of code. The\n   instrumentation based profiler is used to do this.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Statistics is empty or contains an invalid statistic/2 keyword.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- File is not an atom or string\n\nExamples\n   \n   [eclipse 1]: instprofile:statprofile(queen, [global_stack_used, trail_stack_used]).\n\n   Yes (0.06s cpu)\n   \n\nSee Also\n   statprofile / 3, statistics / 2, result / 0, aggregate_result / 1, reset / 0, open_delta_file / 1, close_delta_file / 0, library(instprofile), library(instrument)"},"instprofile:statprofile/3":{"prefix":"statprofile","body":"statprofile(${1:File}, ${2:Statistics}, ${3:OptionsList})$4\n$0","description":"statprofile(+File, +Statistics, +OptionsList)\n\n   Instrument a file with statistics profiling code.\n\nArguments\n   File    Atom or string\n   Statistics    List of statistic keywords\n   OptionsList    List of Name:Value pairs\n\nType\n   library(instprofile)\n\nDescription\n    \n   The predicate inserts into the user code of File, instrumentation \n   for the collection of the statistics (statistics/2 metric keywords) \n   specified in Statistics. The instrumentation is inserted by default \n   at clause entry and exit points (i.e. the start, end, fail and redo \n   ports of the conceptual predicate box model) and aggregates the cost \n   for each of the metrics as the program executes. The source code can \n   be annotated with these aggregated results using the result/0 predicate. \n   Additionally, the results may be dumped to a file in a format suitable \n   for offline analysis and graphing.\n   \n   OptionList may contain the following options:\n   \n   instrument_style  (default:clause)\n   \n   Valid values for this option are clause, block, \n   subgoal and call. These values correspond to the\n   instrument insertion points of instrument library. Each provides a\n   different level of granularity for the profiling of code fragments.\n   \n   delta_results (default:off)\n   \n   Specifying this option as on indicates that the instrumentation\n   results for execution of individual profiled code fragments (associated by\n   instrument's callsite identifier) should be written to the file specified \n   using open_delta_file/1. More specifically, these are the delta results,\n   the difference for each of the statistics between the start and end of the\n   profiled code fragment's execution.\n   \n   Instrument library options\n   \n   In addition to the above options, options valid to the instrument\n   library can also be passed in OptionsList. The most useful of which are \n   verbose and instrument_recursive. \n   instrument_recursive is used to prevent the incorrect aggregation\n   of results accumulated during the execution of recursive predicates, by\n   default it is off, i.e. recursive predicates will not be instrumented.\n   \n   \n   The instrumentation profiler places an overhead on the execution of the \n   code undergoing profiling due to the insertion of the profiling code.\n   The sample based profiler is implemented using after events and is\n   therefore less intrusive in its effect on the performance of the \n   executing code than the instrumentation profiler. However, it is used to\n   indicate the trend of resource usage over time of a running program not to\n   attribute specific costs of a statistic to a specific piece of code. The\n   instrumentation based profiler is used to do this.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Statistics is empty or contains an invalid statistic/2 keyword.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- File is not an atom or string.\n\nExamples\n   \n   [eclipse 1]: instprofile:statprofile(queen,[global_stack_used, trail_stack_used], \n    [instrument_style:block, delta_results:on]).\n\n   Yes (0.06s cpu)\n   \n\nSee Also\n   open_delta_file / 1, close_delta_file / 0, result / 0, aggregate_result / 1, reset / 0, statprofile / 2, statistics / 2, library(instprofile), library(instrument), instrument : instrument / 3"},"instprofile:statsample/4":{"prefix":"statsample","body":"statsample(${1:ProfileName}, ${2:SamplePeriod}, ${3:Statistics}, ${4:File})$5\n$0","description":"statsample(+ProfileName, +SamplePeriod, +Statistics, +File)\n\n   Create a statistics sampling profile.\n\nArguments\n   ProfileName    Atom or string\n   SamplePeriod    Number\n   Statistics    List of statistic keywords\n   File    Atom or string\n\nType\n   library(instprofile)\n\nDescription\n    \n   The predicate defines a profile, ProfileName, for use by the sampling\n   profiler. Samples of the statistics (statistics/2 metric keywords)\n   specified in Statistics are collected every SamplePeriod seconds and \n   stored in File. The format of file is such that it can easily be\n   analysed or graphed offline.\n   \n   The sample based profiler is implemented using after events and is\n   therefore less intrusive in its effect on the performance of the \n   executing code than the instrumentation profiler. However, it is used to\n   indicate the trend of resource usage over time of a running program not to\n   attribute specific costs of a statistic to a specific piece of code. The\n   instrumentation based profiler is used to do this.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Statistics is empty or contains an invalid statistic/2 keyword.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- File is not an atom or string\n\nExamples\n   \n   [eclipse 1]: instprofile:statsample(memory, 5, [global_stack_used,\n    trail_stack_used], 'memory_sample.dat').\n   string     compiled traceable 476 bytes in 0.00 seconds\n\n   Yes (0.01s cpu)\n   \n\nSee Also\n   statsample_control / 2, statistics / 2, library(instprofile)"},"instrument:erase_all_templates/0":{"prefix":"erase_all_templates","body":"erase_all_templates","description":"erase_all_templates\n\n   Erase all instrument template stores.\n\nArguments\n\nType\n   library(instrument)\n\nDescription\n\n   This predicate erases all itemplate that are persisted in \n   the global and file local template stores between successive calls \n   to instrument/2 and instrument/3.\n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nSee Also\n   erase_module_templates / 0, erase_file_templates / 1, instrument / 2, instrument / 3, library(instrument), struct(itemplate), defined_modules / 2"},"instprofile:statsample_control/2":{"prefix":"statsample_control","body":"statsample_control(${1:ProfileName}, ${2:State})$3\n$0","description":"statsample_control(+ProfileName, +State)\n\n   Enable / disable the sampling profiler for a named profile.\n\nArguments\n   ProfileName    Atom or string\n   State    Atoms 'on' or 'off'\n\nType\n   library(instprofile)\n\nDescription\n    \n   For the named profile, ProfileName, enable or disable the sampling\n   profiler based on the value of State. Setting State to 'on' immediately\n   enables sample collection at the inteval and to to the file specified in\n   statsample/4.\n   \n   For performance reasons, the results are written to File (specified by\n   statsample/4) using buffered I/O - each result is not flushed to disk as\n   it is written. As a result to ensure all results are flushed to the file,\n   statsample_control(ProfileName, off) must be executed before\n   the results file can be analysed.\n   \n\nFail Conditions\n   Profilename is not a valid profile defined by statsample/4.State is neither the atom 'on' nor the atom 'off'.\n\nResatisfiable\n   no\n\nExamples\n   \n   [eclipse 2]: instprofile:statsample_control(memory, on).\n\n   Yes (0.00s cpu)\n   [eclipse 3]: ...\n\n   Yes (10.24s cpu)\n   [eclipse 4]: instprofile:statsample_control(memory, off).\n\n   Yes (0.00s cpu)\n    \n\nSee Also\n   statsample / 4, statistics / 2, library(instprofile)"},"instrument:erase_module_templates/0":{"prefix":"erase_module_templates","body":"erase_module_templates","description":"erase_module_templates\n\n   Erase all instrument template stores for a specific module.\n\nArguments\n\nType\n   library(instrument)\n\nDescription\n\n   This predicate erases all templates of the calling module context, \n   that are persisted in the global and file local template stores \n   between successive calls to instrument/2 and instrument/3. \n   The predicate is a tool and the templates of a module other than the \n   current calling module context can be erased by invoking \n   erase_module_templates@Module. To erase templates \n   applicable to all modules, the atom every_module may be \n   specified.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   No instrumentation templates exist for the calling module.\n\nResatisfiable\n   no\n\nSee Also\n   erase_all_templates / 0, erase_file_templates / 1, instrument / 2, instrument / 3, library(instrument), struct(itemplate), defined_modules / 2"},"instrument:defined_modules/2":{"prefix":"defined_modules","body":"defined_modules(${1:File}, ${2:Modules})$3\n$0","description":"defined_modules(+File, -Modules)\n\n   Retrieve the modules defined by a file.\n\nArguments\n   File    Atom or string\n   Modules    List of atoms\n\nType\n   library(instrument)\n\nDescription\n\n   It is often necessary to know what modules a file has defined in order \n   to operate on module specific data.  This predicate can be used to return \n   the modules defined by a file which has been compiled with the instrument \n   compiler.\n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nSee Also\n   get_callsite_data / 2, file_callsites / 3, instrument / 2, instrument / 3, library(instrument), set_callsite_data / 2, struct(itemplate), defined_modules / 2"},"instrument:erase_file_templates/1":{"prefix":"erase_file_templates","body":"erase_file_templates(${1:File})$2\n$0","description":"erase_file_templates(+File)\n\n   Erase the file local instrument template store for a\n   specific file.\n\nArguments\n   File    Atom or string\n\nType\n   library(instrument)\n\nDescription\n\n   This predicate erases all templates associated with the named file \n   that was compiled into the the calling module context and persisted \n   by (successive) calls to instrument/2 and instrument/3. \n   The predicate is a tool and the file local templates of a module other \n   than the current calling module context can be erased by invoking \n   erase_file_templates(File)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   No instrumentation templates exist for the file in \n   the calling module context.\n\nResatisfiable\n   no\n\nSee Also\n   erase_all_templates / 0, erase_module_templates / 0, instrument / 2, instrument / 3, library(instrument), struct(itemplate), defined_modules / 2"},"instrument:file_result/1":{"prefix":"file_result","body":"file_result(${1:File})$2\n$0","description":"file_result(+File)\n\n   Pretty-print a file, including any instrumentation results\n\nArguments\n   File    Atom or string\n\nType\n   library(instrument)\n\nDescription\n\n   This will pretty-print the specified source file in the calling \n   module context, annotated with the result of instrumentation. \n   The resulting .html file is placed in a sub-directory called \n   instrument', relative to File.\n   \n   See file_result/2 for options to modify the output.\n   \n   The use of this predicate is only meaningful if the module has \n   previously been instrumented and compiled \n   using instrument:instrument/1,2, and the code has been \n   run in order to obtain instrumentation results.\n   \n   See struct(itemplate) for documentation of how the \n   result instrumentation is used in the annotation and pretty-printing \n   of the code.\n   \n   The predicate is a tool and the instrumentation results of a \n   file in an alternate module to the current calling module context \n   can be obtained invoking file_result(File)@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   instrument / 2, instrument / 3, file_result / 2, library(instrument), library(pretty_printer), module_result / 0, module_result / 1, struct(itemplate), defined_modules / 2"},"instrument:file_callsites/3":{"prefix":"file_callsites","body":"file_callsites(${1:File}, ${2:StartId}, ${3:EndId})$4\n$0","description":"file_callsites(+File, ?StartId, ?EndId)\n\n   Retrieve start and end callsite identifiers for named file.\n\nArguments\n   File    Atom or string\n   StartId    Intger\n   EndId    Integer\n\nType\n   library(instrument)\n\nDescription\n\n   Each code instrumentation point within a file is \n   uniquely identified by its callsite identifier.\n   The callsite identifier is a monotonically increasing \n   integer incrementing from the initial value of 0 for a \n   new module. \n   \n   As additional files are instrumented and \n   compiled into a module, the start identifier is \n   incremented from the end identifier of the previous file. \n   The predicate retrieves the start and end callsite \n   identifiers for the file.\n   \n   The predicate is a tool and the callsite identifiers \n   of a file instrumented in a module other than the current \n   calling module context can be retrieved by invoking \n   file_callsites(File, StartId, EndId)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   StartId or EndId are not the file's starting and \n    ending callsite identifiers.\n\nResatisfiable\n   no\n\nSee Also\n   get_callsite_data / 2, instrument / 2, instrument / 3, library(instrument), module_callsites / 2, set_callsite_data / 2, struct(itemplate), defined_modules / 2"},"instrument:get_callsite_data/2":{"prefix":"get_callsite_data","body":"get_callsite_data(${1:SiteId}, ${2:UserData})$3\n$0","description":"get_callsite_data(+SiteId, ?UserData)\n\n   Retrieve data associated with an instrumentation callsite \n   from its non-logical store.\n\nArguments\n   SiteId    Integer\n   UserData    Valid Prolog term\n\nType\n   library(instrument)\n\nDescription\n\n   Each code instrumentation point within a file is uniquely identified \n   by its callsite identifier. The callsite identifier is a monotonically \n   increasing integer incrementing from the initial value of 0 for a new \n   module. \n   \n   The predicate retrieves the data (a valid Prolog term) that has been \n   associated with the specified instrumentation callsite within a module \n   or file.\n   \n   The data is stored in a non-logical store and can be stored using \n   instrument:set_callsite_data/2.\n   \n   The predicate is a tool and data for a callsite of a module other than \n   the current calling module context can be retrieved by invoking \n   get_callsite_data(SiteId, UserData)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Data has not been stored for callsite identifier SiteId.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- SiteId is not instantiated.\n     5 --- SiteId is not an integer.\n\nSee Also\n   file_callsites / 3, instrument / 2, instrument / 3, library(instrument), module_callsites / 2, set_callsite_data / 2, struct(itemplate), defined_modules / 2"},"instrument:file_result/2":{"prefix":"file_result","body":"file_result(${1:File}, ${2:OptionList})$3\n$0","description":"file_result(+File, +OptionList)\n\n   Pretty-print a file, including any instrumentation results\n\nArguments\n   File    Atom or string\n   OptionList    List of options\n\nType\n   library(instrument)\n\nDescription\n\n   This will pretty-print the specified source file in the calling \n   module context, annotated with the result of instrumentation. \n   The resulting .html file is placed in a sub-directory called \n   instrument', relative to File.\n   \n   The use of this predicate is only meaningful if the module has \n   previously been instrumented and compiled \n   using instrument:instrument/1,2, and the code has been \n   run in order to obtain instrumentation results.\n   \n   OptionList is a list of options identical to the one accepted by \n   pretty_print/2 in the library(pretty_printer), and can be \n   used to modify the output style and the location of the output file.\n   \n   Additionally, OptionList may contain the following options:\n   \n   ignore_module_templates (default:off)\n   \n   Specifying this option as on results in the \n   use of file local templates only during instrumentation. \n   Templates are not sought from the global store.\n   \n   This option should only be specified if it was also specified \n   during instrumentation (i.e. when using \n   instrument:instrument/3).\n   \n   macro_expansion (default:off)\n   \n   This option affects only the printing of the result (html) file. \n   By default, read-macros are not expanded in this output. \n   In rare cases, where macro expansion would affect the placement of \n   instrumentation positions, it may be necessary to set \n   this option to on in order to display the instrumentation \n   at the correct positions in the code.\n   \n   verbose (default:off)\n   \n   If set to on, the instrument preprocessor \n   will print predicate names as they are processed (to \n   log_output). \n   If set to debug, the instrument preprocessor \n   prints each instrumented and/or woven predicate definition (to \n   log_output).\n   \n   See struct(itemplate) for documentation of how the \n   result instrumentation is used in the annotation and pretty-printing \n   of the code.\n   \n   The predicate is a tool and the instrumentation results of a \n   file in an alternate module to the current calling module context \n   can be obtained invoking module_result(File, OptionList)@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   instrument / 2, instrument / 3, file_result / 1, library(instrument), library(pretty_printer), module_result / 0, module_result / 1, struct(itemplate), defined_modules / 2"},"instrument:instrument/2":{"prefix":"instrument","body":"instrument(${1:File}, ${2:ITemplates})$3\n$0","description":"instrument(+File, +ITemplates)\n\n   Compile a file, inserting predicate instrumentation\n\nArguments\n   File    Atom or string\n   ITemplates    itemplate, List of itemplate or PredSpec\n\nType\n   library(instrument)\n\nDescription\n\n   This is a variant of the ECLiPSe compiler that inserts user specified \n   instrumentation predicates into the compiled code. This code can then \n   be run, and the results analysed by printing them using \n   instrument:module_result/0 or instrument:file_result/1.\n   \n   ITemplates can be specified as:\n   \n   PredSpec of arity two\n   \n   If an arity two predicate specification is supplied, then this predicate \n   is invoked in order to retrieve the template for the predicate being \n   instrumented. Argument one is the predicate specification of the \n   predicate undergoing instrumentation. Argument two is an output variable\n   that is to be returned by this predicate as the template to use. The \n   returned itemplate will be validated before instrumentation \n   proceeds.\n   \n   itemplate\n   \n   A single template passed to instrument/2 or instrument/3 \n   is adopted as the global template to be used for predicate \n   instrumentation. If a template for the predicate currently being \n   instrumented is not found in the template stores then if a global template \n   exists, it is used.\n   \n   PredSpec = itemplate\n   \n   A template specification for instrumentation of a single predicate. If \n   however, PredSpec is not actually a valid predicate specification but \n   the atom iglobal, the template is adopted as the global template \n   (see above).\n   \n   List of itemplate\n   \n   The list is of the form: \n   [itemplate{...} | PredSpec = itemplate{...} ... \n   PredSpec = itemplate{...}]\n   The itemplate at the head of the list is specifies the global \n   template and is optional. The remaining elements of the list are \n   itemplate specifying instrumentation for the PredSpec with which \n   they are associated.\n   \n   In addition to supplying the global template, an exclude list of \n   PredSpec for predicates that should not be instrumented by the global \n   template can be specified:\n   itemplate{...} - \n   predicate/1, my_module:my_predicate/8,...]\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ITemplates is not instantiated.\n     5 --- ITemplates is not of the appropriate type.\n\nSee Also\n   erase_all_templates / 0, file_result / 1, file_result / 2, file_callsites / 3, get_callsite_data / 2, instrument / 3, instrument_control / 2, library(instrument), module_callsites / 2, module_result / 0, module_result / 1, set_callsite_data / 2, defined_modules / 2"},"instrument:instrument/3":{"prefix":"instrument","body":"instrument(${1:File}, ${2:ITemplates}, ${3:OptionList})$4\n$0","description":"instrument(+File, +ITemplates, +OptionList)\n\n   Compile a file, inserting predicate instrumentation\n\nArguments\n   File    Atom or string\n   ITemplates    itemplate, List of itemplate or PredSpec\n   OptionList    List of Name:Value pairs\n\nType\n   library(instrument)\n\nDescription\n\n   This is a variant of the ECLiPSe compiler that inserts user specified \n   instrumentation predicates into the compiled code. \n   This code can then be run, and the results analysed by printing them using \n   instrument:module_result/0 or instrument:file_result/1.\n   \n   ITemplates can be specified as:\n   \n   PredSpec of arity two\n   \n   If an arity two predicate specification is supplied, then this predicate \n   is invoked in order to retrieve the template for the predicate being \n   instrumented. Argument one is the predicate specification of the \n   predicate undergoing instrumentation. Argument two is an output variable th\n   at is to be returned by this predicate as the template to use. The \n   returned itemplate will be validated before instrumentation \n   proceeds.\n   \n   itemplate\n   \n   A single template passed to instrument/2 or instrument/3 \n   is adopted as the global template to be used for predicate \n   instrumentation. If a template for the predicate currently being \n   instrumented is not found in the template stores then if a global template \n   exists, it is used.\n   \n   PredSpec = itemplate\n   \n   A template specification for instrumentation of a single predicate. If \n   however, PredSpec is not actually a valid predicate specification but the \n   atom iglobal, the template is adopted as the global template \n   (see above).\n   \n   List of itemplate\n   \n   The list is of the form: \n   [itemplate{...} | PredSpec = itemplate{...} ... \n   PredSpec = itemplate{...}]\n   The itemplate at the head of the list is specifies the global \n   template and is optional. The remaining elements of the list are \n   itemplate specifying instrumentation for the PredSpec with which \n   they are associated.\n   \n   In addition to supplying the global template, an exclude list of PredSpec \n   for predicates that should not be instrumented by the global template can \n   be specified: itemplate{...} - predicate/1, \n   my_module:my_predicate/8,...]\n   \n   OptionList may contain the following options:\n   \n   erase_templates\n   \n   Specifying this option results in the removal of instrumentation templates \n   in file local and/or global template stores. The 'Value' portion of the \n   option can be specified as an atom representing a specific module, the \n   atom all or the atom every_module.\n   \n   instrument_recursive (default:off)\n   \n   Specifying this option as on indicates that instrumentation \n   should be applied within recursive predicates. With it off the \n   net effect is that instrumentation is placed around the recursive \n   call-graph (unless no applicable template exists). This prevents \n   incorrect aggregation of accounting by instrumentation predicates. \n   \n   file_local_templates (default:off)\n   \n   Specifying this option as on indicates that all templates in \n   ITemplates should be stored locally to the file - they are not available \n   for use in instrumenting other files (in other modules). The \n   file_local option of the itemplate in ITemplates are \n   overridden by this option.\n   \n   ignore_module_templates (default:off)\n   \n   Specifying this option as on results in the use of file local \n   templates only during instrumentation. Templates are not sought from \n   the global store.\n   \n   verbose (default:off)\n   \n   If set to on, the instrument preprocessor will print predicate \n   names as they are processed (to log_output). If set to debug, \n   the instrument preprocessor prints each instrumented and/or woven \n   predicate definition (to log_output).\n   \n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- ITemplates is not instantiated.\n     5 --- ITemplates is not of the appropriate type.\n\nSee Also\n   erase_all_templates / 0, file_result / 1, file_result / 2, file_callsites / 3, get_callsite_data / 2, instrument / 3, instrument_control / 2, library(instrument), module_callsites / 2, module_result / 0, module_result / 1, set_callsite_data / 2, defined_modules / 2"},"instrument:instrument_control/2":{"prefix":"instrument_control","body":"instrument_control(${1:Mode}, ${2:InstrumentPredSpec})$3\n$0","description":"instrument_control(+Mode, +InstrumentPredSpec)\n\n   Insert or remove instrumentation predicates dynamically \n   at runtime.\n\nArguments\n   Mode    Atom\n   InstrumentPredSpec  PredSpec\n\nType\n   library(instrument)\n\nDescription\n\n   If the asserted option of an itemplate \n   is set to one of on, off or \n   post_compile then the template's instrumentation \n   predicates may be inserted and removed dynamically at runtime.\n   \n   When Mode is on the instrumentation predicate \n   represented is PredSpec is inserted into the code at the \n   positions specified during instrumentation. This is done \n   efficiently with negligible runtime overhead. When Mode is \n   off the instrumentation predicate is removed from \n   the instrumented code.\n   \n   If PredSpec is module qualified, the instrumentation predicate \n   defined in the context of the module is inserted / removed. If \n   unqualified the predicate is assumed to be defined in the context \n   of the calling module scope.\n   \n   The predicate is a tool and an unqualified instrumentation \n   predicate defined in a module other than the current \n   calling module context can be inserted / removed by invoking \n   instrument_control(Mode, InstrumentPredSpec)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   InstrumentPredSpec is not a predicate specification.\n\nResatisfiable\n   no\n\nExceptions\n    68 --- PredSpec is an undefined procedure.\n\nSee Also\n   instrument / 2, instrument / 3, library(instrument), struct(itemplate)"},"instrument:instrument_desc":{"prefix":"lib","body":"lib(${1:instrument})$2\n$0","description":"lib(instrument)\n\n   The instrument library is a tool that enables predicate definitions or all\n   calls to a specific predicate to be annotated with user-defined predicates.\n   These instrumentation predicates are free to perform such actions as collect\n   program statistics or write debugging data to a stream during program\n   execution.  Additionally, the instrumentation can be inserted and removed\n   dynamically as the program executes.\n\nThe usage is as follows:\n   \n   Load the instrument library\n   \n   ?- lib(instrument).\n   \n   Compile your program with the instrument compiler\n   \n   ?- instrument:instrument(my_program, Templates).\n   \n   Run the query for which you wish to generate instrumentation data\n   \n   ?- my_query(X,Y,Z).\n   \n   Generate an html file containing the results. E.g. the following\n   will create the result file instrument/my_program.html:\n   \n   ?- instrument:results(my_program).\n   \n   View the result file using any browser. The result file\n   contains a pretty-printed form of the source, annotated with\n   the instrumentation results.\n   \n   \n   The following is an example of very basic use of the tool.\n   Consider instrumenting a simple path finding program saved in a\n   file called 'instrument_example.ecl.\n   \n   list_member(X, [X | _Tail]).\n   list_member(X, [_ | Tail]):-\n   list_member(X, Tail).\n \n   all_edges(Graph, Source, Outgoing):-\n       findall((Source-Next),list_member((Source-Next), Graph), Outgoing).\n \n   path(_Graph, Source, Source, []).\n   path(Graph, Source, Sink, [(Source-Next) | Path]):-\n       all_edges(Graph, Source, Outgoing),\n       list_member((Source-Next), Outgoing),\n       path(Graph, Next, Sink, Path).\n \n   test(Path):-\n       path([1-2, 1-3, 2-4, 3-4, 4-5, 4-6, 5-7, 5-8, 6-7,\n    1-8, 8-9, 8-10, 9-10, 9-11, 10-11],\n    1,\n    7,\n    Path).\n   \n   The simplest way to instrument your code is to insert predicates around\n   every call in the source. The following code demonstrates how to\n   print the CPU time before and after every predicate call:\n   \n   get_time(Cpu):-\n       statistics(times, [Cpu, _Sys, _Real]).\n \n   time_point:-\n       get_time(T),\n       writeln(error, T).\n \n   go:-\n       File = instrument_example,\n       GlobalTemplate = itemplate{subgoal_start:time_point/0,\n    subgoal_end:time_point/0},\n       instrument(File, GlobalTemplate),\n       test(Path).\n   \n   Note the same predicate time_point/0 is specified before and\n   after goal calls. If we wished to instrument all calls except those\n   to list_member/2, the following call to instrument/2 is\n   made:\n   \n    instrument(File, GlobalTemplate - [list_member/2])\n   \n   In general any number of goals may be specified in this 'exclusion list'.\n    \n   The following code demonstrates alternative instrumentation\n   for this excluded predicate:\n   \n   :-lib(instrument).\n\n   :-export time_point/0, special_point/0.\n\n   get_time(Cpu):-\n       statistics(times,[Cpu, _Sys, _Real]).    \n\n   time_point:-\n       get_time(T),\n       writeln(error, T).\n\n   special_point:-\n       writeln(error, 'start, end, redo or fail').\n\n   go:-\n       File = instrument_example,\n       GlobalTemplate = itemplate{subgoal_start:time_point/0,\n    subgoal_end:time_point/0},\n       SpecialTemplate = itemplate{call_start:special_point/0,\n    call_end:special_point/0,\n    call_fail:special_point/0\n    call_redo:special_point/0},\n       instrument(File,[GlobalTemplate - [list_member/2],\n    (list_member/2) = SpecialTemplate]),\n       test(Path).\n   \n   Notice how the special_point/0 predicate is assigned to the\n   call_start, call_end, call_fail and \n   call_redo points in this example. This ensures that the \n   special_point predicate is called if list_member/2 \n   fails, or if resatisfiable, executed at the redo.\n   \n   Using arity-1 predicates (i.e. one argument predicates)\n   unique identification of the callsite can be obtained:\n   \n   :-lib(instrument).\n\n   get_time(Cpu):-\n       statistics(times, [Cpu, _Sys, _Real]).    \n\n   time_point(CallSite):-\n       get_time(T),\n       writeln(error,['Time', T, 'at callsite', CallSite]).\n\n   go:-\n       File = instrument_example,\n       GlobalTemplate = itemplate{subgoal_start:time_point/1,\n    subgoal_end:time_point/1},\n       instrument(File, GlobalTemplate),\n       test(Path).\n   \n   \n   By supplying a predicate to the result field of a template \n   one can specify terms to be printed within a copy of the source code.\n   Using this feature along with the utility predicates \n   get_callsite_data/2 and set_callsite_data/2 \n   one can create quite varied and useful output.\n   \n   :-lib(instrument).\n\n   get_time(Cpu):-\n       statistics(times, [Cpu, _Sys, _Real]).    \n\n   time_point(CallSite):-\n       get_time(T),\n       set_callsite_data(CallSite, T).\n\n   result(CallSite, _Type, _Module, Goal, NewGoal):-\n       get_callsite_data(CallSite, Time),\n       NewGoal='instrument:point_before'(Time, Goal).\n   go:-\n       File = instrument_example,\n       GlobalTemplate = itemplate{subgoal_start:time_point/1,\n    result:result/5},\n       instrument(File, GlobalTemplate),\n       test(Path),\n       file_result(File).\n   \n   No data is printed during the running of the test(Path) call, \n   but the file_result(File) call causes the source code to be \n   emitted (color coded) with the given callsite data embedded."},"instrument:module_result/0":{"prefix":"module_result","body":"module_result","description":"module_result\n\n   Pretty-print all files in a module, including any \n    instrumentation results\n\nArguments\n\nType\n   library(instrument)\n\nDescription\n\n   This will pretty-print all source files in the calling module context, \n   annotated with the result of instrumentation.  The resulting .html \n   files are placed in a sub-directory called instrument', relative to \n   the files that were compiled into the file.\n   \n   See module_result/1 for options to modify the output.\n   \n   The use of this predicate is only meaningful if the module has \n   previously been instrumented and compiled \n   using instrument:instrument/1,2, and the code has been \n   run in order to obtain instrumentation results.\n   \n   See struct(itemplate) for documentation of how the \n   result instrumentation is used in the annotation and pretty-printing \n   of the code.\n   \n   The predicate is a tool and the instrumentation results of a \n   module other than the current calling module context can be obtained \n   by invoking module_result@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   instrument / 2, instrument / 3, file_result / 1, file_result / 2, library(instrument), library(pretty_printer), module_result / 1, struct(itemplate), defined_modules / 2"},"instrument:module_callsites/2":{"prefix":"module_callsites","body":"module_callsites(${1:StartId}, ${2:EndId})$3\n$0","description":"module_callsites(?StartId, ?EndId)\n\n   Retrieve module start and end callsite identifiers.\n\nArguments\n   StartId    Intger\n   EndId    Integer\n\nType\n   library(instrument)\n\nDescription\n\n   Each code instrumentation point within a module is \n   uniquely identified by its callsite identifier.\n   The callsite identifier is a monotonically increasing \n   integer incrementing from the initial value of 0.\n   The predicate retrieves the start and end callsite \n   identifiers.\n   \n   The predicate is a tool and the callsite identifiers \n   of a module other than the current calling module \n   context can be retrieved by invoking \n   module_callsites(StartId, EndId)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   StartId or EndId are not the module's starting and \n   ending callsite identifiers.\n\nResatisfiable\n   no\n\nSee Also\n   get_callsite_data / 2, file_callsites / 3, instrument / 2, instrument / 3, library(instrument), set_callsite_data / 2, struct(itemplate), defined_modules / 2"},"instrument:itemplate/s":{"prefix":"struct","body":"struct","description":"struct itemplate(clause_start, clause_end, clause_fail, clause_redo, block_start, block_end, block_fail, block_redo, subgoal_start, subgoal_end, subgoal_fail, subgoal_redo, call_start, call_end, call_fail, call_redo, fact, inbetween, result, meta_args, exclude, code_weaver, asserted, module_scope, file_local, goal_expansion)\n\n    The template used to guide predicate instrumentation\n\nFields\n   clause_start    PredSpec of maximum arity two, the atom 'inherit', or variable\n   clause_end    PredSpec of maximum arity two, the atom 'inherit', or variable\n   clause_fail    PredSpec of maximum arity two, the atom 'inherit', or variable\n   clause_redo    PredSpec of maximum arity two, the atom 'inherit', or variable\n   block_start    PredSpec of maximum arity two, the atom 'inherit', or variable\n   block_end    PredSpec of maximum arity two, the atom 'inherit', or variable\n   block_fail    PredSpec of maximum arity two, the atom 'inherit', or variable\n   block_redo    PredSpec of maximum arity two, the atom 'inherit', or variable\n   subgoal_start       PredSpec of maximum arity two, the atom 'inherit', or variable\n   subgoal_end    PredSpec of maximum arity two, the atom 'inherit', or variable\n   subgoal_fail    PredSpec of maximum arity two, the atom 'inherit', or variable\n   subgoal_redo    PredSpec of maximum arity two, the atom 'inherit', or variable\n   call_start    PredSpec of maximum arity two, the atom 'inherit', or variable\n   call_end    PredSpec of maximum arity two, the atom 'inherit', or variable\n   call_fail    PredSpec of maximum arity two, the atom 'inherit', or variable\n   call_redo    PredSpec of maximum arity two, the atom 'inherit', or variable\n   fact    PredSpec of maximum arity one, the atom 'inherit', or variable\n   inbetween    PredSpec of maximum arity two, the atom 'inherit', or variable\n   result    PredSpec of maximum arity five, the atom 'inherit', or variable\n   meta_args    List of itemplate or variable\n   exclude    List of PredSpec, the atom 'inherit', or variable\n   code_weaver    PredSpec of maximum arity six, the atom 'inherit', or variable\n   asserted    Specific atom, the atom 'inherit' or variable\n   module_scope    Atomic module name, the atom 'inherit' or variable\n   file_local    Specific atom, the atom 'inherit' or variable\n   goal_expansion      Specific atom, the atom 'inherit' or variable\n\nType\n   library(instrument)\n\nDescription\n\n   The itemplate structure serves as a specification that \n   determines how predicate definitions and calls to predicates are instrumented.\n   \n   An itemplate is associated with a predicate whose definition or \n   invocations are to be instrumented. This association is specified as an \n   argument to instrument:instrument/2 or instrument:instrument/3 \n   and is of the form: PredSpec = itemplate{...}.\n   \n   PredSpec is of the form Module:Functor/Arity. \n   If the module qualifier is omitted, then PredSpec is assumed to \n   be a predicate defined within the calling module context in which \n   instrument/2 was invoked. The definition context for a module \n   can be wildcarded by specifying the module qualifier as the atom \n   every_module or by setting the itemplate module_scope \n   field to every_module.\n   \n   This has two effects:\n   \n    When instrumenting predicate definitions a template can be applied \n    to a predicate regardless of the module it is defined in.\n    When instrumenting predicate calls a template can be applied to a \n    predicate regardless of whether it is module qualified or not.\n   \n   However, as a general rule of thumb, predicate specifications for \n   PredSpec and instrumentation predicates within the templates \n   should be correctly module qualified. \n   \n   When determining whether a predicate is to be instrumented, a template is \n   sought which matches the module qualified PredSpec, first using \n   the named module (or current module if unqualified) and then using \n   every_module as the module qualifier.\n   \n   Within the template, predicate specifications supplied to its fields \n   determine how predicate instrumentation and invocation proceeds. \n   The template specifies the following instrumentation points:\n   \n   clause_start\n   \n   A call to the specified predicate is placed at the beginning of each \n   clause definition of the predicate the template is being applied to.\n   \n   clause_end\n   \n   A call to the specified predicate is placed at the end of each clause \n   definition of the predicate the template is being applied to.\n   \n   clause_fail\n   \n   A call to the specified predicate is placed such that failure within \n   the clause definition of the predicate the template is being applied \n   to results in its invocation.\n   \n   clause_redo\n   \n   A call to the specified predicate is placed such that failure and \n   re-execution (i.e. resatisfiable execution) within the clause \n   definition of the predicate the template is being applied to results \n   in its invocation.\n   \n   block_start\n   \n   A call to the specified predicate is placed at the beginning of each \n   conjunction (comma-sequences of subgoals) within the definition of \n   the predicate the template is being applied to.\n   \n   block_end\n   \n   A call to the specified predicate is placed at the end of each \n   conjunction within the definition of the predicate the template is \n   being applied to.\n   \n   block_fail\n   \n   A call to the specified predicate is placed such that failure of each \n   conjunction within the definition of the predicate the template is being \n   applied to results in its invocation.\n   \n   block_redo\n   \n   A call to the specified predicate is placed such that failure and \n   re-execution (i.e. resatisfiable execution) of each conjunction within \n   the definition of the predicate the template is being applied to results \n   in its invocation.\n   \n   subgoal_start\n   \n   A call to the specified predicate is placed at the beginning of each \n   subgoal within the definition of the predicate the template is being \n   applied to.\n   \n   subgoal_end\n   \n   A call to the specified predicate is placed at the end of each subgoal \n   within the definition of the predicate the template is being applied to.\n   \n   subgoal_fail\n   \n   A call to the specified predicate is placed such that failure of each \n   subgoal within the definition of the predicate the template is being \n   applied to results in its invocation.\n   \n   subgoal_redo\n   \n   A call to the specified predicate is placed such that failure and \n   re-execution (i.e. resatisfiable execution) of each subgoal within \n   the definition of the predicate the template is being applied to results \n   in its invocation.\n   \n   call_start\n   \n   A call to the specified predicate is placed at the beginning of each \n   call invocation of the predicate the template is being applied to.\n   \n   call_end\n   \n   A call to the specified predicate is placed at the end of each call \n   invocation of the predicate the template is being applied to.\n   \n   call_fail\n   \n   A call to the specified predicate is placed such that failure of a call \n   invocation of the predicate the template is being applied to results in \n   its invocation.\n   \n   call_redo\n   \n   A call to the specified predicate is placed such that failure and \n   re-execution (i.e. resatisfiable execution) of a call invocation of the \n   predicate the template is being applied to results in its invocation.\n   \n   fact\n   \n   A call to the specified predicate is placed as the clause body of the \n   fact predicate the template is being applied to. A fact is a predicate \n   definition with no defined clause body.\n   \n   inbetween\n   \n   A call to the specified predicate is placed at the end of each subgoal \n   of a conjunction within the definition of the predicate the template is \n   being applied to.\n   \n   \n   The default value for the instrumentation predicates is that none are \n   defined and so no instrumentation is performed. This is equivalent to \n   setting the field values explicitly to free variables.\n   \n   The instrumentation predicates must be defined with one of the following \n   signatures:\n   \n   Arity 0\n   \n   When an arity zero instrumentation predicate is specified, it is invoked \n   with no arguments passed.\n   \n   Arity 1\n   \n   Each code instrumentation point within a module is uniquely identified \n   by its callsite identifier. The callsite identifier is a monotonically \n   increasing integer incrementing from the initial value of 0. It is the \n   callsite identifier value that is passed to an arity one instrumentation \n   predicate.\n   \n   Arity 2\n   \n   An arity two instrumentation predicate is passed the callsite identifier \n   in argument position one and an auxiliary variable in argument position \n   two. The same auxiliary variable is passed as argument two to the start, \n   end and fail instrumentation points (i.e. it is common to clause_start, \n   clause_end , clause_fail and clause_redo while a \n   different auxiliary variable is common to block_start, \n   block_end, block_fail and block_redo, etc).\n   \n   \n   It is anticipated that the callsite identifier be used for executing \n   callsite specific code or storing data pertinent to the callsite in a \n   non-logical store keyed by callsite identifier - \n   set_callsite_data/2 and get_callsite_data/2 are provided \n   for exactly this purpose.\n   \n   The auxiliary variable passed as argument two to instrumentation \n   predicates is provided for convenience for capturing 'delta' measurements \n   between the start, end and fail instrumentation points. The variable is a \n   logical variable and while the value passed to the end or fail predicate \n   is guaranteed to be the value bound by the start predicate, backtracking \n   past the start predicate results in the unbinding of the variable. If the \n   captured delta should be retained beyond backtracking then it should be \n   placed in the callsite's non-logical store using set_callsite_data/2.\n   \n   The maximum arity of the fact and inbetween point predicates is one - \n   only the callsite identifier is passed, there is no benefit in passing an \n   auxiliary variable.\n   \n   The result instrumentation predicate provides a mechanism for \n   pretty-printing the annotated source code with the instrumentation results \n   gathered during execution. By executing instrument:module_result/0\n   or instrument:file_result/1 the predicate specified for result \n   instrumentation within the template is invoked as each of the \n   instrumentation points are encountered for pretty-printing.\n   \n   The result instrumentation predicate must be defined with one of the \n   following signatures:\n    \n   Arity 0\n   \n   When an arity zero predicate is specified, it is invoked with no \n   arguments passed.\n   \n   Arity 1\n   \n   The callsite identifier representing the instrumentation point is \n   passed to an arity one result predicate.\n   \n   Arity 2\n   \n   The instrumentation point type is passed as argument two of an arity \n   two result predicate. The point type is the atom associated with the \n   point, for example call_start, call_end, call_fail or call_redo, \n   etc. \n   \n   Arity 3\n   \n   The module into which the file being pretty-printed was instrumented \n   and compiled is passed as argument three of an arity three result predicate.\n   \n   Arity 4\n   \n   The goal appearing in the source code around which instrumentation was \n   originally placed is passed as argument four of an arity four result \n   predicate.\n   \n   Arity 5\n   \n   The fifth argument of an arity five result predicate is a result goal \n   that can be returned to the pretty-printer to be placed in the \n   pretty-printed output in the place of the fourth argument goal. This \n   allows the goal to be annotated with commentary or instrumentation results.\n   \n   \n   The meta_args field of the itemplate structure is \n   applicable only to templates associated with predicates that are \n   meta-predicates. When applicable, meta_args is a list of \n   itemplate. Each element in the list is a template for the \n   corresponding argument of the meta-predicate. The template defined \n   instrumentation points are applied to the code found inside the \n   meta-predicate at this argument position. For example: \n   findall/3 = itemplate{..., meta_args:[_, ITemplateArg2, _]...} \n   is an itemplate specification describing the instrumentation \n   of the meta-predicate findall/3. Argument one and three undergo \n   no instrumentation (denoted by free variables) and argument two is \n   instrumented according to ITemplateArg2.\n   \n   Within the meta-predicate argument itemplate fields may be \n   specified as being inherit-ed. When such a field is specified \n   as inherited it is set to the corresponding value of the template used in \n   instrumenting the definition of the predicate in which the call to the \n   meta-predicate resides. \n   \n   The exclude field of the itemplate contains a list of \n   predicate specifications. Any occurrence of such a predicate as a call \n   or subgoal is excluded from application of the instrumentation specified \n   by the enclosing template. The main use of exclusion is in preventing \n   instrumentation application to recursive predicates or built-ins.\n   \n   The code_weaver field of the itemplate specifies a \n   predicate of arity six that is a compile-time callback allowing arbitrary \n   user code to be woven into the code currently undergoing compilation. The \n   weaving of user code is performed before the insertion of instrumentation \n   predicates. The arguments of the predicate are as follows:\n    \n   File\n   \n   The name of the file currently undergoing compilation.\n   \n   Code\n   \n   The block of code available for manipulation by the user specified code \n   weaving predicate.\n   \n   Type\n   \n   The ECLiPSe construct type of the 'Code' block, one of: \n   clause, head, body, fact, variable, conjunction, disjunction, \n   conditional, do, goal. The decomposition of code blocks into these \n   various constructs is for convenience to save the weaver predicate from \n   having to match out the constructs itself. It is however free to do so \n   by operating solely on the clause construct.\n   \n   WeavedCode\n   \n   The block of code that results from the weaving of the Code' block with \n   the arbitrary user code. \n   \n   Mode\n   \n   The mode that code weaving is proceeding in, either compile, \n   during compilation, or print during pretty-printing.\n   \n   Module\n   \n   The module the code is being compiled into.\n   \n   \n   The remaining fields of the itemplate structure specify the \n   options:\n   \n   asserted (default:free variable)\n   \n   The value of asserted may be the atoms: on, off and \n   post_compile or a free variable. When a free variable, the \n   instrumentation predicates are compiled into the code like any other \n   predicates. However, when set to one of the atomic values, the predicates \n   are compiled such that they can be inserted and removed at runtime. This \n   is done efficiently such that there is negligible overhead on execution.\n   \n   The value on specifies that the predicates are initially inserted.\n   The value off that they are removed and  post_compile \n   that they are not inserted until compilation of the whole file has \n   completed. The post_compile option is provided so that \n   instrumentation predicates inserted into predicate definitions that get \n   executed at compile-time do not get executed.\n   \n   During execution, the instrumentation predicates can be inserted and \n   removed using instrument:instrument_control/2. \n   \n   module_scope (default:free variable)\n   \n   The possible values are an atom representing a module name, the atom \n   every_module or a free variable indicating the current module. \n   The value is used to determine the module definition context of \n   unqualified instrumentation predicates or the predicate associated with \n   the template for definition and call instrumentation:\n   \n   Named module\n   \n   The unqualified predicate is qualified with the named module.\n   \n   Free variable\n   \n   The unqualified predicate is qualified with the calling module context \n   in which instrument/2 was first invoked.\n   \n   every_module\n   \n   The unqualified predicate is qualified with the name of the current \n   compilation module.\n   \n   file_local (default:off)\n   \n   Templates persist in a global store between successive calls to \n   instrument/2 and instrument/3. If it is undesirable \n   for a template to be added to the global store (thus making it available \n   for the instrumentation of other files and modules) an itemplate \n   may be declared as being applicable to only the file currently being \n   instrumented by setting this option to on.\n   \n   The search order for an instrumentation template is first in the file \n   local store and then in the global store.\n   \n   goal_expansion (default:on)\n   \n   Setting this to off will suppress goal expansion inlining) \n   during compilation. This may be necessary when the processed code \n   contains predicates that get executed at compile time. \n   \n\nSee Also\n   erase_all_templates / 0, get_callsite_data / 2, instrument / 2, instrument / 3, instrument_control / 2, library(instrument), module_callsites / 2, module_result / 0, set_callsite_data / 2, defined_modules / 2"},"instrument:set_callsite_data/2":{"prefix":"set_callsite_data","body":"set_callsite_data(${1:SiteId}, ${2:UserData})$3\n$0","description":"set_callsite_data(+SiteId, ?UserData)\n\n   Associate arbitrary data with an instrumentation callsite \n   in a non-logical store.\n\nArguments\n   SiteId    Integer\n   UserData    Valid Prolog term\n\nType\n   library(instrument)\n\nDescription\n\n   Each code instrumentation point within a file is \n   uniquely identified by its callsite identifier.\n   The callsite identifier is a monotonically increasing \n   integer incrementing from the initial value of 0 for a \n   new module. \n   \n   The predicate associates arbitrary data (a valid Prolog term) \n   with a specified instrumentation callsite within a module or \n   file.\n   \n   The data is stored in a non-logical store and can be \n   retrieved using instrument:get_callsite_data/2.\n   \n   The predicate is a tool and data for a callsite \n   of a module other than the current calling module context \n   can be stored by invoking \n   set_callsite_data(SiteId, UserData)@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExceptions\n     4 --- SiteId is not instantiated.\n     5 --- SiteId is not an integer.\n\nSee Also\n   file_callsites / 3, get_callsite_data / 2, instrument / 2, instrument / 3, library(instrument), module_callsites / 2, struct(itemplate), defined_modules / 2"},"iso_light:iso_light_desc":{"prefix":"lib","body":"lib(${1:iso_light})$2\n$0","description":"lib(iso_light)\n\nOverview\n    This library is identical to library(iso), except that ISO exception\n    handling is not implemented.  See library(iso)."},"instrument:module_result/1":{"prefix":"module_result","body":"module_result(${1:OptionList})$2\n$0","description":"module_result(+OptionList)\n\n   Pretty-print all files in a module, including any \n   instrumentation results\n\nArguments\n   OptionList    List of options\n\nType\n   library(instrument)\n\nDescription\n\n   This will pretty-print all source files in the calling\n   module context, annotated with the result of instrumentation. \n   The resulting .html files are placed in a sub-directory called \n   instrument', relative to the files that were compiled into the file.\n   \n   OptionList is a list of options identical to the one accepted by \n   pretty_print/2 in the library(pretty_printer), and can be \n   used to modify the output style and the location of the output file.\n   \n   Additionally, OptionList may contain the following options:\n   \n   ignore_module_templates (default:off)\n   \n   Specifying this option as on results in the \n   use of file local templates only during instrumentation. \n   Templates are not sought from the global store.\n   \n   This option should only be specified if it was also specified \n   during instrumentation (i.e. when using \n   instrument:instrument/3).\n   \n   macro_expansion (default:off)\n   \n   This option affects only the printing of the result (html) file. \n   By default, read-macros are not expanded in this output. \n   In rare cases, where macro expansion would affect the placement of \n   instrumentation positions, it may be necessary to set \n   this option to on in order to display the instrumentation \n   at the correct positions in the code.\n   \n   \n   verbose (default:off)\n   \n   If set to on, the instrument preprocessor \n   will print predicate names as they are processed (to \n   log_output). \n   If set to debug, the instrument preprocessor \n   prints each instrumented and/or woven predicate definition (to \n   log_output).\n   \n   \n   The use of this predicate is only meaningful if the module has \n   previously been instrumented and compiled \n   using instrument:instrument/1,2, and the code has been \n   run in order to obtain instrumentation results.\n   \n   See struct(itemplate) for documentation of how the \n   result instrumentation is used in the annotation and pretty-printing \n   of the code.\n   \n   The predicate is a tool and the instrumentation results of a \n   module other than the current calling module context can be obtained \n   by invoking module_result(OptionList)@Module.\n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   instrument / 2, instrument / 3, file_result / 1, file_result / 2, library(instrument), library(pretty_printer), module_result / 0, struct(itemplate), defined_modules / 2"},"iso:iso_desc":{"prefix":"lib","body":"lib(${1:iso})$2\n$0","description":"lib(iso)\n\nOverview\n    This library provides an implementation of Standard Prolog as\n    defined in ISO/IEC 13211-1 (Information Technology, Programming\n    Languages, Prolog, Part 1, General Core, 1995) and the technical\n    corrigenda ISO/IEC 13211-1 TC1 (2007) and TC2 (2012).\n    The library is provided in source form.\n    \n    There are libraries for three degrees of compatibility:\n    \n    iso\n    A blend of ISO and ECLiPSe functionality.  All ISO features\n    are available, plus such ECLiPSe features that do not significantly\n    conflict with ISO. But as some of these extensions go beyond what the\n    letter of the standard allows, and because error checking may be\n    less strict than required by ISO, this is not a fully compliant mode.\n    iso_light\n    The same as 'iso', with the exception of error handling.\n    This is sufficient for code that does not rely on a particular\n    form of error terms being thrown by built-in predicates.\n    iso_strict\n    This aims to be fully ISO compliant, and represents the\n    'strict mode' required by the standard.\n    \n    For more details on ISO compliance, see library(iso_strict).\n    \nUsage\n    The effect of this compatibility library is (with minor exceptions)\n    local to the module where it is loaded.  An ISO-program should always\n    be contained in a separate module, starting with a directive like\n    \n    :- module(myisomodule, [], iso).\n    \n    Here, the last argument of the module/3 directive indicates the language.\n    It is not advisable to use \":-lib(iso)\" or \":-ensure_loaded(library(iso))\"\n    within an eclipse_language module, because this would lead to import\n    conflicts between the different versions of built-in predicates.\n    \n    Alternatively, in order to use ISO-Prolog without having different\n    modules, one can invoke eclipse with a \"-L iso\" command line option,\n    or set the ECLIPSEDEFFAULTLANGUAGE environment variable to 'iso'.\n    This will launch eclipse with a default module accepting 'iso' language\n    instead of the usual 'eclipse_language'.\n    \nDifferences\n    The main differences of this extended iso-language compared to the\n    default eclipse_language are the following:\n    \n    The syntax is more restricted, and ISO style is preferred, e.g.\n    for writing hexadecimal numbers.\n    Double quotes denote character lists, while in ECLiPSe they denote\n    string constants.  ECLiPSe-strings can however be written using\n    back-quotes, e.g. `abc`.\n    Arithmetic functions like floor/1 return integer results.\n    All ISO built-in predicates are available.\n    \nLimitations\n    ISO's idiosyncratic char_conversion features is not implemented."},"java_vc:find_java/1":{"prefix":"find_java","body":"find_java(${1:JavaLocation})$2\n$0","description":"find_java(-JavaLocation)\n\n   Determine the path of the known Java installation.\n\nArguments\n   JavaLocation    A string: the path of the known Java Runtime Environment installation.\n\nType\n   library(java_vc)\n\nDescription\nIf this predicate succeeds, JavaLocation is instantiated to the root directory of the Java Runtime Environment which ECLiPSe will use to run a new Java VC. If the predicate fails, this means that to use the you need to install a Java Runtime Environment (JRE) on your computer (at least version 1.2.2) and then re-run the installation script. \n\nResatisfiable\n   no"},"iso_strict:iso_strict_desc":{"prefix":"lib","body":"lib(${1:iso_strict})$2\n$0","description":"lib(iso_strict)\n\nOverview\n    This library provides an implementation of Standard Prolog as\n    defined in ISO/IEC 13211-1 (Information Technology, Programming\n    Languages, Prolog, Part 1, General Core, 1995) and the technical\n    corrigenda ISO/IEC 13211-1 TC1 (2007) and TC2 (2012).\n    The library is provided in source form.\n    \n    This library aims at providing a \"strict mode\" as required by ISO 13211-1,\n    paragraph 5.1.e.  For non-strict versions, see library(iso) and\n    library(iso_light).\n    \nUsage\n    The effect of this compatibility library is (with minor exceptions)\n    local to the module where it is loaded.  An ISO-program should always\n    be contained in a separate module, starting with a directive like\n    \n    :- module(myisomodule, [], iso_strict).\n    \n    Here, the last argument of the module/3 directive indicates the language.\n    It is not advisable to use \":-lib(iso_strict)\" or\n    \":-ensure_loaded(library(iso_strict))\" within an eclipse_language module,\n    because this would lead to import conflicts between the different\n    versions of built-in predicates.\n    \n    Alternatively, in order to use ISO-Prolog without having different\n    modules, one can invoke eclipse with a \"-L iso_strict\" command line option,\n    or set the ECLIPSEDEFFAULTLANGUAGE environment variable to 'iso_strict'.\n    This will launch eclipse with a default module accepting 'iso_strict'\n    language instead of the usual 'eclipse_language'.\n    \nSpecification of implementation defined features\n    \n    6.5 Processor characted set\n\tThe PCS is the ISO 8859-1 character set.  Classification of\n\textended characters: 7f-a0 layout; a1-bf, d7, f7 graphic;\n\tc0-d6, d8-f6, f8-ff alphanumeric.\n    6.6 Collating sequence\n\tThe collating sequence is that of the ISO 8859-1 character set\n    7.1.2.2 Character codes\n\tEach character maps to a corresponding byte\n    7.1.4.1 Characters\n\tAs in the ISO 8859-1 character set\n    7.2.1 Variable term order\n\tOlder variables precede newer variables\n    7.4.2.4,5 op/3 and char_conversion/2\n\tAn operator or character-conversion defined in a directive is\n\teffective at runtime, and only in the module in which it occurs\n    7.4.2.6 initialization/1\n\tInitialization goals are executed in the order in which they\n\toccur in the Prolog text\n    7.4.2.7 include/1\n\tThe argument is a file name atom according to ECLiPSe's canonical\n\tfile name syntax, or a term of the form library(atom)\n    7.4.2.8 ensure_loaded/1\n\tThe argument is a file name atom according to ECLiPSe's canonical\n\tfile name syntax, or a term of the form library(atom).  A file will\n\tbe loaded on the first occurrence of ensure_loaded/1 in a prolog text,\n\tand if the file has been modified since the time it was first loaded.\n\t\n    7.4.2.7 set_prolog_flag/2\n\tFlag setting are effective at runtime and globally (except for\n\ta few module-local flags in non-strict mode, see set_flag/2)\n    7.5.1 Preparing for execution\n\tSee the eclipse_language built-ins, menu items and command line\n\toptions for compiling, loading and module handling, and also the\n\tinstructions for using library(iso) or library(iso_strict)\n    7.7.1,3 Execution and Initialization\n\tSee the general ECLiPSe facilities, i.e. toplevel, graphical\n\tuser interface and command line options\n    7.10.1 Sources and sinks\n\tSee open/3,4\n    7.10.2.6 Text streams\n\tText streams are very similar to binary streams, no characters\n\tare implicitly inserted or removed.  The nl/0,1 predicates emit\n\tan operating system and device dependent newline sequence.\n    7.10.2.8,11 Stream positions\n\tFile, string, and null streams can be (re)positioned\n    7.10.2.9 End position of a stream\n\tThe end position of a stream is the same as the position that\n\ta character appended to the stream would have\n    7.10.2.11 Stream options\n\tThe default eof_action is error\n    7.10.2.13 Stream properties\n\tFile names are atoms according to ECLiPSe's canonical file name\n\tsyntax.\n    7.11 Flags\n\tFixed values: bounded=false, min_integer and max_integer fail,\n\tinteger_rounding_function=toward_zero, max_arity=unbounded,\n\tchar_conversion=off.\n\tDefault values: double_quotes=chars, debug=off.\n\tIf debug=on, the ECLiPSe tracer is active.  In non-strict mode,\n\tthere is an additional flag max_predicate_arity, which indicates\n\tthe limit on predicate arity (there is no limit on term arity).\n\t\n    7.12.1 Effect of an error\n\tThe implementation defined error term argument is normally the\n\tpredicate indicator of the culprit goal.  For syntax errors, it is\n\ta term describing the error location.\n    8.15.4 call/N\n\tThe maximum N is given by the flag max_predicate_arity (255)\n    8.17.1 set_prolog_flag/2\n\tThe admissible flag values are the ones defined by ISO-Prolog (for\n\tiso_strict), plus those accepted by ECLiPSe's set_flag/2 (for iso)\n    8.17.3,4 halt/0,1\n\tExits the OS process with the given return code (or 0)\n    9 Evaluable functors\n    The 'exceptional values' are realized as follows: 'float_overflow'\n\tleads to a floating point infinity result; 'underflow' leads to\n\ta floating point denormalized value result; 'zero_divisor' leads\n\tto a floating point infinity result in the case of floats,\n\tor an evaluation_error(zero_divisor) in the case of integers;\n\t'int_overflow' does not occur and might lead to running out of\n\tmemory instead.\n    9.3 Other arithmetic operations\n\tWhen min/2 or max/2 are used with mixed integer and float\n\targuments, the integer is coerced to float, and the result\n\tcomputed by comparing two floats\n    9.4 Bitwise arithmetic operations\n\tThe bitwise arithmetic operations behave as if operating on\n\tan unlimited length two's complement representation\n    \n\nImplementation specific features\n    These are only available with library(iso), not with library(iso_strict)!\n    \n    7.10.2.11 Stream options\n\tFor additional stream options, see open/4\n    7.10.2.12 Options on stream closure\n\tNone\n    7.10.2.13 Stream properties\n\tFor additional stream properties, see get_stream_info/3\n    7.10.3 Read options\n\tFor additional read options, see read_term/3\n    7.10.4 Write options\n\tFor additional stream options, see write_term/3\n    7.11 Flags\n\tFor additional Prolog flags, see get_flag/2\n    \n\nRemaining deviations from Standard\n    \n    The write predicates output extra spaces\n    The char_conversion flag is always off, meaning that character\n    conversion is not applied to prolog texts or on term input.  However,\n    char_conversion/2 and current_char_conversion/2 predicates are operational."},"java_vc:start_vc/1":{"prefix":"start_vc","body":"start_vc(${1:VisClientName})$2\n$0","description":"start_vc(-VisClientName)\n\n   Start a new Java Visualisation Client\n\nArguments\n   VisClientName       An atom; the name of the new visualisation client.\n\nType\n   library(java_vc)\n\nDescription\nThis predicates starts a new Java Visualisation Client (VC). The VC survives backtracking over the start_vc/1 goal, and persists until it is explicitly terminated. VisClientName becomes instantiated to an atom which can be used when the VC is to be stopped. For start_vc to work correctly, ECLiPSe needs to know where to find the Java installation. To check whether this is so, use find_java/1. If the result of find_java/1 is not the root directory of a Java installation (at least version 1.2.2) then the behaviour of start_vc/1 prints an error message and fails.    \n\n\t\n\nResatisfiable\n   no\n\nSee Also\n   stop_vc / 1, find_java / 1"},"java_vc:java_vc_desc":{"prefix":"lib","body":"lib(${1:java_vc})$2\n$0","description":"lib(java_vc)\n\n Module for the management of the Java Visualisation Client (VC) from ECLiPSe. The Java VC is an extensible, customisable, graphical visualisation tool for ECLiPSe implemented in Java. A new Java VC can be started using the predicate start_vc/1. While the Java VC is running, it will react automatically to the creation of viewables during ECLiPSe execution. For more information on how to declare and use viewables see the documentation for lib(viewable). The Java VC can be terminated from ECLiPSe using the predicate stop_vc/1."},"java_vc:stop_vc/1":{"prefix":"stop_vc","body":"stop_vc(${1:VisClientName})$2\n$0","description":"stop_vc(+VisClientName)\n\n   Terminate a running Java visualisation client.\n\nArguments\n   VisClientName       An atom; the name of the client to be terminated.\n\nType\n   library(java_vc)\n\nDescription\nTerminate a running Java visualisation client which was started using start_vc/1. The name atom is displayed at the top of the client's window.\n\nResatisfiable\n   no\n\nSee Also\n   start_vc / 1"},"linearize:linearize/3":{"prefix":"linearize","body":"linearize(${1:Expression}, ${2:Linear}, ${3:Residue})$4\n$0","description":"linearize(?Expression, -Linear, -Residue)\n\n   Split and arithmetic expression into linear and nonlinear parts\n\nArguments\n   Expression    Arithmetic expression with constants and variables\n   Linear    Normalized lists of monomials\n   Residue    Residual nonlinear components in the form AuxVar=Expr\n\nType\n   library(linearize)\n\nDescription\n\tThe linear component of expression is normalised into a list\n\t(sum) of monomials of the form\n\n\t\t[C0*1, C1*X1, C2*X2, ...]\n\n\twhere Ci are numbers and Xi are distinct variables.\n\tThe first (constant) term is always present, Ci (i>=1) are nonzero.\n\n\tlinearize/3 converts a general arithmetic expression into a\n\tnormalised linear form. The nonlinear parts are extracted using\n\tauxiliary variables, and returned as Residue, which is a list of\n\tAux=NonLinExpr constraints.\n\n\tlinearize/3 understands all arithmetic expressions plus\n\n\t    lin(Lin)\n\n\twhere Lin is an already normalised linear expression. All variables\n\twithin Expression (which are free at linearization time) are taken\n\tto be numerical variables. If you intend to have variables which can\n\tbe bound to symbolic expressions rather than numbers, they must be\n\twrapped into an eval/1 functor.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n    ?- linearize(3*X-7*Y+2*(X+Y), L, R).\n    X = X\n    Y = Y\n    L = [0 * 1, 5 * X, -5 * Y]\n    R = []\n    yes.\n\n    ?- linearize(12*3, L, R).\n    L = [36 * 1]\n    R = []\n    yes.\n\n    ?- linearize(X*(3+7*Y)-X, L, R).\n    Y = Y\n    X = X\n    L = [0 * 1, 1 * _308, 2 * X]\n    R = [_308 = X * (7 * Y)]\n    yes.\n    \n\nSee Also\n   polynorm / 3, linrenorm / 2, delinearize / 2"},"lazy_io:list_to_stream/3":{"prefix":"list_to_stream","body":"list_to_stream(${1:Codes}, ${2:Stream}, ${3:Mode})$4\n$0","description":"list_to_stream(?Codes, +Stream, +Mode)\n\n   Map a list to an output stream\n\nArguments\n   Codes    A (possibly partial) list of character codes\n   Stream    A stream handle\n   Mode    One of the atoms 'incremental' or 'delayed'\n\nType\n   library(lazy_io)\n\nDescription\n\r\n\tThis predicates maps a list of character codes to an output\r\n\tstream.  When list_to_stream/3 is called, the list Codes may\r\n\tbe uninstantiated, or it may be a partial list.  Once the list\r\n\tis terminated, and the Stream is closed, the file will reflect\r\n\tthe last state of the list.  As long as the stream is not\r\n\tclosed, the list may be arbitrarily extended, shortened on\r\n\tbacktracking, terminated, un-terminated on backtracking, etc. \r\n\tOnly once the stream is closed using close/1, is the stream\r\n\tcontents committed to reflect the list (provided the list has\r\n\tbeen terminated).  This behaviour is independent of the Mode\r\n\targument.\r\n\r\n\tMode 'incremental' should be used if the list may become very long.\r\n\tIn this mode the list is copied into the stream incrementally, such\r\n\tthat the front of the list can be garbage collected.\r\n\r\n\tMode 'delayed' may be slightly more efficient, since it copies the\r\n\tlist contents to the stream only once the list is terminated.  This\r\n\twill however use more memory, since the whole list needs to be held\r\n\tin memory until it is terminated.\r\n\r\n\tThe Stream must be open in write-mode.  In addition it is advisable\r\n\tto set the delete_file(when_lost) option when opening - this will\r\n\thave the effect of eventually deleting the associated file in case\r\n\tthe stream is never explicitly closed.\r\n\r\n\tIf the stream is closed without the list being terminated, the stream\r\n\tcontent is essentially undefined.  In practice, with 'incremental'\r\n\tmode the stream will reflect the partial list as it was when the\r\n\tstream was closed.  With 'delayed' mode, the stream will be empty\r\n\tor reflect an earlier terminated state that was backtracked over.\r\n\r\n    \n\nModes and Determinism\n   list_to_stream(?, +, +) is det\n\nExamples\n   \r\n    write_list(File, N, Code) :-\r\n\topen(File, write, Out, [delete_file(when_lost)]),\r\n\tlist_to_stream(Codes, Out, incremental),\r\n\t( for(_,1,N), foreach(Code,Codes), param(Code) do true ),\r\n\tclose(Out).\r\n    \n\nSee Also\n   stream_to_lazy_list / 2, open / 4, char_code / 2, string_list / 2"},"lazy_io:stream_to_lazy_list/2":{"prefix":"stream_to_lazy_list","body":"stream_to_lazy_list(${1:Stream}, ${2:Codes})$3\n$0","description":"stream_to_lazy_list(+Stream, ?Codes)\n\n   Map an input stream to a lazy list\n\nArguments\n   Stream    A stream handle\n   Codes    A variable or (possibly partial) list\n\nType\n   library(lazy_io)\n\nDescription\n\r\n    \tThis predicate makes the content of Stream available as a list of\r\n\tcharacter codes, similar to reading the whole stream content into\r\n\ta list, and then using the list.  However, in this lazy version\r\n\tthe list is materialized in an incremental fashion, i.e.  only\r\n\twhen its elements are created by the list processing code, are\r\n\tthe character codes read from the stream and filled in.  For most\r\n\tpurposes, this lazy list can be used like a normal list, e.g. in\r\n\tparsing with DCGs.  The advantage of the lazy version is that at\r\n\tno time is it necessary to have the whole list in memory: the tail\r\n\tis created lazily from the stream, and the front will be garbage\r\n\tcollected when no longer needed.\r\n\t\r\n\tThe stream must be open in read-mode.  The list will reflect the\r\n\tstream content starting from the position the stream is at when\r\n\tstream_to_lazy_list/2 is called.  The list will end with the last\r\n\tcharacter in the stream.  If the stream content changes while the\r\n\tlist is partly materialised, the list content is undefined.\r\n\t\r\n\tThe stream should not be closed as long as it is possible to backtrack\r\n\tto a point between the call to stream_to_lazy_list/2 and the\r\n\ttermination of the list.  In most cases, it is not necessary to close\r\n\tthe stream explicitly at all, because it will be closed automatically\r\n\ton garbage collection or on failure.\r\n\t\r\n\tNOTE about cuts in current ECLiPSe versions: If a unification is\r\n\tfollowed immediately by a cut, and the unification causes waking,\r\n\tthe waking occurs only after the cut.  A unification that creates\r\n\tan element of the lazy list may therefore need a dummy 'true' goal\r\n\tbefore a subsequent cut in order to force waking.\r\n    \n\nModes and Determinism\n   stream_to_lazy_list(+, ?) is semidet\n\nExamples\n   \r\n    copy_file(Old, New) :-\r\n\topen(Old, read, In),\r\n\topen(New, write, Out),\r\n\tstream_to_lazy_list(In, Codes),\r\n\t( foreach(C,Codes), param(Out) do put(Out, C) ),\r\n\tclose(In),\r\n\tclose(Out).\r\n    \n\nSee Also\n   list_to_stream / 3, char_code / 2, string_list / 2"},"linearize:delinearize/2":{"prefix":"delinearize","body":"delinearize(${1:Linear}, ${2:Expression})$3\n$0","description":"delinearize(?Linear, -Expression)\n\n   Convert a linear form back to a standard arithmetic expression\n\nArguments\n   Linear    Normalized lists of monomials\n   Expression    Arithmetic expression with constants and variables\n\nType\n   library(linearize)\n\nExamples\n   \n    ?- linearize(3*X-7*Y+2*(X+Y), L, R), delinearize(L, E).\n    X = X\n    Y = Y\n    R = []\n    L = [0 * 1, 5 * X, -5 * Y]\n    E = 5 * X - 5 * Y\n    yes.\n    \n\nSee Also\n   linrenorm / 2, linearize / 3"},"linearize:linrenorm/2":{"prefix":"linrenorm","body":"linrenorm(${1:LinOld}, ${2:LinNew})$3\n$0","description":"linrenorm(+LinOld, -LinNew)\n\n   Renormalize a linear form\n\nArguments\n   LinOld    Possibly denormal lists of monomials\n   LinNew    Normalized lists of monomials\n\nType\n   library(linearize)\n\nDescription\n\tThe normal form of linear expressions is\n\n\t\t[C0*1, C1*X1, C2*X2, ...]\n\n\twhere Ci are numbers and Xi are distinct variables.\n\tThe first (constant) term is always present, Ci (i>=1) are nonzero.\n\n\tSuch a form can become denormalized due to unifications\n\t(instantiation or variable-variable aliasing). This predicate\n\trenormalizes it. Note that variables may only become instantiated\n\tto numbers!\n    \n\nExamples\n   \n    ?- linearize(3*X-7*Y+2*(X+Y), L1, R), writeln(L1),\n\tY = 3,\n\tlinrenorm(L1,L2), writeln(L2).\n\n    [0 * 1, 5 * X, -5 * Y]\n    [-15 * 1, 5 * X]\n    \n\nSee Also\n   linearize / 3, delinearize / 2"},"linearize:polydenorm/2":{"prefix":"polydenorm","body":"polydenorm(${1:NormPoly}, ${2:Expression})$3\n$0","description":"polydenorm(?NormPoly, -Expression)\n\n   Convert a polynomial form back to a standard arithmetic expression\n\nArguments\n   NormPoly    Normalized polynomial form\n   Expression    Arithmetic expression with constants and variables\n\nType\n   library(linearize)\n\nExamples\n   \n    ?- polynorm(2*5 + 3*(X+5*Y+7)*Z, Poly, []), polydenorm(Poly, Expr).\n    X = X\n    Y = Y\n    Z = Z\n    Poly = [[[10]], [[21, Z]], [[3, X, Z], [15, Y, Z]]]\n    Expr = 10 + 21 * Z + 3 * X * Z + 15 * Y * Z\n    yes.\n    \n\nSee Also\n   polyrenorm / 2, polynorm / 3"},"linearize:polynorm/3":{"prefix":"polynorm","body":"polynorm(${1:Expression}, ${2:NormPoly}, ${3:Residue})$4\n$0","description":"polynorm(?Expression, -NormPoly, -Residue)\n\n   Extracts and normalises the polynomial part of an arithmetic expression\n\nArguments\n   Expression    Arithmetic expression with constants and variables\n   NormPoly    Normalized polynomial\n   Residue    Residual nonpolynomial components in the form AuxVar=Expr\n\nType\n   library(linearize)\n\nDescription\n\tThis predicate converts a general arithmetic expression into a\n\tnormalized polynomial representation and possibly a nonpolynomial\n\tresidue. The normalized polynomial representation is a follows:\n\n\tA monomial is a list of constants and variables and represents\n\tthe product of all the list elements.\n\tIn a normalised monomial, the list is sorted, the first element is\n\tthe (only) constant and the others are variables.\n\n\tA normalised polynomial is represented as a list of lists of\n\tnormalised monomials. The sublists represent groups of monomials\n\tof the same degree in ascending order. If there are no monomials\n\tfor a certain degree, the list element is missing:\n\n\t[ConstantMonos, LinearMonos, QuadraticMonos, CubicMonos, ...]\n\n\tIn a normalised polynomial, all monomials are normalised and\n\tall monomials with identical variables are merged.\n\n\tNon-polynomial components are factored out by introducing an\n\tauxiliary variable and adding a term Aux=NonPolyExpr to the\n\tResidue result list.  All variables within Expression (which\n\tare free at normalization time) are taken to be numerical\n\tvariables.  If you intend to have variables which can be bound\n\tto symbolic expressions rather than number, they must be\n\twrapped into an eval/1 functor.\n    \n\nExamples\n   \n    ?- polynorm(2*5 + 3*(X+5*Y+7)*Z, Poly, Res).\n    X = X\n    Y = Y\n    Z = Z\n    Poly = [[[10]], [[21, Z]], [[3, X, Z], [15, Y, Z]]]\n    Res = []\n    yes.\n\n    ?- polynorm(3*(X+Y),  Poly, Res).\n    X = X\n    Y = Y\n    Poly = [[[3, X], [3, Y]]]\n    Res = []\n    yes.\n\n    ?- polynorm(3, Poly, Res).\n    Poly = [[[3]]]\n    Res = []\n    yes.\n    \n\nSee Also\n   polydenorm / 2, polyrenorm / 2, linearize / 3"},"linearize:polyrenorm/2":{"prefix":"polyrenorm","body":"polyrenorm(${1:PolyOld}, ${2:PolyNew})$3\n$0","description":"polyrenorm(+PolyOld, -PolyNew)\n\n   Renormalize a polynomial form\n\nArguments\n   PolyOld    Possibly denormal polynomial form\n   PolyNew    Normalized polynomial form\n\nType\n   library(linearize)\n\nDescription\n\tSee polynorm/3 for the definition of the polynomial form.\n\tSuch a form can become denormalized due to unifications\n\t(instantiation or variable-variable aliasing). This predicate\n\trenormalizes it.\n    \n\nExamples\n   \n    ?- polynorm(3*(X+Y),  Poly1, []), writeln(Poly1),\n\tY = 3,\n\tpolyrenorm(Poly1, Poly2), writeln(Poly2).\n\n    [[[3, X], [3, Y]]]\n    [[[9]], [[3, X]]]\n    \n\nSee Also\n   polynorm / 3, polydenorm / 2"},"lips:lips/0":{"prefix":"lips","body":"lips","description":"lips\n\n   Run the benchmark a reasonable number of times and print the average speed\n\nType\n   library(lips)"},"linearize:quadnorm/6":{"prefix":"quadnorm","body":"quadnorm(${1:Expression}, ${2:Const}, ${3:Linear}, ${4:Quadratic}, ${5:PolyRes}, ${6:Residue})$7\n$0","description":"quadnorm(?Expression, -Const, -Linear, -Quadratic, -PolyRes, -Residue)\n\n   Extracts constant, linear and quadratic part of an arithmetic expression\n\nArguments\n   Expression    Arithmetic expression with constants and variables\n   Const    Variable or number\n   Linear    Variable or normalized linear polynomial\n   Quadratic    Variable or normalized quadratic polynomial\n   PolyRes    Variable or normalized superquadratic polynomial\n   Residue    Residual nonpolynomial components in the form AuxVar=Expr\n\nType\n   library(linearize)\n\nDescription\n\tThis predicate is a simplified interface to polynorm/3 for the case\n\twhere one is only interested in linear and quadratic components.\n\tSee polynorm/3 for details.\n    \n\nExamples\n   \n    ?- quadnorm(2*5 + 3*(X+5*Y+7)*Z, Const, Lin, Quad, Poly, Res).\n    X = X\n    Y = Y\n    Z = Z\n    Const = 10\n    Lin = [[21, Z]]\n    Quad = [[3, X, Z], [15, Y, Z]]\n    Poly = []\n    Res = []\n    yes.\n    \n\nSee Also\n   polynorm / 3, linearize / 3"},"lint:lint/1":{"prefix":"lint","body":"lint(${1:File})$2\n$0","description":"lint(+File)\n\n   Check the given source module file\n\nArguments\n   File    Name of the source file (atom or string)\n\nType\n   library(lint)\n\nDescription\n\n    Analyse a source file, do various heuristic checks on the code,\n    and print warnings if appropriate. This is equivalent to\n    \n\tlint(File, [])\n    \n    The analysed code can use pragmas of the form\n    \n    :- pragma(lint(Option:Value)).\n    \n    to enable or disable individual checks. See lint/2 for a list\n    of the options.\n    \n\nSee Also\n   lint / 2"},"lint:lint_desc":{"prefix":"lib","body":"lib(${1:lint})$2\n$0","description":"lib(lint)\n\n    This library analyses an ECLiPSe source module or file and generates\n    warning messages for dubious programming constructs and violation\n    of naming conventions."},"lint:lint/2":{"prefix":"lint","body":"lint(${1:File}, ${2:Options})$3\n$0","description":"lint(+File, +Options)\n\n   Check the given source module file\n\nArguments\n   File    Name of the source file (atom or string)\n   Options    A list of Option:Value structures\n\nType\n   library(lint)\n\nDescription\n\n    Analyse a source file, do various heuristic checks on the code,\n    and print warnings if appropriate.\n\n    The possible options are:\n\n    head_unify ('off' or 'on')\n\twarn if a clause with a cut contains aliasing in the head,\n\twhich may indicate non-steadfast code. Default: on.\n    missing_else ('off' or 'on')\n\twarn if a conditions does not have an else case, since this\n\twill fail and is more clearly written using a simple conjunction\n\tor once/1. Default: on.\n    naming_conventions ('off' or 'on')\n\tenable/disable naming conventions checks for variable names,\n\tpredicate names and module names. Default: on.\n    singletons ('off' or 'on')\n\tenable/disable singleton variable checks. Default: on.\n\n    These option settings can be overridden via pragmas in the analysed\n    file.  E.g. a pragma\n    \n    :- pragma(lint(head_unify:off)).\n    \n    will disable head_unify checking for the subsequent code, or until\n    another pragma enables it again.\n    \n\nSee Also\n   lint / 1"},"lips:lips/2":{"prefix":"lips","body":"lips(${1:Count}, ${2:Length})$3\n$0","description":"lips(+Count,+Length)\n\n   Run the benchmark Count times with lists of length Length\n\nType\n   library(lips)"},"lips:lips_desc":{"prefix":"lib","body":"lib(${1:lips})$2\n$0","description":"lib(lips)\n\n    Measure the system's speed in logical inferences per second, using\n    the infamous naive reverse program. This test does not say very much\n    about the quality of a system. All it gives is an indication about\n    the speed of list processing.\n    \n    The executed program is:\n    \n    nreverse([], []).\n    nreverse([X|L0],L) :-\n\t    nreverse(L0, L1),\n\t    concatenate(L1, [X], L).\n\n    concatenate([], L, L).\n    concatenate([X|L1], L2, [X|L3]) :-\n\t    concatenate(L1, L2, L3).\n    \n    and the standard benchmark is to call nreverse/2 with a 30-element\n    list as the first and a variable as the second argument.  This\n    instance is assumed to have 496 logical inferences."},"lists:checklist/2":{"prefix":"checklist","body":"checklist(${1:Pred}, ${2:List})$3\n$0","description":"checklist(+Pred, +List)\n\n   Succeeds if Pred(Elem) succeeds for every element of List.\n\nArguments\n   +Pred    Atom or compound term.\n   +List    List.\n\nType\n   library(lists)\n\nDescription\n   checklist/3 succeeds if for every element of List, the invocation of\n   Pred with one aditional argument which is this element succeeds.\n\n   The definition of this Prolog library predicate is:\n\n:- tool(checklist/3, checklist_body/4).\n\nchecklist_body(_, [], _).\nchecklist_body(Pred, [Head|Tail], M) :-\n    call(Pred, Head)@M,\n    checklist_body(Pred, Tail, M).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if at least for one element of List the invocation of Pred with this additional argument fails.\n\nResatisfiable\n   Resatisfiable if at least for one element of List the invocation of Pred with this additional argument is resatisfiable.\n\nExamples\n   \nSuccess:\n  checklist(integer, [1, 3, 5]).\n  checklist(spy, [var/1, functor/3]).\n\nFail:\n  checklist(current_op(_, _), [+, -, =]).\n  (fails because the precedence of = does not match that of +)\n\nSee Also\n   maplist / 3"},"lips:lips/1":{"prefix":"lips","body":"lips(${1:Count})$2\n$0","description":"lips(+Count)\n\n   Run the benchmark Count times and print the average speed\n\nType\n   library(lips)"},"lists:append/3":{"prefix":"append","body":"append(${1:List1}, ${2:List2}, ${3:List3})$4\n$0","description":"append(?List1, ?List2, ?List3)\n\n   Succeeds if List3 is the result of appending List2 to List1.\n\nArguments\n   ?List1    List or variable.\n   ?List2    List or variable.\n   ?List3    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies List3 to the result of appending List2 to List1.  On\n   backtracking append/3 gives all possible solutions for List1 and List2,\n   if both are uninstantiated.\n\n   The definition of this Prolog library predicate is:\n\nappend([],X,X).\nappend([X|L1],L2,[X|L3]):-\n    append(L1,L2,L3).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   append(+, +, -) is det\n   append(-, -, +) is multi\n\nFail Conditions\n      Fails if List3 does not unify with the result of appending List2 to\n   List1.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n  append([1,2],L2,[1,2,3,4]). (gives L2=[3,4]).\n  append([1,B],L2,[A,2,3,4]). (gives B=2 L2=[3,4] A=1).\n  append([1,2],L2,L3).    (gives L2=L2 L3=[1,2|L2]).\n  append([1],[2,3],L3).     (gives L3=[1,2,3]).\n\n  [eclipse]: append(L1,L2,[1,2]), writeln((L1,L2)), fail.\n  [] , [1, 2]\n  [1] , [2]\n  [1, 2] , []\n  no (more) solution.\nFail:\n  append(L1,[3],[1,2,3,4]).\n  append(1,L2,[1,2]).\n\nSee Also\n   union / 3"},"lists:collection_to_list/2":{"prefix":"collection_to_list","body":"collection_to_list(${1:Collection}, ${2:List})$3\n$0","description":"collection_to_list(+Collection, ?List)\n\n   Convert a \"collection\" into a list\n\nType\n   library(lists)\n\nDescription\n   Converts various \"collection\" data structures into a list.  Fails if it\n   does not know how to do this.  The supported collection types are:\n\n   List\n\tThe list is returned unchanged.\n   Array\n\tThe array is flattened into a list using flatten_array/2.\n   Subscript reference (Array[...])\n\tsubscript/3 is called to evaluate the subscript reference.  Note\n\tthat the result is not flattened, so if subscript/3 results in a\n\tnested list, the result is a nested list.  However if the result is\n\ta single element of the array that is not a list, this is converted\n\tinto a list containing that element.\n   flatten(Collection)\n\tCalls collection_to_list/2 on Collection and then flattens the\n\tresult using flatten/2.\n   flatten(MaxDepth, Collection)\n\tCalls collection_to_list/2 on Collection and then flattens the\n\tresult up to MaxDepth levels of nesting using flatten/3.\n\nModes and Determinism\n   collection_to_list(+, -) is det\n\nExamples\n      ?- collection_to_list([a,b,[c,d]], List).\n   List = [a, b, [c, d]]\n   Yes\n   ?- collection_to_list([](a,b,[c,d]), List).\n   List = [a, b, [c, d]]\n   Yes\n   ?- collection_to_list([]([](a,b),[](c,d)), List).\n   List = [a, b, c, d]\n   Yes\n   ?- A = []([](a,b),[](c,d)),\n      collection_to_list(A[1..2,1], List).\n   List = [a, c]\n   Yes\n   ?- A = []([](a,b,c),[](d,e,f)),\n      collection_to_list(A[1..2,2..3], List).\n   List = [[b, c], [e, f]]\n   Yes\n   ?- collection_to_list(flatten([a,b,[c,d]]), List).\n   List = [a, b, c, d]\n   Yes\n   ?- collection_to_list(flatten([](a,b,[c,d])), List).\n   List = [a, b, c, d]\n   Yes\n   ?- A = []([](a,b,c),[](d,e,f)),\n      collection_to_list(flatten(A[1..2,2..3]), List).\n   List = [b, c, e, f]\n   Yes\n   ?- L = [[a,b],[[c,d],[e,f]],g],\n      collection_to_list(flatten(1, L), List).\n   List = [a, b, [c, d], [e, f], g]\n   Yes\n\nSee Also\n   subscript / 3, flatten / 2, flatten / 3, flatten_array / 2"},"lists:delete/3":{"prefix":"delete","body":"delete(${1:Element}, ${2:List1}, ${3:List2})$4\n$0","description":"delete(?Element, ?List1, ?List2)\n\n   Succeeds if List2 is List1 less an occurence of Element in List1.\n\nArguments\n   ?Element    Prolog term.\n   ?List1    List or variable.\n   ?List2    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies the list List2 with the list List1 less an occurence of Element.\n   Any alternative solutions are provided on backtracking.\n\n   This predicate can be used to select an element from a list, delete an\n   element or insert it.\n\n   The definition of this Prolog library predicate is:\n\n    delete(A, [A|B], B).\n    delete(A, [B, C|D], [B|E]) :-\n\t    delete(A, [C|D], E).\n\n   This predicate does not perform any type testing functions.\n   \n\nModes and Determinism\n   delete(+, +, -) is nondet\n   delete(-, +, -) is nondet\n   delete(-, -, -) is multi\n\nFail Conditions\n      Fails if List2 does not unify with List1 less an occurence of Element.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n   [eclipse]: delete(X,[1,M,X],L), writeln((M,X,L)), fail.\n   _g66 , 1 , [_g66, 1]\n   _g66 , _g66 , [1, _g66]\n   _g66 , _g72 , [1, _g66]\n   no (more) solution.\n\n   [eclipse]: delete(3,[1,3,5,3],L).\n   L = [1, 5, 3]    More? (;)\n   L = [1, 3, 5]\n   yes.\n\n   [eclipse]: delete(X,L,[a,b]), writeln((X,L)), fail.\n   _g66 , [_g66, a, b]\n   _g66 , [a, _g66, b]\n   _g66 , [a, b, _g66]\n   no (more) solution.\n\n   delete(X,[1,2],L).   (gives X=1 L=[2]; X=2 L=[1]).\nFail:\n   delete(1,[1,2,1,3],[2,3]).\n\nSee Also\n   subtract / 3, member / 2"},"lists:flatten/2":{"prefix":"flatten","body":"flatten(${1:NestedList}, ${2:FlatList})$3\n$0","description":"flatten(+NestedList, ?FlatList)\n\n   Succeeds if FlatList is the list of all elements in NestedList, as found in\na left-to-right, depth-first traversal of NestedList.\n\nArguments\n   +NestedList    A List.\n   ?FlatList    List or variable.\n\nType\n   library(lists)\n\nDescription\n   FlatList is the list built from all the non-list elements of NestedList\n   and the flattened sublists.  The sequence of elements in FlatList is\n   determined by a left-to-right, depth-first traversal of NestedList.\n\n   The definition of this Prolog library predicate is:\n\nflatten(List, Flat) :-\n\tflatten_aux(List, Flat, []).\n\nflatten_aux([], Res, Cont) :- -?-> !, Res = Cont.\nflatten_aux([Head|Tail], Res, Cont) :-\n\t-?->\n\t!,\n\tflatten_aux(Head, Res, Cont1),\n\tflatten_aux(Tail, Cont1, Cont).\nflatten_aux(Term, [Term|Cont], Cont).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   flatten(+, -) is det\n\nFail Conditions\n      Fails if FlatList does not unify with the flattened version of\n   NestedList.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n    [eclipse]: flatten([[1,2,[3,4],5],6,[7]], L).\n    L = [1, 2, 3, 4, 5, 6, 7]\n    yes.\n\nFail:\n    [eclipse]: flatten([1,[3],2], [1,2,3]).\n    no.\n\nSee Also\n   flatten / 3, sort / 2, sort / 4, length / 2, member / 2"},"lists:flatten/3":{"prefix":"flatten","body":"flatten(${1:MaxDepth}, ${2:NestedList}, ${3:FlatList})$4\n$0","description":"flatten(++MaxDepth, +NestedList, ?FlatList)\n\n   Depth-limited list flattening\n\nArguments\n   ++MaxDepth    Maximum depth to flatten.\n   +NestedList    List.\n   ?FlatList    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Like flatten/2, but does not flatten beyond the specified depth MaxDepth.\n   So flatten(0, List, Flat) just unifies Flat and List (no flattening),\n   flatten(1, List, Flat) just flattens the top-level list of List, etc.\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   flatten(++, +, -) is det\n\nFail Conditions\n      Fails if FlatList does not unify with the flattened version of\n   NestedList.\n\nResatisfiable\n      No.\n\nExamples\n   \n   Success:\n      [eclipse]: flatten(0, [[1,2,[3,4],5],6,[7]], L).\n      L = [[1, 2, [3, 4], 5], 6, [7]]\n      yes.\n      [eclipse]: flatten(1, [[1,2,[3,4],5],6,[7]], L).\n      L = [1, 2, [3, 4], 5, 6, 7]\n      yes.\n      [eclipse]: flatten(2, [[1,2,[3,4],5],6,[7]], L).\n      L = [1, 2, 3, 4, 5, 6, 7]\n      yes.\n      [eclipse]: flatten(3, [[1,2,[3,4],5],6,[7]], L).\n      L = [1, 2, 3, 4, 5, 6, 7]\n      yes.\n      \n   Fail:\n      [eclipse]: flatten(2, [1,[3],2], [1,2,3]).\n      no.\n\nSee Also\n   flatten / 2, sort / 2, sort / 4, length / 2, member / 2"},"lists:intersection/3":{"prefix":"intersection","body":"intersection(${1:List1}, ${2:List2}, ${3:Common})$4\n$0","description":"intersection(+List1, +List2, ?Common)\n\n   Succeeds if Common unifies with the list which contains the common elements\nof List1 and List2.\n\nArguments\n   +List1    List.\n   +List2    List.\n   ?Common    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Common is unified with a list which contains the common elements of\n   List1 and List2.\n\n   The definition of this Prolog library predicate is:\n\nintersection([], _, []).\nintersection([Head|L1tail], L2, L3) :-\n    memberchk(Head, L2),\n    !,\n    L3 = [Head|L3tail],\n    intersection(L1tail, L2, L3tail).\nintersection([_|L1tail], L2, L3) :-\n    intersection(L1tail, L2, L3).\n\n   This predicate does not perform any type testing functions.\n\n   This predicate works properly for set operations only, so repeated\n   elements and variable elements should not be used in the lists.\n\t\n\nModes and Determinism\n   intersection(+, +, -) is det\n\nFail Conditions\n      Fails if Common does not unify with the list which contains the common\n   elements of List1 and List2.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n   intersection([1,2],[2,3],L).     (gives L=[2]).\n   intersection([a,d],[a,b,c],[a]).\n\nFail:\n   intersection([a,b],[a,b],[b]).\n\nSee Also\n   subtract / 3, memberchk / 2, union / 3"},"lists:halve/3":{"prefix":"halve","body":"halve(${1:List}, ${2:Front}, ${3:Back})$4\n$0","description":"halve(+List, ?Front, ?Back)\n\n   Split a list in the middle\n\nType\n   library(lists)\n\nDescription\nReturns two lists (Front and Back) which can be concatenated to give\n\tthe original List. The length of the sub-lists is half the length of\n\tthe original. If the original length is odd, Front is one longer\n\nModes and Determinism\n   halve(+, -, -) is det\n\nExamples\n   \thalve([a,b,c,d,e,f], [a,b,c], [d,e,f])\n\thalve([a,b,c,d,e,f,g], [a,b,c,d], [e,f,g])\n\nSee Also\n   append / 3"},"lists:length/2":{"prefix":"length","body":"length(${1:List}, ${2:N})$3\n$0","description":"length(?List, ?N)\n\n   Succeeds if the length of list List is N.\n\nArguments\n   ?List    List or variable.\n   ?N    Integer or variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies N with the length of list List.  length/2 can be used to create\n   a list List of length N. The definition of this Prolog library predicate\n   is:\n\nlength(List, Length) :-\n    ( var(Length) ->\n    length(List, 0, Length)\n    ;\n    Length >= 0,\n    length1(List, Length) ).\n\nlength([], Length, Length).\nlength([_|L], N, Length) :-\n    N1 is N+1,\n    length(L, N1, Length).\n\nlength1([], 0) :- !.\nlength1([_|L], Length) :-\n    N1 is Length-1,\n    length1(L, N1).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   length(+, +) is semidet\n   length(+, -) is det\n   length(-, +) is det\n   length(-, -) is multi\n\nFail Conditions\n      Fails if the length of list List does not unify with N.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n  length([1,2,3],N).   (gives N=3).\n  length([1,2,1,X],N). (gives X=_g84; N=4).\n  length(L,2).    (gives L=[_g62,_g72]). % creates list\nFail:\n  length([1,2,3],2).\n\nSee Also\n   append / 3"},"lists:lists_desc":{"prefix":"lib","body":"lib(${1:lists})$2\n$0","description":"lib(lists)\n\n    Library containing various simple list manipulation predicates which\n    require no special form of lists. For ordered lists see library(ordset).\n    A number of basic list processing predicates (is_list/1, append/3,\n    member/2, length/2 etc) are available by default and do not require\n    this library to be loaded.\n\n    Note that in the predicate descriptions for this library, the '+' mode\n    in the mode specification for list-valued arguments indicates that the\n    list argument is required to be a proper list in the sense of is_list/1,\n    i.e. all list tails must be recursively instantiated."},"lists:maplist/3":{"prefix":"maplist","body":"maplist(${1:Pred}, ${2:OldList}, ${3:NewList})$4\n$0","description":"maplist(+Pred, ?OldList, ?NewList)\n\n   Succeeds if Pred(Old, New) succeeds for corresponding pairs of elements\nfrom OldList and NewList.\n\nArguments\n   +Pred    Atom or compound term.\n   ?OldList    List or variable.\n   ?NewList    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Either OldList or NewList should be a proper list.  maplist/3 succeeds\n   if for every corresponding pair of elements Old, New of the two lists\n   OldList and NewList the invocation of Pred with two aditional arguments\n   Old and New succeeds.\n\n   The definition of this Prolog library predicate is:\n\n:- tool(maplist/3, maplist_body/4).\n\nmaplist_body(_, [], [], _).\nmaplist_body(Pred, [H1|T1], [H2|T2], M) :-\n    call(Pred, H1, H2)@M,\n    maplist_body(Pred, T1, T2, M).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   maplist(+, +, -)\n   maplist(+, -, +)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if at least for one pair of corresponding elements of OldList and NewList the invocation of Pred with these two additional arguments fails\n\nResatisfiable\n   Resatisfiable if at least for one pair of corresponding elements of OldList and NewList the invocation of Pred with these two additional arguments is resatisfiable\n\nExamples\n   \nSuccess:\n  maplist(integer_atom, [1, 2, 3], ['1', '2', '3']).\n  maplist(sin, [0, 1, 2], X).\n      (gives X = [0.0, 0.841471, 0.909297])\n  maplist(get_flag(var/1), [skip, type, spy], [off, built_in, off]).\nFail:\n  maplist(type_of, [1, a, \"a\"], [integer, atom, atom]).\n\nSee Also\n   checklist / 2"},"lists:memberchk/2":{"prefix":"memberchk","body":"memberchk(${1:Term}, ${2:List})$3\n$0","description":"memberchk(+Term, ?List)\n\n   Succeeds if Term is a member of the list List.\n\nArguments\n   +Term    Prolog term.\n   ?List    List or a variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies Term with the first matching element of the list List.\n\n   If List is not instantiated, memberchk/2 binds List to a new partial\n   list containing an element Term.\n\n   The definition of this Prolog library predicate is:\n\nmemberchk(X,[X|_]) :- !.\nmemberchk(X,[_|T]):- memberchk(X,T).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   memberchk(+, +) is semidet\n   memberchk(+, -) is det\n\nFail Conditions\n      Fails if Term is not a member of the list List.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n      memberchk(0,[1,B,2]). (gives B=0).\n      memberchk(1,[1,X]).   (gives X=_g76).\n      memberchk(1,X), memberchk(2,X).\n    (gives X=[1,2|_g98]).\n\nFail:\n      memberchk(0,[1,2,3,4]).\n\nSee Also\n   member / 2"},"lists:member/2":{"prefix":"member","body":"member(${1:Term}, ${2:List})$3\n$0","description":"member(?Term, ?List)\n\n   Succeeds if Term unifies with a member of the list List.\n\nArguments\n   ?Term    Prolog term.\n   ?List    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Tries to unify Term with an element of the list List.\n\n   If Term is a variable and List is a list, all the members of the list\n   List are found on backtracking.\n\n   If List is not instantiated, member/2 binds List to a new partial list\n   containing the element Term.\n\n   The definition of this Prolog library predicate is:\n\n       member(X,[X|_]).\n       member(X,[Y|T]) :- member(X,T).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   member(-, +) is nondet\n   member(+, -) is nondet\n   member(-, -) is multi\n\nFail Conditions\n      Fails if Term does not unify with a member of the list List.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n      member(q,[1,2,3,p,q,r]).\n      member(q,[1,2,F]).      (gives F=q).\n      member(X,[1,X]).    (gives X=1; X=_g118).\n      member(X,[2,I]).    (gives X=2 I=_g114; X=_g94 I=_g94).\n      member(1,L).    (gives L=[1|_g64];\n    L=[_g62,1|_g68] etc).\n\nFail:\n      member(4,[1,2,3]).\n\nSee Also\n   memberchk / 2"},"lists:print_list/1":{"prefix":"print_list","body":"print_list(${1:List})$2\n$0","description":"print_list(+List)\n\n   Print the elements of a list, one per line\n\nType\n   library(lists)\n\nModes and Determinism\n   print_list(+) is det\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"lists:nonmember/2":{"prefix":"nonmember","body":"nonmember(${1:Element}, ${2:List})$3\n$0","description":"nonmember(+Element, +List)\n\n   Succeeds if Element is not an element of the list List.\n\nArguments\n   +Element    Prolog term.\n   +List    List.\n\nType\n   library(lists)\n\nDescription\n   Used to check that Element is not a member of the list List.\n\n   The definition of this Prolog library predicate is:\n\nnonmember(Arg,[Arg|_]) :-\n    !,\n    fail.\nnonmember(Arg,[_|Tail]) :-\n    !,\n    nonmember(Arg,Tail).\nnonmember(_,[]).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   nonmember(+, +) is semidet\n\nFail Conditions\n      Fails if Element is an element of the list List.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n  nonmember(q,[1,2,3,4,5,6,7]).\n\nFail:\n  nonmember(1,[1,2,3]).\n  nonmember(q,[1,2,2,X]). % X and q are unifiable\n\nSee Also\n   member / 2, memberchk / 2"},"lists:reverse/2":{"prefix":"reverse","body":"reverse(${1:List}, ${2:Reversed})$3\n$0","description":"reverse(+List, ?Reversed)\n\n   Succeeds if Reversed is the reversed list List.\n\nArguments\n   +List    A List.\n   ?Reversed    List or variable.\n\nType\n   library(lists)\n\nDescription\n   The List is reversed and the resulting list is unified with Reverse.\n\n   The definition of this Prolog library predicate is:\n\nreverse(List, Rev) :-\n    reverse(List, Rev, []).\n\nreverse([], L, L).\nreverse([H|T], L, SoFar) :-\n    reverse(T, L, [H|SoFar]).\n\n   This predicate does not perform any type testing functions.\n\t\n\nModes and Determinism\n   reverse(+, -) is det\n\nFail Conditions\n      Fails if Reverse does not unify with the reversed version of List.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n    [eclipse]: reverse([1,2,3,4,5], X).\n    X = [5, 4, 3, 2, 1]\n    yes.\n\nSee Also\n   append / 3, member / 2"},"lists:middle_out/2":{"prefix":"middle_out","body":"middle_out(${1:List}, ${2:Reordered})$3\n$0","description":"middle_out(+List, -Reordered)\n\n   Reorder a list such that the middle elements come first\n\nArguments\n   List    A list\n   Reordered    A variable or list\n\nType\n   library(lists)\n\nModes and Determinism\n   middle_out(+, -) is det\n\nExamples\n   \n?- middle_out([1,2,3,4,5], Zs).\nZs = [3, 2, 4, 1, 5]\nYes (0.00s cpu)\n\n?- middle_out([1,2,3,4,5,6], Zs).\nZs = [3, 4, 2, 5, 1, 6]\nYes (0.00s cpu)\n\t\n\nSee Also\n   reverse / 2"},"lists:select/3":{"prefix":"select","body":"select(${1:Element}, ${2:List1}, ${3:List2})$4\n$0","description":"select(?Element, ?List1, ?List2)\n\n   Succeeds if List2 is List1 less an occurence of Element in List1.\n\nArguments\n   ?Element    Prolog term.\n   ?List1    List or variable.\n   ?List2    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies the list List2 with the list List1 less an occurence of Element.\n   Any alternative solutions are provided on backtracking.\n\n   This predicate can be used to select an element from a list, delete an\n   element or insert it.\n\n   The definition of this Prolog library predicate is:\n\n    select(A, [A|B], B).\n    select(A, [B, C|D], [B|E]) :-\n\t    select(A, [C|D], E).\n\n   This predicate does not perform any type testing functions.\n   \n\nModes and Determinism\n   select(+, +, -) is nondet\n   select(-, +, -) is nondet\n   select(-, -, -) is multi\n\nFail Conditions\n      Fails if List2 does not unify with List1 less an occurence of Element.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n    [eclipse]: select(X,[1,M,X],L), writeln((M,X,L)), fail.\n    _g66 , 1 , [_g66, 1]\n    _g66 , _g66 , [1, _g66]\n    _g66 , _g72 , [1, _g66]\n    no (more) solution.\n    \n    [eclipse]: select(3,[1,3,5,3],L).\n    L = [1, 5, 3]    More? (;)\n    L = [1, 3, 5]\n    yes.\n    \n    [eclipse]: select(X,L,[a,b]), writeln((X,L)), fail.\n    _g66 , [_g66, a, b]\n    _g66 , [a, _g66, b]\n    _g66 , [a, b, _g66]\n    no (more) solution.\n    \n    select(X,[1,2],L).   (gives X=1 L=[2]; X=2 L=[1]).\n\nFail:\n    select(1,[1,2,1,3],[2,3]).\n\t\n\nSee Also\n   subtract / 3, member / 2"},"lists:shuffle/2":{"prefix":"shuffle","body":"shuffle(${1:List}, ${2:ShuffledList})$3\n$0","description":"shuffle(+List, ?ShuffledList)\n\n   Shuffle a list, ie randomize the element order\n\nType\n   library(lists)\n\nModes and Determinism\n   shuffle(+, -) is det\n\nSee Also\n   msort / 2"},"lists:splice/3":{"prefix":"splice","body":"splice(${1:Odds}, ${2:Evens}, ${3:List})$4\n$0","description":"splice(?Odds, ?Evens, ?List)\n\n   Merge two lists by interleaving the elements\n\nArguments\n   Odds    List or variable\n   Evens    List or variable\n   List    Variable or list\n\nType\n   library(lists)\n\nDescription\nCreate a new list by alternating elements from two input lists,\n    \tstarting with the first. When one input list is longer, its extra\n\telements form the tail of the result list.\n\t\n\tThe reverse mode splice(-,-,+) is nondeterministic, and\n\tthe most balanced solution(s) will be found first.\n\nModes and Determinism\n   splice(+, +, -) is det\n   splice(-, -, +) is multi\n\nExamples\n   ?- splice([1,2,3], [a,b,c], X).\nX = [1, a, 2, b, 3, c]\nYes (0.00s cpu)\n\n?- splice([1,2,3], [a,b,c,d,e], X).    \nX = [1, a, 2, b, 3, c, d, e]\nYes (0.00s cpu)\n\n?- splice(A, B, [1,a,2,b,3,c]).\nA = [1, 2, 3]\nB = [a, b, c]\nMore (0.00s cpu) ? ;\nA = [1, 2, 3, c]\nB = [a, b]\nMore (0.00s cpu) ? ;\nA = [1, 2]\nB = [a, b, 3, c]\nMore (0.00s cpu) ? ;\nA = [1, 2, b, 3, c]\nB = [a]\nMore (0.00s cpu) ? ;\nA = [1]\nB = [a, 2, b, 3, c]\nMore (0.00s cpu) ? ;\nA = [1, a, 2, b, 3, c]\nB = []\nMore (0.00s cpu) ? ;\nA = []\nB = [1, a, 2, b, 3, c]\nYes (0.00s cpu)\n\nSee Also\n   merge / 3"},"lists:subtract/3":{"prefix":"subtract","body":"subtract(${1:List1}, ${2:List2}, ${3:Remainder})$4\n$0","description":"subtract(+List1, +List2, ?Remainder)\n\n   Succeeds if Remainder is the list which contains those elements of List1\nwhich are not in List2.\n\nArguments\n   +List1    List.\n   +List2    List.\n   ?Remainder    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Unifies Remainder with a list containing those elements of List1 which\n   are not in List2.\n\n   The definition of this Prolog library Predicate is:\n\nsubtract([], _, []).\nsubtract([Head|Tail], L2, L3) :-\n    memberchk(Head, L2),\n    !,\n    subtract(Tail, L2, L3).\nsubtract([Head|Tail1], L2, [Head|Tail3]) :-\n    subtract(Tail1, L2, Tail3).\n\n   This predicate does not perform any type testing functions.\n\n   This predicate works properly for set operations only, so repeated\n   elements and variable elements should not be used.\n\t\n\nModes and Determinism\n   subtract(+, +, -) is det\n\nFail Conditions\n      Fails if if Remainder does not unify with the list which contains those\n   elements of List1 which are not in List2.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n   subtract([1,2,3,4],[1],R).     (gives R=[2,3,4]).\n   subtract([1,2,3],[3,4],R).     (gives R=[1,2]).\n   subtract([1,1,2,3],[2],[1,1,3]).\nFail:\n   subtract([1,1,2,3],[1],[1,2,3]). % Fails - List2 and\n    % Remainder share elements\n\nSee Also\n   intersection / 3, union / 3"},"lists:subset/2":{"prefix":"subset","body":"subset(${1:SubList}, ${2:List})$3\n$0","description":"subset(?SubList, +List)\n\n   Succeeds if List is the list which contains all elements from SubList in\nthe same order as in SubList.\n\nArguments\n   ?SubList    A term which unifies with a list.\n   +List    A term which unifies with a list.\n\nType\n   library(lists)\n\nDescription\n   Used to test if a specified list contains all elements of another list,\n   or to generate all sublists of a given list.\n\n   The definition of this Prolog library predicate is:\n\n    subset([],[]).\n    subset([X|L],[X|S]) :-\n    subset(L,S).\n    subset(L, [_|S]) :-\n    subset(L,S).\n\n   This predicate does not perform any type testing functions.\n\n   This predicate works properly for set operations only, so repeated\n   elements, variable elements and unsorted lists should not be used.\n\t\n\nModes and Determinism\n   subset(-, +) is multi\n\nFail Conditions\n      Fails if SubList does not unify with a list whose elements are all\n   contained in List in the same order as in SubList.\n\nResatisfiable\n      Yes.\n\nExamples\n   \nSuccess:\n      subset([1,3], [1,2,3]).\n      subset(X, [1,3,4]).    % backtracks over all subsets\n\nFail:\n      subset([2,1], [1,2,3]).   % different order\n\nSee Also\n   union / 3, subtract / 3, intersection / 3"},"matrix_util:concat/2":{"prefix":"concat","body":"concat(${1:RowsOrCols}, ${2:List})$3\n$0","description":"concat(+RowsOrCols, -List)\n\n   Concatenate all the rows (or columns) into a flat list\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- list2rows([1,2,3,4,5,6],2,3,Rows), concat(Rows,Xs).\n    Rows = [[1, 2, 3], [4, 5, 6]]\n    Xs = [1, 2, 3, 4, 5, 6]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   list2rows / 4, list2cols / 4, transpose / 2"},"make_overlap_bivs:make_overlap_bivs/5":{"prefix":"make_overlap_bivs","body":"make_overlap_bivs(${1:Tasks}, ${2:BivLists}, ${3:BivSums}, ${4:Resource}, ${5:Options})$6\n$0","description":"make_overlap_bivs(+Tasks, -BivLists, -BivSums, ++Resource, ++Options)\n\n   Make a set of overlap bivalued variables for a set of tasks.\nIntroduce a set of 'bivalued sum' variables, equal to the sum of the binaries at\nan overlap.  The bivalued sum variables represent the total resources needed\n\nArguments\n   Tasks    A list of task structures - see library(probe_support)\n   BivLists    A list of lists of integer variables\n   BivSums    A list of integer variables, each one the sum of a list \n    of binaries\n   Resource    An integer quantity of resource available\n   Options    An options structure\n\nType\n   library(make_overlap_bivs)\n\nDescription\n\n    Based on the tentative assignments, probe_search finds a task\n    start time where the resources are not sufficient to make the\n    tentative assignment feasible.  In case a bottleneck task has a\n    variable resource requirement, this is reduced to its minimum\n    possible value. Otherwise, probe_search chooses a bivalued\n    'overlap' variable at this bottleneck and using add_con it adds \n    a constraint trying to eliminate the overlap.\n\nResatisfiable\n   no\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, probe : add_con / 3, ic_probe : add_con / 3"},"lists:union/3":{"prefix":"union","body":"union(${1:List1}, ${2:List2}, ${3:Union})$4\n$0","description":"union(+List1, +List2, ?Union)\n\n   Succeeds if Union is the list which contains the union of elements in List1\nand those in List2.\n\nArguments\n   +List1    List.\n   +List2    List.\n   ?Union    List or variable.\n\nType\n   library(lists)\n\nDescription\n   Used to create the list of elements in List1 and not in List2, added to\n   those in List2.\n\n   The definition of this Prolog library predicate is:\n\nunion([], L, L).\nunion([Head|L1tail], L2, L3) :-\n    memberchk(Head, L2),\n    !,\n    union(L1tail, L2, L3).\nunion([Head|L1tail], L2, [Head|L3tail]) :-\n    union(L1tail, L2, L3tail).\n\n   This predicate does not perform any type testing functions.\n\n   This predicate works properly for set operations only, so repeated\n   elements and variable elements should not be used.\n\t\n\nModes and Determinism\n   union(+, +, -) is det\n\nFail Conditions\n      Fails if Union does not unify with the list which contains the union of\n   elements in List1 and those in List2.\n\nResatisfiable\n      No.\n\nExamples\n   \nSuccess:\n      union([1,2,3],[1,3],L).     (gives L=[2,1,3]).\n\nFail:\n      union([1,2,3,2],[1,3],[1,2,3]).  % repeated elements\n\nSee Also\n   subtract / 3, intersection / 3"},"matrix_util:list2rows/4":{"prefix":"list2rows","body":"list2rows(${1:List}, ${2:NRows}, ${3:NCols}, ${4:Rows})$5\n$0","description":"list2rows(+List, +NRows, +NCols, -Rows)\n\n   Create a matrix from a flat list of row-wise listed elements\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- list2rows([1,2,3,4,5,6],2,3,Rows).\n    Rows = [[1, 2, 3], [4, 5, 6]]\n    Yes (0.00s cpu)"},"matrix_util:list2cols/4":{"prefix":"list2cols","body":"list2cols(${1:List}, ${2:NRows}, ${3:NCols}, ${4:Cols})$5\n$0","description":"list2cols(+List, +NRows, +NCols, -Cols)\n\n   Create a matrix from a flat list of row-wise listed elements\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- list2cols([1,2,3,4,5,6],2,3,Cols).\n    Cols = [[1, 4], [2, 5], [3, 6]]\n    Yes (0.00s cpu)"},"matrix_util:matrix/3":{"prefix":"matrix","body":"matrix(${1:NRow}, ${2:NCols}, ${3:Rows})$4\n$0","description":"matrix(+NRow, +NCols, -Rows)\n\n   Create a matrix as a list of rows\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- matrix(2,3,M).\n    M = [[_175, _177, _179], [_183, _185, _187]]\n    Yes (0.00s cpu)"},"matrix_util:matrix/4":{"prefix":"matrix","body":"matrix(${1:NRows}, ${2:NCols}, ${3:Rows}, ${4:Cols})$5\n$0","description":"matrix(+NRows, +NCols, -Rows, -Cols)\n\n   Create a matrix as both a list of rows and a list of columns\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- matrix(2,3,Rows,Cols).\n    Rows = [[_183, _185, _187], [_191, _193, _195]]\n    Cols = [[_183, _191], [_185, _193], [_187, _195]]\n    Yes (0.00s cpu)"},"max_flow:max_flow/5":{"prefix":"max_flow","body":"max_flow(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue})$6\n$0","description":"max_flow(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue)\n\n   Ford-Fulkerson maximum flow algorithm\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n\nType\n   library(max_flow)\n\nDescription\nThis predicate provides an implementation of the Ford-Fulkerson max-flow algorithm between two nodes in a graph. It returns the maximal achievable flow allowed by the capacities in the network.\n\nFail Conditions\n   There is no feasible flow between Source and Sink nodes (they are not connected).\n\nSee Also\n   max_flow / 5, max_flow / 7, max_flow_with_lb / 6, max_flow_with_lb / 8, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"matrix_util:read_data/3":{"prefix":"read_data","body":"read_data(${1:File}, ${2:List}, ${3:Length})$4\n$0","description":"read_data(+File, ?List, -Length)\n\n   Read numbers from a file into List\n\nType\n   library(matrix_util)\n\nDescription\nRead numbers from a file into List until either the list is full or\n    the end of file has been reached. In the first case, not all numbers in the\n    file may be read, in the second, the list may not be fully instantiated.\n    The count of numbers that have actually been read is returned in Length.\n    \n\nSee Also\n   list2rows / 4, list2cols / 4, transpose / 2"},"max_flow:feas_flow_with_lb/8":{"prefix":"feas_flow_with_lb","body":"feas_flow_with_lb(${1:Graph}, ${2:LowerBoundArg}, ${3:CapacityArg}, ${4:SourceNode}, ${5:SinkNode}, ${6:FlowValue}, ${7:FlowEdges}, ${8:FlowEdgesGraph})$9\n$0","description":"feas_flow_with_lb(+Graph, +LowerBoundArg, +CapacityArg, +SourceNode, +SinkNode, -FlowValue, -FlowEdges, -FlowEdgesGraph)\n\n   Finds a feasible flow for a network with non-negative lower-bounds imposed on the edge flows,using an adapted Ford-Fulkerson maximum flow algorithm\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData), EdgeData must be a structure with at least two arguments (for the lower and upper bounds of the edge capacity\n   LowerBoundArg       which argument of EdgeData to use as the minimum flow (lower bound) for edge (integer) \n   CapacityArg    which argument of EdgeData to use as (uppoer bound) edge capacity (integer),\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   FlowValue    value of the  flow\n   FlowEdges    list denoting edges with non-zero flow (form: Flow-Edge)\n   FlowEdgesGraph      a graph structure, original nodes (as in Graph) but only the edges that are in max flow\n\nType\n   library(max_flow)\n\nDescription\nThis predicate returns a feasible flow for a network whose edges can have a (non-negative) lower bound imposed on the edge flows. This is done by transforming the network to one with zero lower-bounds and solving for feasibility. Normally this will serve as the starting point for obtaining the maximal flow for the original network, but this predicate is provided for cases where a feasible solution is sufficient. If there is a feasible solution, it returns the total flow  value for this solution, a list of all edges with  flow, and a graph of the edges with non-zero flow. It  fails if there are no feasible flow.\n\nFail Conditions\n   There is no feasible flow from Source to Sink\n\nSee Also\n   max_flow_with_lb / 8, max_flow / 5, max_flow / 7"},"matrix_util:transpose/2":{"prefix":"transpose","body":"transpose(${1:Matrix}, ${2:Transposed})$3\n$0","description":"transpose(+Matrix, -Transposed)\n\n   Transpose a matrix (list of rows or list of columns)\n\nType\n   library(matrix_util)\n\nExamples\n   \n    ?- list2rows([1,2,3,4,5,6],2,3,Rows), transpose(Rows,Cols).\n    Rows = [[1, 2, 3], [4, 5, 6]]\n    Cols = [[1, 4], [2, 5], [3, 6]]\n    Yes (0.00s cpu)"},"max_flow:max_flow/7":{"prefix":"max_flow","body":"max_flow(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue}, ${6:MaxFlowEdges}, ${7:MaxFlowEdgesGraph})$8\n$0","description":"max_flow(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue, -MaxFlowEdges, -MaxFlowEdgesGraph)\n\n   Ford-Fulkerson maximum flow algorithm\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n   MaxFlowEdges    list denoting edges with non-zero flow (form: Flow-Edge)\n   MaxFlowEdgesGraph   a graph structure, original nodes (as in Graph) but only the edges that are in max flow\n\nType\n   library(max_flow)\n\nDescription\nThis predicate provides an implementation of the Ford-Fulkerson max-flow algorithm between two nodes in a graph. It returns the maximal achievable flow allowed by the capacities in the network, a list of all edges with non-zero flow, and a graph of the edges with non-zero flow.\n\nFail Conditions\n   There is no feasible flow between Source and Sink nodes (they are not connected).\n\nSee Also\n   max_flow / 5, max_flow / 7, max_flow_with_lb / 6, max_flow_with_lb / 8, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"matrix_util:matrix_util_desc":{"prefix":"lib","body":"lib(${1:matrix_util})$2\n$0","description":"lib(matrix_util)\n\nThis library contains predicates for representing and manipulating matrices as nested lists.  Both list of rows and list of columns can be created and mapped into each other.Note that newer versions of ECLiPSe have good support for representing matrices as multi-dimensional arrays, which is often preferrable to the list representation used here."},"mode_analyser:reset/0":{"prefix":"reset","body":"reset","description":"reset\n\n   Reset the mode analysis results for predicates compiled \n   into the calling context module.\n\nArguments\n\nType\n   library(mode_analyser)\n\nDescription\n\n   This predicate erases all mode analysis data for every predicate that \n   has been compiled into the calling context module using the mode \n   analysis compiler.  The predicate is a tool and as such can be \n   invoked for an arbitrary module using mode_analyser:reset@Module.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   no\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Calling context module is not instantiated\n\nExamples\n   \n   [eclipse 6]: mode_analyser:reset@eclipse.\n\n   Yes (0.00s cpu)\n\nSee Also\n   analyse / 1, result / 0, result / 1"},"max_flow:max_flow_with_lb/6":{"prefix":"max_flow_with_lb","body":"max_flow_with_lb(${1:Graph}, ${2:LowerBoundArg}, ${3:CapacityArg}, ${4:SourceNode}, ${5:SinkNode}, ${6:MaxFlowValue})$7\n$0","description":"max_flow_with_lb(+Graph, +LowerBoundArg, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue)\n\n   Finds rhe maximum flow for a network with non-negative lower-bounds imposed on the edge flows,using an adapted Ford-Fulkerson maximum flow algorithm\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   LowerBoundArg       which argument of EdgeData to use as the minimum flow (lower bound) for edge (integer) \n   CapacityArg    which argument of EdgeData to use as edge capacity (integer),\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n\nType\n   library(max_flow)\n\nDescription\nThis predicate provides an implementation of the Ford-Fulkerson max-flow algorithm between two nodes in a graph, modified to allow edges to have non-negative minimum flows. It returns the maximal achievable flow allowed by the capacities in the network.\n\nFail Conditions\n   There is no feasible flow between Source and Sink nodes.\n\nSee Also\n   max_flow_with_lb / 8, max_flow / 5, max_flow / 7, feas_flow_with_lb / 8, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5"},"mode_analyser:result/0":{"prefix":"result","body":"result","description":"result\n\n   Produce the mode analysis results for predicates \n   compiled into the calling context module.\n\nArguments\n\nType\n   library(mode_analyser)\n\nDescription\n\n   This predicate displays the suggested invocation modes for each \n   predicate compiled using the mode analyser into the calling context module. \n   The suggested mode annotations can be passed to the mode/1 directive for \n   the associated predicate. The predicate is a tool and as such can be \n   invoked for an arbitrary module using mode_analyser:result@Module.\n   \n   The possible argument modes produced for each argument of each \n   predicate are: \n   \n   +   The argument is instantiated, i.e. it is not a variable.\n   \n   ++  The argument is ground.\n   \n   -   The argument is not instantiated, it must be a free variable without \n       any constraints, especially it must not occur in any other argument \n       and it cannot be a suspending variable. \n   \n   ?   The mode is not known or it is neither of the above ones.\n   \n   NOTE: It is imperative to understand that the results of mode analysis \n   are merely suggestions for the invocation modes of a predicate based on \n   runtime information. If there are potential predicate invocation modes \n   that were not exercised during runtime, the tool is unable to account \n   for them in its analysis. For the mode specifier '-' the mode analyser\n   does not determine whether the variable occurs in any other argument\n   (i.e. is aliased), this must be manually verified. \n   In summary, the programmer must verify that the suggested modes are correct \n   before using the directive in the code.  If the instantiation of the \n   predicate call violates its mode declaration, no exception is raised and \n   its behaviour is undefined.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   No predicates have been compiled with the mode analyser \n   into the calling context module.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Calling context module is not instantiated\n\nExamples\n   \n   [eclipse 2]: nqueens(8, Qs).\n   L = [1, 5, 8, 6, 3, 7, 2, 4]\n   Yes (0.00s cpu, solution 1, maybe more) ?\n\n   ...\n   ...\n\n   Yes (0.10s cpu)\n\n   [eclipse 5]: mode_analyser:result.\n    nqueens(++, -)\n    noattack(?, ?)\n    safe(+)\n    noattack(?, +, ++)\n\n   Yes (0.00s cpu)\n\nSee Also\n   analyse / 1, result / 1, reset / 0"},"max_flow:max_flow_with_lb/8":{"prefix":"max_flow_with_lb","body":"max_flow_with_lb(${1:Graph}, ${2:LowerBoundArg}, ${3:CapacityArg}, ${4:SourceNode}, ${5:SinkNode}, ${6:MaxFlowValue}, ${7:MaxFlowEdges}, ${8:MaxFlowEdgesGraph})$9\n$0","description":"max_flow_with_lb(+Graph, +LowerBoundArg, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue, -MaxFlowEdges, -MaxFlowEdgesGraph)\n\n   Finds rhe maximum flow for a network with non-negative lower-bounds imposed on the edge flows,using an adapted Ford-Fulkerson maximum flow algorithm\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   LowerBoundArg       which argument of EdgeData to use as the minimum flow (lower bound) for edge (integer) \n   CapacityArg    which argument of EdgeData to use as edge capacity (integer),\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n   MaxFlowEdges    list denoting edges with non-zero flow (form: Flow-Edge)\n   MaxFlowEdgesGraph   a graph structure, original nodes (as in Graph) but only the edges that are in max flow\n\nType\n   library(max_flow)\n\nDescription\nThis predicate provides an implementation of the Ford-Fulkerson max-flow algorithm between two nodes in a graph, modified to allow edges to have non-negative minimum flows. It returns the maximal achievable flow allowed by the capacities in the network, a list of all edges with non-zero flow, and a graph of the edges with non-zero flow.\n\nFail Conditions\n   There is no feasible flow between Source and Sink nodes.\n\nSee Also\n   max_flow_with_lb / 6, max_flow / 5, max_flow / 7, feas_flow_with_lb / 8, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5"},"mode_analyser:analyse/1":{"prefix":"analyse","body":"analyse(${1:File})$2\n$0","description":"analyse(+File)\n\n   Compile a file, inserting invocation mode analysis \n   instrumentation for each predicate definition.\n\nArguments\n   File    Atom or string\n\nType\n   library(mode_analyser)\n\nDescription\n    \n   The mode analyser is a variant of the ECLiPSe that inserts \n   instrumentation into the clause definitions of predicates\n   (defined in the named file) during compilation in order to record mode \n   usage of each predicate argument. The code is then run as many times \n   as is necessary to capture the most common invocations of each \n   predicate undergoing analysis. Finally, the results are analysed, \n   using mode_analyser:result/0, to produce suggested mode/1 \n   directives for each predicate.\n   \n   The mode/1 directive informs the compiler that the arguments of the \n   specified predicate will always have the corresponding form when the \n   predicate is called.  The compiler utilises this information during \n   compilation of the predicate in order to generate more compact and/or \n   faster code. Specifying the mode of a predicate that has already been \n   compiled has no effect, unless it is recompiled. If the specified \n   procedure does not exist, a local undefined procedure is created.\n   \n   NOTE: It is imperative to understand that the results of mode analysis \n   are merely suggestions for the invocation modes of a predicate based on \n   runtime information. If there are potential predicate invocation modes \n   that were not exercised during runtime, the tool is unable to account \n   for them in its analysis. For the mode specifier '-' the mode analyser\n   does not determine whether the variable occurs in any other argument\n   (i.e. is aliased), this must be manually verified. \n   In summary, the programmer must verify that the suggested modes are correct \n   before using the directive in the code.  If the instantiation of the \n   predicate call violates its mode declaration, no exception is raised and \n   its behaviour is undefined.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   no\n\nExceptions\n     5 --- File is not an atom or string\n\nExamples\n   \n   [eclipse 1]: mode_analyser:analyse('queens_gfc.pl').\n   queens_gfc.pl compiled traceable 13920 bytes in 0.10 seconds\n\n   Yes (0.10s cpu)\n\nSee Also\n   result / 0, result / 1, reset / 0"},"module_options:get_options/2":{"prefix":"get_options","body":"get_options(${1:OptionList}, ${2:OptionStruct})$3\n$0","description":"get_options(+OptionList, -OptionStruct)\n\n   Create a structure OptionStruct from OptionList and the context module's default settings\n\nArguments\n   OptionList    List of Name:Value pairs\n   OptionStruct    Variable, will be bound to a structure\n\nType\n   library(module_options)\n\nDescription\n\n    The exact behaviour of this predicate depends on the module from where\n    it is invoked: It returns a structure OptionStruct, whose skeleton and\n    default field values are defined by the predicate default_options/1 in\n    the context module. Moreover, OptionList is analysed, and any option\n    values specified there will show up in the corresponding fields of the\n    returned structure OptionStruct, instead of the default values defined\n    by default_options/1.\n\n    The option names in OptionList must be valid according to the predicate\n    valid_option_field/2 in the context module, and the corresponding values\n    must be valid according to valid_option_value/2.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   OptionList contains illegal names or values\n\nSee Also\n   library(module_options), set_default_option / 2, print_default_options / 1"},"mode_analyser:mode_analyser_desc":{"prefix":"lib","body":"lib(${1:mode_analyser})$2\n$0","description":"lib(mode_analyser)\n\n    The mode_analyser library is a tool that assists in the determination of\n    the mode/1 directive for predicate definitions. This directive informs\n    the compiler that the arguments of the specified predicate will always \n    have the corresponding form when the predicate is called. The compiler \n    utilises this information during compilation of the predicate in order\n    to generate more compact and/or faster code. Specifying the mode of a \n    predicate that has already been compiled has no effect, unless it is \n    recompiled. If the specified procedure does not exist, a local\n    undefined procedure is created.\n\n    The mode analyser inserts instrumentation into the clause definitions of\n    predicates during compilation in order to record mode usage of each \n    predicate argument. The code should then be run (as many times as is\n    necessary to capture the most common invocations of each predicate \n    undergoing analysis). Finally, the results of the analysis are requested\n    and the suggested mode annotations for each predicate are displayed.\n\n    NOTE: It is imperative to understand that the results of mode analysis \n    are merely suggestions for the invocation modes of a predicate based on \n    runtime information. If there are potential predicate invocation modes \n    that were not exercised during runtime, the tool is unable to account \n    for them in its analysis. For the mode specifier '-' the mode analyser\n    does not determine whether the variable occurs in any other argument\n    (i.e. is aliased), this must be manually verified. \n    In summary, the programmer must verify that the suggested modes are correct \n    before using the directive in the code.  If the instantiation of the \n    predicate call violates its mode declaration, no exception is raised and \n    its behaviour is undefined.\n\n\tThe usage is as follows:\n\t\n\tLoad the mode_analyser library\n\t\n\t?- lib(mode_analyser).\n\t\n\tCompile your program with the mode analyser compiler\n    \n\t?- mode_analyser:analyse(my_program).\n\t\n\tRun the query for which you wish to generate mode analysis data\n\t\n\t?- my_query(X,Y,Z).\n\t\n\tGenerate the results for the module into which the program\n    was compiled.\n\t\n\t?- mode_analyser:result(my_program_module).\n\t\n\n\tLimitations to be resolved shortly: \n\t\n    A future enhancement will enable the insertion of the suggested \n    (or programmer ammended) mode/1 directives for each predicate\n    definition into the source code."},"mode_analyser:result/1":{"prefix":"result","body":"result(${1:OptionList})$2\n$0","description":"result(+OptionList)\n\n   Produce the mode analysis results for predicates\n   compiled into the calling context module.\n\nArguments\n   OptionList    List of Name:Value pairs\n\nType\n   library(mode_analyser)\n\nDescription\n\n   This predicate displays the suggested invocation modes for each predicate \n   compiled using the mode analyser into the calling context module. \n   The suggested mode annotations can be passed to the mode/1 directive for \n   the associated predicate. The predicate is a tool and as such can be \n   invoked for an arbitrary module using mode_analyser:result@Module.\n   \n   OptionList may contain the following options:\n   \n   verbose (default:off)\n   If set to 'on', the mode analyser will print details of argument \n   invocation modes for each argument of every predicate compiled into \n   the module with the mode analyser.\n   \n   The possible argument modes produced for each argument of each \n   predicate are: \n   \n   +   The argument is instantiated, i.e. it is not a variable.\n   \n   ++  The argument is ground.\n   \n   -   The argument is not instantiated, it must be a free variable without \n       any constraints, especially it must not occur in any other argument \n       and it cannot be a suspending variable. \n   \n   *   The argument is an attributed variable that may have constraints \n       or is a suspending variable. This detail is not a valid argument mode\n       to the mode/1 directive and is printed merely for interest. As a result\n       the actual argument mode will appear as '?'.\n   \n   ?   The mode is not known or it is neither of the above ones.\n   \n   NOTE: It is imperative to understand that the results of mode analysis \n   are merely suggestions for the invocation modes of a predicate based on \n   runtime information. If there are potential predicate invocation modes \n   that were not exercised during runtime, the tool is unable to account \n   for them in its analysis. For the mode specifier '-' the mode analyser\n   does not determine whether the variable occurs in any other argument\n   (i.e. is aliased), this must be manually verified. \n   In summary, the programmer must verify that the suggested modes are correct \n   before using the directive in the code.  If the instantiation of the \n   predicate call violates its mode declaration, no exception is raised and \n   its behaviour is undefined.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   No predicates have been compiled with the mode analyser \n   into the calling context module.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Calling context module is not instantiated\n\nExamples\n   \n   [eclipse 2]: nqueens(8, Qs).\n   L = [1, 5, 8, 6, 3, 7, 2, 4]\n   Yes (0.00s cpu, solution 1, maybe more) ?\n   ...\n   ...\n   Yes (0.10s cpu)\n   [eclipse 5]: mode_analyser:result([verbose:on]).\n\n   Mode analysis for eclipse : nqueens / 2:\n    Results for argument 1:\n    -: 0    *: 0    +: 0    ++: 1\n    Results for argument 2:\n    -: 1    *: 0    +: 0    ++: 0\n\n    nqueens(++, -)\n\n   Mode analysis for eclipse : noattack / 2:\n    Results for argument 1:\n    -: 0    *: 8    +: 0    ++: 0\n    Results for argument 2:\n    -: 0    *: 0    +: 7    ++: 1\n\n    noattack(?, ?)\n\n   Mode analysis for eclipse : safe / 1:\n    Results for argument 1:\n    -: 0    *: 0    +: 8    ++: 0\n\n    safe(+)\n\n   Mode analysis for eclipse : noattack / 3:\n    Results for argument 1:\n    -: 0    *: 28   +: 0    ++: 0\n    Results for argument 2:\n    -: 0    *: 0    +: 28   ++: 0\n    Results for argument 3:\n    -: 0    *: 0    +: 0    ++: 28\n\n    noattack(?, +, ++)\n\n   Yes (0.00s cpu)\n\nSee Also\n   analyse / 1, result / 0, reset / 0"},"module_options:module_options_desc":{"prefix":"lib","body":"lib(${1:module_options})$2\n$0","description":"lib(module_options)\n\n\tThis library provides utilities to manage option settings on behalf\n\tof other library modules. The basic idea is that each client module\n\tcan define what it considers to be valid option names and values, plus\n\tthe structure in terms of which the set of all options will be stored\n\tand returned.\n\n\tFor each client library, global default option settings are maintained\n\twhich can be modified (in a non-backtrackable fashion) using\n\tset_default_option/2. Whenever the settings are retrieved, the\n\tdefaults can be individually overridden using a user-supplied option\n\tlist.\n\n\tEvery client module has to define 3 local predicates:\n\n\tvalid_option_field(?Name, -FieldIndex)\n\t    defines the option names (atoms) and the position (integer)\n\t    of the option value within an option structure.\n\tvalid_option_value(+Name, +Value)\n\t    defines what constitues a valid option value, by\n\t    provides a type/range check for Value. The predicate should\n\t    fail if Value is not a valid value for option Name.\n\tdefault_options(-OptionStructure)\n\t    this should be a single fact which should return a structure.\n\t    The structure arguments define the initial default settings\n\t    for each option field. The structure's functor defines the\n\t    skeleton in terms of which option settings will be returned\n\t    by get_options/2.\n\t    Note that the structure can have extra fields which are\n\t    not defined as valid options, are not user-modifiable, and\n\t    will therefore always be returned unchanged by get_options/2.\n\n\tA typical application would in addition define a toplevel predicate\n\tthat accepts a user-supplied option list per invocation, and possibly\n\ta predicate to modify the global default settings.  Sample usage:\n\n\t:- module(my_module).\n\n\t:- lib(module_options).\n\n\tvalid_option_field(a, 1).\n\tvalid_option_field(b, 2).\n\tvalid_option_field(c, 3).\n\n\tvalid_option_value(a, Value) :- integer(Value).\n\tvalid_option_value(b, Value) :- atom(Value).\n\tvalid_option_value(c, Value) :- atom(Value).\n\n\tdefault_options(options(23,hello,world,there)).\n\n\t:- export my_set_default_option/2.\n\tmy_set_default_option(Name, Value) :-\n\t    set_default_option(Name, Value).\n\n\t:- export my_predicate/2.\n\tmy_predicate(Arguments, OptionList) :-\n\t    ( get_options(OptionList, OptionStruct) ->\n\t\t...\n\t    ;\n\t\tprintf(error, \"Invalid option list: %w%n\", [OptionList]),\n\t\tprint_default_options(error),\n\t\tabort\n\t    ).\n\n\tIn practice, it is recommended to use structure notation for the\n\toption structure for better readability and maintainability, i.e.\n\n\t:- module(my_module).\n\n\t:- lib(module_options).\n\n\t:- local struct(options(a,b,c,d)).\n\n\tvalid_option_field(a, a of options).\n\tvalid_option_field(b, b of options).\n\tvalid_option_field(c, c of options).\n\n\tvalid_option_value(a, Value) :- integer(Value).\n\tvalid_option_value(b, Value) :- atom(Value).\n\tvalid_option_value(c, Value) :- atom(Value).\n\n\tdefault_options(options{a:23,b:hello,c:world,d:there}).\n\n\t:- export my_set_default_option/2.\n\tmy_set_default_option(Name, Value) :-\n\t    set_default_option(Name, Value).\n\n\t:- export my_predicate/2.\n\tmy_predicate(Arguments, OptionList) :-\n\t    ( get_options(OptionList, OptionStruct) ->\n\t\t...\n\t    ;\n\t\tprintf(error, \"Invalid option list: %w%n\", [OptionList]),\n\t\tprint_default_options(error),\n\t\tabort\n\t    ).\n\n\tIt is not absulotely necessary to define a predicate like\n\tmy_set_default_option/2 since my_set_default_option(opt,val)\n\tis equivalent to set_default_option(opt,val)@my_module."},"module_options:set_default_option/2":{"prefix":"set_default_option","body":"set_default_option(${1:OptionName}, ${2:OptionValue})$3\n$0","description":"set_default_option(+OptionName, +OptionValue)\n\n   Permanently set the default value for the given option in the context module\n\nArguments\n   OptionName    An atom\n   OptionValue    A valid option term\n\nType\n   library(module_options)\n\nDescription\n\n    The exact behaviour of this predicate depends on the module from where\n    it is invoked: It changes the default value for a named option in the\n    context module. The initial default values are defined by the predicate\n    default_options/1 in the context module.\n\n    The option name OptionName must be valid according to the predicate\n    valid_option_field/2 in the context module, and OptionValue\n    must be valid according to valid_option_value/2.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n     4 --- OptionName or OptionValue are uninstantiated\n     5 --- OptionName is not an atom\n     6 --- OptionName is not a valid option, or OptionValue is not a valid value in the context module\n\nSee Also\n   library(module_options), get_options / 2, print_default_options / 1"},"multifile:multifile_desc":{"prefix":"lib","body":"lib(${1:multifile})$2\n$0","description":"lib(multifile)\n\n\tThis library implements the multifile/1 declaration, and allows clauses\n\tfor multifile predicates to be prefixed with their module name."},"module_options:print_default_options/1":{"prefix":"print_default_options","body":"print_default_options(${1:Stream})$2\n$0","description":"print_default_options(+Stream)\n\n   Print the valid options and their current default values to Stream\n\nArguments\n   Stream    An output stream\n\nType\n   library(module_options)\n\nDescription\n\n    The exact behaviour of this predicate depends on the module from where\n    it is invoked: It prints a list of the valid options and their current\n    default values onto the stream Stream.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   library(module_options), get_options / 2, set_default_option / 2"},"notify_ports:close_sender/1":{"prefix":"close_sender","body":"close_sender(${1:SendPort})$2\n$0","description":"close_sender(+SendPort)\n\n   Close a send port\n\nArguments\n   SendPort    a send port structure\n\nType\n   library(notify_ports)"},"notify_ports:close_sender/2":{"prefix":"close_sender","body":"close_sender(${1:Pos}, ${2:Struct})$3\n$0","description":"close_sender(+Pos, +Struct)\n\n   Close a send port on a structure field\n\nArguments\n   Pos    positive integer, the send port's field number in Struct\n   Struct    a structure whose Pos-th field is a send port\n\nType\n   library(notify_ports)"},"notify_ports:foreachnotification/6":{"prefix":"foreachnotification","body":"foreachnotification(${1:BaseName}, ${2:Message}, ${3:Params}, ${4:ReceivePort}, ${5:Status}, ${6:Goals})$7\n$0","description":"foreachnotification(+BaseName, -Message, +Params, +ReceivePort, -Status, +Goals)\n\n   A control construct to iterate over received notifications\n\nArguments\n   BaseName    an atom used as the basename for the generated auxiliary predicate\n   Message    a variable\n   Params    a list of global variables in the iteration body (as in do/2)\n   ReceivePort    a receiver structure as created by open_receiver\n   Status    a variable, will be bound to 'open' or 'closed'\n   Goals    the goals that will be called for each iteration\n\nType\n   library(notify_ports)\n\nDescription\n\n    This is a control construct iterating over the currently available\n    messages on the given receive port. The purpose is to process the\n    received messages one by one without the need to create an auxiliary\n    list of received messages. The iteration terminates when there are\n    (currently) no more message on the receive port.\n    \n    When the iteration terminates, the Status argument indicates whether\n    the associated sender is still open ('open') or has been closed\n    ('closed'). If closed, no more messages will arrive on this receive\n    port in the future.\n    \n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n\tprocess_all_messages(ReceivePort, Log) :-\n\t    foreachnotification(sample, Message, [Log], ReceivePort, Status, (\n\t\twriteln(Log, received(Message)),\n\t\tdo_something(Message)\n\t    )),\n\t    ( Status = closed ->\n\t\twriteln(Log, end_of_messages)\n\t    ;\n\t\twriteln(Log, more_coming)\n\t    ).\n    \n\nSee Also\n   receive_notifications / 3"},"notify_ports:foreachnotification/7":{"prefix":"foreachnotification","body":"foreachnotification(${1:BaseName}, ${2:Message}, ${3:Params}, ${4:ReceivePos}, ${5:ReceiveStruct}, ${6:Status}, ${7:Goals})$8\n$0","description":"foreachnotification(+BaseName, -Message, +Params, +ReceivePos, +ReceiveStruct, -Status, +Goals)\n\n   A control construct to iterate over received notifications\n\nArguments\n   BaseName    an atom used as the basename for the generated auxiliary predicate\n   Message    a variable\n   Params    a list of global variables in the iteration body (as in do/2)\n   ReceivePos    positive integer, the send port's field number in ReceiveStruct\n   ReceiveStruct       a structure\n   Status    a variable, will be bound to 'open' or 'closed'\n   Goals    the goals that will be called for each iteration\n\nType\n   library(notify_ports)\n\nDescription\n\n    This is a control construct iterating over the currently available\n    messages on the given receive port. The purpose is to process the\n    received messages one by one without the need to create an auxiliary\n    list of received messages. The iteration terminates when there are\n    (currently) no more message on the receive port.\n    \n    When the iteration terminates, the Status argument indicates whether\n    the associated sender is still open ('open') or has been closed\n    ('closed'). If closed, no more messages will arrive on this receive\n    port in the future.\n    \n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   see general example for the library\n\nSee Also\n   receive_notifications / 4"},"notify_ports:notify_ports_desc":{"prefix":"lib","body":"lib(${1:notify_ports})$2\n$0","description":"lib(notify_ports)\n\n    This library implements a nonlogical feature, called notification\n    ports.  They are a form of messaging, i.e. there is are send ports\n    and attached receive ports, and messages in the form of general terms\n    can be passed through these ports.  Both send and receive ports have\n    unique handles, which is the nonlogical bit.\n    \n    There are two variants of this feature, one-to-many and many-to-many\n    ports.\n    \n\n    One-To-Many\n    \n    In the one-to-many variant, messages sent from a single send port\n    can be received independently by several receivers. In this setting,\n    the message stream is essentially an infinite list, with the sender\n    extending the list at the tail and the receivers each individually\n    progressing through the list.\n    \n    Straightforward interface:\n    \n\topen_sender(-Sender)\n\tclose_sender(+Sender)\n\tsend_notification(+Sender, +Message)\n\topen_receiver(+Sender, -Receiver)\n\topen_receiver_init(+Sender, +InitMsgs, -InitMsgsTail, -Receiver)\n\treceive_notifications(+Receiver, -Messages, -Status)\n\tforeachnotification(+BaseName, -Message, +Params, +Receiver, -Status, +Goals)\n    \n    There is also a slightly more memory efficient API where sender and\n    receiver can be fields of larger structures rather than separate\n    substructures. These  larger structures must always be created\n    by the caller (in the case of the sender this is often an attribute\n    structure, in the case of the receiver it is sometimes advantageous\n    to package a suspension together with the receiver in order to kill\n    it at the end of all messages):\n    \n\topen_sender(+SendPos, +SendStruct)\n\tclose_sender(+SendPos, +SendStruct)\n\tsend_notification(+SendPos, +SendStruct, +Message)\n\topen_receiver(+SendPos, +SendStruct, +ReceivePos, +ReceiveStruct)\n\topen_receiver_init(+SendPos, +SendStruct, +InitMsgs, -InitMsgsTail,\n\t\t\t\t+ReceivePos, +ReceiveStruct)\n\treceive_notifications(+ReceivePos, +ReceiveStruct, -Messages, -Status)\n\tforeachnotification(+BaseName, -Message, +Params, +ReceivePos, +ReceiveStruct, -Status, +Goals)\n    \n\n    Many-To-Many\n    \n    In the many-to-many variant, several send ports can be connected\n    to several receive ports in an arbitray manner.\n    To enable a receiver to distinguish messages from multiple senders,\n    the messages get tagged with a sender- and receiver-specific id as\n    they are received.\n    \n    The corresponding predicates are the following. Note that sender and\n    receiver are opened with different predicates, but the send and receive\n    predicates are the same as for one-to-many ports:\n    \n\topen_tagging_sender(-Sender)\n\topen_tagged_receiver(+Tag, +Sender, -Receiver)\n\n\tsend_notification(+Sender, +Message)\n\treceive_notifications(+Receiver, -Messages, -Status)\n\tforeachnotification(+BaseName, -Message, +Params, +Receiver, -Status, +Goals)\n    \n    Note that closing of tagging senders is currently not implemented."},"notify_ports:merge_senders/2":{"prefix":"merge_senders","body":"merge_senders(${1:DyingSender}, ${2:SurvivingSender})$3\n$0","description":"merge_senders(+DyingSender, +SurvivingSender)\n\n   Merge DyingSender into SurvivingSender\n\nArguments\n   DyingSender    a send port opened with open_sender/1 or open_tagging_sender/1\n   SurvivingSender     a send port opened with open_sender/1 or open_tagging_sender/1\n\nType\n   library(notify_ports)\n\nDescription\n\n    Destroy DyingSender, but only after adding its receivers to the receivers\n    of SurvivingSender.  In the case of tagging senders, duplicate receivers\n    will be eliminated iff their tags are equal."},"notify_ports:open_receiver_init/4":{"prefix":"open_receiver_init","body":"open_receiver_init(${1:SendPort}, ${2:InitialMessages}, ${3:InitialMessagesTail}, ${4:ReceivePort})$5\n$0","description":"open_receiver_init(+SendPort, +InitialMessages, -InitialMessagesTail, -ReceivePort)\n\n   Create a receiver for a given notification sender\n\nArguments\n   SendPort    a send port structure\n   InitialMessages     the head of a list of initial messages\n   InitialMessagesTail the tail of the list of initial messages\n   ReceivePort    a variable, will be bound to a structure\n\nType\n   library(notify_ports)\n\nDescription\n\n    This predicate creates a receive port listening to messages sent\n    via the specified send port.  The new receive port will receive\n    all messages that are sent via the send port after the receiver\n    has been opened.  Messages that were sent before the receiver has\n    been opened will not be received by this receiver.\n    \n    In addition to open_receiver/2, there is a difference list pair\n    (InitialMessages and InitialMessagesTail) which can be used to\n    fake a sequence of initial message that will be received on\n    the receive port without actually having been sent from the\n    associated send port. This feature can be used to bring the\n    message receiving agent into a particular starting state.\n    \n\nSee Also\n   open_receiver / 2"},"notify_ports:open_receiver/4":{"prefix":"open_receiver","body":"open_receiver(${1:SendPos}, ${2:SendStruct}, ${3:ReceivePos}, ${4:ReceiveStruct})$5\n$0","description":"open_receiver(+SendPos, +SendStruct, +ReceivePos, +ReceiveStruct)\n\n   Create a receiver for a given notification sender\n\nArguments\n   SendPos    positive integer, the send port's field number in SendStruct\n   SendStruct    a structure whose SendPos-th field is a send port\n   ReceivePos    positive integer, the send port's field number in ReceiveStruct\n   ReceiveStruct       a structure with free field ReceivePos\n\nType\n   library(notify_ports)\n\nDescription\n\n    SendPos and SendStruct identify a send port.  This predicate\n    creates a receive port listening to messages sent via the\n    specified send port.  The new receive port will receive all\n    messages that are sent via the send port after the receiver has\n    been opened.  Messages that were sent before the receiver has been\n    opened will not be received by this receiver.\n    \n    The receiver will be installed in field ReceivePos of the structure\n    ReceiveStruct.\n    \n\nSee Also\n   open_receiver_init / 6"},"notify_ports:open_receiver/2":{"prefix":"open_receiver","body":"open_receiver(${1:SendPort}, ${2:ReceivePort})$3\n$0","description":"open_receiver(+SendPort, -ReceivePort)\n\n   Create a receiver for a given notification sender\n\nArguments\n   SendPort    a send port structure\n   ReceivePort    a variable, will be bound to a structure\n\nType\n   library(notify_ports)\n\nDescription\n\n    This predicate creates a receive port listening to messages sent\n    via the specified send port.  The new receive port will receive\n    all messages that are sent via the send port after the receiver\n    has been opened.  Messages that were sent before the receiver has\n    been opened will not be received by this receiver.\n    \n\nSee Also\n   open_receiver_init / 4"},"notify_ports:open_receiver_init/6":{"prefix":"open_receiver_init","body":"open_receiver_init(${1:SendPos}, ${2:SendStruct}, ${3:InitialMessages}, ${4:InitialMessagesTail}, ${5:ReceivePos}, ${6:ReceiveStruct})$7\n$0","description":"open_receiver_init(+SendPos, +SendStruct, +InitialMessages, -InitialMessagesTail, +ReceivePos, +ReceiveStruct)\n\n   Create a receiver for a given notification sender\n\nArguments\n   SendPos    positive integer, the send port's field number in SendStruct\n   SendStruct    a structure whose SendPos-th field is a send port\n   InitialMessages     the head of a list of initial messages\n   InitialMessagesTail the tail of the list of initial messages\n   ReceivePos    positive integer, the send port's field number in ReceiveStruct\n   ReceiveStruct       a structure with free field ReceivePos\n\nType\n   library(notify_ports)\n\nDescription\n\n    SendPos and SendStruct identify a send port.  This predicate\n    creates a receive port listening to messages sent via the\n    specified send port.  The new receive port will receive all\n    messages that are sent via the send port after the receiver has\n    been opened.  Messages that were sent before the receiver has been\n    opened will not be received by this receiver.\n    \n    The receiver will be installed in field ReceivePos of the structure\n    ReceiveStruct.\n    \n    In addition to open_receiver/4, there is a difference list pair\n    (InitialMessages and InitialMessagesTail) which can be used to\n    fake a sequence of initial message that will be received on\n    the receive port without actually having been sent from the\n    associated send port. This feature can be used to bring the\n    message receiving agent into a particular starting state.\n    \n\nSee Also\n   open_receiver / 4"},"notify_ports:open_sender/1":{"prefix":"open_sender","body":"open_sender(${1:SendPort})$2\n$0","description":"open_sender(-SendPort)\n\n   Create a send port\n\nArguments\n   SendPort    a variable, will be bound to a structure\n\nType\n   library(notify_ports)"},"notify_ports:open_sender/2":{"prefix":"open_sender","body":"open_sender(${1:Pos}, ${2:Struct})$3\n$0","description":"open_sender(+Pos, +Struct)\n\n   Initialise a structure field as a send port\n\nArguments\n   Pos    positive integer, the send port's field number in Struct\n   Struct    a structure (with arity Pos or more)\n\nType\n   library(notify_ports)"},"notify_ports:open_tagged_receiver/3":{"prefix":"open_tagged_receiver","body":"open_tagged_receiver(${1:Tag}, ${2:SendPort}, ${3:ReceivePort})$4\n$0","description":"open_tagged_receiver(+Tag, +SendPort, ?ReceivePort)\n\n   Create a receiver for one or more tagging senders\n\nArguments\n   Tag    an arbitrary term\n   SendPort    a tagged-send-port structure\n   ReceivePort    a tagged-receive-port structure or a variable\n\nType\n   library(notify_ports)\n\nDescription\n\n    This predicate either creates a new receive port and connects it to an\n    existing tagged-send port, or connects an existing receive port to an\n    additional existing tagged-send port.  The new receive port will receive\n    all messages that are sent via the send port after the receiver\n    has been opened.  Any messages that were sent before the receiver was\n    opened will not be received by this receiver.\n    \n    Messages that arrive on ReceivePort from SendPort will get tagged with\n    Tag, i.e. the received message will be a structure of the form\n    \n    \tTag : Message\n    \n    If several senders are connected to ReceivePort, the tag can thus\n    be used to identify the origin of the message.\n    \n    \n\nModes and Determinism\n   open_tagged_receiver(+, +, -)\n   open_tagged_receiver(+, +, +)\n\nExamples\n   \n    ?-\topen_tagging_sender(S1),\n\topen_tagging_sender(S2),\n\topen_tagged_receiver(r1s1, S1, R1),\n\topen_tagged_receiver(r1s2, S2, R1),\n\topen_tagged_receiver(r2s1, S1, R2),\n\topen_tagged_receiver(r2s2, S2, R2),\n\n\tsend_notification(S1, m1),\n\tsend_notification(S1, m2),\n\tsend_notification(S2, m3),\n\tsend_notification(S1, m4),\n\tsend_notification(S2, m5),\n\n\treceive_notifications(R1, R1M1, _),\n\treceive_notifications(R2, R2M1, _).\n\n    ...\n    R1M1 = [r1s1 : m1, r1s1 : m2, r1s2 : m3, r1s1 : m4, r1s2 : m5]\n    R2M1 = [r2s1 : m1, r2s1 : m2, r2s2 : m3, r2s1 : m4, r2s2 : m5]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   open_tagging_sender / 1, send_notification / 2, receive_notifications / 3, foreachnotification / 6"},"notify_ports:receive_notifications/3":{"prefix":"receive_notifications","body":"receive_notifications(${1:ReceivePort}, ${2:Messages}, ${3:Status})$4\n$0","description":"receive_notifications(+ReceivePort, -Messages, -Status)\n\n   Receive a list of currently available notification messages\n\nArguments\n   ReceivePort    a receiver structure as created by open_receiver\n   Messages    a variable, will be bound to a list\n   Status    a variable, will be bound to 'open' or 'closed'\n\nType\n   library(notify_ports)\n\nDescription\n\n    This predicate retrieves all the messages that are currently\n    available at the given receive port.  This means all messages that\n    were sent via the associated send port but have not yet been\n    retrieved from this receive port. The messages are listed in the\n    order in which they were sent.\n    \n    The Status argument indicates whether the associated sender is still\n    open ('open') or has been closed ('closed'). If closed, no more\n    messages will arrive on this receive port in the future.\n    \n\nSee Also\n   foreachnotification / 6"},"notify_ports:open_tagging_sender/1":{"prefix":"open_tagging_sender","body":"open_tagging_sender(${1:SendPort})$2\n$0","description":"open_tagging_sender(-SendPort)\n\n   Create a many-to-many send port \n\nArguments\n   SendPort    a variable, will be bound to a structure\n\nType\n   library(notify_ports)\n\nDescription\n\n    Creates a send port that can be used in many-to-many communication,\n    i.e. several of these ports can be connected to a single receiver.\n    \n\nSee Also\n   open_tagged_receiver / 3, send_notification / 2, receive_notifications / 3, foreachnotification / 6"},"notify_ports:receive_notifications/4":{"prefix":"receive_notifications","body":"receive_notifications(${1:ReceivePos}, ${2:ReceiveStruct}, ${3:Messages}, ${4:Status})$5\n$0","description":"receive_notifications(+ReceivePos, +ReceiveStruct, -Messages, -Status)\n\n   Receive a list of currently available notification messages\n\nArguments\n   ReceivePos    positive integer, the send port's field number in ReceiveStruct\n   ReceiveStruct       a structure\n   Messages    a variable\n   Status    a variable\n\nType\n   library(notify_ports)\n\nDescription\n\n    This predicate retrieves all the messages that are currently\n    available at the given receive port.  This means all messages that\n    were sent via the associated send port but have not yet been\n    retrieved from this receive port.\n    \n    The Status argument indicates whether the associated sender is still\n    open ('open') or has been closed ('closed'). If closed, no more\n    messages will arrive on this receive port in the future.\n    \n\nSee Also\n   foreachnotification / 7"},"notify_ports:send_notification/2":{"prefix":"send_notification","body":"send_notification(${1:SendPort}, ${2:Message})$3\n$0","description":"send_notification(+SendPort, +Message)\n\n   Send a notification message\n\nArguments\n   SendPort    a send port structure\n   Message    arbitrary term\n\nType\n   library(notify_ports)\n\nDescription\n\n    Messages is an arbitrary term that gets send via the send port SendPort.\n    All receivers that have connected to this send port at the time of\n    sending will be able to receive the message.\n    \n\nFail Conditions\n   Fails if SendPort is closed"},"notify_ports:send_notification/3":{"prefix":"send_notification","body":"send_notification(${1:Pos}, ${2:Struct}, ${3:Message})$4\n$0","description":"send_notification(+Pos, +Struct, +Message)\n\n   Send a notification message\n\nArguments\n   Pos    positive integer, the send port's field number in Struct\n   Struct    a structure whose Pos-th field is a send port\n   Message    arbitrary term\n\nType\n   library(notify_ports)\n\nDescription\n\n    Pos and Struct identify a send port. Messages is an arbitrary\n    term that gets send via this port. All receivers that have connected\n    to this send port at the time of sending will be able to receive\n    the message.\n    \n\nFail Conditions\n   Fails if send port is closed"},"notinstance:TE/2":{"prefix":"X","body":"X","description":"X ~= Y\n\n   Constrains X and Y to be different\n\nType\n   library(notinstance)\n\nDescription\nFails if X and Y are non-unifiable, otherwise succeeds\n    or delays.  Unlike the implementation of the same predicate in the\n    kernel, this one maintains and explicit wavefront and has only one\n    delayed goal.  Failure is detected eagerly.  Success may be\n    detected late."},"numbervars:numbervars_desc":{"prefix":"lib","body":"lib(${1:numbervars})$2\n$0","description":"lib(numbervars)\n\n    Implements the numbervars(Term, From, To) predicate of C-Prolog.  Term\n    is any term, From and To are integer numbers.  All variables in Term\n    are instantiated to terms of the form\n    \n\t$VAR(N) \n    \n    where N is an integer number.  The first encountered variable will be\n    coded by the number From, on exit To is instantiated to the next\n    unused number. \n    \n    This predicate can thus be used to encode nonground term using a\n    ground representation.  Note that metaterms can be used for the same\n    purpose, but their use is both more efficient and more general,\n    because the variables are not actually instantiated and so they can be\n    used again as variables when needed."},"notinstance:TEL/2":{"prefix":"X","body":"X","description":"X ~=< Y\n\n   Constrain X not to be an instance of Y\n\nType\n   library(notinstance)\n\nDescription\nWe assume:\n    \n\t no shared variables between X and Y\n\t X may get more instantiated, but not Y\n    \n    Failure is detected eagerly. Success may be detected late."},"ordset:is_ordset/1":{"prefix":"is_ordset","body":"is_ordset(${1:Term})$2\n$0","description":"is_ordset(?Term)\n\n   Checks whether term is an ordered set in the sense of lib(ordset)\n\nArguments\n   Term    Any Term\n\nType\n   library(ordset)\n\nDescription\n\tChecks whether term is an ordered set in the sense of lib(ordset),\n\ti.e. a proper, duplicate-free list with elements in increasing order.\n    \n\nModes and Determinism\n   is_ordset(?) is semidet\n\nSee Also\n   @< / 2"},"ordset:list_to_ord_set/2":{"prefix":"list_to_ord_set","body":"list_to_ord_set(${1:List}, ${2:Set})$3\n$0","description":"list_to_ord_set(+List, -Set)\n\n   Converts a list to a set\n\nArguments\n   List    A list of terms\n   Set    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Set is the ordered representation of the set\n\trepresented by the unordered representation List.  The only\n\treason for giving it a name at all is that you may not have\n\trealised that sort/2 could be used this way.\n\nModes and Determinism\n   list_to_ord_set(+, -) is det\n\nSee Also\n   sort / 2"},"ordset:ord_add_element/3":{"prefix":"ord_add_element","body":"ord_add_element(${1:Set1}, ${2:Element}, ${3:Set2})$4\n$0","description":"ord_add_element(+Set1, +Element, -Set2)\n\n   Adds an element to a set\n\nArguments\n   Set1    A set\n   Element    A term\n   Set2    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSet2 is the set resulting from adding Element to Set1. It should\n\tgive exactly the same result as merge(Set1, [Element], Set2).\n\tThis is a synonym of ord_insert/3.\n    \n\nModes and Determinism\n   ord_add_element(+, +, -) is det\n\nSee Also\n   ord_insert / 3"},"ordset:ord_compare/3":{"prefix":"ord_compare","body":"ord_compare(${1:Rel}, ${2:Set1}, ${3:Set2})$4\n$0","description":"ord_compare(-Rel, +Set1, +Set2)\n\n   Rel is the ordering relationship between Set1 and Set2\n\nArguments\n   Rel    A variable or an atom\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tRel is the ordering relationship between Set1 and Set2.\n\tRel is one of the atoms =, > or <\n\t\n\t=    The sets are identical (in the sense of ==/2)\n\t>    Set1 is a proper superset of Set2\n\t<    Set1 is a proper subset of Set2\n\t\n\tOtherwise the predicate fails.\n\nModes and Determinism\n   ord_compare(-, +, +) is semidet\n\nFail Conditions\n   Fails if the sets are not comparable\n\nSee Also\n   @< / 2, ord_seteq / 2, ord_proper_subset / 2, ord_proper_superset / 2"},"ordset:ord_del_element/3":{"prefix":"ord_del_element","body":"ord_del_element(${1:Set}, ${2:Term}, ${3:Remainder})$4\n$0","description":"ord_del_element(+Set, ?Term, -Remainder)\n\n   Remainder is the set Set without the element Term\n\nArguments\n   Set    A set\n   Term    Any Term\n   Remainder    A variable or set\n\nType\n   library(ordset)\n\nDescription\n\tRemainder is the set Set without the element Term. If Term is not\n\tin Set, Remainder is identical to Set.\n\nModes and Determinism\n   ord_del_element(+, ?, -) is det\n\nSee Also\n   ord_selectchk / 3"},"ordset:ord_disjoint_union/3":{"prefix":"ord_disjoint_union","body":"ord_disjoint_union(${1:Set1}, ${2:Set2}, ${3:Union})$4\n$0","description":"ord_disjoint_union(+Set1, +Set2, -Union)\n\n   Computes the union of Set1 and Set2 when they are disjoint\n\nArguments\n   Set1    A set\n   Set2    A set\n   Union    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Union is the union of disjoint sets Set1 and Set2.\n\tFails if Set1 and Set2 are not disjoint, i.e. if they have a\n\tnon-empty intersection.\n    \n\nModes and Determinism\n   ord_disjoint_union(+, +, -) is semidet\n\nFail Conditions\n   Fails if the sets are not disjoint\n\nSee Also\n   ord_union / 4, ord_union / 2"},"ordset:ord_disjoint/2":{"prefix":"ord_disjoint","body":"ord_disjoint(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_disjoint(+Set1, +Set2)\n\n   Checks whether two sets are disjoint\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when the two ordered sets have no element in common.\n    \n\nModes and Determinism\n   ord_disjoint(+, +) is semidet\n\nSee Also\n   ord_intersect / 2"},"ordset:ord_intersect/3":{"prefix":"ord_intersect","body":"ord_intersect(${1:Set1}, ${2:Set2}, ${3:Intersection})$4\n$0","description":"ord_intersect(+Set1, +Set2, -Intersection)\n\n   Computes the intersection of two sets\n\nArguments\n   Set1    A set\n   Set2    A set\n   Intersection    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Intersection is the intersection of Set1 \n\tand Set2, provided that Set1 and Set2 are ordered sets.\n\t\n\tThe use of ord_intersection/3 is preferred.\n\t\n    \n\nModes and Determinism\n   ord_intersect(+, +, -) is det\n\nSee Also\n   ord_intersection / 3"},"ordset:ord_insert/3":{"prefix":"ord_insert","body":"ord_insert(${1:Set1}, ${2:Element}, ${3:Set2})$4\n$0","description":"ord_insert(+Set1, +Element, -Set2)\n\n   Adds an element to a set\n\nArguments\n   Set1    A set\n   Element    A term\n   Set2    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSet2 is the set resulting from adding Element to Set1. It should\n\tgive exactly the same result as merge(Set1, [Element], Set2).\n\tThis is a synonym of ord_add_element/3.\n    \n\nModes and Determinism\n   ord_insert(+, +, -) is det\n\nSee Also\n   ord_add_element / 3"},"ordset:ord_intersect/2":{"prefix":"ord_intersect","body":"ord_intersect(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_intersect(+Set1, +Set2)\n\n   Checks whether two sets have a non-empty intersection\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when the two ordered sets have at least one element\n\tin common.  Note that the test is == rather than = .\n    \n\nModes and Determinism\n   ord_intersect(+, +) is semidet\n\nSee Also\n   ord_disjoint / 2"},"ordset:ord_intersection/3":{"prefix":"ord_intersection","body":"ord_intersection(${1:Set1}, ${2:Set2}, ${3:Intersection})$4\n$0","description":"ord_intersection(+Set1, +Set2, -Intersection)\n\n   Computes the intersection of two sets\n\nArguments\n   Set1    A set\n   Set2    A set\n   Intersection    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Intersection is the intersection of Set1 \n\tand Set2, provided that Set1 and Set2 are ordered sets.\n    \n\nModes and Determinism\n   ord_intersection(+, +, -) is det\n\nSee Also\n   ord_intersect / 2, ord_intersection / 5"},"ordset:ord_intersection/2":{"prefix":"ord_intersection","body":"ord_intersection(${1:Sets}, ${2:Intersection})$3\n$0","description":"ord_intersection(+Sets, -Intersection)\n\n   Computes the intersection of all sets in Sets\n\nArguments\n   Sets    A list of sets\n   Intersection    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Intersection is the intersection of all sets in\n\tthe list Sets.\n    \n\nModes and Determinism\n   ord_intersection(+, -) is det\n\nSee Also\n   ord_intersection / 3, ord_union / 2"},"ordset:ord_intersection/5":{"prefix":"ord_intersection","body":"ord_intersection(${1:Set1}, ${2:Set2}, ${3:Intersection}, ${4:Only1}, ${5:Only2})$6\n$0","description":"ord_intersection(+Set1, +Set2, -Intersection, -Only1, -Only2)\n\n   Computes the intersection and the differences of two sets\n\nArguments\n   Set1    A set\n   Set2    A set\n   Intersection    A variable or set\n   Only1    A variable or set\n   Only2    A variable or set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Intersection is the intersection of the ordered\n\tsets Set1 and Set2, Only1 is the set of elements that are only\n\tin Set1, and Only2 is the set of elements that are only in Set2.\n    \n\nModes and Determinism\n   ord_intersection(+, +, -, -, -) is det\n\nSee Also\n   ord_intersection / 3, ord_subtract / 3, ord_symdiff / 3"},"ordset:ord_memberchk/2":{"prefix":"ord_memberchk","body":"ord_memberchk(${1:Term}, ${2:Set})$3\n$0","description":"ord_memberchk(?Term, +Set)\n\n   Checks whether Term is a member of Set\n\nArguments\n   Term    Any Term\n   Set    A set\n\nType\n   library(ordset)\n\nModes and Determinism\n   ord_memberchk(?, +) is semidet\n\nFail Conditions\n   Term is not a member of Set\n\nSee Also\n   lists : member / 2, ord_nonmember / 2, ord_selectchk / 3"},"ordset:ord_nonmember/2":{"prefix":"ord_nonmember","body":"ord_nonmember(${1:Term}, ${2:Set})$3\n$0","description":"ord_nonmember(?Term, +Set)\n\n   Term is not a member of Set\n\nArguments\n   Term    Any Term\n   Set    A set\n\nType\n   library(ordset)\n\nModes and Determinism\n   ord_nonmember(?, +) is semidet\n\nFail Conditions\n   Term is a member of Set\n\nSee Also\n   ord_memberchk / 2"},"ordset:ord_proper_subset/2":{"prefix":"ord_proper_subset","body":"ord_proper_subset(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_proper_subset(+Set1, +Set2)\n\n   Checks whether Set1 is a proper subset of Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when every element of the ordered set Set1 appears\n\tin the ordered set Set2, and Set2 has at least on element that\n\tdoes not occur in Set1.\n    \n\nModes and Determinism\n   ord_proper_subset(+, +) is semidet\n\nSee Also\n   ord_subset / 2, ord_compare / 3"},"ordset:ord_proper_superset/2":{"prefix":"ord_proper_superset","body":"ord_proper_superset(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_proper_superset(+Set1, +Set2)\n\n   Checks whether Set1 is a proper superset of Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when every element of the ordered set Set2 appears\n\tin the ordered set Set1, and Set1 has at least on element that\n\tdoes not occur in Set2.\n    \n\nModes and Determinism\n   ord_proper_superset(+, +) is semidet\n\nSee Also\n   ord_superset / 2, ord_compare / 3"},"ordset:ord_seteq/2":{"prefix":"ord_seteq","body":"ord_seteq(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_seteq(+Set1, +Set2)\n\n   Compares two sets for identity\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when the two arguments represent the same set.  Since they\n\tare assumed to be ordered representations, they must be identical.\n    \n\nModes and Determinism\n   ord_seteq(+, +) is semidet\n\nSee Also\n   == / 2, ord_compare / 3"},"ordset:ord_selectchk/3":{"prefix":"ord_selectchk","body":"ord_selectchk(${1:Term}, ${2:Set}, ${3:Remainder})$4\n$0","description":"ord_selectchk(?Term, +Set, -Remainder)\n\n   Set contains Term, and Remainder is the set Set without Term\n\nArguments\n   Term    Any Term\n   Set    A set\n   Remainder    A variable or set\n\nType\n   library(ordset)\n\nDescription\n\tIf Set contains Term, Remainder is the set Set without the Term.\n\tOtherwise the predicate fails.\n\nModes and Determinism\n   ord_selectchk(?, +, -) is semidet\n\nFail Conditions\n   Term is not a member of Set\n\nSee Also\n   ord_del_element / 3, lists : delete / 3, listut : delete / 3, m_tree234 : delete / 3, m_map : delete / 3"},"ordset:ord_subset/2":{"prefix":"ord_subset","body":"ord_subset(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_subset(+Set1, +Set2)\n\n   Checks whether Set1 is a subset of Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when every element of the ordered set Set1 appears\n\tin the ordered set Set2.\n    \n\nModes and Determinism\n   ord_subset(+, +) is semidet\n\nSee Also\n   ord_proper_subset / 2, lists : subset / 2, ic_hybrid_sets : subset / 2, ic_sets : subset / 2, fd_sets : subset / 2, ord_compare / 3"},"ordset:ord_superset/2":{"prefix":"ord_superset","body":"ord_superset(${1:Set1}, ${2:Set2})$3\n$0","description":"ord_superset(+Set1, +Set2)\n\n   Checks whether Set1 is a superset of Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when every element of the ordered set Set2 appears\n\tin the ordered set Set1.\n    \n\nModes and Determinism\n   ord_superset(+, +) is semidet\n\nSee Also\n   ord_proper_superset / 2, lists : subset / 2, ic_hybrid_sets : subset / 2, ic_sets : subset / 2, fd_sets : subset / 2, ord_compare / 3"},"ordset:ord_subtract/3":{"prefix":"ord_subtract","body":"ord_subtract(${1:Set1}, ${2:Set2}, ${3:Difference})$4\n$0","description":"ord_subtract(+Set1, +Set2, -Difference)\n\n   Subtracts Set2 from Set1\n\nArguments\n   Set1    A set\n   Set2    A set\n   Difference    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Difference contains all and only the elements\n\tof Set1 which are not also in Set2.\n    \n\nModes and Determinism\n   ord_subtract(+, +, -) is det\n\nSee Also\n   ord_symdiff / 3"},"ordset:ord_symdiff/3":{"prefix":"ord_symdiff","body":"ord_symdiff(${1:Set1}, ${2:Set2}, ${3:Difference})$4\n$0","description":"ord_symdiff(+Set1, +Set2, -Difference)\n\n   Computes the symmetric difference of Set1 and Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n   Difference    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Difference is the symmetric difference of Set1 and Set2.\n\tThese are the elements that occur either only in Set1 or only in Set2,\n\tbut not both.\n    \n\nModes and Determinism\n   ord_symdiff(+, +, -) is det\n\nSee Also\n   ord_subtract / 3"},"ordset:ord_union/3":{"prefix":"ord_union","body":"ord_union(${1:Set1}, ${2:Set2}, ${3:Union})$4\n$0","description":"ord_union(+Set1, +Set2, -Union)\n\n   Computes the union of Set1 and Set2\n\nArguments\n   Set1    A set\n   Set2    A set\n   Union    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Union is the union of Set1 and Set2.  Note that when\n\tsomething occurs in both sets, we want to retain only one copy.\n    \n\nModes and Determinism\n   ord_union(+, +, -) is det\n\nSee Also\n   ord_disjoint_union / 3, ord_union / 4, ord_union / 2"},"ordset:ord_union/2":{"prefix":"ord_union","body":"ord_union(${1:Sets}, ${2:Union})$3\n$0","description":"ord_union(+Sets, -Union)\n\n   Computes the union of all sets in Sets\n\nArguments\n   Sets    A list of sets\n   Union    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Union is the union of all sets in the list Sets.\n    \n\nModes and Determinism\n   ord_union(+, -) is det\n\nSee Also\n   ord_union / 3, ord_intersection / 2"},"ordset:ord_union/4":{"prefix":"ord_union","body":"ord_union(${1:Set1}, ${2:Set2}, ${3:Union}, ${4:New})$5\n$0","description":"ord_union(+Set1, +Set2, -Union, -New)\n\n   Computes the union and difference of Set2 and Set1\n\nArguments\n   Set1    A set\n   Set2    A set\n   Union    A set or variable\n   New    A set or variable\n\nType\n   library(ordset)\n\nDescription\n\tSucceeds when Union is the union of Set1 and Set2, and New is the\n\tset of elements that are in Set2 but not in Set1.  This is useful\n\tin order to know which elements were newly added when incrementally\n\tmerging sets.\n    \n\nModes and Determinism\n   ord_union(+, +, -, -) is det\n\nSee Also\n   ord_disjoint_union / 3, ord_union / 3, ord_union / 2"},"par_util:Y/2":{"prefix":"Goal1","body":"Goal1","description":"Goal1 & Goal2\n\n   Parallel AND operator implemented on top of OR-parallelism\n\nType\n   library(par_util)\n\nDescription\nParallel AND operator implemented on top of\n    OR-parallelism.  This will only pay off for sufficiently\n    coarse-grained computations in Goal1 and Goal2.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"ordset:ordset_desc":{"prefix":"lib","body":"lib(${1:ordset})$2\n$0","description":"lib(ordset)\n\n\tIn this module, sets are represented by ordered lists with no\n\tduplicates.  Thus the set {c,r,a,f,t} would be [a,c,f,r,t].  The\n\tordering is defined by the @\n\tThe benefit of the ordered representation is that the elementary\n\tset operations can be done in time proportional to the Sum of\n\tthe argument sizes rather than their Product.  Some of the\n\tunordered set routines, such as member/2, length/2, select/3\n\tcan be used unchanged.\n\t\n\tThe implementation allows nonground set elements. The only problem\n\twith this is that a set can lose its set property as a result of\n\tvariable bindings: unifications can create duplicates or change\n\tthe element's position in the term order. The set can be repaired\n\tby applying list_to_ord_set/2 again, i.e. re-sorting it.\n\t\n\tNote that the predicates of this library do no error checking.\n\tWhen called with the wrong argument types or modes, the result is\n\tundefined."},"par_util:par_between/3":{"prefix":"par_between","body":"par_between(${1:From}, ${2:To}, ${3:I})$4\n$0","description":"par_between(+From, +To, ?I)\n\n   Generates integers between From and To in parallel\n\nType\n   library(par_util)\n\nSee Also\n   fork / 2, swi : between / 3, util : between / 3, between : between / 3, between / 4"},"par_util:par_maplist/3":{"prefix":"par_maplist","body":"par_maplist(${1:Pred}, ${2:In}, ${3:Out})$4\n$0","description":"par_maplist(+Pred, +In, ?Out)\n\n   Parallel version of maplist/3\n\nType\n   library(par_util)\n\nDescription\nParallel version of maplist/3.  The semantics is not\n    exactly the same as maplist/3:  It does not work backwards and it\n    does not cope with aliasing between the In and the Out list, since\n    it is implemented on top of findall/3.  There will only be a\n    performance gain if the mapping predicate does enough computation\n    to make the overhead pay off.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   apply_macros : maplist / 3, lists : maplist / 3, applic : maplist / 3"},"par_util:par_delete/3":{"prefix":"par_delete","body":"par_delete(${1:Element}, ${2:List}, ${3:Rest})$4\n$0","description":"par_delete(?Element, ?List, ?Rest)\n\n   Parallel version of delete/3\n\nType\n   library(par_util)"},"par_util:par_member/2":{"prefix":"par_member","body":"par_member(${1:Element}, ${2:List})$3\n$0","description":"par_member(?Element, +List)\n\n   Parallel version of member/2\n\nType\n   library(par_util)\n\nDescription\nParallel version of member/2, i.e.  selects elements from\n    the given list in parallel.  Note that it cannot work backwards\n    and generate lists like member/2 can, the list must be a proper list."},"port_profiler:port_profile/2":{"prefix":"port_profile","body":"port_profile(${1:Goal}, ${2:Options})$3\n$0","description":"port_profile(+Goal, ++Options)\n\n   Create a (box model) port profile for the given Goal execution\n\nArguments\n   Goal    A callable goal (atom or compound term)\n   Options    A list of OptionName:OptionValue structures\n\nType\n   library(port_profiler)\n\nDescription\n    \tExecutes Goal and creates a (box model) port profile for this execution.\n\tThe ports are the ports as defined for the debugger's box model and\n\tinclude:\n\t\n\tcall predicate invocation\n\t\n\texit deterministic predicate success\n\t\n\t\n\tfail predicate failure\n\t\n\t\n\t*exit nondeterministic predicate success\n\t\n\t\n\tredo reentering a predicate on backtracking\n\t\n\t\n\tnext going to the next clause of a predicate\n\t\n\t\n\telse going to an alternative within a predicate\n\t\n\t\n\tleave leaving a predicate with throw/1\n\t\n\t\n\tdelay delaying a predicate\n\t\n\t\n\tresume reentering a predicate on waking\n\t\n\t\n\t\n    \tThe available options are:\n\t\n\tformat (default:txt) output format, txt or html\n\t    \n\t    txt prints an ascii table, taking width-option into account\n\t    html prints an html table, taking border-option into account\n\t    raw prints the raw results as lines of the form\n\t\t\n\t\t[M:F/A from PM:PF/PA, Port, Count].\n\t\t\n\t\tif the show_caller-option is on, and\n\t\t\n\t\t[M:F/A, Port, Count].\n\t\t\n\t\tif the show_caller-option is off. These are valid Prolog\n\t\tterms which can be read back using read/2.\n\t    \n\t    \n\tborder (default:0) table border width for html output\n\toutput (default:default)\n\t    where to put the result: possible values are\n\t    \n\t    file(File) where File is a file name\n\t    stream(Stream) where Stream is an Eclipse stream identifier\n\t    dir(Dir) where Dir is a directory in which files with generated names will be placed\n\t    default either dir(profiler) for html format, or stream(output) otherwise\n\t    \n\t    \n\tports (default:all) the atom 'all' or a list of port names\n\tpredicates (default:all) the atom 'all' or 'spied_only'.\n\t    The latter means that only predicates with a spy point have their\n\t    ports counted.\n\tshow_caller (default:on) whether to show and distinguish\n\t    predicates by their calling predicate (on or off). This is the\n\t    only option that affects data collection as well as presentation.\n\tshow_module (default:off) whether to show the predicate's\n\t    definition modules in the output table (on or off)\n\twidth (default:80) page width for txt output\n\t\n\tNote: Any choicepoints that are left behind by Goal will be cut, i.e.\n\tport_profile/2 behaves like once/1.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   library(port_profiler), library(coverage), profile / 1, last_port_profile / 1"},"pretty_print:pretty_print/3":{"prefix":"pretty_print","body":"pretty_print(${1:Stream}, ${2:Term}, ${3:Max})$4\n$0","description":"pretty_print(+Stream, +Term, +Max)\n\n   Print a term on the given stream, split it if its width exceeds Max\n\nType\n   library(pretty_print)"},"port_profiler:last_port_profile/1":{"prefix":"last_port_profile","body":"last_port_profile(${1:Options})$2\n$0","description":"last_port_profile(++Options)\n\n   Output another port profile for the most recently profiled goal\n\nArguments\n   Options    A list of OptionName:OptionValue structures\n\nType\n   library(port_profiler)\n\nDescription\n    This allows to output (again) the results of the previous call to\n    port_profile/2, possibly in a different format. The options are\n    the same as in port_profile/2. Note that the show_caller option can\n    only be given if it was on in the corresponding call to port_profile/2,\n    otherwise the corresponding information is not available.\n    \n\nSee Also\n   port_profile / 2"},"port_profiler:port_profiler_desc":{"prefix":"lib","body":"lib(${1:port_profiler})$2\n$0","description":"lib(port_profiler)\n\n    This is a performance analysis tool based on counting of events during\n    program execution. The events that are counted are defined in terms\n    of the 'box model' of execution (the same model that the debugger uses).\n    In this box model, predicates are entered though call, redo or resume\n    ports, and exited through exit, fail or leave ports. In addition, other\n    interesting events are indicated by ports as well (next, else, delay).\n    \n    The usage is as follows:\n    \n    Compile your program in debug mode, as you would normally do during\n    program development, e.g.\n    \n    \t?- compile(queen).\n    \n    Load the port_profiler library\n    \n    \t?- lib(port_profiler).\n    \n    Run the query which you want to examine, using port_profile/2:\n    \n    \t?- port_profile(queen([1,2,3,4],Out), []).\n    \n    This will print the results in a table.\n    \n    The default output you get looks like this:\n    \n\tPREDICATE       CALLER    call     exit     fail    *exit     redo\n\tstore_set   /3  nodiag      /3    106      106    .    .    .\n\t-    /3  nodiag      /3    46       46    .    .    .\n\t=\\=    /2  nodiag      /3    46       45    1    .    .\n\tqperm       /2  qperm       /2    30       28    .       16       14\n\tqdelete     /4  qperm       /2    20       18    .       12       10\n\tnodiag      /3  nodiag      /3    17       14    3    .    .\n\tnodiag      /3  safe    /1    17    7       10    .    .\n\t+    /3  nodiag      /3    17       17    .    .    .\n\tqdelete     /4  qdelete     /4    10    9    .    3    2\n\tqperm       /2  queen       /2    1    .    .       11       10\n\tsafe    /1  queen       /2    11    1       10    .    .\n\tsafe    /1  safe    /1    7    4    3    .    .\n\tqueen       /2  trace_body  /2    1    .    .    1    .\n    \n    The port counts give information about\n    \n    what are the most frequently called predicates (call ports)\n    whether predicates failed unexpectedly (fail ports)\n    whether predicates exited nondeterministically (*exit ports), i.e.\n    \twhether they left behind any choice-points for backtracking.\n    whether nondeterministically exited predicates were ever re-entered\n\tto find alternative solutions (redo ports).\n    whether predicates did internal backtracking (next ports) in order\n    \tto find the right clause. This may indicate suboptimal indexing.\n    how often predicates were delayed and resumed.\n    \n    By default, statistics are collected separately for each predicate-caller\n    pair, i.e. multiple lines appear for a predicate when it is called from\n    different caller predicates. This feature can be disabled so that predicates\n    are not distingushed by their caller. It is also possible to restrict\n    data collection to predicates with a spy point only (less time consuming).\n    \n    Other options allow output in different formats, e.g. as an html file,\n    with a subset or different order of the ports, or with module information.\n    For details, see the description of port_profile/2.\n    \n    Related, but different tools are:\n    \n    The sampling profiler (profile/1,2 from lib(profile)): this works\n\teven on optimized, non-traceable code and gives timing information.\n\tIt does not give information about the caller predicate.\n    The coverage analyzer (see lib(coverage)): this is also based on\n\tcounting, but has counters for every program point and is probably\n\tless useful for performance analysis."},"pretty_printer:pretty_print/1":{"prefix":"pretty_print","body":"pretty_print(${1:Files})$2\n$0","description":"pretty_print(++Files)\n\n   Print a file in html format\n\nArguments\n   Files    a filename (atom or string), or a list of filenames\n\nType\n   library(pretty_printer)\n\nDescription\n\nThe system prints the contents of the file given as the argument as an\noutput file in html format.  This is one of the possible formats\nsupported by the pretty printer (see pretty_print/2).  The system\nautomatically adds the extension .html and places the result in a\nsubdirectory called 'pretty' relative to the source file.  Syntax coloring\nis used to highlight different language features, and a uniform formatting\nof the source code is used.\n\nAs the clauses are read with the normal Prolog read routine, comments\nwithin clauses are lost, but comments and spacing between clauses is\npreserved.\n\nHyperlinks are used for documented builtin predicates, as well as\npredicates defined in the same file.  For a built-in, the hyperlink\nwill lead to the manual page of the predicate, for other predicates\nthe link points to the first definition of the predicate.  The\nhyperlinks to the builtins are based on the installation directory of\nEclipse, so that the resulting output will normally not work on a\nmachine where eclipse is installed in a different directory.\n\nIf a list of several files is given, an additional index page index.html\nwith links to the individual pretty-printed source files will be generated.\n\nThe pretty printer does not check for undefined predicates or\npredicates that are defined in included files.\n\nThe colours used are similar to those used by the EMACS Eclipse mode.\nColours are used more consistently than in the EMACS editor, as the\nsource text is parsed completely.\n\nYou can modify the colour scheme by modifying the style sheet\nstyle.css which is located in the directory where the .html files get\ngenerated (by default the subdirectory 'pretty').  The pretty-printer\nwill generate a default style sheet file if none exists, but not touch\nany existing one.\n\nExamples\n   \n?- pretty_print(simple').\n\nSee Also\n   pretty_print / 2"},"pretty_printer:pretty_print/2":{"prefix":"pretty_print","body":"pretty_print(${1:Files}, ${2:Options})$3\n$0","description":"pretty_print(++Files, ++Options)\n\n   Print a file in one of different formats\n\nArguments\n   Files    a filename (atom or string), or a list of filenames\n   Options    A list of Name:Value pairs\n\nType\n   library(pretty_printer)\n\nDescription\n\n    The system prints the contents of the file given as the argument as an\n    output file in different formats. See pretty_print/1 for the general\n    description.\n\n    This predicate allows the following options to modify the results:\n\n    format (default:html)\n\tPossible values are 'html' or 'txt'.  The 'html' format\n\tproduces html output with syntax coloring and navigation\n\tlinks.  The output file goes into a directory 'pretty' and has\n\tthe suffix .html.  The 'txt' format produces pure text output. \n\tThe output file goes into a directory 'pretty' and has the\n\tsuffix .txt.\n    outdir (default:pretty)\n    \tThe location of the generated files. This can be an absolute or\n\ta relative pathname (in Eclipse's generic pathname syntax, atom\n\tor string). If it is a relative pathname, it is interpreted as\n\treative to the location of the input source file.\n    style (default:pretty)\n    \tPossible values are 'pretty' or 'coverage'. Selects one of two\n\tpredefined styles for html output. The latter is a less colourful\n\tform intended for code coverage output.\n    inline_css (default:off)\n    \tPossible values are 'off' or 'on'. If 'on', the html output will\n\tuse an inlined style sheet instead of an external one. This is\n\tprovided for browsers that have problems with including style sheets.\n    css_span (default:span)\n    \tPossible values are 'span' or 'font'. If 'font', the html output will\n\tnot emit span tags. This is provided for browsers that do not yet\n\tsupport HTML 4.x.\n    link_back (default:\"\")\n    \tA string in html format that gets inserted as a link to a parent\n\tpage into the generated pretty-printed source index.html page.\n\nSee Also\n   pretty_print / 1"},"probe:add_con/3":{"prefix":"add_con","body":"add_con(${1:Constraint}, ${2:Options}, ${3:Handle})$4\n$0","description":"add_con(+Constraint, ++Options, +Handle)\n\n   Add a constraint to the fd and linear solvers\n\nArguments\n   Constraint    A numerical constraint, with functor \n    '=:=', '>=', '=<', '>' or '<'\n   Options    An options structure\n   Handle    A linear solver handle\n\nType\n   library(probe)\n\nDescription\n \nIf the inequality is strict, X>Y or X', then the granularity \n specified in the options is added to the smaller term to create a non-strict \n inequality, which can be passed to the linear solver.  Thus if the granularity\n is 3, then for X>Y the constraint X>=Y+3 is added to the \n linear  solver and  X#>=Y+3  is added to the fd solver.\n\nResatisfiable\n   no\n\nSee Also\n   set_up_probe / 5"},"pretty_printer:pretty_printer_desc":{"prefix":"lib","body":"lib(${1:pretty_printer})$2\n$0","description":"lib(pretty_printer)\n\nThis library prints a file in different formats. It can either produce \n\ntxt\n\ttext only format, reformatting the input\nhtml\n\thtml format with syntax coloring and navigation"},"probe:probe_desc":{"prefix":"lib","body":"lib(${1:probe})$2\n$0","description":"lib(probe)\n\n    This implementation of probing is a call to an external linear solver, \n    whose optimal solution is assigned to the problem variables as tentative \n    variables.\n\nA counter is created an initialised to zero.  At every probe it is incremented.\nThe counter can be set using set_probect(N), and can be read using \nget_probect(N)"},"probe_search:probe_search/5":{"prefix":"probe_search","body":"probe_search(${1:Bivs}, ${2:BivSums}, ${3:Resource}, ${4:Options}, ${5:Handle})$6\n$0","description":"probe_search(+Bivs, +BivSums, ++Resource, ++Options, +Handle)\n\n   Add alternative constraints to try and repair infeasible probes\n\nArguments\n   Bivs    A list of lists of binary integer variables\n   BivSums    A list of integer variables, each one the sum of a list \n    of binaries\n   Resource    An integer quantity of resource available\n   Options    An options structure\n   Handle    A linear solver handle\n\nType\n   library(probe_search)\n\nDescription\n\n    Based on the tentative assignments, probe_search finds a task\n    start time where the resources are not sufficient to make the\n    tentative assignment feasible.  In case a bottleneck task has a\n    variable resource requirement, this is reduced to its minimum\n    possible value. Otherwise, probe_search chooses a binary\n    'overlap' variable at this bottleneck and using add_con it adds \n    a constraint trying to eliminate the overlap.\n\nResatisfiable\n   no\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, probe : add_con / 3, ic_probe : add_con / 3"},"probe:set_up_probe/5":{"prefix":"set_up_probe","body":"set_up_probe(${1:Tasks}, ${2:Constraints}, ${3:Cost}, ${4:Options}, ${5:Handle})$6\n$0","description":"set_up_probe(+Tasks, +Constraints, -Cost, ++Options, -Handle)\n\n   Sets up a linear probe for a set of constraints\n\nArguments\n   Tasks    A term containing some variables\n   Constraints    A list of numerical constraints\n   Cost    A cost variable\n   Options    An options structure\n   Handle    A variable which will record the handle of the matrix \nused by the linear solver\n\nType\n   library(probe)\n\nDescription\n\nThe constraints are passed to add_con, which adds them to both the \nfd and linear solvers.  The cost is declared to be an integer.  All the \nfinite domain variables in the term Tasks are associated with a demon \nwhich forwards their bounds to the linear solver.  (The priority of this \ndemon is one higher than that of the probe.)\n\nlp_demon_setup is then invoked to set up the linear solver, with the \npriority specified in the Options parameter.  Solutions returned\nby the linear solver are automatically used to update the tentative values  \nof all the variables.\n\nResatisfiable\n   no\n\nExamples\n   \n?- Options = options{granularity:3,priority:5},\n   Cost=X1,\n   set_up_probe([X1,X2,X3],[X1>X2,X2>X3],Cost,Options,H).\n\nSee Also\n   probing_for_scheduling : probe_cstr_sched / 7, ic_probing_for_scheduling : probe_cstr_sched / 7, add_con / 3, eplex : lp_demon_setup / 5"},"probe_search:probe_search_desc":{"prefix":"lib","body":"lib(${1:probe_search})$2\n$0","description":"lib(probe_search)\n\n    A search routine which fixes resource bottlenecks by forcing tasks not to overlap."},"probe_support:probe_support_desc":{"prefix":"lib","body":"lib(${1:probe_support})$2\n$0","description":"lib(probe_support)\n\n    A library exporting structures and predicates used in probing for scheduling.\n\nThe following two structures are exported:\n\ntask(start,duration,resource)\noptions(granularity,priority)"},"probing_for_scheduling:fun_to_cons_var/3":{"prefix":"fun_to_cons_var","body":"fun_to_cons_var(${1:CostFun}, ${2:ConsList}, ${3:CostVar})$4\n$0","description":"fun_to_cons_var(+CostFun, -ConsList, -CostVar)\n\n   Convert a cost expression to a variable and a list of constraints, \nsuitable to pass into probe_cstr_sched/7\n\nArguments\n   CostFun    a cost function of the form accepted by probe_sched/5\n   ConsList    a variable which will be instantiated to a list of constraints, \nsuitable to pass into probe_cstr_sched/7\n   CostVar    a variable constrained to take a value greater than or equal to \nthe cost function\n\nType\n   library(probing_for_scheduling)\n\nDescription\n\nIf the user needs to use probe_cstr_sched instead of probe_sched, this predicate can be used to convert the cost function to a list of constraints and a cost variable suitable for passing to probe_cstr_sched\n\nResatisfiable\n   no\n\nExamples\n   \nfun_to_cons_var(abs(X-10)+abs(Y-3),ConsList,Var)\n\nSee Also\n   probe_sched / 5, probe_cstr_sched / 7"},"probing_for_scheduling:probe_sched/5":{"prefix":"probe_sched","body":"probe_sched(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:MaxResource}, ${5:CostFun})$6\n$0","description":"probe_sched(+Starts, +Durations, +Resources, ++MaxResource, ?CostFun)\n\n   Find a resource-feasible schedule that minimises the\ncost function\n\nArguments\n   Starts    a list of (n) task start times (integers or\nfinite domain variables)\n   Durations    a list of (n) task durations (integers or\nfinite domain variables)\n   Resources    a list of (n) task resource needs (integers or \nfinite domain variables)\n   MaxResource    The available resource, not to be exceeded\n   CostFun    An expression involving start times and durations\nto be minimised\n\nType\n   library(probing_for_scheduling)\n\nDescription\n\n\tThis predicate finds start times for a set of tasks, which\nminimise the value of a given cost function.\n\nThe cost function is the only information the search algorithm can use to\nfocus on the optimum.  It cannot guide the search if the cost is a variable, \nonly linked to the tasks start times by constraints.  For this reason the \ncost function admits the special functions abs and maxlist.\n\nThe syntax for cost functions is:\n\nCostFunction ::- PosExpr | PosExpr + PosExpr | Integer * PosExpr\nPosExpr ::- abs(LinearExpr) | maxlist([LinearExpr]) | LinearExpr.\n\nThe algorithm is described in more detail in the documentation of \nprobe_cstr_sched/7. \n\nResatisfiable\n   no\n\nExamples\n   \nprobe_schedule(Starts,CostFun) :-\n\tStarts=[X,Y,Z],\n    fd:(Starts::1..10),\n    Durations=[10,5,5],\n    Resources=[R1,R2,R3],\n    fd:(R1::1..2), R2=2, R3=1,\n    MaxResource=2,\n    [OldX,OldY,OldZ]=[1,5,5],\n    CostFun= abs(X-OldX)+abs(Y-OldY)+abs(Z-OldZ),\n\tprobe_sched(Starts,Durations,Resources,MaxResource,CostFun).\n\nSee Also\n   probe_cstr_sched / 7, fd : min_max / 2, probe : set_up_probe / 5, ic_probe : set_up_probe / 5, ic_make_overlap_bivs : make_overlap_bivs / 5, make_overlap_bivs : make_overlap_bivs / 5, probe_search : probe_search / 5, ic_probe_search : probe_search / 5, ic_global : maxlist / 2, ic : maxlist / 2, fd_global : maxlist / 2"},"profile:profile/1":{"prefix":"profile","body":"profile(${1:Goal})$2\n$0","description":"profile(+Goal)\n\n   Execute Goal (once) and print profiling information\n\nType\n   library(profile)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"probing_for_scheduling:probing_for_scheduling_desc":{"prefix":"lib","body":"lib(${1:probing_for_scheduling})$2\n$0","description":"lib(probing_for_scheduling)\n\n    This is a complete search method for resource-constrained scheduling \n    problems\n    \n    The user interface is similar to the cumulative constraint, with a \n    list of task start times, durations and resources; and a maximum \n    resource limit.  There is one extra argument, a cost function which \n    is to be minimised. \n    \n    Probing for scheduling differs radically from the cumulative constraint\n    because it includes a search routine.  In its behaviour it is an\n    optimisation procedure and not simply a constraint which enforces \n    consistency. \n    \n    The search is focussed towards an optimal vlaue of the cost function."},"probing_for_scheduling:probe_cstr_sched/7":{"prefix":"probe_cstr_sched","body":"probe_cstr_sched(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:MaxResource}, ${5:Constraints}, ${6:Cost}, ${7:Options})$8\n$0","description":"probe_cstr_sched(+Starts, +Durations, +Resources, ++MaxResource, +Constraints, -Cost, ++Options)\n\n   Find a resource-feasible schedule that minimises the\ncost, subject to the constraints\n\nArguments\n   Starts    A list of (n) task start times (integers or\nfinite domain variables)\n   Durations    A list of (n) task durations (integers or\nfinite domain variables)\n   Resources    A list of (n) task resource needs (integers)\n   MaxResource    The available resource, not to be exceeded\n   Constraints    A list of numeric equations and inequations, \nusing functors '=:=', '>=', '>', '=<' and '<'.\n   Cost    A numeric variable which will be minimised during search\n   Options    A list, '[granularity(G),priority(P)]',\n    where\n    'G' is an integer specifying the time granularity, and\n    'P' is the priority of the probe demon.\n\nType\n   library(probing_for_scheduling)\n\nDescription\n \nThis offers the same functionality as probe_sched/5, but with added \nflexibility, and a more complex user interface.  The extra arguments offer \nthe user  more control.  \n\nThe Cost argument is a variable, and it must be linked to the task \nvariables by the list of linear constraints.  The user can add not only \nlinear constraints on the cost function, but also constraints between the \ntask variables.  Only constraints made explicit in this list are 'seen' by \nthe probe.   probe_cstr_sched also posts them to the fd solver.\n\nThe options offer user control over\nthe temporal granularity, and the priority of the probe.\n\nThe algorithm uses min_max, but directs the search using a probe\nwhich focusses the search on the optimum.  The probe is a procedure\nthat finds optimal solutions to a relaxed problem ignoring resource\nlimits.  For details see setup_probe.  Additionally the algorithm\nsets up a binary variable between each pair of tasks, see\nmake_overlap_bivs.  Whenever the probe returns tentative start\ntimes, these are propagated to the overlap binary variables yielding a\ntotal resource usage which reveals any bottlenecks, where needed\nresources exceed thos available.  probe_search then\nnon-deterministically introduces a new constraint which reduces the\nbottleneck.\nThe probe_sched call:\n\nprobe_sched(Ss,Ds,Rs,MaxR,abs(X-X1)+Y)\n\ntranslates into the probe_cstr_sched call:\n\nprobe_cstr_sched(Ss,Ds,Rs,MaxR,[Cost=:=E1+Y,E1>=X-X1,E1>=X1-X],Cost,\n[granularity(1),priority(5)])\n\nThus making the default granularity '1' and the default priority '5'.\n\nResatisfiable\n   no\n\nSee Also\n   probe_sched / 5, fd : min_max / 2, probe : set_up_probe / 5, ic_probe : set_up_probe / 5, ic_make_overlap_bivs : make_overlap_bivs / 5, make_overlap_bivs : make_overlap_bivs / 5, probe_search : probe_search / 5, ic_probe_search : probe_search / 5"},"profile:profile/2":{"prefix":"profile","body":"profile(${1:Goal}, ${2:Options})$3\n$0","description":"profile(+Goal, +Options)\n\n   Execute Goal (once) and print profiling information\n\nArguments\n   Goal    Callable term\n   Options    List of options\n\nType\n   library(profile)\n\nDescription\nPossible options:\n    \n    simple\n\tshow external predicates in the output profile\n    keep_file\n\tdon't destroy the samples file after profiling\n    \n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"queues:empty_queue/1":{"prefix":"empty_queue","body":"empty_queue(${1:Queue})$2\n$0","description":"empty_queue(Queue)\n\n   tests whether the queue is empty\n\nType\n   library(queues)\n\nDescription\n\n    tests whether the queue is empty.  If the back of a queue were\n    guaranteed to be a variable, we could have\n\n \tempty_queue(Front-Back) :- var(Front).\n\n    but I don't see why you shouldn't be able to treat difference\n    lists as queues if you want to."},"queues:join_queue/3":{"prefix":"join_queue","body":"join_queue(${1:Element}, ${2:OldQueue}, ${3:NewQueue})$4\n$0","description":"join_queue(Element, OldQueue, NewQueue)\n\n   adds the new element at the end of the queue\n\nType\n   library(queues)\n\nDescription\n\n    adds the new element at the end of the queue.  The old queue is\n    side-effected, so you *can't* do\n\n \tjoin_queue(1, OldQ, NewQ1),\n \tjoin_queue(2, OldQ, NewQ2).\n\n    There isn't any easy way of doing that, sensible though it might\n    be.  You *can* do\n\n \tjoin_queue(1, OldQ, MidQ),\n \tjoin_queue(2, MidQ, NewQ).\n\n    \n\nSee Also\n   list_join_queue / 3"},"queues:head_queue/2":{"prefix":"head_queue","body":"head_queue(${1:Queue}, ${2:Head})$3\n$0","description":"head_queue(Queue, Head)\n\n   unifies Head with the first element of the queue\n\nType\n   library(queues)\n\nDescription\n\n    unifies Head with the first element of the queue.  The tricky part\n    is that we might be at the end of a queue: Back-Back, with Back a\n    variable, and in that case this predicate should not succeed, as we\n    don't know what that element is or whether it exists yet."},"queues:jump_queue/3":{"prefix":"jump_queue","body":"jump_queue(${1:Element}, ${2:OldQueue}, ${3:NewQueue})$4\n$0","description":"jump_queue(Element, OldQueue, NewQueue)\n\n   adds the new element at the front of the list\n\nType\n   library(queues)\n\nDescription\n\n    adds the new element at the front of the list.  Unlike join_queue,\n\n \tjump_queue(1, OldQ, NewQ1),\n \tjump_queue(2, OldQ, NewQ2)\n\n    *does* work, though if you add things at the end of NewQ1 they\n    will also show up in NewQ2.  Note that\n\n \tjump_queue(1, OldQ, MidQ),\n \tjump_queue(2, MidQ, NewQ)\n\n    makes NewQ start 2, 1, ..."},"queues:list_join_queue/3":{"prefix":"list_join_queue","body":"list_join_queue(${1:List}, ${2:OldQueue}, ${3:NewQueue})$4\n$0","description":"list_join_queue(List, OldQueue, NewQueue)\n\n   adds the new elements at the end of the queue\n\nType\n   library(queues)\n\nDescription\n\n    adds the new elements at the end of the queue.  The elements are\n    added in the same order that they appear in the list, e.g.\n\n    list_join_queue([y,z], [a,b,c|M]-M, [a,b,c,y,z|N]-N)."},"queues:length_queue/2":{"prefix":"length_queue","body":"length_queue(${1:Queue}, ${2:Length})$3\n$0","description":"length_queue(Queue, Length)\n\n   counts the number of elements currently in the queue\n\nType\n   library(queues)\n\nDescription\n\n    counts the number of elements currently in the queue.  Note that\n    we have to be careful in checking for the end of the list, we\n    can't test for [] the way length(List) does."},"queues:list_jump_queue/3":{"prefix":"list_jump_queue","body":"list_jump_queue(${1:List}, ${2:OldQueue}, ${3:NewQueue})$4\n$0","description":"list_jump_queue(List, OldQueue, NewQueue)\n\n   adds all the elements of List at the front of the queue\n\nType\n   library(queues)\n\nDescription\n\n    adds all the elements of List at the front of the queue.  There  are\n    two  ways  we might do this.  We could add all the elements one at a\n    time, so that they would appear at the beginning of the queue in the\n    opposite order to the order they had in the list, or  we  could  add\n    them in one lump, so that they have the same order in the  queue  as\n    in  the  list.   As you can easily add the elements one at a time if\n    that is what you want, I have chosen the latter."},"queues:make_queue/1":{"prefix":"make_queue","body":"make_queue(${1:Queue})$2\n$0","description":"make_queue(Queue)\n\n   creates a new empty queue\n\nType\n   library(queues)\n\nDescription\n\n    creates a new empty queue.  It will also match empty queues, but\n    because Prolog doesn't do the occurs check, it will also match\n    other queues, creating circular lists.  So this should ONLY be\n    used to make new queues."},"queues:list_to_queue/2":{"prefix":"list_to_queue","body":"list_to_queue(${1:List}, ${2:Queue})$3\n$0","description":"list_to_queue(List, Queue)\n\n   creates a new queue with the same elements as List\n\nType\n   library(queues)"},"queues:queue_to_list/2":{"prefix":"queue_to_list","body":"queue_to_list(${1:Queue}, ${2:List})$3\n$0","description":"queue_to_list(Queue, List)\n\n   creates a new list with the same elements as Queue\n\nType\n   library(queues)"},"queues:serve_queue/3":{"prefix":"serve_queue","body":"serve_queue(${1:OldQueue}, ${2:Head}, ${3:NewQueue})$4\n$0","description":"serve_queue(OldQueue, Head, NewQueue)\n\n   removes the first element of the queue for service\n\nType\n   library(queues)"},"queues:queues_desc":{"prefix":"lib","body":"lib(${1:queues})$2\n$0","description":"lib(queues)\n\n    In this package, a queue is represented as a term Front-Back,  where\n    Front  is  a list and Back is a tail of that list, and is normally a\n    variable.  join_queue will only work when the Back  is  a  variable,\n    the  other routines will accept any tail.  The elements of the queue\n    are the list difference, that is, all the elements starting at Front\n    and stopping at Back.  Examples:\n\n\t[a,b,c,d,e|Z]-Z\t    has elements a,b,c,d,e\n\t[a,b,c,d,e]-[d,e]   has elements a,b,c\n\tZ-Z\t\t    has no elements\n\t[1,2,3]-[1,2,3]\t    has no elements"},"quintus:quintus_desc":{"prefix":"lib","body":"lib(${1:quintus})$2\n$0","description":"lib(quintus)\n\n    ECLiPSe includes a Quintus Prolog compatibility package to ease the\n    task of porting Quintus Prolog applications to ECLiPSe Prolog.  This\n    package does not provide the user with a system completely compatible\n    to Quintus Prolog, however it provides most of the Quintus built-in\n    predicates, moreover some of the Quintus library predicates are\n    available in the ECLiPSe library.  This package includes the C-Prolog\n    compatibility package (see Appendix A.6). \n    \n    Please note that this appendix does not detail the functionality of\n    Quintus Prolog, refer to the Quintus Prolog documentation for this\n    information. \n    \n    The effect of the compatibility library is local to the module where\n    it is loaded. For maximum compatibility, a Quintus program should\n    be wrapped in a separate module starting with a directive like\n    \n    :- module(mymodule, [], quintus).\n    \n    In this case, Eclipse-specific language constructs will not be available.\n    \n    If the compatibility package is loaded into a standard module, e.g. like\n    \n    :- module(mymixedmdule).\n    :- use_module(library(quintus)).\n    \n    then Quintus and Eclipse language features can be used together. \n    However, ambiguities must be resolved explicitly and confusion may\n    arise from the different meaning of quotes in Eclipse vs Quintus-Prolog.\n    \n    The following differences remain even with the compatibility package: \n    \n    expand_term/2 \n\tThis predicate is dummy, since the ECLiPSe macro facility\n\tworks on every input term, provided that the flag\n\tmacro_expansion is set to on. \n    get0/2 \n\tThis predicate is identical to get/2 in ECLiPSe. \n    help/1 \n\tThis is the normal ECLiPSe help/1 predicate. \n    meta_predicate/1 \n\tThis declaration does not cause passing of module information\n\tin Quintus-style, as ECLiPSe's concept of meta predicates\n\tdiffers substantially.  The meta-predicates very likely have\n\tto be modified manually to use ECLiPSe tools (see User Manual).\n    multifile/1 \n\tThis is implemented by declaring the predicates as dynamic, so\n\tto obtain more efficient programs it is better to put all\n\tclauses of the same procedure into one file (or to concatenate\n\tall files where multifile predicates occur). \n    predicate_property/2 \n\tThe property interpreted is not provided.  The property\n\texported is returned if the predicate is exported or global. \n\tUse of get_flag/3 should be preferred. \n    prolog_flag/2, 3 \n\tThere are some differences in the flags, as they are mostly\n\tsimulated with the ECLiPSe flags:\n\t\n\t    not all the character escapes used in the Quintus Prolog\n\t    are available.\n\t    gc_margin is taken as the ECLiPSe flag gc_interval\n\t    (see Section 19.2)\n\t    setting gc_trace to on sets also gc to on\n\t\n    public/1\n\tsynonym for export/1 \n    statistics/0, 2 \n\tthese predicates are slightly different than in Quintus, in\n\tparticular the meaning of the memory statistics is approximate,\n\tand the output format is different.\n    ttyflush/0, ttyget/1, ttyget0/1, ttynl/0, ttyput/1, ttyskip/1, ttytab/1 \n\tthese predicates work with the stdout stream \n    line_position/2\n\tNot implemented.  To perform sophisticated output formatting,\n\tprintf/2,3 or string streams can be used.\n    \n    The list below describes the syntax differences between\n    ECLiPSe and Quintus Prolog.  The following properties of Quintus\n    Prolog are simulated by the compatibility package: \n    \n\tsingle (resp.  double) quote must be doubled between\n\t    single (resp.  double) quote. \n\tThe symbol | (bar) is recognised as an alternative sign\n\t    for a disjunction and it acts as an infix operator. \n\tthe symbol | is not an atom\n    \n    The following Quintus properties are not simulated: \n    \n\ta clause can not be ended by end of file. \n\tsigned numbers: explicitly positive numbers are structures. \n\ta real with an exponent must have a floating point. \n\ta space is allowed before the decimal point and the exponent sign. \n\tthe definition of the escape sequence is more extended\n\t    than in ECLiPSe. \n\tspy/1 and nospy/1 accept as arguments lists, rather than\n\t    comma-separated terms like in ECLiPSe."},"regex:match/2":{"prefix":"match","body":"match(${1:Pattern}, ${2:String})$3\n$0","description":"match(+Pattern, +String)\n\n   A substring of String matches the regular expression Pattern\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n\nType\n   library(regex)\n\nDescription\n\n\tSucceeds if all or a substring of String matches the regular\n\texpression Pattern. For the description of regular expressions\n\tsee the library(regex) page.\n\t\n    \tEquivalent to match(Pattern, String, []).\n    \n\nModes and Determinism\n   match(+, +) is semidet\n\nFail Conditions\n   String does not match Pattern\n\nExamples\n   \n    ?- match(\"aca\", \"abracadabra\").\n    Yes\n\n    ?- match(\"^a[cd]a$\", \"abracadabra\").\n    No\n\n    ?- match(\"^a[cd]a$\", \"ada\").\n    Yes\n    \n\nSee Also\n   library(regex), match / 3, match / 4, matchsub / 4, matchall / 4, split / 4, compile_pattern / 3"},"regex:compile_pattern/3":{"prefix":"compile_pattern","body":"compile_pattern(${1:Pattern}, ${2:Options}, ${3:CompiledPattern})$4\n$0","description":"compile_pattern(+Pattern, +Options, -CompiledPattern)\n\n   Precompile a pattern for repeated use\n\nArguments\n   Pattern    A string\n   Options    List of atoms\n   CompiledPattern     Output: a compiled pattern handle\n\nType\n   library(regex)\n\nDescription\n\n\tAll matching predicates in this library accept either a regular\n\texpression in string form, or a precompiled regular expression.\n\tThe matching predicates will execute faster if invoked with a\n\tprecompiled pattern instead of the string.  Whenever a pattern\n\tneeds to be matched more than once, it will typically be more\n\tefficient to work with a precompiled pattern.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.  The options give here\n\tshould be the same as the ones given to the matching-predicates later.\n\t\n\tThe space consumed by the compiled pattern will be automatically\n\treclaimed on failure, or on garbage collection when no longer needed.\n    \n\nModes and Determinism\n   compile_pattern(+, +, -) is det\n\nFail Conditions\n   None\n\nExamples\n   \n    ?- compile_pattern(\"ab+a\", [], C),\n       match(C, \"bbabbbaab\", [], M1),\n       match(C, \"abacus\", [], M2).\n\n    C = 'HANDLE'(16'00025c60)\n    M1 = \"abbba\"\n    M2 = \"aba\"\n    Yes\n    \n\nSee Also\n   library(regex), match / 2, match / 3, match / 4, matchsub / 4, matchall / 4"},"regex:match/3":{"prefix":"match","body":"match(${1:Pattern}, ${2:String}, ${3:Options})$4\n$0","description":"match(+Pattern, +String, +Options)\n\n   A substring of String matches the regular expression Pattern\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n   Options    List of atoms\n\nType\n   library(regex)\n\nDescription\n\n\tSucceeds if all or a substring of String matches the regular\n\texpression Pattern. For the description of regular expressions\n\tsee the library(regex) page.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.\n    \n\nModes and Determinism\n   match(+, +, +) is semidet\n\nFail Conditions\n   String does not match Pattern\n\nExamples\n   \n    ?- match(\"april\", \"April\", []).\n    No\n    ?- match(\"april\", \"April\", [icase]).\n    Yes\n\n    ?- match(\"(^(a[cd]a)$)+\", \"aca\\nada\", []).\n    No\n    ?- match(\"(^(a[cd]a)$)+\", \"aca\\nada\", [newline]).\n    Yes\n\n    ?- match(\"\\\\<word\\\\>\", \"a word only\", [basic]).\n    Yes\n    ?- match(\"\\\\<word\\\\>\", \"not words though\", [basic]).\n    No\n    \n\nSee Also\n   library(regex), match / 2, match / 4, matchall / 4, matchsub / 4, split / 4, compile_pattern / 3"},"regex:matchall/4":{"prefix":"matchall","body":"matchall(${1:Pattern}, ${2:String}, ${3:Options}, ${4:AllMatches})$5\n$0","description":"matchall(+Pattern, +String, +Options, -AllMatches)\n\n   AllMatches is a list of substrings of String which match the regular expression Pattern\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n   Options    List of atoms\n   AllMatches    Output: List of strings\n\nType\n   library(regex)\n\nDescription\n\n\tThis predicates always succeeds.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.\n\t\n\tAllMatches is bound to a list of strings. If the input string String\n\tdoes not match the pattern, the list is empty. Otherwise the list\n\tcontains substrings of String which match the entire pattern,\n\tordered according to their occurrence within String. No overlapping\n\tmatches are returned, i.e. the next match is found by examining the\n\tremainder of String after the previous match.\n\t\n\tNote that this predicate does not return any information about\n\tmatching (parenthesised) sub-expressions!\n    \n\nModes and Determinism\n   matchall(+, +, +, -) is det\n\nFail Conditions\n   None\n\nExamples\n   \n    ?- matchall(\"[0-9]+\", \" blue 27 red123 green99\", [], L).\n    L = [\"27\", \"123\", \"99\"]\n    Yes\n\n    ?- matchall(\"([0-9]+|[^0-9]+)\", \" blue 27 red123 green99\", [], L).\n    L = [\" blue \", \"27\", \" red\", \"123\", \" green\", \"99\"]\n    Yes\n    \n\nSee Also\n   library(regex), match / 2, match / 3, match / 4, split / 4, compile_pattern / 3"},"regex:match/4":{"prefix":"match","body":"match(${1:Pattern}, ${2:String}, ${3:Options}, ${4:Match})$5\n$0","description":"match(+Pattern, +String, +Options, -Match)\n\n   Match is the first substring of String that matches the regular expression Pattern\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n   Options    List of atoms\n   Match    Output: a string\n\nType\n   library(regex)\n\nDescription\n\n\tSucceeds if all or a substring of String matches the regular\n\texpression Pattern. For the description of regular expressions\n\tsee the library(regex) page.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.\n\t\n\tMatch is bound to the first substring of String which matches\n\tPattern.\n\t\n\tNote that this predicate does not return any information about\n\tmatching (parenthesised) sub-expressions!\n    \n\nModes and Determinism\n   match(+, +, +, -) is semidet\n\nFail Conditions\n   String does not match Pattern\n\nExamples\n   \n    ?- match(\"<[a-z]+>\", \"Text with <HTML> tags\", [icase], M).\n    M = \"<HTML>\"\n    Yes\n    \n\nSee Also\n   library(regex), match / 2, match / 3, matchsub / 4, matchall / 4, compile_pattern / 3"},"remote_tools:attach_tools/0":{"prefix":"attach_tools","body":"attach_tools","description":"attach_tools\n\n   Initiate the attachment of remote development tools\n\nType\n   library(remote_tools)\n\nDescription\n   Initiate the attachment of the remote development tools. This will create\n   a connection waiting for the remote development tools to be attached to.\n   It will print the hostname and the port number that should be given to\n   the development tools. The remote development tools should be started \n   and supplied with the hostname and port number. Once this is done, the\n   development tools are ready to be used. Control is initially given back\n   to ECLiPSe when the tools have been attached.\n\nFail Conditions\n   Development tools already attached.\n\nResatisfiable\n   no\n\nSee Also\n   tools / 0, attach_tools / 3"},"regex:matchsub/4":{"prefix":"matchsub","body":"matchsub(${1:Pattern}, ${2:String}, ${3:Options}, ${4:SubMatches})$5\n$0","description":"matchsub(+Pattern, +String, +Options, -SubMatches)\n\n   A substring of String matches the regular expression Pattern and SubMatches are matching sub-expressions\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n   Options    List of atoms\n   SubMatches    Output: List of strings\n\nType\n   library(regex)\n\nDescription\n\n\tSucceeds if all or a substring of String matches the regular\n\texpression Pattern. For the description of regular expressions\n\tsee the library(regex) page.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.\n\t\n\tSubMatches is bound to a list of strings, each corresponding to\n\ta parenthesized subexpression in Pattern. These subexpressions\n\tare ordered according to the position of their opening parenthesis\n\twithin the pattern. The matching string appears on the corresponding\n\tposition in the SubMatches list. Note that, if a subexpression matches\n\tseveral times, only the last match is returned.\n\t\n    \n\nModes and Determinism\n   matchsub(+, +, +, -) is semidet\n\nFail Conditions\n   String does not match Pattern\n\nExamples\n   \n    ?- matchsub(\"Name:([^,]+), Age:([0-9]+),\", \"Name:Fred, Age:34,\", [], L).\n    L = [\"Fred\", \"34\"]\n    Yes\n    \n\nSee Also\n   library(regex), match / 2, match / 3, match / 4, compile_pattern / 3"},"regex:split/4":{"prefix":"split","body":"split(${1:Pattern}, ${2:String}, ${3:Options}, ${4:Parts})$5\n$0","description":"split(+Pattern, +String, +Options, -Parts)\n\n   Parts is a list of substrings, partitioning String according to Pattern\n\nArguments\n   Pattern    A string (or a compiled pattern handle)\n   String    A string\n   Options    List of atoms\n   Parts    Output: List of strings\n\nType\n   library(regex)\n\nDescription\n\n\tThis predicates always succeeds.\n\t\n    \tOptions is a (possibly empty) list of atomic option names,\n\tas described in the library(regex) page.\n\t\n\tParts is bound to a list of strings which are consecutive substrings\n\tof the input string String (i.e. concatenating this list using\n\tconcat_strings/2 will yield the original String). The list is\n\tconstructed such that it has an odd number of elements, where the\n\teven numbered elements match the pattern, and the odd numbered\n\telements contains those portions of String that did not match\n\tthe Pattern. Some of these substrings may be empty.\n\t\n\tThis partitioning of the String can be used to construct a new\n\tstring with the matches replaced by something else. Use the\n\tfollowing code pattern:\n\t\n\t    split(Pattern, String, Options, Parts),\n\t    (\n\t\tfromto(Parts, [NoMatch,Match|NMs], NMs, [Last]),\n\t\tfromto(Repl,  [NoMatch,Subst|NSs], NSs, [Last])\n\t    do\n\t\t%%% compute Subst from Match here %%%\n\t    ),\n\t    concat_string(Repl, NewString),\n\t\n\t\n\tNote that the split/4 predicate does not return any information about\n\tmatching (parenthesised) sub-expressions!\n    \n\nModes and Determinism\n   split(+, +, +, -) is det\n\nFail Conditions\n   None\n\nExamples\n   \n    ?- split(\"cad\", \"abracadabra\", [], Parts).\n    Parts = [\"abra\", \"cad\", \"abra\"]\n    Yes (0.00s cpu)\n\n    ?- split(\"bra\", \"abracadabra\", [], Parts).\n    Parts = [\"a\", \"bra\", \"cada\", \"bra\", \"\"]\n    Yes (0.00s cpu)\n\n    ?- split(\"bla\", \"abracadabra\", [], Parts).\n    Parts = [\"abracadabra\"]\n    Yes (0.00s cpu)\n\n    ?- split(\"a\", \"aaa\", [], Parts).\n    Parts = [\"\", \"a\", \"\", \"a\", \"\", \"a\", \"\"]\n    Yes (0.00s cpu)\n \n    ?- split(\"%[a-z]\", \"format %s %f=%d.\", [], Parts).\n    Parts = [\"format \", \"%s\", \" \", \"%f\", \"=\", \"%d\", \".\"]\n    Yes (0.00s cpu)\n\n    % With the following definition\n    replace(Pattern, New, String, NewString) :-\n\tsplit(Pattern, String, [], Parts),\n\t(\n\t    fromto(Parts, [NoMatch,_Match|NMs], NMs, [Last]),\n\t    fromto(Repl,  [NoMatch, Subst|NSs], NSs, [Last]),\n\t    param(New)\n\tdo\n\t    Subst = New\n\t),\n\tconcat_string(Repl, NewString).\n\n    ?- replace(\"2\", \"to\", \"2 be or not 2 be\", S).\n    S = \"to be or not to be\"\n    Yes (0.00s cpu)\n    \n\nSee Also\n   library(regex), matchall / 4, compile_pattern / 3, concat_string / 2, split_string / 4"},"regex:regex_desc":{"prefix":"lib","body":"lib(${1:regex})$2\n$0","description":"lib(regex)\n\n    This library implements an ECLiPSe API for POSIX 1003.2 regular\n    expressions (on Unix systems it calls the regular expression\n    functions from the standard library, on Windows it uses Henry\n    Spencer's regex library version 3.8).\n\n    Regular Expressions\n    This is just a very brief summary of the essentials.  For details\n    of regular expressions see any POSIX regex(7) man page.\n    Two types of regular expressions are supported:\n    \n    Extended Regular Expressions (the default)\n\tThese are described below and correspond essentially to those\n\tunderstood by the UNIX egrep command.\n    Basic Regular Expressions\n\tThese correspond essentially to those in the UNIX ed editor\n\tor the grep command, and are mostly obsolete.\n    \n    Note that our choice of default differs from the POSIX 1003.2 C API.\n\n    Characters\n    Every character stands for itself, except for the characters\n    ^.[$()|*+?{\\ which must be escaped with a \\ to prevent\n    them from having special meaning (and note that, since the ECLiPSe\n    parser already interprets backslashes, you will have escape the\n    backslash with another backslash in your ECLiPSe source string).\n    \n    .\n\tMatches any character\n    [aeiou]\n\tMatches any of the characters between the brackets\n    [^aeiou]\n\tMatches any character except those listed\n    [a-z0-9]\n\tMatches any character in the given ranges\n    \n\n    Anchors\n    \n    ^\n\tMatches at the beginning of the string (or line)\n    $\n\tMatches at the end of the string (or line)\n    \n\n    Repetition\n    \n    ?\n\tMatches the preceding element 0 or 1 times\n    *\n\tMatches the preceding element 0 or more times\n    +\n\tMatches the preceding element 1 or more times\n    {3}\n\tMatches the preceding element 3 times\n    {1,3}\n\tMatches the preceding element 1 to 3 times\n    \n\n    Grouping\n    \n    (subexpr)\n\tMatches the parenthesized expression. This grouping is used\n\tin connection with the repetition operators, or for indicating \n\tsubexpressions whose matches are to be captured and returned\n    (one|two|three)\n\tMatches any of the alternative expressions\n    \n\n    Options\n    Most of the predicates in this library accept a list of options.\n    The accepted options are:\n    \n    basic\n\tInterpret the pattern as a Basic Regular Expression, rather\n\tthan the default Extended Regular Expression.\n    extended\n\tInterpret the pattern as an Extended Regular Expression\n\t(this flag is redundant since this is the default).\n    icase\n\tIgnore case when matching.\n    newline\n\tTreat newlines specially, i.e. don't treat them as normal\n\tcharacters and make ^ match after a newline and $ before a newline.\n\tBy default, newlines are treated as ordinary characters.\n    notbol\n\tDon't interpret the beginning of the string as the beginning\n\tof a line, i.e. don't let ^ match there.\n    noteol\n\tDon't interpret the end of the string as the end of a line,\n\ti.e. don't let $ match there.\n\t\n    \n    Shortcomings\n    \n    \n    Due to limitations of the underlying implementation, the predicates\n    in this library do not handle embedded NUL characters in strings correctly\n    (they are interpreted as the end of the string).\n    \n    POSIX regular expressions don't seem to have a notion of  \"noncapturing\n    parentheses\", i.e. parentheses that are only used for grouping, not for\n    indicating that one wants to capture the matching substring.\n    \n    In an environment like ECLiPSe, one would like to be able to do things like\n    \n\t?- ideal_match(\"(/[^/]*)+\", \"/usr/local/eclipse\", L).\n\tL = [\"/usr\", \"/local\", \"/eclipse\"]\n\tYes\n    \n    i.e. capture every instance of a matching subexpression.  There seems\n    to be no way to do that with a POSIX regexp implementation."},"remote_tools:tools/0":{"prefix":"tools","body":"tools","description":"tools\n\n   Transfer control from ECLiPSe to the development tools.\n\nType\n   library(remote_tools)\n\nDescription\n\n\tTransfer the `control' from ECLiPSe to the development tools,\n\tallowing the user to use the development tools GUI interactively.\n\tThis predicate returns when control is returned to ECLiPSe.\n\n    Note that some features of the development tools can be triggered\n    without interacting directly with the GUI. For example, placing a\n    spy-point on a predicate will cause the tracer tool to pop-up when\n    the predicate is called.\n\n    If the development tools have not been attached beforehand,\n\tthe predicate tries to start them on the local machine,\n\tand attaches them.\n\nResatisfiable\n   no\n\nSee Also\n   attach_tools / 0, attach_tools / 3"},"remote_tools:attach_tools/3":{"prefix":"attach_tools","body":"attach_tools(${1:Address}, ${2:TimeOut}, ${3:Goal})$4\n$0","description":"attach_tools(?Address, ++TimeOut, ?Goal)\n\n   A flexible attachment of remote development tools\n\nArguments\n   Address    Address for the remote connection (Host/Port or variable)\n   TimeOut    Time-out interval (int/float or the atom block)\n   Goal    Goal to execute during connection\n\nType\n   library(remote_tools)\n\nDescription\n\n   Initiate the attachment of the remote development tools, providing the\n   user with more control over the connection than attach_tools/0. The\n   predicate will create a connection waiting for the remote development\n   tools to be attached to.  It will then execute Goal and then tries to\n   complete the connection by waiting at most TimeOut seconds for the\n   remote development tools to connect.  If TimeOut is the atom block, then\n   it will wait indefinitely.\n\n   Address is the Host/Port address that the remote connection will be\n   made.  This can be left as a variable, so that the system can determine\n   its own address, or the user can specify a specific Port. The main\n   purpose for Goal is to allow the user to start out the remote\n   development tools from it using Address, so that the user does not need\n   to manually connect the remote development tools. Control is initially\n   given back to ECLiPSe when the tools have been attached.\n\n   The predicate will fail or throw an exception if Goal respectively fails\n   or throw an exception. It will also fail if it waits more than TimeOut\n   seconds for the remote tools to connect. In these cases, the server\n   socket will be properly closed.\n\n   attach_tools/0 can be implemented using attach_tools/3 as follows:\n\n   \n    attach_tools :-\n    attach_tools(_, block, true).\n   \n   \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n      Development tools already attached, or waiting TimeOut seconds  \n   for remote tools to connect, or if Goal fails\n\nResatisfiable\n   no\n\nExceptions\n     4 --- Goal or TimeOut are variables\n     5 --- TimeOut is not an integer nor float nor atom\n     6 --- TimeOut is either too small or large or is an atom other than block\n\nExamples\n   \n    % the following will cause the remote tools to start automatically\n    % if tktools can be run from a shell. It will wait 10 seconds before\n    % failing and closing the server socket.\n    [eclipse 2]:  attach_tools(H/P,10,\n    exec(['tktools','--','-h',H,'-p',P], [], Pid)).\n\n    H = 'cow.icparc.ic.ac.uk'\n    P = 1953\n    Pid = 27678\n    Yes (0.04s cpu)\n    [eclipse 3]:\n   \n\nSee Also\n   tools / 0, attach_tools / 0"},"remote_tools:attached/1":{"prefix":"attached","body":"attached(${1:ControlStream})$2\n$0","description":"attached(?ControlStream)\n\n   Checks if remote tools are currently attached or not.\n\nArguments\n   ControlStream       control stream (stream name or variable)\n\nType\n   library(remote_tools)\n\nDescription\n\n\tChecks if the remote development tools have been attached to this \n    ECLiPSe session or not. If attached, the predicate succeeds and \n    returns the stream name of the control stream. If not attached, the\n    predicate fails.\n\nFail Conditions\n   Remote tools are not currently attached."},"remote_tools:remote_tools_desc":{"prefix":"lib","body":"lib(${1:remote_tools})$2\n$0","description":"lib(remote_tools)\n\n   This library allows the Tk development tools to be used via the remote Tcl\ninterface. This allows the development tools to be used by any ECLiPSe\nsession, and not just one which uses the embedded Tcl interface."},"repair:conflict_constraints/2":{"prefix":"conflict_constraints","body":"conflict_constraints(${1:ConflictSet}, ${2:Constraints})$3\n$0","description":"conflict_constraints(+ConflictSet, -Constraints)\n\n   Retreive the set of conflicting constraints monitored in ConflictSet.\n\nArguments\n   ConflictSet    name or handle of a conflict set\n   Constraints    List of conflicting constraints in ConflictSet (variable)\n\nType\n   library(repair)\n\nDescription\n\nWhen a repair constraint goes into conflict (i.e. when it does not satisfy\nthe tentative assignment of its variables), it appears in a conflict set,\nonce it satisfies the tentative assignment, it disappears.\nThis primitive returns the list of all current conflict constraints\nin the given conflict set.\n\nConflictSet is the conflict set name (or handle) which has\nbeen used in the corresponding constraint annotation.  For example\n\nconflict_constraints(cap_cstr, Conflicts)\n\nwould retrieve all constraints that were annotated with cap_cstr\nand are currently in conflict.\n\nResatisfiable\n   no"},"repair:conflict_constraints/1":{"prefix":"conflict_constraints","body":"conflict_constraints(","description":"conflict_constraints(?)\n\n   Obsolete: use conflict_constraints/2 instead.\n\nType\n   library(repair)\n\nSee Also\n   conflict_constraints / 2"},"repair:r/1":{"prefix":"r","body":"r(","description":"r(?)\n\n   Obsolete: use r_conflict/2 and r_conflict_prop/2 instead.\n\nType\n   library(repair)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   r_conflict / 2, r_conflict_prop / 2"},"repair:conflict_vars/1":{"prefix":"conflict_vars","body":"conflict_vars(${1:Vars})$2\n$0","description":"conflict_vars(-Vars)\n\n   Returns the list of variables which are currently non-tenable.\n\nArguments\n   Vars    List of variables that are currently non-tenable\n\nType\n   library(repair)\n\nDescription\n\nWhen a variable becomes untenable, it appears in the set of conflict\nvariable, when it becomes tenable, is disappears.\nThis primitive returns the list of all currently untenable variables.\nNote that all these variables must be reassigned in any solution\n(there is no other way to repair untenability).\nVariable reassignment can be achieved\nby changing the variable's tentative value with tent_set/2,\nor by instantiating the variable.\nCare should be taken whilst implementing repairs through tentative\nvalue changes since this is a non-monotonic operation: conflicting repairs\nmay lead to cycles and the computation may not terminate.  \n\nSee Also\n   tenable / 1, tent_set / 2"},"repair:poss_conflict_vars/2":{"prefix":"poss_conflict_vars","body":"poss_conflict_vars(${1:ConflictSet}, ${2:Vars})$3\n$0","description":"poss_conflict_vars(+ConflictSet, -Vars)\n\n   Returns the set of variables within the conflict constraints in ConflictSet.\n\nArguments\n   ConflictSet    name or handle of a conflict set\n   Vars    Variables within conflict constraints\n\nType\n   library(repair)\n\nDescription\nThe set of variables within the conflict constraints.\nThis is generally a mixture of tenable and untenable variables."},"repair:r_no_prop/1":{"prefix":"r_no_prop","body":"r_no_prop(","description":"r_no_prop(?)\n\n   Obsolete: use r_conflict/2 and r_conflict_prop/2 instead.\n\nType\n   library(repair)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   r_conflict / 2, r_conflict_prop / 2"},"repair:r_prop/1":{"prefix":"r_prop","body":"r_prop(","description":"r_prop(?)\n\n   Obsolete: use r_conflict/2 and r_conflict_prop/2 instead.\n\nType\n   library(repair)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   r_conflict / 2, r_conflict_prop / 2"},"repair:tenable/1":{"prefix":"tenable","body":"tenable(${1:Var})$2\n$0","description":"tenable(?Var)\n\n   Check if Var is tenable.\n\nArguments\n   Var    Term\n\nType\n   library(repair)\n\nDescription\n\nSucceeds if Term is tenable. A Term is tenable if it does not contain any\nvariables with tentative values which are inconsistent with any constraints\ninvolving thevariable. Note that variables with no tentative values are\nconsidered tenable.\n\nFail Conditions\n   Fails if Var is non-tenable.\n\nResatisfiable\n   no\n\nExamples\n   % lib(fd) is loaded\n\n[eclipse 3]: X::1..5, X tent_set 3, tenable(X).  % suceeds\n\n[eclipse 3]: X::1..5, X tent_set 7, tenable(X).  % fails\n\nSee Also\n   tent_set / 2, conflict_vars / 1"},"repair:repair_desc":{"prefix":"lib","body":"lib(${1:repair})$2\n$0","description":"lib(repair)\n\nThe repair library provides a framework for the integration of repair-based\nsearch with the constraint consistency checking techniques of ECLiPSe. It\nallows the implementation of classical local search methods within a CLP\nenvironment.\n\nIt provides two facilities:\n\n The maintenance of tentative values for problem variables. These\n    tentative values may together form a partial or even inconsistent \n    tentative assignment.  Modifications to, or extensions of this\n    assignment may be applied until a correct solution is found.\n\n The monitoring of constraints (the so called repair constraints)\n    for being either satisfied or violated under the current tentative\n    assignment.  Search algorithms can then access the set of\n    constraints that are violated at any point in the search,\n    and perform repairs by changing the tentative assignment\n    of the problem variables.\n\nNormally, the repair library communicates with another solver (such as fd or \nria) to check for constraint violations. \n\nTentative values can be visualised using the ECLiPSe visualisations tools.\nTo do so, set up a viewable using viewable:viewable_create/3,4 and specify\nchangeable(repair,Type) as its element type."},"repair:tent_call/3":{"prefix":"tent_call","body":"tent_call(${1:In}, ${2:Out}, ${3:Goal})$4\n$0","description":"tent_call(+In, +Out, +Goal)\n\n   Eagerly call Goal whenever tentative values of variables in In changes.\n\nArguments\n   In    List of variables (subset of variables in Goal)\n   Out    List of variables (subset of variables in Goal)\n   Goal    Goal to be called\n\nType\n   library(repair)\n\nDescription\n\nThis is a completely general meta-predicate to support computations\nwith tentative values. Goal is a general goal, and In and Out are\nlists (or other terms) containing subsets of Goal's variables.\nA copy of Goal is called, with the In-variables replaced by their\ntentative values and the Out-variables replaced by fresh variables.\nGoal is expected to return values for the Out variables. These values\nare then used to update the tentative values of the original Out variables.\nThis process repeats whenever the tentative value of any In-variable\nchanges.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   tent_set / 2, tent_is / 2"},"sd:deleteff/3":{"prefix":"deleteff","body":"deleteff(${1:Min}, ${2:List}, ${3:Rest})$4\n$0","description":"deleteff(-Min, +List, -Rest)\n\n   Pick minimum domain size element from a list (first fail principle)\n\nArguments\n   Min    Smallest list element in terms of domain size\n   List    List of domain variables or constants\n   Rest    Remaining list without smallest element\n\nType\n   library(sd)\n\nDescription\n\n\tExtracts from a list of domain variables (or constants) the first\n\telement with the smallest domain. This element is returned as Min,\n\tand the remaining list without this element is returned as Rest.\n\tThis predicate is useful for implementing the first-fail-principle\n\tin a search procedure, i.e. labeling the variable with the smallest\n\tdomain first. E.g.\n\t\n\tlabelingff(List) :-\n\t\t( deleteff(X, List, Rest) ->\n\t\t    indomain(X),\n\t\t    labelingff(Rest)\n\t\t;\n\t\t    true\n\t\t).\n\t\n\nFail Conditions\n   List is empty\n\nSee Also\n   get_domain_size / 2"},"sd:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:List})$2\n$0","description":"alldifferent(?List)\n\n   All elements of List are different\n\nArguments\n   List    List of domain variables or atomic values\n\nType\n   library(sd)\n\nDescription\n\n\tConstrains all list elements to be different atomic values.\n\tAt call time, the list elements must already have domains or\n\tbe instantiated.\n\t\n\tOperationally, the predicate delays until list elements become\n\tinstatiated, and removes the corresponding values from the domains\n\tof the other list elements.\n\t\n\nExamples\n   \n    ?- [X, Y, Z] &:: [a,b,c,d], alldifferent([X,Y,Z]), X = a.\n    X = a\n    Y = Y{[b, c, d]}\n    Z = Z{[b, c, d]}\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n\n    ?- X &:: [a,b,c], alldifferent([a,b,X]).\n    X = c\n    Yes (0.00s cpu)\n    \n\nSee Also\n   &\\= / 2"},"sd:get_domain_size/2":{"prefix":"get_domain_size","body":"get_domain_size(${1:Term}, ${2:Size})$3\n$0","description":"get_domain_size(?Term, -Size)\n\n   Gives the size of the domain of a variable (or value)\n\nArguments\n   Term    Domain variable or atomic value\n   Size    Variable or integer\n\nType\n   library(sd)\n\nDescription\n\n\tRetrieves the domain size of a domain variable (or value).\n\tIt Term is instantiated, Size is 1.\n\nSee Also\n   &:: / 2, get_domain_as_list / 2, deleteff / 3"},"sd:indomain/1":{"prefix":"indomain","body":"indomain(${1:X})$2\n$0","description":"indomain(?X)\n\n   Nondeterministically instantiate to domain values\n\nArguments\n   X    Domain variable or value\n\nType\n   library(sd)\n\nDescription\n\n\tNondeterministically instantiates a domain variable to its domain\n\tvalues. The order of enumeration is in increasing term order (i.e.\n\talphabetic for atoms).\n    \n\nExamples\n   \n    ?- X &:: [mo, tu, we, th, fr, sa, su], indomain(X).\n    X = fr\n    Yes (0.00s cpu, solution 1, maybe more)\n    X = mo\n    Yes (0.05s cpu, solution 2, maybe more)\n    X = sa\n    Yes (0.06s cpu, solution 3, maybe more)\n    X = su\n    Yes (0.06s cpu, solution 4, maybe more)\n    X = th\n    Yes (0.06s cpu, solution 5, maybe more)\n    X = tu\n    Yes (0.07s cpu, solution 6, maybe more)\n    X = we\n    Yes (0.08s cpu, solution 7)\n\n    ?- indomain(we).\n    Yes (0.00s cpu)\n    \n\nSee Also\n   &:: / 2"},"sd:get_domain_as_list/2":{"prefix":"get_domain_as_list","body":"get_domain_as_list(${1:Term}, ${2:List})$3\n$0","description":"get_domain_as_list(?Term, -List)\n\n   Retrieves the domain of a variable (or value) as a list of values\n\nArguments\n   Term    Domain variable or atomic value\n   List    List of atomic values\n\nType\n   library(sd)\n\nDescription\n\n\tRetrieves the domain of a variable (or value) as a list of values.\n\tThe list is an ordered set in the sense of library(ordset), i.e.\n\ta duplicate-free list in ascending term order.\n\nSee Also\n   &:: / 2, indomain / 1, get_domain_size / 2"},"sd:is_solver_var/1":{"prefix":"is_solver_var","body":"is_solver_var(${1:Term})$2\n$0","description":"is_solver_var(?Term)\n\n   The argument is a domain variable\n\nArguments\n   Term    A term\n\nType\n   library(sd)\n\nDescription\n\n\tTests if the argument is a domain variable from this library.\n\nSee Also\n   &:: / 2, is_solver_type / 1"},"sd:is_exact_solver_var/1":{"prefix":"is_exact_solver_var","body":"is_exact_solver_var(${1:Term})$2\n$0","description":"is_exact_solver_var(?Term)\n\n   The argument is a domain variable\n\nArguments\n   Term    A term\n\nType\n   library(sd)\n\nDescription\n\n\tTests if the argument is a domain variable from this library.\n\tAn alias for is_solver_var/1, used by lib(propia).\n\nSee Also\n   is_solver_var / 1"},"sd:is_solver_type/1":{"prefix":"is_solver_type","body":"is_solver_type(${1:Term})$2\n$0","description":"is_solver_type(?Term)\n\n   The argument is a domain variable or atomic constant\n\nArguments\n   Term    A term\n\nType\n   library(sd)\n\nDescription\n\n\tTests if the argument is a domain variable from this library\n\tor a valid domain value (atomic term).\n\nSee Also\n   &:: / 2, is_solver_var / 1"},"sd:labeling/1":{"prefix":"labeling","body":"labeling(${1:Term})$2\n$0","description":"labeling(+Term)\n\n   Instantiate all domain variables in a list to domain values\n\nArguments\n   Term    A list of domain variables or atomic terms\n\nType\n   library(sd)\n\nDescription\n\n\tInstantiate all domain variables in a list to their domain values.\n\tAlternative instantiations are tried on backtracking. This predicate\n\tsimply calls indomain/1 on all variable in the given list.\n\nSee Also\n   &:: / 2, indomain / 1"},"sd:msg/3":{"prefix":"msg","body":"msg(${1:X}, ${2:Y}, ${3:MSG})$4\n$0","description":"msg(?X, ?Y, -MSG)\n\n   MSG is the most specific generalisation of X and Y representable with domain variables from this library\n\nArguments\n   X    Any term or variable\n   Y    Any term or variable\n   MSG    A domain variable or constant (output)\n\nType\n   library(sd)\n\nDescription\n\n\tThis predicate computes the most specific generalisation of X and Y\n\twhich can be represented using this library's domain variables.\n\t\n\tIf X and Y are domain variables (or atomic constants), then MSG\n\twill be unified with a new domain variable whose domain\n\tconsists of the union of the domain elements of X and Y.\n\tIf the domain union contains only a single value, the result\n\tis this single value.\n\t\n\tIf X or Y are free (unconstrained) variables, then the result will\n\talso be a free (unconstrained) variable.\n    \n\nFail Conditions\n   None\n\nExamples\n   \n    ?- msg(we, fr, Z).\n    Z = Z{[we, fr]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], msg(X, we, Z).\n    X = X{[sa, su]}\n    Z = Z{[we, sa, su]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], Y &:: [mo, tu, we], msg(X, Y, Z).\n    X = X{[sa, su]}\n    Y = Y{[mo, tu, we]}\n    Z = Z{[mo, tu, we, sa, su]}\n    Yes (0.00s cpu)\n\n    ?- X &:: [sa, su], msg(X, _, Z).\n    X = X{[sa, su]}\n    Z = Z\n    Yes (0.01s cpu)\n\n    ?- msg(we, we, X).\n    X = we\n    Yes (0.00s cpu)\n    \n\nSee Also\n   ic_kernel : msg / 3, fd : msg / 3, ic_sets : msg / 3, fd_sets : msg / 3, ic_symbolic : msg / 3, gfd : msg / 3, library(propia), &:: / 2"},"sd:sd_desc":{"prefix":"lib","body":"lib(${1:sd})$2\n$0","description":"lib(sd)\n\n    Overview\n    \n    This is a simple library implementing variables and constraints over\n    atomic values.  Its main purpose is for first experiments with constraint\n    solving.  Moreover, those interested in writing their own constraint\n    solvers can use the source code of this library as a starting point.\n    Domains\n    Domains are declared by giving a list of possible values for a variable,\n    e.g.\n    \n    \t?- X &:: [red, green, blue].\n\tX = X{[blue, green, red]}\n\tYes (0.00s cpu)\n    \n    A variable that has been given a domain can only be instantiated to\n    values from this domain. Any attempt to instantiate the variable to\n    a non-domain value will cause failure:\n    \n    \t?- X &:: [red, green, blue], X = red.\n\tX = red\n\tYes (0.00s cpu)\n    \t?- X &:: [red, green, blue], X = yellow.\n\tNo (0.00s cpu)\n    \n    Basic Constraints\n    There are only two basic constraints, equality and disequality:\n    \n    X &= YX is the same as Y\n    X &\\= YX is different from Y\n    \n    Both constraints exist in a reified form:\n    \n    &=(X,Y,Bool)Bool is the truth value (0/1) of X &= Y\n    &\\=(X,Y,Bool)Bool is the truth value (0/1) of X &\\= Y\n    \n    \n    Global Constraints\n    One derived, global constraint is implemented:\n    \n    alldifferent(List)All list elements are different\n    \n    Search\n    Domain variables can be instantiated to their domain values using\n    \n    indomain(X)enumerate values of X\n    labeling(Xs)enumerate values of all elements of list Xs"},"shadow_cons:shadow_call/2":{"prefix":"shadow_call","body":"shadow_call(${1:StoreName}, ${2:Goal})$3\n$0","description":"shadow_call(+StoreName, ?Goal)\n\n    Invokes a constraint on (the shadow variables of) a shadow constraint store.\n\nArguments\n   StoreName    The name of a shadow constraint store.  This call may be the first reference to this store. It must be an atom.\n   Goal    A goal (i.e. a constraint): its variables need not (yet) have shadows in the named store\n\nType\n   library(shadow_cons)\n\nDescription\nA copy of the Goal is made, replacing all the variables by their representatives in the shadow constraint store.  This copied goal is then called\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   The constraint is inconsistent with those previously imposed on the shadow store\n\nResatisfiable\n   No.\n\nExceptions\n     4 --- StoreName is uninstantiated\n     5 --- StoreName is not an atom\n\nExamples\n   \n    Success:\n    [eclipse]: X::1..10, shadow_call(fred,X#>2).\n    X = X{fd:[1..10], shadow_cons:[fred - ShadowVar{[3..10]}]}\n    yes.\n    [eclipse]: shadow_call(fred, X#>2), \n    shadow_call(fred, Y #> X), \n    shadow_var(Y, fred, Z).\n    X = X{[fred - ShadowVar{[3..9999999]}]}\n    Y = Y{[fred - Z{[4..10000000]}]}\n    Z = Z{[4..10000000]}\n    yes.\n\n    Fail:\n    [eclipse]: X::1..10, shadow_call(fred,X#>10).\n    no (more) solution.\n    Error:\n    shadow_call(Var,true).  % Error 4\n    \n\nSee Also\n   shadow_var / 3"},"shadow_cons:shadow_var/3":{"prefix":"shadow_var","body":"shadow_var(${1:Var}, ${2:StoreName}, ${3:ShadowVar})$4\n$0","description":"shadow_var(?Var, +StoreName, -ShadowVar)\n\n   Finds the shadow variable associated with the input\n\tvariable in the specified shadow constraint store.  If none\n\texists, it creates one.\n\nArguments\n   Var    A variable to be shadowed\n   StoreName    The name of a shadow constraint store.  This call may be the first reference to this store. It must be an atom.\n   ShadowVar    The associated shadow variable\n\nType\n   library(shadow_cons)\n\nDescription\n\n    The shadow variable 'represents' the original variable in the\n    named constraint store.  This allows it to be more (or less)\n    constrained than the original variable.  When the original\n    variable becomes instantiated, or has its domain/range narrowed,\n    this change is propagated to the shadow variable.\n\nResatisfiable\n   No.\n\nExceptions\n     4 --- StoreName is uninstantiated\n     5 --- StoreName is not an atom\n\nExamples\n   \n    Success:\n    [eclipse]: shadow_var(X,fred,Y).\n    X = X{[fred - Y]}\n    Y = Y\n    yes.\n\n    [eclipse]: lib(fd).\n    ...\n    [eclipse]:  X::1..10, shadow_var(X,fred,Y), X#<5, Y#>3.\n    X = X{fd:[1..4], shadow_cons:[fred-4]}\n    Y = 4\n\n    Error:\n    shadow_var(X,Var,Y).  % Error 4\n    \n\nSee Also\n   shadow_call / 2"},"sicstus:call_residue/2":{"prefix":"call_residue","body":"call_residue(${1:Goal}, ${2:Residue})$3\n$0","description":"call_residue(+Goal,-Residue)\n\n   This is only approximate, the variables in the second argument are dummies\n\nType\n   library(sicstus)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"sicstus:sicstus_desc":{"prefix":"lib","body":"lib(${1:sicstus})$2\n$0","description":"lib(sicstus)\n\n    ECLiPSe includes a SICStus Prolog compatibility package to ease\n    the task of porting SICStus Prolog applications to ECLiPSe Prolog. \n    This package includes the C-Prolog compatibility package (lib(cprolog))\n    and the Quintus-Prolog compatibility package (lib(quintus)). \n    \n    Please note that this appendix does not detail the functionality\n    of SICStus Prolog, refer to the SICStus Prolog documentation for\n    this information. \n    \n    The effect of the compatibility library is local to the module where\n    it is loaded. For maximum compatibility, a Sicstus program should\n    be wrapped in a separate module starting with a directive like\n    \n    :- module(mymodule, [], sicstus).\n    \n    In this case, Eclipse-specific language constructs will not be available.\n    \n    If the compatibility package is loaded into a standard module, e.g. like\n    \n    :- module(mymixedmdule).\n    :- use_module(library(sicstus)).\n    \n    then Sicstus and Eclipse language features can be used together. \n    However, ambiguities must be resolved explicitly and confusion may\n    arise from the different meaning of quotes in Eclipse vs Sicstus-Prolog.\n    \n    A sockets library is provided for compatibility with the sockets\n    manipulation predicates of SICStus.  To use these predicates, the\n    sockets library has to be loaded: \n    \n    :- use_module(library(sockets)).\n    \n    For SICStus 3.0, the sockets predicates are also in a sockets library,\n    so no changes are needed to load the library.  However, for older\n    versions of SICStus, the predicates are available as built-ins, and no\n    library has to be loaded.  So if the code is written for older\n    versions of SICStus, then the above line has to be added. \n    \n    The sockets library can be used independently of the sicstus library. \n    Note also that ECLiPSe also provides its own socket manipulation\n    predicates that provides similar functionalities to the sockets library. \n    \n    Since the SICStus package contains the Quintus one, the syntax\n    differences are the same."},"sockets:socket/2":{"prefix":"socket","body":"socket(${1:Domain}, ${2:Socket})$3\n$0","description":"socket(+Domain, -Socket)\n\n   Create a socket\n\nType\n   library(sockets)\n\nSee Also\n   socket / 3"},"sockets:current_host/1":{"prefix":"current_host","body":"current_host(${1:HostName})$2\n$0","description":"current_host(?HostName)\n\n   Get the host machine name\n\nType\n   library(sockets)\n\nSee Also\n   get_flag / 2"},"sockets:socket_accept/2":{"prefix":"socket_accept","body":"socket_accept(${1:Socket}, ${2:Stream})$3\n$0","description":"socket_accept(+Socket, -Stream)\n\n   Extract the first connection to socket\n\nType\n   library(sockets)\n\nSee Also\n   accept / 3"},"sockets:socket_connect/3":{"prefix":"socket_connect","body":"socket_connect(${1:Socket}, ${2:Address}, ${3:Stream})$4\n$0","description":"socket_connect(+Socket, +Address, -Stream)\n\n   Connect a socket to an address\n\nType\n   library(sockets)\n\nSee Also\n   connect / 2"},"sockets:socket_bind/2":{"prefix":"socket_bind","body":"socket_bind(${1:Socket}, ${2:Address})$3\n$0","description":"socket_bind(+Socket, +Address)\n\n   Bind a socket to an address\n\nType\n   library(sockets)\n\nSee Also\n   bind / 2"},"sockets:socket_listen/2":{"prefix":"socket_listen","body":"socket_listen(${1:Socket}, ${2:Length})$3\n$0","description":"socket_listen(+Socket, +Length)\n\n   Limit the maximum of pending connections\n\nType\n   library(sockets)\n\nSee Also\n   listen / 2"},"sockets:sockets_desc":{"prefix":"lib","body":"lib(${1:sockets})$2\n$0","description":"lib(sockets)\n\n    Note that ECLiPSe provides its own built-in socket manipulation\n    predicates which provides similar functionality to this library.\n    \n    This library is only provided for compatibility with the socket\n    manipulation predicates of SICStus Prolog. To use these predicates,\n    the sockets library has to be loaded: \n    \n    :- use_module(library(sockets)).\n    \n    For SICStus 3.0, the sockets predicates are also in a sockets library,\n    so no changes are needed to load the library.  However, for older\n    versions of SICStus, the predicates are available as built-ins, and no\n    library has to be loaded.  So if the code is written for older\n    versions of SICStus, then the above line has to be added. \n    \n    The sockets library can be used independently of the sicstus library."},"source_processor:source_close/2":{"prefix":"source_close","body":"source_close(${1:SourcePos}, ${2:OptionList})$3\n$0","description":"source_close(+SourcePos, +OptionList)\n\n   Close an open ECLiPSe source file.\n\nArguments\n   SourcePos    Source position handle\n   OptionList    List of options, possibly empty\n\nType\n   library(source_processor)\n\nDescription\nThis is used to close an ECLiPSe source file that was\n    previously opened with source_open/3.  It is possible to close\n    before the end of the source is reached. Nesting of included\n    files is properly handled.\n    \n    OptionList can contain the following:\n    \n    keep_modules\n    \tkeep the modules that have been created implicitly during\n\tsource processing (by default they are erased to restore the\n\toriginal state)\n    \n    \n    Note that if source_open/3 had been called on an already open stream\n    with a stream(Stream) argument, then Stream will not be closed by\n    source_close/2.\n    \n\nSee Also\n   source_open / 3"},"sockets:socket_select/5":{"prefix":"socket_select","body":"socket_select(${1:Socket}, ${2:NewStream}, ${3:TimeOut0}, ${4:Streams}, ${5:ReadStreams})$6\n$0","description":"socket_select(+Socket, -NewStream, +TimeOut0, +Streams, -ReadStreams)\n\n   Wait for new connection on Socket, and for data on Streams\n\nType\n   library(sockets)\n\nSee Also\n   stream_select / 3"},"sockets:stream_select/3":{"prefix":"stream_select","body":"stream_select(${1:Streams}, ${2:TimeOut0}, ${3:ReadStreams})$4\n$0","description":"stream_select(+Streams, +TimeOut0, -ReadStreams)\n\n   Wait for data on Streams\n\nType\n   library(sockets)\n\nSee Also\n   eclipse_language : stream_select / 3, select / 3"},"source_processor:source_read/4":{"prefix":"source_read","body":"source_read(${1:SourcePos}, ${2:NextPos}, ${3:Kind}, ${4:SourceTerm})$5\n$0","description":"source_read(+SourcePos, -NextPos, -Kind, -SourceTerm)\n\n   Read the next term from an open ECLiPSe source file\n\nArguments\n   SourcePos    Source position handle\n   NextPos    Source position handle\n   Kind    kind of source term (atom)\n   SourceTerm    a source_term structure\n\nType\n   library(source_processor)\n\nDescription\nThis reads the next source term from a source file previously\n    opened with source_open/3. The term at the current source position\n    SourcePos is read, and the next source position is returned for use\n    in subsequent source_read/4 invocations (it is not possible to read\n    twice from the same source position!).\n    \n    The term that has been read is classified into one of the following\n    categories (Kind):\n    \n    handled_directive\n    \tA directive (a term with functor :-/1) which has already\n\tbeen handled (interpreted by source_read/4). Such directives are:\n\tmodule/1,3, local/1, export/1, reexport/1, use_module/1, lib/1,\n\tpragma/1, include/1, ./2, op/3, meta_attribute/2 and\n\tcomment(include,...)\n    directive\n    \tA directive (a term with functor :-/1) which has not\n\tbeen handled (ignored by source_read/4)\n    query\n    \tA query (a term with functor ?-/1)\n    clause\n    \tAny other structure, list or atom (usually a clause)\n    var\n    \tA term consisting of only a variable (very likely an error)\n    other\n    \tA number, string, etc (very likely an error)\n    comment\n    \tSpacing, layout and comments between source terms\n    \t(only when keep_comments option is in effect)\n    end_include\n    \tThe end of an included source file\n    end\n    \tThe end of the (top-level) source file\n    \n    The information about the source term itself is returned as a structure\n    \n    :- export struct(source_term(\n\tterm,\t\t% the read term itself\n\tvars,\t\t% list of [VarName|Var] pairs (as in readvar/3)\n\tannotated       % the read term with type and source annotations \n\t...\n    )).\n    \n    For category 'comment', the term is a string containing the comment.\n    For category 'end' and 'end_include', the term is the atom end_of_file.\n    In all these cases, vars is the empty list, and annotated is\n    uninstantiated.\n    \n    Note that either the vars-field or the annotated field is valid,\n    depending on the setting of the with_annotations-option.  If the option\n    is set, the vars field contains an empty list, and the annotated term\n    is in the same format as that returned by read_annotated/2, i.e. a\n    recursive wrapper structure around the read term of the following format:\n\n    :- export struct(annotated_term(\n    term,    % var, atomic or compound\n    % args of compound terms are annotated\n    type,    % term type (see below)\n    file,    % file name (atom)\n    line,    % line number (integer >= 1)\n    from, to    % source position (integers >= 0)\n    ...\n    )).\n\n    If the with_annotations-option is not set, the annotated-field remains\n    uninstantiated, and the vars-field is a list as detailed in readvar/3.\n    \n    Notes on module handling:  When source_read/4 encounters a\n    module-directive (which is a handled_directive), the corresponding\n    module is implicitly created (unless it exists already, in which\n    case it is either reused or erased and re-created, depending on\n    the setting of the recreate_modules option), and that\n    module becomes the context module for any subsequently read\n    clauses or directives.  By default, source_close/2 removes these\n    modules again in order to restore the original state.\n    \n\nSee Also\n   source_open / 3, source_close / 2, readvar / 3, read_annotated / 2"},"source_processor:source_open/3":{"prefix":"source_open","body":"source_open(${1:File}, ${2:OptionList}, ${3:SourcePos})$4\n$0","description":"source_open(+File, +OptionList, -SourcePos)\n\n   Open an ECLiPSe source code file for subsequent processing\n\nArguments\n   File    Name of source file (Atom or string), or term of the form stream(Stream)\n   OptionList    List of options, possibly empty\n   SourcePos    Source position handle\n\nType\n   library(source_processor)\n\nDescription\nThis predicates opens an ECLiPSe source file (or prepares and\n    already opened stream) for subsequent reading with source_read/4.\n    Compared to the standard primitives for reading from a file, this\n    takes care of\n    \n    nesting of included files\n    creating and keeping track of modules\n    syntax settings\n    comments (optional)\n    changing the current directory to the opened file's directory\n    handling of if-elif-else-endif directives\n    \n    OptionList can contain the following:\n    \n    keep_comments\n\ttreat comments and spacing between source terms as data\n\trather than ignoring it\n    include_comment_files\n\tinterpret the comment(include,Files) directive and include\n\tthe contents of the given files, identical to an include(Files)\n\tdirective. By default, these directives are ignored.\n    ignore_conditionals\n\tIgnore any special meaning of conditional directives (if/1,\n\telif/1, else/0, endif/0) and just return them as a source term.\n\tThe default is to interpret these directives, including or\n\texcluding corresponding source parts accordingly, while removing\n\tthe directives themselves\n    with_annotations\n\treturn an annotated source term with every source term\n\t(and do not return a separate variable list)\n    no_macro_expansion\n\tdo not expand term macros (e.g. with/2 and of/2)\n    minimal_macro_expansion\n\tdo not expand term macros except in :- directives\n    no_clause_expansion\n\tdo not expand clause macros (e.g. DCGs)\n    goal_expansion\n\tdo inline expansion of goals (only works if clause expansion\n\tis not disabled)\n    recreate_modules\n\terase and re-create module when encountering a module directive\n    \n    source_open/3 and source_read/4 maintain a 'current source position',\n    which is a structure containing (among others) the following fields:\n    \n    :- export struct(source_position(\n\tstream,\t\t\t% Eclipse stream\n\tfile,\t\t\t% canonical file name\n\tline,\t\t\t% integer\n\toffset,\t\t\t% integer\n\tincluded_from,\t\t% source_position or []\n\tmodule,\t\t\t% current source module\n\t...\n    )).\n    \n    i.e. information about the module context and the precise location\n    of a source term (e.g. for error messages).\n    \n    If File is of the form stream(Stream), then the predicate expects\n    Stream to be an already opened input stream. Correspondingly, the\n    processed stream will not be closed at the end of source processing\n    (unlike files).\n    \n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   source_close / 2, source_read / 4"},"source_processor:source_position/s":{"prefix":"struct","body":"struct","description":"struct source_position(filespec, stream, file, line, offset, remaining_files, included_from, options, created_modules, oldcwd, module, ifdefs, old_compiled_stream)\n\n   Current source position\n\nFields\n   filespec    the original source file argument used in source_open/3\n   stream    the Eclipse stream being read\n   file    this file's canonical file name\n   line    this position's line number (integer)\n   offset    this position's byte offset (integer)\n   remaining_files     list of files still to be included\n   included_from       the source_position from which this file is included, or [] if not included\n   options    structure describing option settings\n   created_modules     list of modules created so far\n   oldcwd    current directory before opening this file\n   module    read-module at this source position\n   ifdefs    list of atoms (then|else) describing nesting of if-directives\n   old_compiled_stream value of compiled_stream/1 when toplevel file was opened\n\nType\n   library(source_processor)\n\nDescription\nThis structure describes a particular position that has been\n    \treached during processing of an ECLiPSe source file. It also describes\n\twhat has to be done when this file is finished. The source_read/4\n\tpredicate reads a term from a given source position and returns\n\tthe new source position after the read.\n\nSee Also\n   source_open / 3, source_close / 2, source_read / 4"},"source_processor:source_term/s":{"prefix":"struct","body":"struct","description":"struct source_term(term, vars, annotated)\n\n   A source term with additional information\n\nFields\n   term    A term read from a source file (a clause, fact, etc)\n   vars    A list of the term's variables and their names information (or [] if the with_annotations option is in effect)\n   annotated    An annotated version of term with source and type information (only if with_annotations option given, otherwise uninstantiated)\n\nType\n   library(source_processor)\n\nSee Also\n   readvar / 3, read_annotated / 2"},"spell:spell_desc":{"prefix":"lib","body":"lib(${1:spell})$2\n$0","description":"lib(spell)\n\n    The effect of loading this library is to modify the event handler\n    for calling an undefined procedure.  A spelling correction\n    algorithm is used to see if the cause was a misspelling of an\n    existing predicate."},"swi:swi_desc":{"prefix":"lib","body":"lib(${1:swi})$2\n$0","description":"lib(swi)\n\n    This library is incomplete, and intended to ease the task of\n    porting SWI-Prolog programs to ECLiPSe Prolog, or to add modules\n    written in SWI-Prolog to applications written in ECLiPSe. \n    \n    It reuses parts of the C-Prolog, Quintus and Iso compatibility\n    libraries.\n    \n    The effect of the compatibility library is local to the module where\n    it is loaded. For maximum compatibility, an SWI program should\n    be wrapped in a separate module starting with a directive like\n    \n    :- module(mymodule, [], swi).\n    \n    In this case, Eclipse-specific language constructs will not be available.\n    \n    If the compatibility package is loaded into a normal Eclipse module, like\n    \n    :- module(mymixedmdule).\n    :- use_module(library(swi)).\n    \n    then SWI and Eclipse language features can be used together. \n    However, ambiguities must be resolved explicitly and confusion may\n    arise from the different meaning of quotes in Eclipse vs SWI-Prolog."},"suspend:integers/1":{"prefix":"integers","body":"integers(${1:Vars})$2\n$0","description":"integers(?Vars)\n\n   Constrain Vars to be integers\n\nArguments\n   Vars    List of variables or integers\n\nType\n   library(suspend)\n\nDescription\n    This constraint suspends until its argument is ground. It then succeeds\n    iff Vars is an integer or a list of integers.\n\nFail Conditions\n   Vars contains non-integers.\n\nSee Also\n   :: / 2, #:: / 2, reals / 1"},"suspend:and/3":{"prefix":"and","body":"and(${1:Expr1}, ${2:Expr2}, ${3:Bool})$4\n$0","description":"and(?Expr1, ?Expr2, ?Bool)\n\n   Reified boolean operation\n\nArguments\n   Expr1    An arithmetic expression\n   Expr2    An arithmetic expression\n   Bool    Variable, 0 or 1\n\nType\n   library(suspend)\n\nDescription\n    Reified version of and/2, i.e. the truth value of the boolean operation\n    is reflected in the value of the 0/1 variable Bool.\n\n    This constraint suspends until its first two arguments are ground.\n    It then unifies Bool according to the truth value of the corresponding\n    and/2 constraint.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n    24 --- Expr1 or Expr2 is not an arithmetic expression.\n\nSee Also\n   and / 2"},"suspend:neg/1":{"prefix":"neg","body":"neg","description":"neg ?Expr\n\n   Expr arithmetically evaluates to 0\n\nArguments\n   Expr    A boolean expression\n\nType\n   library(suspend)\n\nDescription\n    Suspends until Expr is ground, and then evaluates it. Succeeds if it\n    evaluates to 0.\n\n    Typically, the expression contains reifiable constraints, in which case\n    a corresponding reified constraint is set up, and the expression is\n    replaced by the resulting boolean variable.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Expr does not evaluate to 0\n\nExceptions\n    24 --- Expr is not an arithmetic expression.\n\nExamples\n   \n\t?- neg B, B = 1.\n\tNo (0.00s cpu)\n\n\t?- neg B, B = 0.\n\tB = 0\n\tYes (0.00s cpu)\n\n\t% arguments are typically reifiable expressions:\n\t?- neg X > 7, X = 8.\n\tNo (0.00s cpu)\n\n\t% the previous example is equivalent to:\n\t?- >(X,7,B), neg B, X=8.\n\tNo (0.00s cpu)\n\n\t% and/or/=>/neg are themselves reifiable:\n\t?- neg(X > 7 or X < 5), X = 7.\n\tX = 7\n\tYes (0.00s cpu)\n\t\n\nSee Also\n   neg / 2, and / 2, or / 2, => / 2, ic : neg / 1, gfd : neg / 1"},"suspend:neg/2":{"prefix":"neg","body":"neg(${1:Expr}, ${2:Bool})$3\n$0","description":"neg(?Expr, ?Bool)\n\n   Reified boolean operation\n\nArguments\n   Expr    An arithmetic expression\n   Bool    Variable, 0 or 1\n\nType\n   library(suspend)\n\nDescription\n    Reified version of neg/1, i.e. the truth value of the boolean operation\n    is reflected in the value of the 0/1 variable Bool.\n\n    This constraint suspends until its first argument is ground.\n    It then unifies Bool according to the truth value of the corresponding\n    neg/1 constraint.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n    24 --- Expr is not an arithmetic expression.\n\nSee Also\n   neg / 1"},"suspend:reals/1":{"prefix":"reals","body":"reals(${1:Vars})$2\n$0","description":"reals(?Vars)\n\n   Constrain Vars to be a number or list of numbers\n\nArguments\n   Vars    List of variables or numbers\n\nType\n   library(suspend)\n\nDescription\n    This constraint suspends until its argument is ground. It then succeeds\n    iff Vars is a number or a list of numbers (any type).\n\nFail Conditions\n   Vars contains non-numbers.\n\nExamples\n   \n    ?- reals(L), L = [3.4, 7].\n    L = [3.4, 7]\n    Yes (0.00s cpu)\n\n    \n\nSee Also\n   :: / 2, $:: / 2, integers / 1"},"suspend:or/3":{"prefix":"or","body":"or(${1:Expr1}, ${2:Expr2}, ${3:Bool})$4\n$0","description":"or(?Expr1, ?Expr2, ?Bool)\n\n   Reified boolean operation\n\nArguments\n   Expr1    An arithmetic expression\n   Expr2    An arithmetic expression\n   Bool    Variable, 0 or 1\n\nType\n   library(suspend)\n\nDescription\n    Reified version of or/2, i.e. the truth value of the boolean operation\n    is reflected in the value of the 0/1 variable Bool.\n\n    This constraint suspends until its first two arguments are ground.\n    It then unifies Bool according to the truth value of the corresponding\n    or/2 constraint.\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExceptions\n    24 --- Expr1 or Expr2 is not an arithmetic expression.\n\nSee Also\n   or / 2"},"sym_expr:construct_group/8":{"prefix":"construct_group","body":"construct_group(${1:Array}, ${2:VarDimNames}, ${3:ValueSpec}, ${4:SymSpecs}, ${5:GroupName}, ${6:MaxPoints}, ${7:ToPointPred}, ${8:FromPointPred})$9\n$0","description":"construct_group(+Array, ++VarDimNames, ++ValueSpec, ++SymSpecs, ++GroupName, -MaxPoints, -ToPointPred, -FromPointPred)\n\n   Constructs a GAP group based on the provided symmetry specification.\n\nArguments\n   Array    The array of search variables\n   VarDimNames    A list of symbolic names for each dimension in Array\n   ValueSpec    The symbolic name for values and their range\n   SymSpecs    A list of symmetry specifiers\n   GroupName    The GAP name to give the constructed group (string)\n   MaxPoints    The number of GAP points operated on by group\n   ToPointPred    A predicate for converting a variable/value assignment to a GAP point\n   FromPointPred       A predicate for converting a GAP point to a variable/value assignment\n\nType\n   library(sym_expr)\n\nDescription\n    This predicate is intended for use in conjunction with a\n    GAP/ECLiPSe-based symmetry breaking method.  Given an array of search\n    variables (Array) and a description of the symmetries, this predicate\n    constructs the corresponding group in GAP (GroupName) and returns a pair\n    of `to point' and `from point' predicates suitable for use in\n    conjunction with it.\n\n    In order to facilitate the expression of the symmetries, a list of\n    symbolic names (VarDimNames) is required, to specify a symbolic name for\n    each of the dimensions of Array.  Similarly, some way is needed to\n    refer to the value `dimension'; this is provided by ValueSpec, which is\n    of the form ValueName:ValueRange.  ValueRange specifies the range of\n    values the variables may take (this is just used for constructing the\n    group; it is not imposed on the variables) and must be of the form\n    Lo..Hi.\n\n    The symmetries (SymSpecs) are then specified by a list with entries of\n    the form symmetry(Symmetry, SymmetryDimensions, OtherDimensions).\n    Roughly speaking, Symmetry specifies the base symmetry,\n    SymmetryDimensions specifies which dimensions it applies to, and\n    OtherDimensions specifies which other dimensions should be treated\n    specially with respect to this symmetry (if any).  The options for\n    Symmetry are:\n\n    s_n\n\t(1 dimension)\n\tFull permutation of the indices of the specified dimension.\n\n    cycle\n\t(1 dimension)\n\tIndices may be cycled (i.e. all shifted k positions modulo the\n\tsize of the dimension).\n\n    r_4\n\t(2 dimensions)\n\tRotational symmetry of the square.  The two dimensions specified\n\tmust be of equal size.\n\n    d_4\n\t(2 dimensions)\n\tFull symmetry of the square (i.e. including reflections).  The\n\ttwo dimensions specified must be of equal size.\n\n    reverse\n\t(1 dimension)\n\tIndices may be reversed.\n\n    gap_group(GroupFunc)\n\t(no fixed number of dimensions)\n\tThe symmetries described by the group returned by the GAP\n\tfunction GroupFunc.  GroupFunc should accept a single argument,\n\twhich is a list of the sizes of the dimensions that the symmetry is\n\texpected to act upon.  The mapping between GAP points and the\n\telements of the subarray that this symmetry acts upon is obtained\n\tby numbering the indices of the elements in lexicographic order\n\t(first dimension most significant).  For example, if the symmetry\n\tsubarray is of size MxN, then the element with index [I,J] is\n\tmapped to point (I-1)*N + J, so that [1,1]->1, [1,N]->N, [2,1]->N+1,\n\tetc.\n\n    function(Func)\n\t(no fixed number of dimensions)\n\tAllows a generator to be specified via an ECLiPSe function Func,\n\ta la classic SBDS symmetry functions.  Func should accept three\n\t(extra) arguments: DimSizes, SrcIdx and DestIdx.  The first,\n\tDimSizes, is a list of the sizes of the dimensions that the symmetry\n\tis expected to act upon.  The second, SrcIdx, provides the index of\n\tan element of the subarray that the symmetry acts upon.  The third,\n\tDestIdx, should then be unified with the index of the element that\n\tSrcIdx is mapped to by this function.  For example, if the generator\n\tis intended to exchange the dimensions of a square array (i.e.\n\treflect along the leading diagonal), if `swap_dim' is passed as\n\tFunc, then the definition of `swap_dim' might be\n\tswap_dim([N, N], [I, J], [J, I]).\n\tNote that for 1-dimensional arrays, DestIdx may be returned as\n\tjust an integer rather than a length-1 list containing the integer,\n\tif desired.\n\n    table(Generator)\n\t(no fixed number of dimensions)\n\tAllows a generator to be specified via a lookup table.\n\tGenerator must be an array of same size as the subarray the\n\tsymmetry acts upon, with each element containing the index of the\n\telement that that element should be mapped to.\n\tNote that for 1-dimensional arrays, an index may be specified\n\tusing just an integer rather than a length-1 list containing the\n\tinteger, if desired.\n\n    SymmetryDimensions must be a list with one entry for each dimension of\n    the base symmetry.  Each entry must either be the name of a dimension,\n    or of the form Dimension:IdxSpec, where Dimension is the name of a\n    dimension and IdxSpec specifies a subset of the indices of that\n    dimension.  IdxSpec may be an integer, an integer range L..H, or a list\n    of these.  Providing such a qualification means that the symmetry is\n    only applied to the specified indices of the dimension, not the\n    dimension as a whole.\n\n    By default, a symmetry affects the array as a whole; that is, for\n    example, a symmetry applied to columns will affect all rows, and in\n    particular all rows in the same way (it won't, say, swap columns 1 and 3\n    in row 1, but swap 5 and 6 in row 2; the columns will be rearranged in\n    the same way in every row).  If one or more indices for a dimension\n    should be affected independently of the rest of the indices for that\n    dimension, then this can be specified in the OtherDimensions field,\n    which is a list of terms of the form Dimension:IdxSpec.  This specifies\n    that the symmetry should only affect the given indices of the given\n    dimension, independent of the other indices (the specified indices are\n    still affected synchronously).  This allows one to express, for example,\n    that the elements of a given row can be permuted, independent of the\n    other rows.  If OtherDimensions is just the empty list, then it may be\n    omitted.\n\n    To do:\n\tSupport multiple value dimensions\n\tSupport multiple matrices\n\tMore error checking...  :)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n    Balanced Incomplete Block Design (BIBD)\n\tStandard model, with a 2-D array of booleans.\n\tFull row and column permutation.\n\n\tdim(Array, [NRows, NCols]),\n\t...\n\tconstruct_group(Array, [rows, cols], values:0..1, [\n\t\t    symmetry(s_n, [rows], []),\n\t\t    symmetry(s_n, [cols], [])\n\t\t], \"bibd_group\", MaxPoints, ToPointPred, FromPointPred)\n\n    Social golfer problem\n\tBoolean model, with one boolean variable for each round/group/player\n\tcombination.\n\tFull permutation of the rounds, full permutation of the groups in\n\tany round, and full permutation of the players.\n\n\tdim(Array, [NRounds, NGroups, NPlayers]),\n\t...\n\tconstruct_group(Array, [rounds, groups, players], values:0..1, [\n\t\t    symmetry(s_n, [rounds], []),\n\t\t    symmetry(s_n, [groups], [rounds:1]),\n\t\t    symmetry(s_n, [players], [])\n\t\t], \"golf_group\", MaxPoints, ToPointPred, FromPointPred)\n\n\tNote that the permutation of the groups within a round does not\n\tneed to be specified for every round; the fact that the rounds are\n\tinterchangeable means that it need only be specified for one round.\n\n    N Queens problem\n\tStandard row model, with one integer for each row specifying which\n\tcolumn the queen appears in.\n\tThe symmetries of the square, including reflection, applied to the\n\trow/column combination.\n\n\tdim(Array, [NQueens]),\n\t...\n\tconstruct_group(Array, [rows], cols:1..NQueens, [\n\t\t    symmetry(d_4, [rows, cols], [])\n\t\t], \"queens_group\", MaxPoints, ToPointPred, FromPointPred)\n\n    N Queens problem\n\tBoolean model, with one boolean for each location on the board,\n\tspecifying whether a queen appears there or not.\n\tThe symmetries of the square, including reflection.\n\n\tdim(Array, [NQueens, NQueens]),\n\t...\n\tconstruct_group(Array, [rows, cols], values:0..1, [\n\t\t    symmetry(d_4, [rows, cols], [])\n\t\t], \"queens_group\", MaxPoints, ToPointPred, FromPointPred)\n\n\tNote that the symmetry expression for this model is exactly the\n\tsame as for the standard row model; whether the columns are values\n\tor a dimension of the variable array is irrelevant."},"suspend:suspend_desc":{"prefix":"lib","body":"lib(${1:suspend})$2\n$0","description":"lib(suspend)\n\n    This library provides the following:\n\n    the suspend pseudo-solver for general arithmetic\n    the suspend attribute\n\n    The suspend pseudo-solver for arithmetic comparisons simply consists\n    of suspending (lazy-checking) versions of all arithmetic comparisons\n    (>/2, #>/2, etc).  These all suspend until all their variables\n    have been instantiated, then they wake up and test the condition,\n    succeeding or failing as appropriate. Together with a search routine,\n    this provides the means to implement simple test-and-generate algorithms.\n\n    The suspend-attribute is a basis for the implementation of similar\n    user-defined data-driven computations that react to variable instantiation,\n    variable binding, or general variable-constraining events.  The suspend-\n    attribute defines the following three suspension lists (and thus waking\n    conditions) for a variable:\n\n    inst\n    \twoken when variable is instantiated.\n    bound\n    \twoken when variable is bound, even to an other variable.\n    constrained\n    \twoken when variable is (further) constrained.  This is\n\ttriggered by the notify_constrained built-in.\n\n    These three lists can be used as waking conditions in the suspend/3,4\n    built-in. Variables using the suspend-attribute do not have to be\n    declared specially, the attribute is implicitly created when needed."},"sym_expr:sym_expr_desc":{"prefix":"lib","body":"lib(${1:sym_expr})$2\n$0","description":"lib(sym_expr)\n\n   This library provides a convenient way to express the symmetries of a\n   CSP, as described in:\n\n   Warwick Harvey, Tom Kelsey and Karen Petrie.  \"Symmetry Group Expression\n   for CSPs.\"  In Barbara Smith et al., editors, Proceedings of\n   SymCon'03: Third International Workshop on Symmetry in Constraint\n   Satisfaction Problems, a workshop of CP 2003, pages 86-96.\n   September, 2003.\n\n   This is particularly useful for GAP-based symmetry-breaking libraries, as\n   it will construct an appropriate group in GAP and provide predicates for\n   mapping between CSP assignments and the points acted on by the GAP group.\n\n   Please note that this library currently does not work on Windows machines\n   due to its dependence on the GAP interface library."},"tentative_constraints:alldifferent_t/3":{"prefix":"alldifferent_t","body":"alldifferent_t(${1:Xs}, ${2:Cs}, ${3:MC})$4\n$0","description":"alldifferent_t(+Xs, +Cs, +MC)\n\n   Tentative value implementation of alldifferent/2 constraint\n\nArguments\n   Xs    A list or array of variables/values\n   Cs    A list or array of numbers\n   MC    A monitored_constraint descriptor\n\nType\n   library(tentative_constraints)\n\nDescription\n\n    \tTentative value implementation of alldifferent constraint with\n\toffsets. The difference releationship must hold between the\n\tvalues resulting from adding each variable Xi to its corresponding\n\toffset Ci.\n\t\n\tThe violatedness of the constraint is the number of identical\n\tvalue pairs among these Xi+Ci values.\n\t\n\tThe following declaration is in effect, meaning that alldifferent_t/3\n\tis used whenever alldifferent/2 is added to a constraint set:\n\t\n\t:- alldifferent_t/3 tent_implements alldiffernet/2.\n\t\n    \n\nModes and Determinism\n   alldifferent_t(+, +, +) is det\n\nExamples\n   \n    ?- Xs = [A,B,C], Xs tent_set [1,2,3], CS :~ alldifferent(Xs, [1,0,0]).\n    Xs = [A{1 -> 1}, B{2 -> 1}, C{3 -> 0}]\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   alldifferent_t / 2, neq_t / 3, tentative : tent_implements / 2"},"tentative_constraints:alldifferent_t/2":{"prefix":"alldifferent_t","body":"alldifferent_t(${1:Cs}, ${2:MC})$3\n$0","description":"alldifferent_t(+Cs, +MC)\n\n   Tentative value implementation of alldifferent constraint\n\nArguments\n   Cs    A list or array of variables/values\n   MC    A monitored_constraint descriptor\n\nType\n   library(tentative_constraints)\n\nDescription\n\n    \tTentative value implementation of alldifferent constraint.\n\t\n\tThe violatedness of the constraint is the number of identical\n\tvalue pairs among its arguments.\n\t\n\tThe following declaration is in effect, meaning that alldifferent_t/2\n\tis used whenever alldifferent/1 is added to a constraint set:\n\t\n\t:- alldifferent_t/2 tent_implements alldiffernet/1.\n\t\n    \n\nModes and Determinism\n   alldifferent_t(+, +) is det\n\nExamples\n   \n    ?- Xs = [A,B,C], Xs tent_set [1,2,3], CS :~ alldifferent(Xs).\n    Xs = [A{1 -> 0}, B{2 -> 0}, C{3 -> 0}]\n    CS = constraint_set(TotalVio{0 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   alldifferent_t / 3, neq_t / 3, tentative : tent_implements / 2"},"tentative_constraints:eq_t/3":{"prefix":"eq_t","body":"eq_t(${1:X}, ${2:Y}, ${3:MC})$4\n$0","description":"eq_t(?X, ?Y, +MC)\n\n   Tentative value implementation of $=/2 arithmetic equality constraint\n\nArguments\n   X    Expression containing tentative variables\n   Y    Expression containing tentative variables\n   MC    A monitored_constraint descriptor\n\nType\n   library(tentative_constraints)\n\nDescription\n\n\t\n    \tTentative value implementation of equality constraint.\n\t\n\tThe violatedness of the constraint is 0 if the equality holds,\n\t1 otherwise.\n\t\n\tThe following declaration is in effect, meaning that eq_t/3\n\tis used whenever $= /2 is added to a constraint set:\n\t\n\t:- eq_t/3 tent_implements $= /2.\n\t\n\t\n    \n\nModes and Determinism\n   eq_t(?, ?, +) is det\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n\n    ?- [X, Y] tent_set [3, 3], CS :~ (X $= Y).\n    X = X{3 -> 0}\n    Y = Y{3 -> 0}\n    CS = constraint_set(TotalVio{0 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   alldifferent_t / 2, alldifferent_t / 3, neq_t / 3, tentative : tent_implements / 2"},"tentative_constraints:integral_t/3":{"prefix":"integral_t","body":"integral_t(${1:X}, ${2:Epsilon}, ${3:MC})$4\n$0","description":"integral_t(?X, ?Epsilon, +MC)\n\n   Tentative value implementation of approximate integrality\n\nArguments\n   X    Tentative variables\n   Epsilon    Allowed deviation from integrality\n   MC    A monitored_constraint descriptor\n\nType\n   library(tentative_constraints)\n\nDescription\n\n\t\n    \tTentative value implementation of approximate integrality constraint.\n\t\n\tThe violatedness of the constraint is 0 if X's value is within\n\ttolerance Epsilon of the nearest integers, 1 otherwise.\n\t\n\tThe following declaration is in effect, meaning that integral_t/3\n\tis used whenever integral/2 is added to a constraint set:\n\t\n\t:- integral_t/3 tent_implements integral/2.\n\t\n\t\n    \n\nModes and Determinism\n   integral_t(?, ?, +) is det\n\nExamples\n   \n    ?- X tent_set 3.2, CS :~ integral(X, 0.1).\n    X = X{3.2 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n\n    ?- X tent_set 3.2, CS :~ integral(X, 0.1), X tent_set 3.01.\n    X = X{3.01 -> 0}\n    CS = constraint_set(TotalVio{0 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   eq_t / 3, neq_t / 3, tentative : tent_implements / 2"},"tentative_constraints:neq_t/3":{"prefix":"neq_t","body":"neq_t(${1:X}, ${2:Y}, ${3:MC})$4\n$0","description":"neq_t(?X, ?Y, +MC)\n\n   Tentative value implementation of $\\=/2 arithmetic disequality constraint\n\nArguments\n   X    Expression containing tentative variables\n   Y    Expression containing tentative variables\n   MC    A monitored_constraint descriptor\n\nType\n   library(tentative_constraints)\n\nDescription\n\n\t\n    \tTentative value implementation of disequality constraint.\n\t\n\tThe violatedness of the constraint is 0 if the disequality holds,\n\t1 otherwise.\n\t\n\tThe following declaration is in effect, meaning that neq_t/3\n\tis used whenever $\\= /2 is added to a constraint set:\n\t\n\t:- neq_t/3 tent_implements $\\= /2.\n\t\n\t\n    \n\nModes and Determinism\n   neq_t(?, ?, +) is det\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $\\= Y).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{0 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n\n    ?- [X, Y] tent_set [3, 3], CS :~ (X $\\= Y).\n    X = X{3 -> 0}\n    Y = Y{3 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   alldifferent_t / 2, alldifferent_t / 3, eq_t / 3, tentative : tent_implements / 2"},"tentative_constraints:tentative_constraints_desc":{"prefix":"lib","body":"lib(${1:tentative_constraints})$2\n$0","description":"lib(tentative_constraints)\n\n    This library contains tentative value implementations for some basic\n    constraints.  It is intended to be used together with lib(tentative),\n    which provides the underlying primitives and facilities to create\n    tentative variables, manage constraint sets, and to do search."},"tentative:NT/2":{"prefix":"CS","body":"CS","description":"CS :~ ConstrSpec\n\n   Add a constraint to a constraint set\n\nArguments\n   CS    Constraint set or free variable\n   ConstrSpec    A constraint specification\n\nType\n   library(tentative)\n\nDescription\n\n\tAdd a constraint to a constraint set. After adding, the constraint\n\twill be part of the constraint set, and add to its total violatedness.\n\tThe amount of violatedness contributed by the constraint depends on\n\tthe constraint's implementation, but can be scaled.\n\t\n\tThree forms of constraint specification are recognised here:\n\t\n\tConstraint\n\t    A constraint goal. The constraint must have a 'tentative\n\t    implementation', i.e. a predicate must be defined that takes one\n\t    additional argument and implements the violation monitoring for\n\t    the constraint (see constraint implementation interface).\n\tWeight * Constraint\n\t    where Weight is an integer. This means that the constraints\n\t    violatedness is scaled with the factor Weight before being added\n\t    to the total violatedness of the constraint set.\n\tConstraint alias Term\n\t    Term is the term that can be retrieved from the constraint\n\t    set, in place of the constraint goal itself (see cs_all/2 etc).\n\tWeight * Constraint alias Term\n\t    Conbination of both modifiers above.\n\t\n\t\n\tIf CS is a free variable, a new constraint set will be implicitly\n\tcreated (as if created with cs_create(CS, [])).\n\t\n    \n\nModes and Determinism\n   :~(?, +) is det\n\nExamples\n   \n    ?- length(Xs, 5), tent_set_all(Xs, 99), CS :~ alldifferent(Xs).\n    Xs = [Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}]\n    CS = constraint_set(TotalVio{10 -> 0}, ...)\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_create / 2, cs_clear_all / 1, cs_clear_satisfied / 1, cs_violations / 2, cs_current_violations / 2, cs_random_worst / 2, cs_all_worst / 2, cs_all_violated / 2, cs_random_violated / 2, cs_all / 2, tent_implements / 2"},"tentative:cs_all/2":{"prefix":"cs_all","body":"cs_all(${1:CS}, ${2:Cstr})$3\n$0","description":"cs_all(+CS, -Cstr)\n\n   Get all constraints in the constraint set\n\nArguments\n   CS    Constraint set\n   Cstr    A list of constraints (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a list of all constraints in the constraint set.\n\t\n\tIf the constraints were added with aliases (see :~ /2),\n\tthe alias term is retrieved instead of the constraint goal.\n\t\n    \n\nModes and Determinism\n   cs_all(+, -) is det\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y), CS :~ (X $\\= Y), cs_all(CS, C).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    C = [X{3 -> 0} $\\= Y{4 -> 0}, X $= Y]\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_all_violated / 2, cs_all_worst / 2"},"tentative:cs_all_violated/2":{"prefix":"cs_all_violated","body":"cs_all_violated(${1:CS}, ${2:Cstr})$3\n$0","description":"cs_all_violated(+CS, -Cstr)\n\n   Get all violated constraints in the constraint set\n\nArguments\n   CS    Constraint set\n   Cstr    A list of constraints (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a list of all currently violated constraints in the\n\tconstraint set, i.e. all the constraints whose violation count\n\tis currently nonzero.\n\t\n\tIf the constraints were added with aliases (see :~ /2),\n\tthe alias term is retrieved instead of the constraint goal.\n\t\n    \n\nModes and Determinism\n   cs_all_violated(+, -) is det\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y), CS :~ (X $\\= Y), cs_all_violated(CS, C).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    C = [X{3 -> 0} $= Y{4 -> 0}]\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_all / 2, cs_all_worst / 2"},"tentative:cs_all_worst/2":{"prefix":"cs_all_worst","body":"cs_all_worst(${1:CS}, ${2:Cstr})$3\n$0","description":"cs_all_worst(+CS, -Cstr)\n\n   Get all worst violated constraints in the constraint set\n\nArguments\n   CS    Constraint set\n   Cstr    A list of constraints (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a list of all the worst violated constraints in the\n\tconstraint set, i.e. all the constraints that have maximum\n\tviolation count among the constraints in the set.\n\t\n\tIf the constraints were added with aliases (see :~ /2),\n\tthe alias term is retrieved instead of the constraint goal.\n\t\n    \n\nModes and Determinism\n   cs_all_worst(+, -) is det\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y), CS :~ (X $\\= Y), cs_all_worst(CS, C).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    C = [X{3 -> 0} $= Y{4 -> 0}]\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_all / 2, cs_all_violated / 2"},"tentative:cs_clear_all/1":{"prefix":"cs_clear_all","body":"cs_clear_all(${1:CS})$2\n$0","description":"cs_clear_all(+CS)\n\n   Clean up the constraint set completely\n\nArguments\n   CS    Constraint set\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tClean up the constraint set completely. All delayed goals related\n\tto this constraint set will be removed and the constraints forgotten.\n\tA constraint set that has been cleaned up should not be used any longer.\n\t\n    \n\nModes and Determinism\n   cs_clear_all(+) is det\n\nSee Also\n   cs_clear_satisfied / 1"},"tentative:cs_clear_satisfied/1":{"prefix":"cs_clear_satisfied","body":"cs_clear_satisfied(${1:CS})$2\n$0","description":"cs_clear_satisfied(+CS)\n\n   Remove the satisfied constraints from the constraint set\n\nArguments\n   CS    Constraint set\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tRemove all currently satisfied constraints from the constraint set.\n\tThis means, even if they become violated again later, they will no\n\tlonger contribute to the set's violatedness count.  All delayed goals\n\trelated to these constraints will be removed and the constraints\n\tforgotten.\n\t\n    \n\nModes and Determinism\n   cs_clear_satisfied(+) is det\n\nSee Also\n   cs_clear_all / 1"},"tentative:cs_create/2":{"prefix":"cs_create","body":"cs_create(${1:CS}, ${2:Options})$3\n$0","description":"cs_create(-CS, ++Options)\n\n   Create an empty constraint set\n\nArguments\n   CS    Constraint set (output)\n   Options    List of options\n\nType\n   library(tentative)\n\nDescription\n\n\tCreate an empty constraint set. No options are currently supported.\n\tA constraint set is an abstract data structure which should only\n\tbe accessed through the cs_xxx group of predicates. Its purpose\n\tis to group constraints together and organise access to these\n\tconstraints based on their violatedness counts.\n    \n\nModes and Determinism\n   cs_create(-, ++) is det\n\nExamples\n   \n    ?- cs_create(CS, []).\n    CS = constraint_set(Violations{0 -> 0}, [])\n    Yes (0.00s cpu)\n    \n\nSee Also\n   :~ / 2, cs_clear_all / 1, cs_clear_satisfied / 1, cs_violations / 2, cs_current_violations / 2, cs_random_worst / 2, cs_all_worst / 2, cs_all_violated / 2, cs_random_violated / 2, cs_all / 2"},"tentative:cs_current_violations/2":{"prefix":"cs_current_violations","body":"cs_current_violations(${1:CS}, ${2:Vio})$3\n$0","description":"cs_current_violations(+CS, -Vio)\n\n   Get the current violatedness of the constraint set\n\nArguments\n   CS    Constraint set\n   Vio    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns an integer representing the current violatedness of\n\tthe constraint set.\n\t\n    \n\nModes and Determinism\n   cs_current_violations(+, -) is det\n\nExamples\n   \n    ?- length(Xs, 5), tent_set_all(Xs, 99), CS :~ alldifferent(Xs),\n       cs_current_violations(CS, V).\n    Xs = [Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}]\n    CS = constraint_set(TotalVio{10 -> 0}, ...)\n    V = 10\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_violations / 2"},"tentative:cs_random_violated/2":{"prefix":"cs_random_violated","body":"cs_random_violated(${1:CS}, ${2:Cstr})$3\n$0","description":"cs_random_violated(+CS, -Cstr)\n\n   Get random violated constraints in the constraint set\n\nArguments\n   CS    Constraint set\n   Cstr    A constraint term (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a currently violated constraint from the constraint set,\n\ti.e. all the constraints whose violation count is currently nonzero.\n\tIf there are several, a random one is returned.\n\t\n\tIf the constraints were added with aliases (see :~ /2),\n\tthe alias term is retrieved instead of the constraint goal.\n\t\n    \n\nModes and Determinism\n   cs_random_violated(+, -) is semidet\n\nFail Conditions\n   Fails if there is no violated constraint in the set\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y), CS :~ (X $\\= Y),\n       cs_random_violated(CS, C).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    C = X{3 -> 0} $= Y{4 -> 0}\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_random_worst / 2, cs_all_violated / 2"},"tentative:cs_random_worst/2":{"prefix":"cs_random_worst","body":"cs_random_worst(${1:CS}, ${2:Cstr})$3\n$0","description":"cs_random_worst(+CS, -Cstr)\n\n   Get random worst violated constraint from the constraint set\n\nArguments\n   CS    Constraint set\n   Cstr    A constraint term (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a worst violated constraint from the constraint set, i.e.\n\ta constraint that has maximum violation count among the constraints\n\tin the set. If there are several, a random one is picked.\n\t\n\tIf the constraints were added with aliases (see :~ /2),\n\tthe alias term is retrieved instead of the constraint goal.\n\t\n    \n\nModes and Determinism\n   cs_random_worst(+, -) is semidet\n\nFail Conditions\n   Fails if there is no violated constraint in the set\n\nExamples\n   \n    ?- [X, Y] tent_set [3, 4], CS :~ (X $= Y), CS :~ (X $\\= Y), cs_random_worst(CS, C).\n    X = X{3 -> 0}\n    Y = Y{4 -> 0}\n    CS = constraint_set(TotalVio{1 -> 0}, ...)\n    C = X{3 -> 0} $= Y{4 -> 0}\n    There are 2 delayed goals.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_random_violated / 2, cs_all_worst / 2"},"tentative:cs_violations/2":{"prefix":"cs_violations","body":"cs_violations(${1:CS}, ${2:Vio})$3\n$0","description":"cs_violations(+CS, -Vio)\n\n   Get a tentative variable reflecting the violatedness of the constraint set\n\nArguments\n   CS    Constraint set\n   Vio    A tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tReturns a tentative variable reflecting the (current and future)\n\tviolatedness of the constraint set.\n\t\n    \n\nModes and Determinism\n   cs_violations(+, -) is det\n\nExamples\n   \n    ?- length(Xs, 5), tent_set_all(Xs, 99), CS :~ alldifferent(Xs),\n       cs_violations(CS, V).\n    Xs = [Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}, Xi{99 -> 4}]\n    CS = constraint_set(V{10 -> 0}, ...)\n    V = V{10 -> 0}\n    There is 1 delayed goal.\n    Yes (0.00s cpu)\n    \n\nSee Also\n   cs_current_violations / 2"},"tentative:has_tent_value/1":{"prefix":"has_tent_value","body":"has_tent_value(${1:X})$2\n$0","description":"has_tent_value(?X)\n\n   X has a tentative value (succeeds also for X nonvar)\n\nArguments\n   X    Any term\n\nType\n   library(tentative)\n\nDescription\n\n    \tSucceeds if X is a variable with a tentative value, or if X is\n\ta nonvariable (i.e. has a definitive value).\n    \n\nModes and Determinism\n   has_tent_value(?) is semidet\n\nExamples\n   \n    ?- tent_set(X, 27), has_tent_value(X).\n    X = X{27 -> 0}\n    Yes (0.00s cpu)\n\n    ?- has_tent_value(_).\n    No (0.00s cpu)\n\n    ?- has_tent_value(35).\n    Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, tent_get / 2, tent_fix / 1"},"tentative:random_element/2":{"prefix":"random_element","body":"random_element(${1:Values}, ${2:X})$3\n$0","description":"random_element(+Values, -X)\n\n   Pick random element from range or collection\n\nArguments\n   Values    Specification of possible values\n   X    Output variable\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tSelect a random value from the given specification of possible\n\tvalues.  The Values specification can be\n\t\n\t\n\tMin..Max\n\t    A range of integers from Min to Max\n\tList\n\t    A list of possible values\n\tArray\n\t    An array of possible values\n\t\n    \n\nModes and Determinism\n   random_element(+, -) is semidet\n\nFail Conditions\n   The range specification is empty or invalid\n\nExamples\n   \n    ?- random_element(3 .. 7, X).\n    X = 5\n    Yes (0.00s cpu)\n\n    ?- random_element([a, b, c, d], X).\n    X = a\n    Yes (0.00s cpu)\n\n    ?- random_element([a, b, c, d], X).\n    X = c\n    Yes (0.00s cpu)\n\n    \n\nSee Also\n   random / 1, frandom / 1, random_sample / 3, tent_set_random / 2"},"tentative:random_sample/3":{"prefix":"random_sample","body":"random_sample(${1:Values}, ${2:SampleSize}, ${3:X})$4\n$0","description":"random_sample(+Values, +SampleSize, -X)\n\n   Nondeterministically pick SampleSize random elements\n\nArguments\n   Values    Specification of possible values\n   SampleSize    Integer\n   X    Output variable\n\nType\n   library(tentative)\n\nDescription\n\n\tThis predicate succeeds SampleSize times. Each time it succeeds,\n\tit returns a random value from the given specification of possible\n\tvalues.  The Values specification are as in random_element/2.\n    \n\nModes and Determinism\n   random_sample(+, +, -) is nondet\n\nExamples\n   \n    ?- random_sample(0 .. 9, 3, X).\n    X = 9\n    Yes (0.00s cpu, solution 1, maybe more)\n    X = 0\n    Yes (0.03s cpu, solution 2, maybe more)\n    X = 5\n    Yes (0.03s cpu, solution 3)\n    \n\nSee Also\n   random / 1, frandom / 1, random_element / 2, tent_set_random / 2"},"tentative:register_for_notification/3":{"prefix":"register_for_notification","body":"register_for_notification(${1:X}, ${2:Tag}, ${3:Receiver})$4\n$0","description":"register_for_notification(?X, +Tag, ?Receiver)\n\n   Constraint implementation: register for notification\n\nArguments\n   X    A non-free term, usually a tentative variable\n   Tag    A user-defined term\n   Receiver    A notification-receiver (input or output)\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tThis is part of the interface for implementing tentative constraints.\n\tIt sets up a receiver in the sense of lib(notify_ports), such\n\tthat every time the tentative value of X changes, a message\n\tis sent to this receiver. The message has the form\n\t\n\t\tTag:chg(Old,New)\n\t\n\twhere Tag is the parameter given here in the setup (e.g. the\n\tindex of a variable within the constraint where it occurs),\n\tOld is the tentative value before the change, and New the\n\ttentative value after the change.\n\t\n\tThe same receiver can register for many variables. Messages\n\tfrom the different variables are distinguished by their Tag.\n\t\n\tSuch a receiver would typically be used by a demon that is woken\n\tup on tentative value change (tent_chg of tentative), to obtain\n\tprecise information about the changes that caused the wakeup.\n\t\n    \n\nExamples\n   \n    tent_trace_array(Stream, Name, Xs) :-\n\t    ( foreacharg(X,Xs,I), param(Stream,Name) do\n\t\tregister_for_notification(X, I, Receiver),\n\t\tsuspend(tent_trace_demon(Stream, Name, Receiver, Susp),\n\t\t\t1, X->tent_chg, Susp)\n\t    ).\n\n\t:- demon tent_trace_demon/4.\n\ttent_trace_demon(Stream, Name, Receiver, Susp) :-\n\t    foreachnotification(tent_trace_demon,\n\t\t    I:Notification, [Stream, Name], Receiver, Status, (\n\t\tprintf(Stream, \"%w[%w]: %w%n\", [Name,I,Notification])\n\t    )),\n\t    ( Status = closed ->\n\t\twriteln(Stream, Name:Status),\n\t\tkill_suspension(Susp)\n\t    ; true ).\n    \n\nSee Also\n   library(notify_ports)"},"tentative:tent_fix/1":{"prefix":"tent_fix","body":"tent_fix(${1:X})$2\n$0","description":"tent_fix(?X)\n\n   Instantiate X to its tentative value\n\nArguments\n   X    Any term, typically containing tentative variables\n\nType\n   library(tentative)\n\nDescription\n\n\tThis is a shorthand for\n\t\n\t\ttent_get(X, TV), X = TV.\n\t\n    \n\nModes and Determinism\n   tent_fix(?) is det\n\nExceptions\n   tentative_value_not_set --- X (or a subterm of X) has no tentative value\n\nExamples\n   \n    ?- tent_set(X, 27), tent_fix(X).\n    X = 27\n    Yes (0.00s cpu)\n\n    ?- X = foo(_, _), tent_set(X, foo(27, 99)), tent_fix(X).\n    X = foo(27, 99)\n    Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, has_tent_value / 1, tent_get / 2"},"tentative:tent_get/2":{"prefix":"tent_get","body":"tent_get(${1:X}, ${2:TV})$3\n$0","description":"tent_get(?X, -TV)\n\n   Get X's tentative value\n\nArguments\n   X    Any term, typically a variable\n   TV    Will be bound to a (nonvar) term\n\nType\n   library(tentative)\n\nDescription\n\n    \tGet a variable's (or a whole term's) tentative value, i.e. create a\n\tterm TV that represents the current tentative value of X. \n\t\n    \tIf X is a tentative variable, TV is bound to the tentative value.\n\tIf X is a variable without tentative value, an error is raised.\n    \tIf X is atomic, its tentative value is the same as X.\n\tIf X is a compound term, TV will be bound to a corresponding compound\n\tterm with all variables replaced by their tentative values. The resulting\n\tterm TV will be a proper instance of X.\n\t\n    \n\nModes and Determinism\n   tent_get(?, -) is det\n\nExceptions\n   tentative_value_not_set --- X (or a subterm of X) has no tentative value\n\nExamples\n   \n    ?- tent_set(X, 27), tent_get(X, TV).\n    X = X{27 -> 0}\n    TV = 27\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, 27), tent_set(X, 99), tent_get(X, TV).\n    X = X{99 -> 0}\n    TV = 99\n    Yes (0.00s cpu)\n\n    ?- X = foo(Y), tent_set(X, foo(27)), X tent_get TV.\n    X = foo(Y{27 -> 0})\n    Y = Y{27 -> 0}\n    TV = foo(27)\n    Yes (0.00s cpu)\n\n    ?- tent_get(27, TV).\n    TV = 27\n    Yes (0.00s cpu)\n\n    ?- tent_get(X, TV).\n    uncaught exception in exit_block(tentative_value_not_set)\n    Abort\n\n    ?- tent_get(foo(X), TV).\n    uncaught exception in exit_block(tentative_value_not_set)\n    Abort\n    \n\nSee Also\n   tent_set / 2, has_tent_value / 1, tent_fix / 1"},"tentative:tent_minimize_random/3":{"prefix":"tent_minimize_random","body":"tent_minimize_random(${1:MoveGenerator}, ${2:Violations}, ${3:MoveId})$4\n$0","description":"tent_minimize_random(+MoveGenerator, ?Violations, -MoveId)\n\n   Find a move that minimizes violations\n\nArguments\n   MoveGenerator       A goal\n   Violations    A tentative variable\n   MoveId    Placeholder for move identifier\n\nType\n   library(tentative)\n\nDescription\n\n\tThis metapredicate finds a local search move that minimizes\n\tviolations. It requries that the tentative variables and constraints\n\tover them have been set up beforehand. \n\t\n    \tMoveGenerator is a nondeterministic goal that implements a local\n\tsearch step. It should explore all neighbours on backtracking.\n\tA move should be made by changing tentative values, and\n\tinstantiating MoveId to a unique identifier for every move.\n\t\n\tViolations should be a tentative variable that reflects the\n\ttotal problem violations that are to be minimized.\n\t\n\tMoveId is a variable which occurs in MoveGenerator. At the end of\n\tminimization, it will contain the ID of the best move. If there\n\tare multiple moves of the same quality, a random one is returned.\n\t\n\tAfter tent_minimize_random/3 succeeds, all the trial moves are undone\n\tand the computation state is as before the call. Only the MoveId\n\tcontains the identifier of the best move. This move can then be\n\tcommitted to by performing it again according to MoveId.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nFail Conditions\n   Fails if MoveGenerator fails\n\nExamples\n   \n\n    % This example tries 8 moves that lead to different tentative values\n    % of Viol. One of the moves that lead to a value of 1 is selected.\n\n    ?-  Viol tent_set 0,\n\ttent_minimize_random((\n\t\tbetween(1, 8, 1, MoveId),\n\t\targ(MoveId, viol(9,5,6,1,3,6,1,9), N),\n\t\tViol tent_set N\n\t    ), Viol, MoveId).\n     ...\n     MoveId = 7\t\t% 4 or 7, the result is random!\n     Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2"},"tentative:tent_set/2":{"prefix":"tent_set","body":"tent_set(${1:X}, ${2:TV})$3\n$0","description":"tent_set(?X, +TV)\n\n   Set X's tentative value to TV\n\nArguments\n   X    Any term, typically a variable\n   TV    A (nonvar) term\n\nType\n   library(tentative)\n\nDescription\n\n\tGive a variable (or several variables within a term) a tentative value.\n\tA tentative value cannot be itself a variable.\n\t\n\tIf X is a variable without tentative value, it will be given the\n\ttentative value TV. In addition, its violatedness count will be\n\tinitialised to 0.\n\tIf X already has a tentative value, its tentative value is\n\tchanged to TV. (Note that this may trigger further computation!)\n\tThe violatedness count remains unchanged.\n\tIf X is already instantiated, TV must be a strict instance of X.\n\tVariables within X are given tentative values from the corresponding\n\tinstantiated parts of TV.\n\t\n    \n\nModes and Determinism\n   tent_set(-, +) is det\n   tent_set(+, +) is semidet\n\nFail Conditions\n   TV is not an instance of X\n\nExceptions\n   4 --- TV is not sufficiently instantiated\n\nExamples\n   \n    ?- tent_set(X, 27).\n    X = X{27 -> 0}\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, 27), tent_set(X, 99).\n    X = X{99 -> 0}\n    Yes (0.00s cpu)\n\n    ?- tent_set(foo(X), foo(27)).\n    X = X{27 -> 0}\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, Y).\n    instantiation fault in X tent_set Y\n    Abort\n    \n\nSee Also\n   tent_get / 2, has_tent_value / 1, tent_fix / 1"},"tentative:tent_set_all/2":{"prefix":"tent_set_all","body":"tent_set_all(${1:Vars}, ${2:TV})$3\n$0","description":"tent_set_all(?Vars, +TV)\n\n   Set the tentative values of all variables within Vars to the same value TV\n\nArguments\n   Vars    A term\n   TV    A (nonvar) term\n\nType\n   library(tentative)\n\nDescription\n\n\tAssign the tentative value TV to each variable in the term Vars.\n\tVars would typically be a list (or array) of variables.\n    \n\nModes and Determinism\n   tent_set_all(?, +) is det\n\nExamples\n   \n    ?- tent_set_all([A, B, C], 3).\n    A = A{3 -> 0}\n    B = B{3 -> 0}\n    C = C{3 -> 0}\n    Yes (0.00s cpu)\n\n    ?- length(L, 5), tent_set_all(L, 3).\n    L = [Xi{3 -> 0}, Xi{3 -> 0}, Xi{3 -> 0}, Xi{3 -> 0}, Xi{3 -> 0}]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, tent_set_random / 2"},"tentative:tent_set_random/2":{"prefix":"tent_set_random","body":"tent_set_random(${1:Vars}, ${2:Values})$3\n$0","description":"tent_set_random(?Vars, ++Values)\n\n   Set the tentative value of each variable within Vars to a random value from the given Range\n\nArguments\n   Vars    A term\n   Values    Specification of possible values\n\nType\n   library(tentative)\n\nDescription\n\n\tAssign to each variable in Vars a random value from the given\n\tspecification of possible values.  The Values specification can be\n\t\n\tMin..Max\n\t    A range of integers from Min to Max\n\tList\n\t    A list of possible values\n\tArray\n\t    An array of possible values\n\t\n    \n\nModes and Determinism\n   tent_set_random(?, ++) is det\n\nExamples\n   \n    ?- length(L, 5), tent_set_random(L, 1 .. 9).\n    L = [Xi{2 -> 0}, Xi{3 -> 0}, Xi{7 -> 0}, Xi{5 -> 0}, Xi{3 -> 0}]\n    Yes (0.00s cpu)\n\n    ?- length(L, 5), tent_set_random(L, [a, e, i, o, u]).\n    L = [Xi{o -> 0}, Xi{e -> 0}, Xi{o -> 0}, Xi{e -> 0}, Xi{e -> 0}]\n    Yes (0.00s cpu)\n\n    ?- length(L, 5), tent_set_random(L, [](a, e, i, o, u)).\n    L = [Xi{u -> 0}, Xi{i -> 0}, Xi{a -> 0}, Xi{o -> 0}, Xi{a -> 0}]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, tent_set_all / 2"},"tentative:tent_trace_array/3":{"prefix":"tent_trace_array","body":"tent_trace_array(${1:Stream}, ${2:Name}, ${3:ArrayList})$4\n$0","description":"tent_trace_array(+Stream, +Name, +ArrayList)\n\n   Simple tracing facility for several variables\n\nArguments\n   Stream    A stream identifier\n   Name    Usually atom or string (but general term allowed)\n   ArrayList    Array or list of tentative variables\n\nType\n   library(tentative)\n\nDescription\n\n\t\n\tThis predicate sets up a demon that prints a message whenever the\n\ttentative value of one of the variables in ArrayList changes.\n\tThe message is printed onto Stream and is of the form\n\t\n\t\tName[Index]: chg(Old,New)\n\t\n\twhere Index is the index of the changed variable in the given\n\tarray, Old is the tentative value before the change, and New\n\tthe tentative value after the change.\n\t\n\tAnother way of tracing tentative value changes is by using the\n\tVisualisation Tools.\n\t\n    \n\nModes and Determinism\n   tent_trace_array(+, +, +) is det\n\nExamples\n   \n    ?- Xs = [X,Y], tent_set(Xs, [1,2]),\n      tent_trace_array(output, hello, Xs),\n      tent_set(X, 7),\n      tent_set(Y, 3),\n      tent_set([X,Y], [5,5]).\n\n    hello[1]: chg(1, 7)\n    hello[2]: chg(2, 3)\n    hello[1]: chg(7, 5)\n    hello[2]: chg(3, 5)\n\n    Xs = [X{5 -> 0}, Y{5 -> 0}]\n    There are 2 delayed goals.\n    Yes (0.02s cpu)\n    \n\nSee Also\n   library(viewable)"},"tentative:var_get_violations/2":{"prefix":"var_get_violations","body":"var_get_violations(${1:X}, ${2:Violations})$3\n$0","description":"var_get_violations(?X, -Violations)\n\n   Get X's violation count\n\nArguments\n   X    A a tentative variable or instantiated term\n   Violations    Variable, will be bound to a number\n\nType\n   library(tentative)\n\nDescription\n\n\tGet X's violations count. The violation count of a tentative variable\n\tis the cumulative result of all previous increments of that count.\n\tThe violation count of a nonvariable term is 0.\n    \n\nModes and Determinism\n   var_get_violations(?, -) is det\n\nExceptions\n   tentative_value_not_set --- X is a variable without tentative value\n\nExamples\n   \n    ?- tent_set(X, 27), var_get_violations(X, V).\n    X = X{27 -> 0}\n    V = 0\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, 27), var_inc_violations(X, 3), var_get_violations(X, V).\n    X = X{27 -> 3}\n    V = 3\n    Yes (0.00s cpu)\n\n    ?- var_get_violations(a, V).\n    V = 0\n    Yes (0.00s cpu)\n\n    ?- var_get_violations(_, V).\n    uncaught exception in exit_block(tentative_value_not_set)\n    Abort\n    \n\nSee Also\n   tent_set / 2, var_inc_violations / 2"},"tentative:var_inc_violations/2":{"prefix":"var_inc_violations","body":"var_inc_violations(${1:X}, ${2:Delta})$3\n$0","description":"var_inc_violations(?X, +Delta)\n\n   Increment X's violation count by Delta\n\nArguments\n   X    A a tentative variable\n   Delta    A number\n\nType\n   library(tentative)\n\nDescription\n\n\tIncrement X's violation count by Delta. X should be a variable with\n\ta tentative value. The initial violation count for every variable is 0.\n\t\n\tCalling var_inc_violations/2 on a nonvariable has no effect and\n\tsilently succeeds.\n    \n\nModes and Determinism\n   var_inc_violations(?, +) is semidet\n\nFail Conditions\n   Fails if X is a variable without tentative value\n\nExamples\n   \n    ?- tent_set(X, 27), var_inc_violations(X, 3).\n    X = X{27 -> 3}\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, 27), var_inc_violations(X, 3), var_inc_violations(X, 1).\n    X = X{27 -> 4}\n    Yes (0.00s cpu)\n\n    ?- tent_set(X, 27), var_inc_violations(X, 3), var_inc_violations(X, -1).\n    X = X{27 -> 2}\n    Yes (0.00s cpu)\n\n    ?- var_inc_violations(foo, 3).\n    Yes (0.00s cpu)\n\n    ?- var_inc_violations(_, 3).\n    No (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, has_tent_value / 1, tent_get / 2, var_get_violations / 2"},"tentative:vs_all/2":{"prefix":"vs_all","body":"vs_all(${1:VS}, ${2:Vars})$3\n$0","description":"vs_all(+VS, -Vars)\n\n   Retrieve all variables from a varset\n\nArguments\n   VS    A varset\n   Vars    A list of tentative variables (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve all variables from a varset.\n    \n\nModes and Determinism\n   vs_all(+, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]),\n       vs_create(Vars, VS), vs_all(VS, VSVars).\n    Vars = [A{1 -> 0}, B{2 -> 0}, C{3 -> 0}]\n    VS = ...\n    VSVars = [C{3 -> 0}, B{2 -> 0}, A{1 -> 0}]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_create / 2, vs_random / 2, vs_member / 2"},"tentative:tentative_desc":{"prefix":"lib","body":"lib(${1:tentative})$2\n$0","description":"lib(tentative)\n\n    Overview\n\n    This is a library for implementing Local Search algorithms.\n    It is intended as a successor for library(repair).\n\n    This library provides the following concepts and primitives:\n\n    A variable can be given a tentative value. This is a value which\n    is attached to the variable, but does not constrain the variable.\n\n    Tentative values are observed by monitored constraints. A monitored\n    constraint checks whether a constraint is satisfied given the current\n    tentative values of its variables, or computes a measure of violatedness\n    for a tentatively violated constraint.\n\n    Violatedness can be attached to constraints and to variables.\n    Typically, when a constraint is tentatively violated, this increases\n    the violatedness count of the constraint itself, and the violatedness\n    count of those variables that can be made responsible for the violation.\n\n    Actual constraint implementations can be found in the library\n    lib(tentative_constraints).\n\n    Tentative Values\n\n    A tentative value (TV) can be an atomic term or a (possibly nonground)\n    compound term. It is a conscious design choice not to allow variable\n    tentative values.\n    A tentative value can be attached to a variable, and freely changed.\n    It is not possible to remove a variable's tentative value once\n    it has had one, it can only be replaced by a different one.\n    The change of tentative value can be used as a trigger condition for\n    waking delayed goals.\n\n    Instantiating a tentative variable to a value V is equivalent to first\n    setting/changing its tentative value to V, and then instantiating to V.\n\n    When two tentative variables get unified, one of them acquires the\n    tentative value of the other (which one is undefined).  Such unifications\n    do not fit well with the concepts of this library and are best avoided.\n\n    Variables with tentative value are printed in the following format:\n\n\tX{99 -> 7}\n\n    where the first number (99) is the tentative value, and the second\n    number (7) is the variable's violation count.\n\n    The primitives related to tentative values are:\n\n    has_tent_value(?X)\n\tX has a tentative (or definitive) value\n    tent_get(?X, -Val)\n\tget tentative value\n    tent_set(?X, -Val)\n\tset tentative value\n    tent_set_all(?Xs, +Val)\n\tset multiple identical tentative values\n    tent_set_random(?Xs, +Range)\n\tset multiple random tentative values\n    tent_fix(?X)\n\tinstantiate to tentative value\n    var_get_violations(?X, -Violations)\n\tget the number of violations the variable is currently involved in\n    var_inc_violations(?Var, +Delta)\n\tadd Delta to Var's violation counter\n\n    All these operations are undone on backtracking.\n\n    Variable Sets\n\n    Tentative variables can be grouped into indexed sets, from which elements\n    (or their index) can then be selected according to different criteria.\n    The corresponding predicates are:\n\n    vs_create(+Vars, -VarSet)\n    construct a variable set from the variables in Vars\n    vs_all(+VS, -Vs)\n    get a list of all the variables in the set\n    vs_element(+VS, +I, -V)\n    get a particular variable from the set\n    vs_member(+VS, -V)\n    enumerate all variables from the set\n    vs_random(+VS, -Vs), vs_random_index(+VS, -Is)\n    pick a random variable from the set\n    vs_random_violated(+VS, -Vs), vs_random_violated_index(+VS, -Is)\n    pick a random violated variable from the set\n    vs_all_violated(+VS, -Vs), vs_all_violated_index(+VS, -Is)\n    get a list of all violated variables from the set\n    vs_violated(+VS, -V), vs_violated_index(+VS, -I)\n    enumerate all violated variables from the set\n    vs_random_worst(+VarSet, -WorstVar), vs_random_worst_index(+VarSet, -I)\n    \tpick a random variable with maximum violations from the set\n    vs_all_worst(+VS, -Vs), vs_all_worst_index(+VS, -Is)\n    get a list of all the maximally violated variables from the set\n    vs_worst(+VS, -V), vs_worst_index(+VS, -I)\n    enumerate all maximally violated variables from the set\n\n    Constraint Sets\n\n    To monitor a constraint's tentative violatedness, it must be added\n    to a constraint set.  The predicates to create, add and remove\n    constraints from a constraint set are:\n\n    CS :~ C\n    \tadd a constraint to the constraint set\n    cs_create(-CS, +Options)\n    \tcreate an empty constraint set\n    cs_clear_all(+CS)\n    \tremove all constraints from the constraint set\n    cs_clear_satisfied(+CS)\n    \tremove all satisfied constraints from the constraint set\n\n    The total violation count of all the constraints in the set can be\n    accessed through the following predicates:\n\n    cs_violations(+CS, -VioVar)\n    \tget a tentative variable reflecting violatedness of the constraint set\n    cs_current_violations(+CS, -Vio)\n    \tget the current violatedness of the constraint set (integer)\n\n    Constraints from the constraint set can be selected according to\n    different criteria through the following predicates:\n\n    cs_random_worst(+CS, -C)\n    \tget a random worst violated constraint from the constraint set\n    cs_all_worst(+CS, -Cs)\n    \tget all worst violated constraints from the constraint set\n    cs_all_violated(+CS, -Cs)\n    \tget all violated constraints from the constraint set\n    cs_random_violated(+CS, -Cs)\n    \tget a random violated constraint from the constraint set\n    cs_all(+CS, -Cs)\n    \tget all constraints from the constraint set\n\n    Invariants\n\n    There is currently one primitive to maintain arithmetic invariants:\n\n    -Res tent_is +Expr\n    \tthe tentative value of Res is the tentative result of Expr\n\n    Search and Randomised Primitives\n\n    The following primitives support the implementation of the actual\n    Local Search routines:\n\n    tent_minimize_random(MoveGenerator, Violations, MoveId)\n    \tFind a best neighbour using MoveGenerator\n\n    random_element(+Range, -Value)\n\tPick a random element from Range\n\n    random_sample(+Range, +N, -Value)\n    \tSucceed N times with random values from Range\n\n    Tracing\n\n    A simple tracing facility is provided via\n\n    tent_trace_array(+Stream, +Name, +ArrayList)\n    \tPrint a message whenever a tentative value changes\n\n    Also, the Visualisation Tools can be used with this library,\n    by creating viewables with type changeable(tentative,Type).\n\n    Constraint implementation interface\n\n    Constraints are implemented by an implementation predicate. A constraint\n    is linked to its implementation predicate by a tent_implements/2\n    declaration, e.g.\n\n\t:- alldifferent_t/2 tent_implements alldifferent/1.\n\n    The implementation predicate must have one more argument than the\n    constraint itself.  The extra (last) argument is a structure\n\n\tstruct(monitored_constraint(\n\t\talias,\t\t% the constraint goal (or equivalent term)\n\t\tviolations,\t% a tentative variable\n\t\tsuspensions\t% suspensions of the monitoring goals\n\t)\n\n    The implementation predicate is supposed to update the constraint's\n    violation TV plus the violation counters of the variables that occur\n    in the constraint. It should do this by suspending on the variable's\n    tent_chg list, and by registering for exact change notification via:\n\n    register_for_notification(?TV, +Tag, ?Receiver)\n    \tregister to receive messages about changes to TV's tentative value\n\n     This messaging facility is based upon the primitive in lib(notify_ports).\n\n    Constraints\n\n    Actual constraint implementations can be found in the library\n    lib(tentative_constraints).\n\n    Example\n\n    See lib(tentative_constraints)."},"tentative:vs_all_violated/2":{"prefix":"vs_all_violated","body":"vs_all_violated(${1:VS}, ${2:Vars})$3\n$0","description":"vs_all_violated(+VS, -Vars)\n\n   Retrieve all violated variables from a varset\n\nArguments\n   VS    A varset\n   Vars    A list of tentative variables (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve all variables from a varset which have nonzero violation\n\tcounts.\n    \n\nModes and Determinism\n   vs_all_violated(+, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]), vs_create(Vars, VS),\n       var_inc_violations(B, 1), vs_all_violated(VS, VSVars).\n    Vars = [A{1 -> 0}, B{2 -> 1}, C{3 -> 0}]\n    VS = ...\n    VSVars = [B{2 -> 1}]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_random_violated / 2, vs_violated / 2, vs_all_violated_index / 2"},"tentative:vs_all_violated_index/2":{"prefix":"vs_all_violated_index","body":"vs_all_violated_index(${1:VS}, ${2:Vars})$3\n$0","description":"vs_all_violated_index(+VS, -Vars)\n\n   Retrieve all violated variable indices from a varset\n\nArguments\n   VS    A varset\n   Vars    A list of integers (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve all variable indices from a varset which have nonzero\n\tviolation counts.\n    \n\nModes and Determinism\n   vs_all_violated_index(+, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]), vs_create(Vars, VS),\n       var_inc_violations(B, 1), vs_all_violated(VS, VSIs).\n    Vars = [A{1 -> 0}, B{2 -> 1}, C{3 -> 0}]\n    VS = ...\n    VSVars = [2]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_random_violated_index / 2, vs_violated_index / 2, vs_all_violated / 2"},"tentative:vs_create/2":{"prefix":"vs_create","body":"vs_create(${1:Vars}, ${2:VS})$3\n$0","description":"vs_create(?Vars, -VS)\n\n   Construct a varset from the variables in Vars\n\nArguments\n   Vars    A term containing tentative variables\n   VS    Varset (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tCreate an abstract 'varset' from the tentative variables in a term.\n\tA varset is an ordered set of variables that can be accessed by\n\tindex, or by their violation properties. Elements are indexed from\n\t1 to size of the set.\n    \n\nModes and Determinism\n   vs_create(?, -) is semidet\n\nFail Conditions\n   Vars contains variables without tentative values\n\nExamples\n   \n    ?- Vars = [_,_,_], tent_set_all(Vars, 99), vs_create(Vars, VS).\n    Vars = [Xi{99 -> 0}, Xi{99 -> 0}, Xi{99 -> 0}]\n    VS = ...\n    Yes (0.00s cpu)\n    \n\nSee Also\n   tent_set / 2, vs_size / 2, vs_element / 3, vs_all / 2, vs_all_violated / 2, vs_all_worst / 2, vs_all_violated_index / 2, vs_all_worst_index / 2, vs_random / 2, vs_random_violated / 2, vs_random_worst / 2, vs_random_index / 2, vs_random_violated_index / 2, vs_random_worst_index / 2, vs_member / 2, vs_violated / 2, vs_worst / 2, vs_violated_index / 2, vs_worst_index / 2"},"tentative:vs_all_worst_index/2":{"prefix":"vs_all_worst_index","body":"vs_all_worst_index(${1:VS}, ${2:Vars})$3\n$0","description":"vs_all_worst_index(+VS, -Vars)\n\n   Retrieve all worst violated variable indices from a varset\n\nArguments\n   VS    A varset\n   Vars    A list of integers (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve all variable indices from a varset whose violation count is\n\tmaximal in the varset.\n    \n\nModes and Determinism\n   vs_all_worst_index(+, -) is det\n\nSee Also\n   vs_random_worst_index / 2, vs_worst_index / 2, vs_all_worst / 2"},"tentative:vs_element/3":{"prefix":"vs_element","body":"vs_element(${1:VS}, ${2:I}, ${3:X})$4\n$0","description":"vs_element(+VS, +I, -X)\n\n   Get an element of a varset by index\n\nArguments\n   VS    A varset\n   I    A positive integer\n   X    A variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tGet the Ith element of a varset. I must be between 1 and the\n\tsize of the set.\n    \n\nModes and Determinism\n   vs_element(+, +, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], vs_create(Vars, VS), vs_element(VS, 1, X).\n    VS = ...\n    X = C\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_create / 2, vs_size / 2"},"tentative:vs_member/2":{"prefix":"vs_member","body":"vs_member(${1:VS}, ${2:X})$3\n$0","description":"vs_member(+VS, -X)\n\n   Succeed for each element of a varset\n\nArguments\n   VS    A varset\n   X    A variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tBacktrack over all elements of a varset.\n    \n\nModes and Determinism\n   vs_member(+, -) is nondet\n\nSee Also\n   vs_create / 2, vs_element / 3, vs_all / 2, vs_random / 2"},"tentative:vs_all_worst/2":{"prefix":"vs_all_worst","body":"vs_all_worst(${1:VS}, ${2:Vars})$3\n$0","description":"vs_all_worst(+VS, -Vars)\n\n   Retrieve all worst violated variables from a varset\n\nArguments\n   VS    A varset\n   Vars    A list of tentative variables (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve all variables from a varset whose violation count is\n\tmaximal in the varset.\n    \n\nModes and Determinism\n   vs_all_worst(+, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]), vs_create(Vars, VS),\n       var_inc_violations(A, 2),\n       var_inc_violations(B, 1),\n       var_inc_violations(C, 2),\n       vs_all_worst(VS, VSVars).\n    Vars = [A{1 -> 2}, B{2 -> 1}, C{3 -> 2}]\n    VS = ...\n    VSVars = [A{1 -> 2}, C{3 -> 2}]\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_random_worst / 2, vs_worst / 2, vs_all_worst_index / 2"},"tentative:vs_random/2":{"prefix":"vs_random","body":"vs_random(${1:VS}, ${2:Var})$3\n$0","description":"vs_random(+VS, -Var)\n\n   Retrieve a random variable from a varset\n\nArguments\n   VS    A varset\n   Var    Tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a random variable from a varset.\n    \n\nModes and Determinism\n   vs_random(+, -) is semidet\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [a,b,c]), vs_create(Vars, VS),\n       vs_random(VS, Var).\n    Vars = [Var{a -> 0}, B{b -> 0}, C{c -> 0}]\n    VS = ...\n    Var = Var{a -> 0}\t% A, B or C, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_create / 2, vs_element / 3, vs_random_index / 2"},"tentative:vs_random_index/2":{"prefix":"vs_random_index","body":"vs_random_index(${1:VS}, ${2:Var})$3\n$0","description":"vs_random_index(+VS, -Var)\n\n   Retrieve a random variable index from a varset\n\nArguments\n   VS    A varset\n   Var    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a random variable index from a varset.\n    \n\nModes and Determinism\n   vs_random_index(+, -) is semidet\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [a,b,c]), vs_create(Vars, VS),\n       vs_random(VS, I).\n    Vars = [A{a -> 0}, B{b -> 0}, C{c -> 0}]\n    VS = ...\n    I = 1\t\t% 1, 2 or 3, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_create / 2, vs_element / 3, vs_random / 2"},"tentative:vs_random_violated_index/2":{"prefix":"vs_random_violated_index","body":"vs_random_violated_index(${1:VS}, ${2:I})$3\n$0","description":"vs_random_violated_index(+VS, -I)\n\n   Retrieve a random violated variable index from a varset\n\nArguments\n   VS    A varset\n   I    An integer variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a variable index from a varset whose violation count is\n\tnonzero. If there are more than one, a random candidate is returned.\n    \n\nModes and Determinism\n   vs_random_violated_index(+, -) is semidet\n\nFail Conditions\n   The varset does not contain a violated variable\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [a,b,c]), vs_create(Vars, VS),\n       var_inc_violations(A, 2),\n       var_inc_violations(C, 1),\n       vs_random_violated(VS, I).\n    Vars = [A{a -> 2}, B{b -> 0}, C{c -> 1}]\n    VS = ...\n    I = 1\t\t% 1 or 3, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_all_violated_index / 2, vs_violated_index / 2, vs_random_violated / 2"},"tentative:vs_random_violated/2":{"prefix":"vs_random_violated","body":"vs_random_violated(${1:VS}, ${2:Var})$3\n$0","description":"vs_random_violated(+VS, -Var)\n\n   Retrieve a random violated variable from a varset\n\nArguments\n   VS    A varset\n   Var    Tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a variable from a varset whose violation count is\n\tnonzero. If there are more than one, a random candidate is returned.\n    \n\nModes and Determinism\n   vs_random_violated(+, -) is semidet\n\nFail Conditions\n   The varset does not contain a violated variable\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [a,b,c]), vs_create(Vars, VS),\n       var_inc_violations(A, 2),\n       var_inc_violations(C, 1),\n       vs_random_violated(VS, Var).\n    Vars = [Var{a -> 2}, B{b -> 0}, C{c -> 1}]\n    VS = ...\n    Var = Var{a -> 2}\t% A or C, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_all_violated / 2, vs_violated / 2, vs_random_violated_index / 2"},"tentative:vs_random_worst/2":{"prefix":"vs_random_worst","body":"vs_random_worst(${1:VS}, ${2:Var})$3\n$0","description":"vs_random_worst(+VS, -Var)\n\n   Retrieve a worst violated variable from a varset\n\nArguments\n   VS    A varset\n   Var    Tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a variable from a varset whose violation count is\n\tmaximal in the varset. In case of ties, a random candidate\n\tis returned.\n    \n\nModes and Determinism\n   vs_random_worst(+, -) is semidet\n\nFail Conditions\n   Fails if there is no violated variable in the set\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]), vs_create(Vars, VS),\n       var_inc_violations(A, 2),\n       var_inc_violations(B, 1),\n       var_inc_violations(C, 2),\n       vs_random_worst(VS, Worst).\n    Vars = [A{1 -> 2}, B{2 -> 1}, Worst{3 -> 2}]\n    VS = ...\n    Worst = Worst{3 -> 2}       % A or C, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_all_worst / 2, vs_worst / 2, vs_random_worst_index / 2"},"tentative:vs_random_worst_index/2":{"prefix":"vs_random_worst_index","body":"vs_random_worst_index(${1:VS}, ${2:Var})$3\n$0","description":"vs_random_worst_index(+VS, -Var)\n\n   Retrieve a worst violated variable index from a varset\n\nArguments\n   VS    A varset\n   Var    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tRetrieve a variable index from a varset whose violation count is\n\tmaximal in the varset. In case of ties, a random candidate\n\tis returned.\n    \n\nModes and Determinism\n   vs_random_worst_index(+, -) is semidet\n\nFail Conditions\n   Fails if there is no violated variable in the set\n\nExamples\n   \n    ?- Vars=[A,B,C], tent_set(Vars, [1,2,3]), vs_create(Vars, VS),\n       var_inc_violations(A, 2),\n       var_inc_violations(B, 1),\n       var_inc_violations(C, 2),\n       vs_random_worst(VS, Worst).\n    Vars = [A{1 -> 2}, B{2 -> 1}, Worst{3 -> 2}]\n    VS = ...\n    Worst = 1       % 1 or 3, the result is random!\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_all_worst_index / 2, vs_worst_index / 2, vs_random_worst / 2"},"tentative:vs_size/2":{"prefix":"vs_size","body":"vs_size(${1:VS}, ${2:N})$3\n$0","description":"vs_size(+VS, -N)\n\n   Get the size of a varset\n\nArguments\n   VS    A varset\n   N    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tGet the size (number of elements) of a varset.\n    \n\nModes and Determinism\n   vs_size(+, -) is det\n\nExamples\n   \n    ?- Vars=[A,B,C], vs_create(Vars, VS), vs_size(VS, N).\n    VS = ...\n    N = 3\n    Yes (0.00s cpu)\n    \n\nSee Also\n   vs_create / 2, vs_element / 3"},"tentative:vs_violated/2":{"prefix":"vs_violated","body":"vs_violated(${1:VS}, ${2:Vars})$3\n$0","description":"vs_violated(+VS, -Vars)\n\n   Succeeds for each violated variable from a varset\n\nArguments\n   VS    A varset\n   Vars    A tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tBacktrack over all variables from a varset which have nonzero\n\tviolation counts.\n    \n\nModes and Determinism\n   vs_violated(+, -) is nondet\n\nSee Also\n   vs_all_violated / 2, vs_random_violated / 2, vs_violated_index / 2"},"tentative:vs_violated_index/2":{"prefix":"vs_violated_index","body":"vs_violated_index(${1:VS}, ${2:Vars})$3\n$0","description":"vs_violated_index(+VS, -Vars)\n\n   Succeeds for each violated variable index from a varset\n\nArguments\n   VS    A varset\n   Vars    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tBacktrack over all variable indices from a varset which have\n\tnonzero violation counts.\n    \n\nModes and Determinism\n   vs_violated_index(+, -) is nondet\n\nSee Also\n   vs_all_violated_index / 2, vs_random_violated_index / 2, vs_violated / 2"},"tentative:vs_worst/2":{"prefix":"vs_worst","body":"vs_worst(${1:VS}, ${2:Vars})$3\n$0","description":"vs_worst(+VS, -Vars)\n\n   Succeeds for each worst violated variable from a varset\n\nArguments\n   VS    A varset\n   Vars    A tentative variable (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tBacktrack over all variable indices from a varset whose violation\n\tcount is maximal in the varset.\n    \n\nModes and Determinism\n   vs_worst(+, -) is nondet\n\nSee Also\n   vs_all_worst / 2, vs_random_worst / 2, vs_worst_index / 2"},"tentative:vs_worst_index/2":{"prefix":"vs_worst_index","body":"vs_worst_index(${1:VS}, ${2:Vars})$3\n$0","description":"vs_worst_index(+VS, -Vars)\n\n   Succeeds for each worst violated variable index from a varset\n\nArguments\n   VS    A varset\n   Vars    An integer (output)\n\nType\n   library(tentative)\n\nDescription\n\n\tBacktrack over all variable indices from a varset whose violation\n\tcount is maximal in the varset.\n    \n\nModes and Determinism\n   vs_worst_index(+, -) is nondet\n\nSee Also\n   vs_all_worst_index / 2, vs_random_worst_index / 2, vs_worst / 2"},"test_util:fixme/1":{"prefix":"fixme","body":"fixme","description":"fixme +SkippedTest\n\n   Skip a test that is known to fail.\n\nType\n   library(test_util)\n\nDescription\nfixme/1 is a low-precedence prefix operator, and can thus be\n    textually prefixed to any other test.  Its effect is that the test\n    is skipped (not executed).  When multiple tests are done, the number\n    of skipped tests gets reported at the end.  Skipped tests count as\n    neither succeeded or failed.\n\nExamples\n   fixme X is 0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1 should_give X=0.8.\n\nSee Also\n   should_give / 2, should_fail / 1, should_throw / 2, should_raise / 2, should_give / 3, should_fail / 2, should_throw / 3"},"test_util:get_failed_test_count/1":{"prefix":"get_failed_test_count","body":"get_failed_test_count(${1:N})$2\n$0","description":"get_failed_test_count(-N)\n\n   Returns the number of tests that failed.\n\nType\n   library(test_util)\n\nDescription\n\n    The test framework counts the number of tests which fail; use this\n    predicate to retrieve this number."},"test_util:should_fail/2":{"prefix":"should_fail","body":"should_fail(${1:Goal}, ${2:TestName})$3\n$0","description":"should_fail(+Goal,+TestName)\n\n   Run the goal Goal and print a message if it doesn't fail\n\nType\n   library(test_util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   should_fail(3.0 > 3, test_float_not_greater_than_integer).\n\nSee Also\n   should_give / 2, should_throw / 2, should_raise / 2, should_fail / 1, should_give / 3, should_throw / 3, should_raise / 3"},"test_util:should_give/3":{"prefix":"should_give","body":"should_give(${1:Goal}, ${2:CheckGoal}, ${3:TestName})$4\n$0","description":"should_give(+Goal,+CheckGoal,+TestName)\n\n   Run the goal Goal and print a message if the result doesn't satisfy CheckGoal\n\nType\n   library(test_util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   should_give(X is 3.0+4, X=7.0, test_float_plus_integer_equals_float).\n\nSee Also\n   should_fail / 1, should_throw / 2, should_raise / 2, should_give / 2, should_fail / 2, should_throw / 3, should_raise / 3"},"test_util:should_raise/3":{"prefix":"should_raise","body":"should_raise(${1:Goal}, ${2:Event}, ${3:TestName})$4\n$0","description":"should_raise(+Goal,+Event,+TestName)\n\n   Run the goal Goal and print a message if it doesn't raise Event.\n\nType\n   library(test_util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   should_raise(number_string(hello,_),5,test_raises_5). % type error\n\nSee Also\n   should_give / 2, should_fail / 1, should_throw / 2, should_raise / 2, should_give / 3, should_fail / 2, should_throw / 3"},"test_util:should_throw/3":{"prefix":"should_throw","body":"should_throw(${1:Goal}, ${2:Exception}, ${3:TestName})$4\n$0","description":"should_throw(+Goal,+Exception,+TestName)\n\n   Run the goal Goal and print a message if it doesn't throw Exception\n\nType\n   library(test_util)\n\nDescription\nThe exception term thrown must be an instance (see instance/2) of Exception\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nExamples\n   \n\tshould_throw(throw(ball),ball,test_throw).\n\tshould_throw(throw(error(type,atom)),error(type,_),test_type_error).\n    \n\nSee Also\n   should_give / 2, should_fail / 1, should_raise / 2, should_throw / 2, should_give / 3, should_fail / 2, should_raise / 3, instance / 2"},"test_util:test/1":{"prefix":"test","body":"test(${1:File})$2\n$0","description":"test(+File)\n\n   Runs all the test patterns in File.\n\nType\n   library(test_util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   test / 2, test_info / 2, should_give / 2, should_fail / 1, should_throw / 2, should_raise / 2, should_give / 3, should_fail / 2, should_throw / 3, should_raise / 3"},"test_util:test/2":{"prefix":"test","body":"test(${1:File}, ${2:Option})$3\n$0","description":"test(+File, +Option)\n\n   Runs all the test patterns in File.\n\nType\n   library(test_util)\n\nDescription\n    Runs all the test patterns in File. Option is either 'call' (the default)\n    or 'compile'.\n    When 'call' is chosen, every test goal gets executed simply by metacall\n    using call/1.\n    When 'compile' is chosen, every test goal gets compiled into an auxiliary\n    predicate (with all compile-time transformations applied), which in turn\n    is then executed.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   test_info / 2, should_give / 2, should_fail / 1, should_throw / 2, should_raise / 2, should_give / 3, should_fail / 2, should_throw / 3, should_raise / 3"},"test_util:test_info/2":{"prefix":"test_info","body":"test_info(${1:File}, ${2:Info})$3\n$0","description":"test_info(+File,+Info)\n\n   Runs all the test patterns in File, printing the Info string in test_csv_log.\n\nType\n   library(test_util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   test / 1, should_give / 2, should_fail / 1, should_throw / 2, should_raise / 2, should_give / 3, should_fail / 2, should_throw / 3, should_raise / 3"},"test_util:test_util_desc":{"prefix":"lib","body":"lib(${1:test_util})$2\n$0","description":"lib(test_util)\n\n    Use this library as follows: Write a file with test patterns, using\n    the primitives should_fail/1, should_give/2, should_throw/2 and\n    should_raise/2, e.g.\n    \n    3.0 > 3 should_fail.\n    X is 3.0+4 should_give X=7.0.\n    throw(ball) should_throw ball.\n    number_string(hello,_) should_raise 5.\n    \n    The file name should have a .tst extension, e.g. mytests.tst.\n    Then run all the test in the file by calling test(mytests).  This will\n    print a message for every test pattern that does not behave as expected.\n    The messages go to a stream called testlog (which defaults to output).\n\n    \n    Alternatively, you can write a file with test patterns, using the\n    primitives should_fail/2, should_give/3, should_throw/3 and\n    should_raise/3, e.g.\n    \n    should_fail(3.0 > 3, test_float_not_greater_than_integer).\n    should_give(X is 3.0+4, X=7.0, test_float_plus_integer_equals_float).\n    should_throw(throw(ball),ball,test_throw).\n    should_raise(number_string(hello,_),5,test_raises_5).\n    \n    Here the extra last argument serves as a name for the test (or a short\n    description).  It can be an atom or a string and it is used to output\n    results in comma separated format to a stream called test_csv_log\n    (defaults to null), e.g. test(mytest) should output the following to\n    test_csv_log:\n    \n    test_float_not_greater_than_integer,pass,2001-10-29,16:59:20,0.00\n    test_float_plus_integer_equals_float,pass,2001-10-29,16:59:20,0.01\n    test_throw,pass,2001-10-29,16:59:20,0.00\n    test_raises_5,pass,2001-10-29,16:59:20,0.00\n    \n    The first value is the name of the test (last argument in test pattern).\n    The second value is either `pass' or `fail' indicating whether the\n    particular test was successful or not.  The third and fourth values show\n    the date and time (UTC) the test was run (in ISO 8601 format).  The last\n    value shows the CPU time taken to run the test.\n    Extra values can be appended at the head of the comma separated values\n    by using test_info/2, e.g. test_info(mytest,test_result) would change\n    the output to test_csv_log as follows:\n    \n    test_result,test_float_not_greater_than_integer,pass,2001-10-29,16:59:20,0.00\n    test_result,test_float_plus_integer_equals_float,pass,2001-10-29,16:59:20,0.01\n    test_result,test_throw,pass,2001-10-29,16:59:20,0.00\n    test_result,test_raises_5,pass,2001-10-29,16:59:20,0.00\n    \n    This can be extremely useful, as useful information as the name of the\n    module tested, the directory where it is located, the name of the host,\n    etc. can be added to the log."},"time_log:collate_time_logs/4":{"prefix":"collate_time_logs","body":"collate_time_logs(${1:Directory}, ${2:Package}, ${3:Embedding}, ${4:MasterLogFile})$5\n$0","description":"collate_time_logs(++Directory, ++Package, ++Embedding, ++MasterLogFile)\n\n   Collate local time logs into master log\n\nArguments\n   Directory    Root test directory\n   Package    ECLiPSe package used\n   Embedding    ECLiPSe embedding used\n   MasterLogFile       Master log file\n\nType\n   library(time_log)\n\nDescription\n    \tCollates all the temporary administrative files in the directory\n\ttree specified and logs them to the specified master log file.\n\n\tPackage specifies which ECLiPSe package was used, such as `standard'\n\tor `runtime'.\n\n\tEmbedding specifies which ECLiPSe embedding was used, such as\n\t`standalone' or `java'."},"time_log:initialise_time_logging/1":{"prefix":"initialise_time_logging","body":"initialise_time_logging(${1:Directory})$2\n$0","description":"initialise_time_logging(++Directory)\n\n   Prepare for time logging\n\nArguments\n   Directory    Root test directory\n\nType\n   library(time_log)\n\nDescription\n\tThis predicate prepares the given directory for time logging.\n\tEssentially all it does is traverse the directory tree looking for\n\told administrative files and deleting them."},"timeout:call_timeout_safe/1":{"prefix":"call_timeout_safe","body":"call_timeout_safe(${1:Goal})$2\n$0","description":"call_timeout_safe(+Goal)\n\n   Execute Goal, deferring the execution of an interrupting timeout predicate TimeOutGoal until Goal completes.\n\nArguments\n   Goal    Goal to execute\n\nType\n   library(timeout)\n\nDescription\n\n    Metacall Goal, ensuring that its execution is not interrupted and\n    preemptively aborted by a timeout of the timeout/3 or timeout/7 predicate.\n    If a timeout would have occurred during the execution of Goal, it is\n    effectively deferred until Goal completes.\n\n    The predicate can be used within a computation which is subject to timeouts,\n    to ensure that subgoals which should be executed as an atomic sequence\n    preserve this atomicity at the cost of delaying the execution\n    of TimeOutGoal.\n\n    In all other respects the semantics of call_timeout_safe/1 is the same\n    as call/1.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   If Goal is resatisfiable.\n\nExamples\n       ?- timeout(call_timeout_safe((writeln('Goal started'), \n    sleep(5), \n    writeln('Goal completed'))),\n    3, writeln('Timeout expired!')).\n    Goal started\n    Goal completed\n    Timeout expired!\n    Yes (0.01s cpu)\n    \n\nSee Also\n   timeout / 3, timeout / 7"},"time_log:log_time_local/2":{"prefix":"log_time_local","body":"log_time_local(${1:Name}, ${2:Time})$3\n$0","description":"log_time_local(++Name, ++Time)\n\n   Log a time in the local directory\n\nArguments\n   Name    Name of test\n   Time    Time taken to run test\n\nType\n   library(time_log)\n\nDescription\n\tLogs to a temporary administrative file in the local directory that\n\tthe test with the given name took the specified time to execute."},"timeout:timeout/3":{"prefix":"timeout","body":"timeout(${1:Goal}, ${2:TimeLimit}, ${3:TimeOutGoal})$4\n$0","description":"timeout(+Goal, ++TimeLimit, +TimeOutGoal)\n\n   Run the goal Goal for a maximum of TimeLimit seconds.\n\nArguments\n   Goal    Goal to run\n   TimeLimit    Time limit of Goal in seconds (integer or float)\n   TimeOutGoal    Goal to run on expiry of TimeLimit\n\nType\n   library(timeout)\n\nDescription\n\n    Goal is executed as if called via call(Goal),\n    but only for a maximum of TimeLimit seconds. If the goal is\n    still executing after TimeLimit, time-out occurs, the execution of the\n    goal is terminated (via throw/1) and TimeOutGoal is executed.  If\n    the value of TimeLimit is 0 or 1.0Inf, no timeout is applied to the Goal.\n\n    Note that, if Goal is nondeterministic, execution flow may leave the scope\n    of timeout/3 on success and re-enter on failure. In this case, only time\n    spent within Goal will be counted towards the TimeLimit.\n\n    The predicate is based on the after event timers, so TimeLimit is \n    measured in the timer currently used by after events. The current time\n    used for the associated event timer can be retrieved using\n    statistics(event_time, CurrentTime). The timeout predicate can be used \n    with other after events, and can be nested within itself (i.e. embedded\n    within Goal or TimeOutGoal).\n\n    Note that timeout/3 can be defined in terms of timeout/7 as:\n\n    timeout(Goal, TimeLimit, TimeOutGoal) :-\n    timeout(Goal, TimeLimit, TimeOutGoal, all_solution, _, _, _).\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   If Goal is resatisfiable.\n\nExamples\n       ?- timeout((repeat,fail), 1.5, writeln(timed-out)). % time-out from infinite loop\n    timed - out\n    Yes (1.51s cpu)\n    \n\nSee Also\n   timeout / 7, call_timeout_safe / 1, event_after / 2"},"time_log:time_log_desc":{"prefix":"lib","body":"lib(${1:time_log})$2\n$0","description":"lib(time_log)\n\n\tThis module is used for logging and collating the times taken to run\n\ttests (but could be used for other similar purposes).  Before\n\trunning any tests, call initialise_time_logging/1.  This deletes any\n\told administrative files from a previous test run.  Then, within the\n\ttest harness for an individual test, call log_time_local/2 to log\n\tthe time taken for the test to a temporary local file.  Finally,\n\tonce all the tests have completed successfully, call\n\tcollate_time_logs/4 to collect all the local administrative files\n\tand add all the data to the master log file."},"timeout:timeout/7":{"prefix":"timeout","body":"timeout(${1:Goal}, ${2:TimeLimit}, ${3:TimeOutGoal}, ${4:SolutionMode}, ${5:Timer}, ${6:DueTime}, ${7:TimeRemaining})$8\n$0","description":"timeout(+Goal, ++TimeLimit, +TimeOutGoal, ++SolutionMode, ?Timer, ?DueTime, ?TimeRemaining)\n\n   Run the goal Goal for a maximum of TimeLimit seconds.\n\nArguments\n   Goal    Goal to run\n   TimeLimit    Time limit of Goal in seconds (integer or float)\n   TimeOutGoal    Goal to run on expiry of TimeLimit\n   SolutionMode    Time limit applies to all solutions or per solution (atom)\n   Timer    After event timer handle\n   DueTime    Time at which TimeLimit expires (float)\n   TimeRemaining       Time remaining until goal would have expired (float)\n\nType\n   library(timeout)\n\nDescription\n\n    Goal is executed for a maximum of TimeLimit seconds. If the goal is still\n    executing after TimeLimit, time-out occurs, the execution of the goal is\n    terminated (via throw/1) and TimeOutGoal is executed.  If the value\n    of TimeLimit is 0 or 1.0Inf, no timeout is applied to the Goal.\n\n    SolutionMode is one of all_solution or per_solution.  If Goal is\n    resatisfiable, then, having found a solution, the per_solution\n    option reapplies the full value of the originally specified\n    TimeLimit to the resuming Goal.  The all_solution option resumes\n    the Goal with the unelapsed portion of TimeLimit (i.e.  its\n    remainder) as the expiry time, the expiry time therefore remains\n    the same.\n\n    Timer is the after-event handle assigned to this timeout goal. It\n    may be used within Goal to force early expiry of the timeout using:\n    event(Timer). \n\n    DueTime is the time at which TimeLimit expires and the TimeOutGoal is \n    posted. It is instantiated before Goal starts executing and may therefore \n    be used within Goal and TimeOutGoal. DueTime is undefined (and remains\n    uninstantiated) if the per_solution SolutionMode is specified.\n\n    On success, TimeRemaining is the time left until TimeLimit expiry,\n    if Goal completes before then, on timeout, TimeRemaining is 0.0.\n\n    The predicate is based on the after event timers, so TimeLimit is \n    measured in the timer currently used by after events. The current time\n    used for the associated event timer can be retrieved using\n    statistics(event_time, CurrentTime). The timeout predicate can be used \n    with other after events, and can be nested within itself (i.e. embedded\n    within Goal or TimeOutGoal). Within Goal, the remaining time that the Goal\n    has left to run before time-out can be computed using:\n\n    RemainingTime is max(0.0, DueTime - statistics(event_time)).\n\n    This may be useful for setting up sub-timeouts as a fraction of the\n    total remaining time.\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   If Goal is resatisfiable.\n\nExamples\n       % time-out from infinite loop\n    ?- timeout((repeat,fail), 1.5, writeln(timed-out), \n    all_solution, Timer, Due, Remainder).\n    timed - out\n    Timer = 'EVENT'(16'ed920978)\n    Due = Due\n    Remainder = 0.0\n    Yes (1.51s cpu)\n    \n\nSee Also\n   timeout / 3, call_timeout_safe / 1, event_after / 2, event / 1"},"toplevel:toplevel/0":{"prefix":"toplevel","body":"toplevel","description":"toplevel\n\n   Run a toplevel interpreter\n\nType\n   library(toplevel)\n\nDescription\n\n    \tRun a toplevel query interpreter. This is a program that\n\tallows to input ECLiPSe queries, runs them, and displays\n\tthe results. Which variant of this interpreter is invoked\n\tdepends on how it was initialized in toplevel_init/1.\n    \n\nSee Also\n   toplevel_init / 1, break / 0"},"toplevel:break/0":{"prefix":"break","body":"break","description":"break\n\n   A new invocation of a top level loop is called as a subgoal\n\nArguments\n\nType\n   library(toplevel)\n\nDescription\n\n    Used to start a new invocation of the top level loop.  Compiled\n    procedures and event handler redefinitions remain valid within the new\n    invocation level.  Exiting with a Control-D (or end_of_file) or\n    calling throw(end) will return the control to the previous level.\n    \n\nFail Conditions\n      None.\n\nResatisfiable\n      No.\n\nExamples\n   \n[eclipse]: [user].\n go:- writeln(\"**** Enter prolog goals and press ^D\"),\n      break,\n      writeln(\"**** Execution continues...\").\n user compiled 144 bytes in 0.02 seconds\n\nyes.\n[eclipse]: go.\n**** Enter prolog goals and press ^D\n\nEntering break level 1\n[eclipse]: date(X).\n\nX = \"Wed Aug  9 12:21:48 1989\\n\"\nyes.\n[eclipse]: ^D\n\nLeaving break level 1\n**** Execution continues...\n\nyes.\n[eclipse]:\n\nSee Also\n   toplevel / 0, throw / 1"},"timeout_simple:timeout/3":{"prefix":"timeout","body":"timeout(${1:Goal}, ${2:TimeLimit}, ${3:TimeOutGoal})$4\n$0","description":"timeout(+Goal, ++TimeLimit, +TimeOutGoal)\n\n   Run the goal Goal for a maximum of TimeLimit seconds.\n\nArguments\n   Goal    Goal to run\n   TimeLimit    Time limit of Goal in seconds (integer or float)\n   TimeOutGoal    Goal to run on expiry of TimeLimit\n\nType\n   library(timeout_simple)\n\nDescription\n\n    Goal is executed as if called via call(Goal),\n    but only for a maximum of TimeLimit seconds. If the goal is\n    still executing after TimeLimit, time-out occurs, the execution of the\n    goal is terminated (via throw/1) and TimeOutGoal is executed.  If\n    the value of TimeLimit is 0 or 1.0Inf, no timeout is applied to the Goal.\n\n    Note that, if Goal is nondeterministic, execution flow may leave the scope\n    of timeout/3 on success and re-enter on failure. In this case, only time\n    spent within Goal will be counted towards the TimeLimit.\n\n    This predicate is implemented using alrm/vtalrm timer signals.  These\n    signals are alse needed for after-events, which will stop working when\n    this predicate is being used.  Also, this timeout predicate cannot be\n    nested.  If you need a timeout that can be nested, and is compatible\n    with after-events, use lib(timeout).\n\n    Note that timeout/3 can be defined in terms of timeout/7 as:\n\n    timeout(Goal, TimeLimit, TimeOutGoal) :-\n    timeout(Goal, TimeLimit, TimeOutGoal, all_solution, _, _, _).\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   If Goal is resatisfiable.\n\nExamples\n       ?- timeout((repeat,fail), 1.5, writeln(timed-out)). % time-out from infinite loop\n    timed - out\n    Yes (1.51s cpu)\n\n    ?- timeout(repeat, 1.5, writeln(timed-out)), fail. % time-out from infinite loop\n    timed - out\n    Yes (1.51s cpu)\n\n    ?- X=f(X), Y=f(Y), timeout(X=Y, 2, fail). % time-out from looping unification\n    No (2.00s cpu)\n    \n\nSee Also\n   timeout / 7"},"timeout_simple:timeout/7":{"prefix":"timeout","body":"timeout(${1:Goal}, ${2:TimeLimit}, ${3:TimeOutGoal}, ${4:SolutionMode}, ${5:Timer}, ${6:DueTime}, ${7:TimeRemaining})$8\n$0","description":"timeout(+Goal, ++TimeLimit, +TimeOutGoal, ++SolutionMode, ?Timer, ?DueTime, ?TimeRemaining)\n\n   Run the goal Goal for a maximum of TimeLimit seconds.\n\nArguments\n   Goal    Goal to run\n   TimeLimit    Time limit of Goal in seconds (integer or float)\n   TimeOutGoal    Goal to run on expiry of TimeLimit\n   SolutionMode    Time limit applies to all solutions or per solution (atom)\n   Timer    After event timer handle\n   DueTime    Time at which TimeLimit expires (float)\n   TimeRemaining       Time remaining until goal would have expired (float)\n\nType\n   library(timeout_simple)\n\nDescription\n\n    Goal is executed for a maximum of TimeLimit seconds. If the goal is still\n    executing after TimeLimit, time-out occurs, the execution of the goal is\n    terminated (via throw/1) and TimeOutGoal is executed.  If the value\n    of TimeLimit is 0 or 1.0Inf, no timeout is applied to the Goal.\n\n    SolutionMode is one of all_solution or per_solution.  If Goal is\n    resatisfiable, then, having found a solution, the per_solution\n    option reapplies the full value of the originally specified\n    TimeLimit to the resuming Goal.  The all_solution option resumes\n    the Goal with the unelapsed portion of TimeLimit (i.e.  its\n    remainder) as the expiry time, the expiry time therefore remains\n    the same.\n\n    Timer is the after-event handle assigned to this timeout goal. It\n    may be used within Goal to force early expiry of the timeout using:\n    event(Timer). \n\n    DueTime is the time at which TimeLimit expires and the TimeOutGoal is \n    posted. It is instantiated before Goal starts executing and may therefore \n    be used within Goal and TimeOutGoal. DueTime is undefined (and remains\n    uninstantiated) if the per_solution SolutionMode is specified.\n\n    On success, TimeRemaining is the time left until TimeLimit expiry,\n    if Goal completes before then, on timeout, TimeRemaining is 0.0.\n\n    TimeLimit is measured in the timer currently used by after events.  The\n    current time used for the associated event timer can be retrieved using\n    statistics(event_time, CurrentTime). The timeout predicate can be used \n    with other after events, and can be nested within itself (i.e. embedded\n    within Goal or TimeOutGoal). Within Goal, the remaining time that the Goal\n    has left to run before time-out can be computed using:\n\n    RemainingTime is max(0.0, DueTime - statistics(event_time)).\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nResatisfiable\n   If Goal is resatisfiable.\n\nExamples\n       % time-out from infinite loop\n    ?- timeout((repeat,fail), 1.5, writeln(timed-out), \n    all_solution, Timer, Due, Remainder).\n    timed - out\n    Timer = 'EVENT'(16'ed920978)\n    Due = Due\n    Remainder = 0.0\n    Yes (1.51s cpu)\n    \n\nSee Also\n   timeout / 3, timeout : call_timeout_safe / 1, event_after / 2, event / 1"},"toplevel:write_history/0":{"prefix":"write_history","body":"write_history","description":"write_history\n\n   Writes the current command history into the .eclipse_history file\n\nType\n   library(toplevel)"},"timeout_simple:timeout_simple_desc":{"prefix":"lib","body":"lib(${1:timeout_simple})$2\n$0","description":"lib(timeout_simple)\n\n   This library prvides the same predicates as lib(timeout),\n\twith the following differences:\n\t1. timeouts can abort certain long-running built-in predicates,\n\t   like looping unifications.\n\t2. timeout predicates cannot be nested.\n\t3. it uses timer events directly, and thus cannot be used together\n\t   with after-events."},"toplevel:toplevel_desc":{"prefix":"lib","body":"lib(${1:toplevel})$2\n$0","description":"lib(toplevel)\n\n\tNote that this library is normally loaded automatically\n\tby the ECLiPSe development environment."},"toplevel:toplevel_init/1":{"prefix":"toplevel_init","body":"toplevel_init(${1:Type})$2\n$0","description":"toplevel_init(?Type)\n\n   Initialize a toplevel\n\nArguments\n   Type    one of the atoms 'tty' or 'gui'\n\nType\n   library(toplevel)\n\nDescription\n\n    \tInitializes streams and event handlers in preparation to\n\ta call to toplevel/0. Two variants of toplevel loop can be\n\tselected: command line oriented (tty) or server oriented\n\t(gui). The latter is intended for an ECLiPSe which is\n\tembedded or remote-interfaced to a GUI-based host program.\n    \n\nSee Also\n   toplevel / 0, break / 0"},"tty_vc:stop_tty_vc/0":{"prefix":"stop_tty_vc","body":"stop_tty_vc","description":"stop_tty_vc\n\n   Stop the TTY visualisation client.\n\nType\n   library(tty_vc)\n\nDescription\n\n\t     This predicate stops the TTY visualisation client (VC). It will no longer react to viewables.\n\nFail Conditions\n   Fails if there is no TTY VC.\n\nResatisfiable\n   no\n\nSee Also\n   start_tty_vc / 1, start_tty_vc / 2, start_tty_vc / 3"},"tty_vc:start_tty_vc/1":{"prefix":"start_tty_vc","body":"start_tty_vc(${1:VCName})$2\n$0","description":"start_tty_vc(++VCName)\n\n   Start a TTY visualisation client.\n\nArguments\n   VCName    An atom; the name of the TTY VC.\n\nType\n   library(tty_vc)\n\nDescription\n\n\t     This predicate starts a TTY visualisation client (VC). The change condition is constrained of suspend. The view granularity is fine. For more control over these options, use start_tty_vc/2 or start_tty_vc/3.  The TTY VC is a non-logical entity in the sense that backtracking over the start_tty_vc goal does not affect the existence of the TTY VC. \n\nFail Conditions\n   Fails when any other TTY VC exists. Only one TTY VC can exist at a time, although in general there can be multiple VCs.\n\nResatisfiable\n   no\n\nSee Also\n   stop_tty_vc / 0, start_tty_vc / 2, start_tty_vc / 3"},"tty_vc:start_tty_vc/2":{"prefix":"start_tty_vc","body":"start_tty_vc(${1:VCName}, ${2:InitialViewGranularity})$3\n$0","description":"start_tty_vc(++VCName, ++InitialViewGranularity)\n\n   Start a TTY visualisation client, specifying the view granularity.\n\nArguments\n   VCName    An atom; the name of the TTY VC.\n   InitialViewGranularityAn atom: 'coarse' or 'fine'\n\nType\n   library(tty_vc)\n\nDescription\n\n\t     This predicate starts a TTY visualisation client (VC), but allows the user to specify the initial view granularity. With 'fine', each propagation step is seen individually. With 'coarse' successful sequences of propagation are seen together in chunks and unsuccessful sequences are skipped. The view granularity for a particular viewable can be changed during search. Otherwise the predicate behaves exactly like start_tty_vc/1.\n\nResatisfiable\n   no\n\nSee Also\n   stop_tty_vc / 0, start_tty_vc / 1, start_tty_vc / 3"},"tty_vc:start_tty_vc/3":{"prefix":"start_tty_vc","body":"start_tty_vc(${1:VCName}, ${2:InitialViewGranularity}, ${3:ChangeCondition})$4\n$0","description":"start_tty_vc(++VCName, ++InitialViewGranularity, ++ChangeCondition)\n\n   Start a TTY visualisation client, specifying both the view granularity and the change condition.\n\nArguments\n   VCName    An atom; the name of the TTY VC.\n   InitialViewGranularityAn atom: 'coarse' or 'fine'\n   ChangeCondition     A term of the form change_condition(<Module>, <AttributeStructName>, <SuspListName>)\n\nType\n   library(tty_vc)\n\nDescription\n\n\t     This predicate starts a TTY visualisation client (VC), but allows the user to specify both the view granularity, as in start_tty_vc/2 and the change condition. The change condition specifies the suspension list to use for updates. The most obvious choice is the default in the other two predicates, constrained of suspend in the suspend module. If other suspension lists are used, the value of the element displayed in the output of the TTY VC may sometimes be out of date. Otherwise the predicate behaves exactly like start_tty_vc/2.\n\nResatisfiable\n   no\n\nSee Also\n   stop_tty_vc / 0, start_tty_vc / 1, start_tty_vc / 2"},"tty_vc:tty_vc_desc":{"prefix":"lib","body":"lib(${1:tty_vc})$2\n$0","description":"lib(tty_vc)\n\nThis module implements a simple TTY visualisation client. A visualisation client (VC) is an entity which monitors viewables. See lib(viewable) for more information on viewables. This module is mainly designed to help evaluate the visualisation architecture.\n\nThe three predicates start_tty_vc/1, start_tty_vc/2 and start_tty_vc/3, can be used to start the TTY VC with various options. The predicate stop_tty_vc/1 is used to stop the TTY VC.  \n\nWhile it is running, when new 2-d viewables are created, the TTY VC starts monitoring them. The TTY VC does not monitor viewables whose number of dimensions is not 2. It reacts to events relating to monitored viewables by outputting messages to stdout, including pretty-printing the viewable elements when updates occur. A forward (normally constraining) update to an element is signified by \"++\", and backtracking over this is signified by \"--\"."},"util:compiled/0":{"prefix":"compiled","body":"compiled","description":"compiled\n\n   List all currently compiled files and indicate if they have been modified since they were compiled.\n\nType\n   library(util)"},"util:add_path/1":{"prefix":"add_path","body":"add_path(${1:Directory})$2\n$0","description":"add_path(+Directory)\n\n   The directory will be added at the beginning of the library path.\n\nType\n   library(util)"},"util:add_suffix/1":{"prefix":"add_suffix","body":"add_suffix(${1:Suffix})$2\n$0","description":"add_suffix(+Suffix)\n\n   The Suffix string will be added at the beginning of the prolog_suffix list.\n\nType\n   library(util)"},"util:between/3":{"prefix":"between","body":"between(${1:From}, ${2:To}, ${3:I})$4\n$0","description":"between(+From, +To, ?I)\n\n   Generates integers between From and To\n\nType\n   library(util)\n\nDescription\nSucceeds if From and To are integers and I unifies with a\n\t  number between the two.  On backtracking it generates all\n\t  values for I starting from From onwards."},"util:edit/1":{"prefix":"edit","body":"edit(${1:PredSpec})$2\n$0","description":"edit(+PredSpec)\n\n   Invoke an editor on the source of the specified predicate (UNIX only)\n\nType\n   library(util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"util:file_info/1":{"prefix":"file_info","body":"file_info(${1:File})$2\n$0","description":"file_info(+File)\n\n   List all information about the specified File\n\nType\n   library(util)"},"util:interface/1":{"prefix":"interface","body":"interface(${1:Module})$2\n$0","description":"interface(+Module)\n\n   List the module interface of the specified Module\n\nType\n   library(util)"},"util:list_error/3":{"prefix":"list_error","body":"list_error(${1:String}, ${2:ErrNo}, ${3:ErrMsg})$4\n$0","description":"list_error(+String, -ErrNo, -ErrMsg)\n\n   Find the event number whose message contains the specified substring\n\nType\n   library(util)"},"util:streams/0":{"prefix":"streams","body":"streams","description":"streams\n\n   List information about the currently opened I/O streams\n\nType\n   library(util)"},"util:read_line/1":{"prefix":"read_line","body":"read_line(${1:String})$2\n$0","description":"read_line(-String)\n\n   Defined as read_string(input, end_of_line, _Length, String)\n\nType\n   library(util)"},"util:stream/1":{"prefix":"stream","body":"stream(${1:Stream})$2\n$0","description":"stream(+Stream)\n\n   List all information about the specified I/O stream\n\nType\n   library(util)"},"util:read_line/2":{"prefix":"read_line","body":"read_line(${1:Stream}, ${2:String})$3\n$0","description":"read_line(+Stream, -String)\n\n   Defined as read_string(Stream, end_of_line, _Length, String)\n\nType\n   library(util)"},"util:time/1":{"prefix":"time","body":"time(${1:Goal})$2\n$0","description":"time(Goal)\n\n   Call the goal Goal, measure its runtime (cputime) and print the result after success or failure\n\nType\n   library(util)\n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2)."},"var_name:get_var_name/2":{"prefix":"get_var_name","body":"get_var_name(${1:Var}, ${2:Name})$3\n$0","description":"get_var_name(?Var, -Name)\n\n   Retrieve the name given to a variable via set_var_name/2\n\nArguments\n   Var    Named variable\n   Name    Variable, will be bound to a string\n\nType\n   library(var_name)\n\nDescription\n\t\n\t  Used to retrieve the unique name that was given to a variable via\n\t  the set_var_name/2 predicate. This name is always of the form\n\t  BaseName#N, where BaseName is the base name that was specified in\n\t  set_var_name/2, and N is an integer.\n\t\n\t  These variable names are intended solely for purposes of debugging\n\t  and visualisation of a program execution. Any use of this feature\n\t  in the actual program logic or algorithm is strongly discouraged.\n\t\n\t\n\nFail Conditions\n   Var is not a variable or has not been named via set_var_name/2\n\nSee Also\n   set_var_name / 2"},"var_name:set_var_name/2":{"prefix":"set_var_name","body":"set_var_name(${1:Vars}, ${2:BaseName})$3\n$0","description":"set_var_name(?Vars, ++BaseName)\n\n   Give a unique name to each variable in Vars based on BaseName and a counter.\n\nArguments\n   Vars    Variable(s) to be named (Prolog term)\n   BaseName    BaseName of variable (atom or string)\n\nType\n   library(var_name)\n\nDescription\n    \n      Give unique and stable names to the variables in Vars. The names have\n      the format BaseName#N where N is the value of a counter, which is\n      incremented each time a variable is named by set_var_name/2. \n      Thus all such named variables are given a unique name. This name is \n      printed wherever the `source name' of a variable would otherwise\n      be printed.  Wherever the system would normally add an arbitrary\n      number to the printed name (e.g. the 'V' option in printf, or the\n      variables(full) option in write_term printing Name_Number), this\n      is not done with named variables.\n\n    \n      BaseName must begin with a capital letter, thus the name looks like a\n      normal ECLiPSe variable name, but they can be recognised as named\n      variables because a normal variable name cannot contain the '#'\n      symbol.  Each BaseName has its own counter, which by default starts\n      at 0 and is incremented each time a variable with that BaseName is\n      named. The default starting value can be changed by\n      set_var_name_counter/2 before any calls to set_var_name/2 with the\n      BaseName.  Note that the counter value is backtrackable.\n      \n    \n      Vars is usually a variable, or a list of variables that the user would\n      like to have the same base name BaseName. Vars is traversed in the usual\n      depth-first left-to-right manner and the variables found numbered \n      consecutively with the same base name BaseName. \n\n    \n      The main feature of this name is that the name is unique and stable.\n      The name is unique in that at any given time during an ECLiPSe\n      execution, the combination of the BaseName and counter can only refer\n      to one variable. The name is stable in that this unique name would\n      not change between runs of the program or running the program on\n      different platforms. Thus, this allows the user to for example\n      uniquely identify a variable between a normal and a debugging run of\n      the program.\n\n    \n      The predicate fails if any variables in Vars has already been given a\n      name. In particular, this means that all variables in Vars should\n      occur only once. When two named variable are unified, the older name\n      is retained, as in existing rules for variable names.\n\n   \n      The variable name is implemented as an attribute. Thus all named\n      variables become attributed variables, which is recognised by\n      ECLiPSe and treated specially when a named variable is printed. It is\n      possible to construct a named variable by directly creating the\n      attribute, either by reading in a previous named variable written\n      using writeq, or by the user explicitly constructing the\n      attribute. In such cases, the name is not recorded by the system and\n      may not be unique in that set_var_name/2 would not take it into\n      account in naming new variables.\n\nFail Conditions\n   Var contain variable(s) that have already been named by set_var_name/2.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- BaseName is not an atom or string.\n     6 --- BaseName does not begin with a capital letter.\n\nExamples\n   \n[eclipse 1]: lib(var_name).\nvar_name.ecl compiled traceable 1308 bytes in 0.02 seconds\n\nYes (0.03s cpu)\n[eclipse 2]: \n\n[eclipse 3]: set_var_name(X, 'Myname'), set_var_name(Y, \"Myname\").\n\nX = Myname#0\nY = Myname#1\nYes (0.00s cpu)\n[eclipse 4]: set_var_name(X, 'Count'), writeln(X).\nCount#0\n\nX = Count#0\nYes (0.00s cpu)\n\n% name is backtrackable. Original source name printed in second branch\n[eclipse 5]: (set_var_name(X, 'Name') ; true), writeln(X), fail.       \nName#0\nX\n\nNo (0.00s cpu)\n\n% naming more than one variable at a time...\n[eclipse 10]: length(L,5), set_var_name(L, 'Start').\n\nL = [Start#0, Start#1, Start#2, Start#3, Start#4]\nYes (0.00s cpu)\n\n% counter is backtrackable\n[eclipse 11]: (set_var_name([X,Y], 'Name') ; set_var_name(Y, 'Name')), writeln(X-Y), fail.\nName#0 - Name#1\nX - Name#0\n\nNo (0.00s cpu)\n\n% each base name has its own counter\n[eclipse 12]: set_var_name(X, 'First'), set_var_name(Y, 'Second'), writeln(X-Y).\nFirst#0 - Second#0\n\nX = First#0\nY = Second#0\nYes (0.00s cpu)\n\n% older name is retained on unification\n[eclipse 9]:  set_var_name(X, 'First'), set_var_name(Y, 'Second'), X = Y, writeln(Y).\nFirst#0\n\nX = First#0\nY = First#0\nYes (0.00s cpu)\n\n[eclipse 10]: lib(fd), X::[1..5], set_var_name(X, 'Domain'), writeln(X).\nfd_domain.pl compiled traceable 22556 bytes in 0.04 seconds\nfd_arith.pl compiled traceable 72296 bytes in 0.13 seconds\nfd_util.pl compiled traceable 2128 bytes in 0.02 seconds\nfd_chip.pl compiled traceable 4720 bytes in 0.05 seconds\nfd_elipsys.pl compiled traceable 11036 bytes in 0.02 seconds\nfd.pl      compiled traceable 17256 bytes in 0.29 seconds\nDomain#0{[1..5]}\n\nX = Domain#0{[1..5]}\nYes (0.29s cpu)\n\n% fails if variable already named\n[eclipse 7]: set_var_name(X, 'Name'), set_var_name(X, 'New').\n\nNo (0.00s cpu)\n\n% no number is attached to name when printed with 'V' option\n[eclipse 14]: set_var_name(X, 'Myname'), printf(\"%Vw%n%Vw%n\", [X,Y]).\nMyname#0\nY_177\n\nX = Myname#0\nY = Y\nYes (0.00s cpu)\n\n% writeq does not print the name\n[eclipse 15]: set_var_name(X, 'Myname'), writeq(X).\n_282{suspend : _285, var_name : vname(\"Myname\", 0)}\nX = Myname#0\nYes (0.00s cpu)\n\n[eclipse 12]: set_var_name(X, 123).\nout of range in set_var_name(X, 123)\nAbort\n[eclipse 13]: set_var_name(X, atomic).\nout of range in set_var_name(X, atomic)\nAbort\n[eclipse 14]: set_var_name(X, f(structure)).\ntype error in set_var_name(X, f(structure))\nAbort\n\nSee Also\n   get_var_name / 2, set_var_name_counter / 2"},"var_name:set_var_name_counter/2":{"prefix":"set_var_name_counter","body":"set_var_name_counter(${1:BaseName}, ${2:Start})$3\n$0","description":"set_var_name_counter(++BaseName, ++Start)\n\n   Set the initial value for the counter for variable name BaseName.\n\nArguments\n   BaseName    A valid base-name (atom or string)\n   Start    Start value for counter (integer)\n\nType\n   library(var_name)\n\nDescription\n    \n\tSet the initial counter value for a variable name BaseName that will\n    then be used in set_var_name/2, with Start as the initial value of \n    the counter. If BaseName already exists (i.e. variables have already\n    been named using BaseName), the predicate will fail.\n\n    \n    It is expected that the main use of this predicate will be to change\n    the default counter start value from 0 to 1. However, no restrictions \n    are placed on what the start value may be.\n\nFail Conditions\n   BaseName already exists.\n\nResatisfiable\n   no\n\nExceptions\n     5 --- BaseName is not an atom or string.\n     5 --- Start is not an integer.\n     6 --- BaseName does not begin with a capital letter.\n\nSee Also\n   set_var_name / 2"},"var_name:var_name_desc":{"prefix":"lib","body":"lib(${1:var_name})$2\n$0","description":"lib(var_name)\n\n    \n    The var_name library is used to allow variables to be given unique and\n    stable names. These names are printed whenever the variable is printed.\n    The main novel feature is that the name is unique at any time, and that\n    this name is stable in that it would not change between runs of the same\n    program.\n    \n    These variable names are intended solely for purposes of debugging\n    and visualisation of a program execution. Any use of this feature\n    in the actual program logic or algorithm is strongly discouraged."},"vc_support:vc_support_desc":{"prefix":"lib","body":"lib(${1:vc_support})$2\n$0","description":"lib(vc_support)\n\n    This library should be used if you intend to implement a \n    new visualisation client. It should not be used for anything \n    else. \n\n    Viewables are made up of viewable elements. A\n    particular viewable element can accessed using\n    viewable_element/3."},"vc_support:viewable_changeable_execute/4":{"prefix":"viewable_changeable_execute","body":"viewable_changeable_execute(${1:ViewableName}, ${2:ElementSpec}, ${3:Goal}, ${4:Solver})$5\n$0","description":"viewable_changeable_execute(++ViewableName, ++ElementSpec, ?Goal, ++Solver)\n\n   Works as viewable_element_execute/3, but replaces the element spec with the changeable value as returned from the given Solver instead.\n\nArguments\n   ViewableName    Atom: name of an existent viewable.\n   ElementSpec    Currently, this should be element(IndexList), where IndexList is a list of integers: the coordinates of the viewable element within the viewable.\n   Goal    Goal to be executed, mentioning ElementSpec.\n   Solver    Solver implementing the changeable interface (eg. an eplex instance)\n\nType\n   library(vc_support)\n\nSee Also\n   viewable_element_execute / 3"},"vc_support:viewable_element/3":{"prefix":"viewable_element","body":"viewable_element(${1:ViewableName}, ${2:IndexList}, ${3:ViewableElement})$4\n$0","description":"viewable_element(++ViewableName, ++IndexList, ?ViewableElement)\n\n   Index a viewable element inside a viewable.\n\nArguments\n   ViewableName    Atom: name of an existent viewable.\n   IndexList    List of integers: the coordinates of the viewable element within the viewable.\n   ViewableElement     Term to be unified with the viewable element.\n\nType\n   library(vc_support)\n\nDescription\nNote that this predicate throws an error if there are no current visualisation clients. Retrieves a single viewable element from a named viewable, given the element's array coordinates, and unifies it with ViewableElement. IndexList must be a ground list which has one positive integer for each dimension of the viewable.\n\nFail Conditions\n   ViewableName is not instantiated to the name of an existent viewable. ViewableElement will not unify with the specified element.\n\nResatisfiable\n   no\n\nExceptions\n     1 --- There are no current visualisation clients\n     4 --- ViewableName is not an atom or string\n     5 --- IndexList is not a ground list of integers\n     6 --- A co-ordinate in Index is out of range\n     8 --- IndexList has the wrong number of elements\n\nExamples\n    Success:\n\n       Failure:\n\n       Exceptions raised:\n\nSee Also\n   viewable : viewable_create / 3, viewable : viewable_size / 2, viewable_element_to_string / 2, viewable_element_execute / 3"},"vc_support:viewable_element_execute/3":{"prefix":"viewable_element_execute","body":"viewable_element_execute(${1:ViewableName}, ${2:ElementSpec}, ${3:Goal})$4\n$0","description":"viewable_element_execute(++ViewableName, ++ElementSpec, ?Goal)\n\n   Execute a goal for a viewable element inside a viewable.\n\nArguments\n   ViewableName    Atom: name of an existent viewable.\n   ElementSpec    Currently, this should be element(IndexList), where IndexList is a list of integers: the coordinates of the viewable element within the viewable.\n   Goal    Goal to be executed, mentioning ElementSpec.\n\nType\n   library(vc_support)\n\nDescription\nNote that this predicate throws an error if there are no current visualisation clients. The purpose of this predicate is to allow visualisation clients to call arbitrary goals which take viewable elements as input, without the visualisation clients having to retrieve the viewable elements themselves. Goal is the goal to be executed, but Goal mentions ElementSpec wherever it wishes to use the viewable element as input. The element specified by ElementSpec is retrieved from the viewable. Then all occurences of ElementSpec within Goal are replaced by the element, to give NewGoal. Finally, NewGoal is executed, and the predicate succeeds if NewGoal succeeds.  \n\nFail Conditions\n   Fails if NewGoal fails.\n\nResatisfiable\n   yes\n\nExceptions\n     1 --- There are no current visualisation clients\n     4 --- ViewableName is not an atom or string\n     5 --- IndexList is not a ground list of integers\n     6 --- A co-ordinate in Index is out of range\n     8 --- IndexList has the wrong number of elements\n\nExamples\n   \nAn example, assumng there are visualisation clients running, would be:\n\n[eclipse 2]: viewable_create(v1, [[X]]), \n    viewable_element_execute(v1, element([1, 1]), var(element([1, 1]))).\n\nX = X\nYes (0.00s cpu)\n[eclipse 3]: \n\nSee Also\n   viewable : viewable_create / 3, viewable : viewable_size / 2, viewable_element_to_string / 2, viewable_element / 3"},"vc_support:viewable_element_to_string/2":{"prefix":"viewable_element_to_string","body":"viewable_element_to_string(${1:ViewableElement}, ${2:String})$3\n$0","description":"viewable_element_to_string(?ViewableElement, -String)\n\n   Convert a variable or term to a nice string.\n\nArguments\n   ViewableElement     Any variable term, for example a viewable element you have just extracted from a viewable.\n   String    A textual representation of the term, produced by this predicate.\n\nType\n   library(vc_support)"},"viewable:viewable/1":{"prefix":"viewable","body":"viewable(${1:ViewableName})$2\n$0","description":"viewable(?ViewableName)\n\n   Test/enumerate names of all existent viewables.\n\nArguments\n   ViewableName    Atom or string: name of a viewable.\n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate fails with all arguments, and has no effect.\n\n       If ViewableName is instantiated, tests whether\n       ViewableName is the name of an existent viewable. If not,\n       ViewableName is successively instantiated to the names of all\n       existent viewables.\n\nFail Conditions\n   Fails if ViewableName is not / cannot be instantiated to the name of an existent viewable.\n\nResatisfiable\n   yes\n\nExceptions\n     4 --- ViewableName is not an atom, string or free variable\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n     Success:\n\n     viewable_create(my_viewable, [X,Y,Z], array([fixed], any)), \n       viewable(my_viewable).\n\n     Failure:\n\n     viewable(non_viewable)\n\n     Exception raised:\n\n     viewable(123).\n     [raises error 4].\n\nSee Also\n   viewable_create / 2, viewable_create / 3"},"viewable:viewable_create/2":{"prefix":"viewable_create","body":"viewable_create(${1:ViewableName}, ${2:Elements})$3\n$0","description":"viewable_create(?ViewableName, +Elements)\n\n   Create a viewable.\n\nArguments\n   ViewableName    A string or atom; the name of the new viewable.\n   Elements    A possibly nested list or array (as created for example by dim/2).\n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate succeeds with any arguments, and has no effect.\n\n\tThis predicate creates a new viewable by specifying its name and\n\telements. The predicate will try to guess the number of dimensions\n\tfor the new viewable from the level of nesting in\n\tElements. All dimensions are set to fixed so\n\tthey cannot be expanded later. The element type is set to\n\tany. For more control over the number and fixity of\n\tdimensions and the element type, use\n\tviewable_create/3.\n\n    In other ways the predicate behaves just like\n    viewable_create/3. See the documentation for that\n    predicate for more details. \n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not an atom, string or free variable.\n     1 --- ViewableName is the name of an existent viewable.\n     1 --- Elements is not a nested list or array.\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n       Success:\n\n       viewable_create(viewable1, [X, Y, Z]).\n\n       viewable_create(\"viewable1\", [](X, Y, Z)).\n\n       viewable_create(m, []).\n\n       viewable_create(var23, [[],[],[]]).\n\n       viewable_create(var315, []([]([](R, T, [E, X, Y]), \n    [](W, T, grok(D))), \n\t\t\t\t  []([](A, B, C),\n\t\t\t\t     [](R, E, W)))).\n\n       Exceptions raised:\n\n       viewable_create(2, [x,y,z]).\n       [gives error 4] \n\n       viewable_create(v1, [x,y,z]), \n       viewable_create(v1, [x,y,z]).\n       [gives error 1] \n\n       viewable_create(v1, _).\n       [gives error 1] \n\n\t\t\t\t    \n\nSee Also\n   viewable_create / 3, viewable_expand / 3"},"viewable:viewable_create/3":{"prefix":"viewable_create","body":"viewable_create(${1:ViewableName}, ${2:Elements}, ${3:Type})$4\n$0","description":"viewable_create(?ViewableName, +Elements, ++Type)\n\n   Create a viewable, specifying type.\n\nArguments\n   ViewableName    A string or atom; the name of the new viewable.\n   Elements    A list nested to at least a depth equal to the number of dimensions, an array with sufficient dimensions (as created for example by dim/2) or graph structure.\n   Type    A ground term which is a valid viewable type. \n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate succeeds with any arguments, and has no effect.\n\n\tThis predicate creates a new viewable by specifying its name,\n\telements and type.  At present the type must be of the form\n\tarray(FixityList, ElementType) or graph(fixed) where \n\tFixityList is a list with an atom fixed or\n\tflexible specifying the fixity for each\n\tdimension. The fixity denotes whether the dimension's size is\n\tfixed or may vary during the time when the viewable is\n\texistent. ElementType is a term which specifies the\n\ttype of the constituent viewable elements.  Currently there\n\tare two supported element types:  any\n\twhich includes any ECLiPSe term \n\tnumeric_bounds which includes any ground number,\n\tinteger fd variables, ic variables\n\tand range variables (including eplex\n\tand ria variables).  \n\tchangeable(Module,Type) which indicates that the\n\tvalue should be accessed through the changeable\n\tinterface of the given Module\n\t(eg. changeable(eplex_instance,any) indicates that the value\n\tis ths solution assigned to the variable by the given\n\teplex_instance).  The Type parameter can be any\n\tof the other ElementTypes in this list. \n\t \n\n\tVisualisation clients, if there are any, are notified of the new\n\tviewable when it is created. On backtracking over a call to\n\tviewable_create/3, the viewable is destroyed, and\n\tvisualisation clients are also notified of this. \n\n\tViewableName is a global handle which can be used to\n\taccess the viewable while it is existent. If ViewableName\n\tis a variable, it is instantiated to an atom. The atom is unique in\n\tthe sense that no two existent viewables will share the same name\n\tat any point during the lifetime of the ECLiPSe engine.\n\n    For array types, the number of dimensions is specified by the\n    length of FixityList in Type. Elements\n    is a nested list or array. The depth of nesting is usually at\n    least the number of dimensions specified in FixityList.\n    However, dimensions with an initial size of 0 are also\n    allowed, and these can implicitly contain an arbitrary number\n    of further dimensions, also assumed to be of initial size\n    0. So for example an Elements argument of\n    [[],[],[]] or []([],[],[]) can be\n    used with a FixityList of [fixed,\n    flexible], giving an initial size of 3 x 0, or used\n    with a FixityList of [fixed, flexible,\n    flexible, flexible], giving an initial size of 3 x 0 x\n    0 x 0. Be sure to make any initially empty dimensions\n    flexible!  Elements must also be regular: each inner\n    list / array at the same level of nesting must be the same\n    length, down to the level equal to the number of dimensions.\n\n    viewable_create/3 sets location names (e.g. row/column\n    names) to \"1\", \"2\", etc. For more control over location names use \n    viewable_create/4.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not an atom, string or free variable.\n     1 --- ViewableName is the name of an existent viewable.\n     1 --- Elements is not a regular nested list or array with enough dimensions.\n     1 --- Type is not a ground valid type.\n     5 --- One of the viewable elements violates the element type.\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered] \n\n       Success:\n\n       viewable_create(viewable1, [X, Y, Z], array([fixed], any)).\n\n       lib(fd), fd:([X, Y, Z]::1..10), \n       viewable_create(viewable1, [X, Y, Z], array([fixed], numeric_bounds)).\n\n       viewable_create(viewable1, [3.2, 5.00__5.01, 7], \n    array([fixed], numeric_bounds)).\n\n       viewable_create(\"viewable1\", [](X, Y, Z), array([flexible], any)).\n\n       viewable_create(m, [], array([flexible], any)).\n\n       viewable_create(var23, [[],[],[]], array([fixed, flexible], any)).\n\n       viewable_create(var315, []([]([](R, T, [E, X, Y]), \n    [](W, T, grok(D))), \n\t\t\t\t  []([](A, B, C),\n\t\t\t\t     [](R, E, W))), \n\t\t       array([fixed, flexible, flexible], any)).\n\n       viewable_create(m,[[],[],[]],array([fixed, flexible, flexible],any)).\n       [Note: the initial size of this viewable would be 3 x 0 x 0]\n\n       lib(graph_algorithms),\n       make_graph(3,[e(1,2,e1), e(2,3,e2), e(1,3,e3)], Graph),\n       viewable_create(m, Graph, graph(fixed)).\n       [Note: the node will be labelled with the numbers '1', '2' and '3',\n       the edges labelled 'e1', 'e2' and 'e3']\n       \n       lib(graph_algorithms),\n       make_graph_symbolic([](n1,n2,n3),[edge(n1,n2,e1), edge(n2,n3,e2), edge(n1,n3,e3)], Graph),\n       viewable_create(m, Graph, graph(fixed)).\n       [Note: the node will be labelled with the strings 'n1', 'n2' and 'n3',\n       the edges labelled 'e1', 'e2' and 'e3']\n\n       lib(eplex),\n       eplex_instance(my_instance),\n       my_instance: eplex_solver_setup(min(X)),\n       viewable_create(eplex,[X,Y],array([fixed],changeable(my_instance,numeric_bounds))),\n       my_instance: (X+Y >= 3),\n       my_instance: (X-2*Y =:= 0),\n       my_instance: eplex_solve(Cost).       \n       [Note: this creates a single viewable using the standalone eplex\n    library and shows how to visualise the bounds stored in the external\n    solver]\n\n       Exceptions raised:\n\n       viewable_create(2, [x,y,z], array([fixed], any)).\n       [gives error 4] \n\n       viewable_create(v1, [x,y,z], array([fixed], any)), \n       viewable_create(v1, [x,y,z], array([fixed], any)).\n       [gives error 1] \n\n       viewable_create(v1, _, array([fixed], any)).\n       [gives error 1] \n\n       viewable_create(v1, [x,y,g], array([fixed, fixed], any)).\n       [gives error 1] \n\n       viewable_create(v1, [x,y,x], array([], any)).\n       [gives error 1] \n\n       viewable_create(v1, [x,y,x], slorg([fixed], any)).\n       [gives error 1] \n\n       viewable_create(v1, [x,y,x], nurg).\n       [gives error 1] \n\n       viewable_create(v1, [x,y,x], numeric_bounds).\n       [gives error 5] \n\t\t\t\t    \n\nSee Also\n   viewable_create / 2, viewable_create / 4, viewable_expand / 3, graph_algorithms : make_graph / 3"},"viewable:viewable_create/4":{"prefix":"viewable_create","body":"viewable_create(${1:ViewableName}, ${2:Elements}, ${3:Type}, ${4:LocNamesList})$5\n$0","description":"viewable_create(?ViewableName, +Elements, ++Type, ++LocNamesList)\n\n   Create a viewable, specifying both type and location names.\n\nArguments\n   ViewableName    A string or atom; the name of the new viewable.\n   Elements    A list nested to at least a depth equal to the number of dimensions, or an array with sufficient dimensions (as created for example by dim/2) or a graph structure.\n   Type    A ground term which is a valid viewable type. \n   LocNamesList    A list of lists of strings (location names) or a list of semantic markup terms from graph structures.\n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate succeeds with any arguments, and has no effect.\n\n    This predicate works exactly the same as\n    viewable_create/3 except that you have the added\n    ability to set location names (e.g. row/column names) for\n    arrays and to indicate which elements of the edge info\n    structure should be attached to edge labels for graphs.\n\n    For array type viewables the LocNamesList argument\n    should be a list as long as the number of dimensions in the\n    viewable. The ith element LocNames of\n    LocNamesList should be a list whose length is equal\n    to the size of the ith dimension of the new viewable. The jth\n    element of LocNames should be a ground string and\n    this will become the name of the jth location of the ith\n    dimension.  \n\n    For graph type viewables the LocNamesList argument\n    should be a list of the following form.\n\n[\n node_property([0->[name(NodeInfoName), label]]),\n edge_property([Index->[name(EdgeInfoName), label]])\n]\n\n    Where NodeInfoName is a meaningful name for the\n    information to be displayed at the nodes in the graph.  eg. If\n    the graph represented a computer network, the nodes may show\n    individual machine names. In such a case, \"machine\n    name\" would be a likely candidate for the NodeInfoName\n    argument.  Similarly EdgeInfoName refers to the\n    information associated with edge labels.\n\n    The Index argument specifies which part of the\n    edge info field should be shown on edges. 0:The whole edge\n    info structure.  N:The Nth argument of the edge info\n    structure.  [...,I,J,K]:The Kth argument of the Jth argument\n    of the Ith argument... of the edge info structure. See below\n    for examples.\n\n    For a more detailed description of creating viewables, refer to the\n    documentation for viewable_create/3.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not an atom, string or free variable.\n     1 --- ViewableName is the name of an existent viewable.\n     1 --- Elements is not a regular nested list or array with enough dimensions.\n     1 --- Type is not a ground valid type.\n     5 --- One of the viewable elements violates the element type.\n     5 --- LocNamesList is not a correctly-sized list of correctly-sized lists of strings.\n\nExamples\n   \n\n    To create a 2 x 3 viewable, you could do:\n\n    viewable_create(v1, [[A,B,C], [D,E,F]], \n    array([fixed, fixed], any), \n    [[\"foo\", \"bar\"], [\"tom\", \"dick\", \"harry\"]]).\n\n    This would have two rows (named \"foo\" and \"bar\") each\n\t    with three columns (named \"tom\", \"dick\" and\n\t    \"harry\").\n\n    To create a graph viewable where node names are attached\n    to node labels and edge info fields are attached to edge\n    lables (ie info(1,foo(A)), info(2,foo(B)) and\n    info(3,foo(C)) as per viewable_create/3).\n\n    lib(graph_algorithms),\n    make_graph_symbolic([](n1,n2,n3),\n    [edge(n1,n2,info(1,foo(A)),\n    edge(n2,n3,info(2,foo(B)),\n    edge(n1,n3,info(3,foo(C))], Graph),\n    viewable_create(v2, Graph, graph(fixed),\n    [node_property([0->[name('node names'), label]]),\n    edge_property([0->[name('edge info'), label]])\n    ]).\n    \n\n    To create a graph where the edges are labelled with the\n    second argument of the edge info structure. (ie with the\n    structures foo(A), foo(B) and foo(C))\n\n    lib(graph_algorithms),\n    make_graph_symbolic([](n1,n2,n3),\n    [edge(n1,n2,info(1,foo(A)),\n    edge(n2,n3,info(2,foo(B)),\n    edge(n1,n3,info(3,foo(C))], Graph),\n    viewable_create(v2, Graph, graph(fixed),\n    [node_property([0->[name('node names'), label]]),\n    edge_property([2->[name('edge info'), label]])\n    ]).\n\n    \n    To create a graph where the edges are labelled with the\n    first argument of the nested structure at the second\n    argument of the edge info structure. (ie with the\n    variables A, B and C)\n\n    lib(graph_algorithms),\n    make_graph_symbolic([](n1,n2,n3),\n    [edge(n1,n2,info(1,foo(A)),\n    edge(n2,n3,info(2,foo(B)),\n    edge(n1,n3,info(3,foo(C))], Graph),\n    viewable_create(v2, Graph, graph(fixed),\n    [node_property([0->[name('node names'), label]]),\n    edge_property([[2,1]->[name('edge info'), label]])\n    ]).\n    \n\nSee Also\n   viewable_create / 2, viewable_create / 3, viewable_expand / 4, graph_algorithms : make_graph / 3"},"viewable:viewable_desc":{"prefix":"lib","body":"lib(${1:viewable})$2\n$0","description":"lib(viewable)\n\n Module for the management of\n    viewables. These are logical, multidimensional\n    arrays and graph structures whose elements can be accessed\n    globally for visualisation purposes. The creation,\n    destruction and modification of viewables and their\n    contents can be monitored by visualisation clients. \n\n    The library lib(graph_algorithms) contains\n    predicates to create and manipulate graph structures.\n\n    Viewables are created using viewable_create/2/3/4\n    and last until this call is\n    backtracked over. During its lifetime, a viewable is said to be\n    existent. This can be tested with\n    viewable/1, which can also be used to enumerate all\n    existent viewables. \n\n    One or more of the dimensions of a viewable can\n    optionally be flexible in size while the viewable is\n    existent. This allows new elements to be added to the\n    viewable, using viewable_expand/3/4. The\n    fixity of a dimension denotes whether it is fixed\n    or flexible. In the case of graph typed viewables, the\n    fixity refers to the ability to add new nodes and/or edges\n    to the graph.  Currently only fixed graphs are\n    supported.\n\n    A viewable is given a type when it is created. For\n    array types, this specifies the number of dimensions, the\n    fixity of each dimension and the type of viewable elements\n    which the viewable can contain. For graph types, this\n    simply specifies whether the graph structure (number of\n    nodes, edge direction etc) may be modified during the\n    viewables lifetime. An existent viewable's type can be\n    retrieved using viewable_type/2, and its\n    current sizes of the dimensions can be retrieved using\n    viewable_size/2. \n\n    Optimised behaviour without visualisation Visualisation\n    clients can only monitor viewables whose creation occurs\n    after they register. When there are no registered\n    visualisation clients, for efficiency purposes no data on\n    viewables is stored and so the predicates in this module behave\n    slightly differently from normal:\n\n    \n\n    viewable_create/2/3/4 and\n    viewable_expand/3/4 succeed with any arguments. It is\n    therefore reasonable to leave these predicates in your code even\n    when not visualising.\n\n    viewable/1, viewable_size/2 and\n    viewable_type/2 fail whatever the arguments. If\n    these predicates are used (normally they should not be\n    necessary) the possibility of failure should be taken into\n    account."},"viewable:viewable_expand/3":{"prefix":"viewable_expand","body":"viewable_expand(${1:ViewableName}, ${2:DimensionNumber}, ${3:ExtraElements})$4\n$0","description":"viewable_expand(++ViewableName, ++DimensionNumber, +ExtraElements)\n\n   Expand a dimension of a viewable by adding new elements.\n\nArguments\n   ViewableName    A string or atom; the name of an existent viewable\n   DimensionNumber     An integer: the number of the dimension to be enlarged.\n   ExtraElements       A nested list or an array of the right size/dimensions, containing the new viewable elements.\n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate succeeds with any arguments, and has no effect.\n\n      A viewable which has a flexible dimension (see\n      viewable_create/3) may be expanded along that dimension\n      by adding new elements. The dimension must have been declared\n      flexible when the viewable was first created. The\n      ExtraElements argument is of the same format as the\n      Elements argument of viewable_create/3.\n\n      The number and size of the dimensions of ExtraElements\n      depends on the number and size of dimensions of the viewable being\n      expanded. ExtraElements should have one less dimension than\n      the viewable -- dimension DimensionNumber should be\n      missing. The remaining dimensions should have the same sizes as the\n      corresponding dimensions in the viewable.\n\n      For example, a viewable of size 3 x 0 x 0 with all dimensions\n      flexible, can be expanded along dimenson 3 using an\n      ExtraElements argument of []([], [], []) which has size 3 x\n      0. The viewable would then have size 3 x 0 x 1. It could then be\n      expanded along dimension 1 using [] as\n      ExtraElements since [] can implicitly have the\n      size 0 x 1. The viewable would then have the size 4 x 0 x 1. Then\n      dimension 2 could be expanded using [[W],[X],[Y],[Z]]\n      for ExtraElements as this has size 4 x 1. The final size of\n      the viewable would then be 4 x 1 x 1.\n\n      The extra viewable elements must each also conform to the element\n      type specified when the viewable was created.\n\n       Note that when the viewable has one dimension, the\n      ExtraElements argument will simply become the new element\n      itself.\n\n      viewable_expand/3 sets the name of the new location \n      (e.g. the column or row name) to its number as a string. For example, \n      adding a third row using viewable_expand/3 will result\n      in the row being named \"3\". For more control over the name of the new\n      location use viewable_expand/4.\n\nFail Conditions\n   Fails if ViewableName is not the name of an existent viewable, or if the requested dimension of the viewable is not flexible.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not a string or atom\n     5 --- DimensionNumber is not a ground integer\n     6 --- DimensionNumber is not positive, or exceeds the viewable's number of dimensions\n     1 --- ExtraElements is not a regular nested list or array of the correct size/dimensions\n     5 --- ExtraElements contains elements which do not conform to the element type of the viewable\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n       Success:\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n       \t    array([flexible, fixed], any)), \n       viewable_expand(v1, 1, [R, S, T]).\n\n       lib(fd), fd:([X, Y, Z, R] :: 1..10), \n       viewable_create(v1, [X, Y, Z], array([flexible], numeric_bounds)),\n       viewable_expand(v1, 1, R).\n       \n       viewable_create(v1, []([](X, Y, Z), [](A, B, C)), \n       \t    array([fixed, flexible], any)), \n       viewable_expand(v1, 2, [R, S]).\n\n       viewable_create(v1, [[], [], []], \n\t\t       array([flexible, flexible, flexible], any)),\n       viewable_expand(v1, 3, []([], [], [])), \n       viewable_expand(v1, 1, []), \n       viewable_expand(v1, 2, [[W], [X], [Y], [Z]]),  \n       viewable_size(v1, Size).\n       [gives Size = [4,1,1]]\n\n       viewable_create(v1, [], array([flexible], any)), \n       viewable_expand(v1, 1, F), \n       viewable_expand(v1, 1, G),\n       viewable_size(v1, Size).\n       [gives Size = [2]]\n       \n       \n\n       Failure:\n\n       viewable_expand(no, 2, [R, S]).\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n\t    array([fixed, flexible], any)), \n       viewable_expand(v1, 1, [R, S, T]).\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n\t    array([flexible, fixed], any)), \n       viewable_expand(v1, 2, [R, S]).\n\n       Exceptions raised:\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n\t    array([flexible, fixed], any)), \n       viewable_expand(_, 1, [R, S, T]).\n       [gives error 4]\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n\t    array([flexible, fixed], any)), \n       viewable_expand(v1, _, [R, S, T]).\n       [gives error 5]\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n    array([flexible, fixed], any)), \n       viewable_expand(v1, 3, [R, S, T]).\n       [gives error 6]\n\n       viewable_create(v1, []([](X, Y, Z), [](A, B, C)), \n\t    array([fixed, flexible], any)), \n       viewable_expand(v1, 2, _).\n       [gives error 1]\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n\t    array([flexible, fixed], any)), \n       viewable_expand(v1, 1, [R, S, T, Q]).\n       [gives error 1]\n\n       lib(fd), fd:([X, Y, Z] :: 1..10), \n       viewable_create(v1, [X, Y, Z], array([flexible], numeric_bounds)),\n       viewable_expand(v1, 1, an_atom)\n       [gives error 5]\n\nSee Also\n   viewable_expand / 4, viewable_create / 3, viewable_size / 2, viewable_type / 2"},"viewable:viewable_expand/4":{"prefix":"viewable_expand","body":"viewable_expand(${1:ViewableName}, ${2:DimensionNumber}, ${3:ExtraElements}, ${4:LocName})$5\n$0","description":"viewable_expand(++ViewableName, ++DimensionNumber, +ExtraElements, ++LocName)\n\n   Expand a dimension of a viewable by adding new elements, specifying the name of the new location.\n\nArguments\n   ViewableName    A string or atom; the name of an existent viewable\n   DimensionNumber     An integer: the number of the dimension to be enlarged.\n   ExtraElements       A nested list or an array of the right size/dimensions, containing the new viewable elements.\n   LocName    A string: the name of the new location.\n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate succeeds with any arguments, and has no effect.\n\n    This predicate behaves exactly the same as viewable_expand/3 except that you have the added ability to name the new location of the expanded dimension. LocName is a string which becomes the name for the new location. \n\n    For more details on expanding viewables, see the documentation for viewable_expand/3. \n\nFail Conditions\n   Fails if ViewableName is not the name of an existent viewable, or if the requested dimension of the viewable is not flexible.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not a string or atom\n     5 --- DimensionNumber is not a ground integer\n     6 --- DimensionNumber is not positive, or exceeds the viewable's number of dimensions\n     1 --- ExtraElements is not a regular nested list or array of the correct size/dimensions\n     5 --- ExtraElements contains elements which do not conform to the element type of the viewable\n     5 --- LocName is not a string\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n       \t    array([flexible, fixed], any)), \n       viewable_expand(v1, 1, [R, S, T], \"barg\").\n\n       This will add to the 2 x 3 viewable a third row, named \"barg\".\n\n       viewable_create(v1, [[X, Y, Z], [A, B, C]], \n       \t    array([fixed, flexible], any)), \n       viewable_expand(v1, 2, [Q, P], \"zatch\").\n\n       This will add to the 2 x 3 viewable a fourth column, named \"zatch\".\n\nSee Also\n   viewable_expand / 3, viewable_create / 4, viewable_size / 2, viewable_type / 2"},"viewable:viewable_size/2":{"prefix":"viewable_size","body":"viewable_size(${1:ViewableName}, ${2:SizeList})$3\n$0","description":"viewable_size(++ViewableName, ?SizeList)\n\n   Query the sizes of the dimensions of an existent viewable.\n\nArguments\n   ViewableName    A string or atom: the name of an existent viewable\n   SizeList    A list of integers: each is the current size of a dimension\n\nType\n   library(viewable)\n\nDescription\n NOTE:When there are no registered visualisation clients, this\n    predicate fails with all arguments, and has no effect.\n\n    If ViewableName is the name of an existent viewable,\n\t    SizeList is unified with a list of integers, each\n\t    integer being the number of elements in one of the viewable's\n\t    dimensions.\n\nFail Conditions\n   Fails if ViewableName is not\n\t    instantiated to the name of an existent viewable, or if\n\t    SizeList fails to unify with the list of dimension sizes.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not a string or an atom\n     5 --- SizeList is not a free variable or list or contains one or more elements which is not a free variable or an integer\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n\tSuccess:\n\n\tviewable_create(v1, [], \n\t\t\tarray([flexible, flexible, flexible], any)), \n\tviewable_size(v1, X).\n    [gives X = [0,0,0]]\n\n\tviewable_create(v1, []([](R,S), [](Q,W)), \n\t\t\tarray([fixed, fixed], any)), \n\tviewable_size(v1, X).\n    [gives X = [2,2]]\n\n\tFailure:\n\n\tviewable_size(no, X).\n\n\tviewable_create(v1, []([](R,S), [](Q,W)), \n\t\t\tarray([fixed, fixed], any)), \n\tviewable_size(v1, [1,2]).\n\n    Exceptions raised:\n\n\tviewable_size(_, X).\n    [gives error 4]\n\n\tviewable_size(123, X).\n    [gives error 4]\n\n\tviewable_create(v1, [X, Y, Z]), \n\tviewable_size(v1, q).\n    [gives error 5]\n\n\tviewable_create(v1, [X, Y, Z]), \n\tviewable_size(v1, [a]).\n    [gives error 5]\n\nSee Also\n   viewable_create / 3, viewable_expand / 3, viewable_type / 2"},"viewable:viewable_type/2":{"prefix":"viewable_type","body":"viewable_type(${1:ViewableName}, ${2:Type})$3\n$0","description":"viewable_type(++ViewableName, ?Type)\n\n   Query the type of an existent viewable.\n\nArguments\n   ViewableName    A string or atom: the name of an existent viewable\n   Type    The type of the viewable. \n\nType\n   library(viewable)\n\nDescription\n\n    NOTE:When there are no registered visualisation clients,\n    this predicate fails with all arguments, and has no effect.\n\n    If ViewableName is the name of an existent viewable,\n    Type is unified with its type. See\n    viewable_create/3 for a discussion of valid viewable\n    types.\n\nFail Conditions\n   Fails if ViewableName is not instantiated to the name of an existent viewable, or if Type fails to unify with the viewable's type.\n\nResatisfiable\n   no\n\nExceptions\n     4 --- ViewableName is not a string or an atom\n\nExamples\n   \n\n[Assuming that at least one visualisation client is registered]\n\n\tSuccess:\n\n\tviewable_create(v1, []([](R,S), [](Q,W)), \n\t\t\tarray([fixed, fixed], any)), \n\tviewable_type(v1, X).\n\n    [gives X = array([fixed, fixed], any)]\n\n\tFailure:\n\n\tviewable_create(v1, []([](R,S), [](Q,W)), \n\t\tarray([fixed, fixed], any)), \n\tviewable_type(v1, q).\n\n\tExceptions raised:\n\n\tviewable_create(v1, []([](R,S), [](Q,W)), \n\t\tarray([fixed, fixed], any)), \n\tviewable_type(123, _).\n    [gives error 4]\n\nSee Also\n   viewable_create / 3, viewable_size / 2, viewable_expand / 3"},"xref:call_graph/3":{"prefix":"call_graph","body":"call_graph(${1:File}, ${2:Graph}, ${3:Options})$4\n$0","description":"call_graph(+File, -Graph, +Options)\n\n   Compute a call graph for a source module file\n\nArguments\n   File    Name of the source file (atom or string)\n   Graph    Variable, returns a graph structure\n   Options    A list of Option:Value structures\n\nType\n   library(xref)\n\nDescription\n\n    Computes a call graph for the given source file. The graph is in the\n    format defined by lib(graph_algorithms).  The relevant options are:\n\n    builtins ('off' or 'on')\n\tselects whether to include built-in predicates or not. Default: off.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   xref / 2, library(graph_algorithms)"},"xref:xref/2":{"prefix":"xref","body":"xref(${1:File}, ${2:Options})$3\n$0","description":"xref(+File, +Options)\n\n   Display a call graph for a source module file\n\nArguments\n   File    Name of the source file (atom or string)\n   Options    A list of Option:Value structures\n\nType\n   library(xref)\n\nDescription\n\n    Computes a call graph for the given source file and displays it.\n    The possible options are:\n\n    builtins ('off' or 'on')\n\tselects whether to show built-in predicates or not. Default: off.\n    output ('text', 'graphviz', graphviz(Options), 'daVinci' or file(File))\n\tselects how to show the results. 'text' is a for a simple textual\n\tlisting on the output stream, file(File) writes text output into\n\tthe specified file, 'daVinci' uses the daVinci graph drawing library,\n\t'graphviz' uses the graphviz graph drawing library. Default: text.\n    relation ('calls' or 'called_by')\n\tselects whether to print the 'calls' relation or it inverse,\n\tthe 'called_by' relation. Default: calls.\n\n    \n\nModules\n   This predicate is sensitive to its module context (tool predicate, see @/2).\n\nSee Also\n   call_graph / 3"},"xref:xref_desc":{"prefix":"lib","body":"lib(${1:xref})$2\n$0","description":"lib(xref)\n\n    This library analyses an ECLiPSe source module or file and build\n    a call graph. The graph can either be returned in the format of\n    lib(graph_algorithms), or output in different ways."},"all_min_cuts:all_min_cuts_list/5":{"prefix":"all_min_cuts_list","body":"all_min_cuts_list(${1:Graph}, ${2:CapacityArg}, ${3:SourceSinkList}, ${4:Limit}, ${5:MinCutEdgesList})$6\n$0","description":"all_min_cuts_list(+Graph, +CapacityArg, +SourceSinkList, +Limit, -MinCutEdgesList)\n\n   Curet et al, algorithm for generating all minimum-cost cuts, to be used for multiple source-sink pairs on the same graph since unnecessary repeat of initializations can be avoided\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceSinkList      list source and sink nodes (integers), form SourceNode-SinkNode\n   Limit    max number of min cuts to output (integer), if 0 then output all possible mincuts\n   MinCutEdgesList     list where for each Source-Sink pair there is list of all minimum cost cutsets, each cutset is represented by a list of edges that separate the source-side and the sink-side of the cut)\n\nType\n   library(all_min_cuts)\n\nDescription\nThis variant of the cutset generator should be used when one is interested in generating cutsets for multiple source-sink pairs in the same graph, as it avoids multiple initialisation of the data structures leading to an overall improved performance.\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts / 8, all_min_cuts / 9, all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"all_min_cuts:all_min_cuts_desc":{"prefix":"lib","body":"lib(${1:all_min_cuts})$2\n$0","description":"lib(all_min_cuts)\n\n   Algorithm for generating all minimum-cost cuts between source and sink. From Norman D. Curet, Jason DeVinney, Matthew E. Gaston. An efficient network flow code for finding all minimum cost s-t cutsets. Computers & Operations Research 29 (2002) 205-219."},"all_min_cuts:all_min_cuts/8":{"prefix":"all_min_cuts","body":"all_min_cuts(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue}, ${6:MaxFlowEdges}, ${7:MinCuts}, ${8:MinCutEdges})$9\n$0","description":"all_min_cuts(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue, -MaxFlowEdges, -MinCuts, -MinCutEdges)\n\n   Curet et al, algorithm for generating all minimum-cost cuts\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n   MaxFlowEdges    list denoting edges with non-zero flow (form: Flow-Edge)\n   MinCuts    list of all minimum cost cutsets (each cutset is represented by a list of nodes belonging to the source-side of the cut)\n   MinCutEdges    list of all minimum cost cutsets (each cutset is represented by a list of edges that separate the source-side and the sink-side of the cut)\n\nType\n   library(all_min_cuts)\n\nDescription\nThis predicate provides all minimal cost cutsets for a max flow problem in a graph between a source and a sink node. It returns the maximal flow value, edges with non-zero flow in the optimal solution, and a list of all minimum cost cutsets corresponding to that flow value. The results are given both as node lists (nodes on the source side of the cut), and as edge lists (edges belonging to the cut), to simplify use of the predicate in situations where either of the output formats is preferred.\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts / 8, all_min_cuts / 9, all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"all_min_cuts:all_min_cuts/9":{"prefix":"all_min_cuts","body":"all_min_cuts(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Limit}, ${6:MaxFlowValue}, ${7:MaxFlowEdges}, ${8:MinCuts}, ${9:MinCutEdges})$10\n$0","description":"all_min_cuts(+Graph, +CapacityArg, +SourceNode, +SinkNode, +Limit, -MaxFlowValue, -MaxFlowEdges, -MinCuts, -MinCutEdges)\n\n   Curet et al, algorithm for generating all minimum-cost cuts, with limit for max number of allowed cuts\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Limit    max number of min cuts to output (integer), if 0 then output all possible mincuts\n   MaxFlowValue    value of the maximum flow\n   MaxFlowEdges    list denoting edges with non-zero flow (form: Flow-Edge)\n   MinCuts    list of max Limit minimum cost cutsets (each cutset is represented by a list of nodes belonging to the source-side of the cut)\n   MinCutEdges    list of all minimum cost cutsets (each cutset is represented by a list of edges that separate the source-side and the sink-side of the cut)\n\nType\n   library(all_min_cuts)\n\nDescription\nThis predicate uses the saem interface, and provides the same information as all_min_cuts/8, but adds an argument to limit the number of cuts that are generated. This can be helpful in graphs with a structure that creates very large numbers of minimal cost cutsets, the Limit argument is used to restrict the number of solutions returned.\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts / 8, all_min_cuts / 9, all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"all_min_cuts_eplex:all_min_cuts_eplex/7":{"prefix":"all_min_cuts_eplex","body":"all_min_cuts_eplex(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue}, ${6:MinCuts}, ${7:MinCutEdges})$8\n$0","description":"all_min_cuts_eplex(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue, -MinCuts, -MinCutEdges)\n\n   MIP algorithm for generating all minimum-cost cuts\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow flow (form: Flow-Edge)\n   MinCuts    list of all minimum cost cutsets (each cutset is represented by a list of nodes belonging to the source-side of the cut)\n   MinCutEdges    list of all minimum cost cutsets (each cutset is represented by a list of edges that separate the source-side and the sink-side of the cut)\n\nType\n   library(all_min_cuts_eplex)\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex / 7, all_min_cuts_eplex / 8"},"all_min_cuts_eplex:all_min_cuts_eplex/8":{"prefix":"all_min_cuts_eplex","body":"all_min_cuts_eplex(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:Limit}, ${6:MaxFlowValue}, ${7:MinCuts}, ${8:MinCutEdges})$9\n$0","description":"all_min_cuts_eplex(+Graph, +CapacityArg, +SourceNode, +SinkNode, +Limit, -MaxFlowValue, -MinCuts, -MinCutEdges)\n\n   MIP algorithm for generating all minimum-cost cuts, with a limit for max allowed number of generated cuts\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   Limit    max number of min cuts to output (integer), if Limit = 0 then output all possible mincuts\n   MaxFlowValue    value of the maximum flow flow (form: Flow-Edge)\n   MinCuts    list of all minimum cost cutsets (each cutset is represented by a list of nodes belonging to the source-side of the cut)\n   MinCutEdges    list of all minimum cost cutsets (each cutset is represented by a list of edges that separate the source-side and the sink-side of the cut)\n\nType\n   library(all_min_cuts_eplex)\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex : max_flow_eplex / 5, max_flow_eplex : max_flow_eplex_dual / 5, max_flow_eplex : max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex / 7, all_min_cuts_eplex / 8"},"all_min_cuts_eplex:all_min_cuts_eplex_desc":{"prefix":"lib","body":"lib(${1:all_min_cuts_eplex})$2\n$0","description":"lib(all_min_cuts_eplex)\n\n   Mixed integer programming solution for generating all minimum-cost cuts between given source and sink nodes. This formulation was used as a comparison algorithm in the experimental section of [Norman D. Curet, Jason DeVinney, Matthew E. Gaston. An efficient network flow code for finding all minimum cost s-t cutsets. Computers & Operations Research 29 (2002) 205-219]. The idea is to iteratively solve dual max flow problem, and at each iteration, post an additional contraint to avoid repeating the same cuts."},"cardinal:all_disjoint/1":{"prefix":"all_disjoint","body":"all_disjoint(${1:SetVars})$2\n$0","description":"all_disjoint(+SetVars)\n\n   All sets disjointness global constraint\n\nArguments\n   SetVars    A list of set variables.\n\nType\n   library(cardinal)\n\nDescription\nConstrain all pairs of sets in SetVars to be disjoint. I.e. No two sets\n\t\tcan have a common element (empty pairwise intersection).\n\t\tThis version of all_disjoint/1 is a weak global constraint, but stronger\n\t\tthan the simple posting of all pairwise disjoint/2 constraints, since\n\t\tit posts the additional constraint that the sum of the cardinalities of\n\t\tSetVars must be less than or equal to the cardinality of the union of all\n\t\tthe initial LUBs.\n\nFail Conditions\n   Fails if SetVars can not be all disjoint.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- all_disjoint([[7],[8],[i,k]]).\nyes\n\n?- all_disjoint([[7,8],[i],[8]]).\nno\n\n?- sets([X,Y,Z], [],[1,2,7,8,9], [cardinality:2]), all_disjoint([X,Y,Z]).\nno\n\n?- sets([X,Y,Z], [],[1,2,7,8,9], [cardinality:2]), all_disjoint([X,Y,Z]), 2 `@ X, lub(Y,LubY), lub(Z,LubZ)\nLubY = [1,7,8,9], LubZ = [1,7,8,9]\n\nSee Also\n   `$ / 2, `<> / 2, complement / 2, complement / 3, `/= / 2, all_union / 2"},"cardinal:all_union/2":{"prefix":"all_union","body":"all_union(${1:SetVars}, ${2:Union})$3\n$0","description":"all_union(+SetVars, ?Union)\n\n   Union constraint of a list of sets\n\nArguments\n   SetVars    A list of variables.\n   Union    A variable or a ground set.\n\nType\n   library(cardinal)\n\nDescription\nConstraint: Union is the set union of SetVars.\n\t\tAny variable in SetVars that is not yet a set domain variable, is declared\n\t\tas such using Union's lub.\n\nFail Conditions\n   Fails if Union can not be the union of SetVars.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- all_union([[8,a,9],[i,8,o],[],[a,8,5]], U).\nU = [5,8,9,a,i,o].\n\n?- all_union([X,Z,S,Y,T], [8,9]), glb_poss(X,GX,PX), glb_poss(Y,GY,PY).\nGX = [], PX = [8,9], GY = [], PY = [8,9]\n\n?- X `:: [a]+[b,c], all_union([X,[b,n],X], U), glb_poss(X,GX,PX), glb_poss(U,GU,PU).\nGX = [a], PX = [b,c], GU = [a,b,n], PU = [c]\n\n?- sets([X,Y,Z],[a,b],[d,g,h,j],[cardinality:4]), all_union([X,Y,Z],U), #(U,C), fd:dom(C,DomC).\nDomC = [4,5,6]\n\n?- sets([X,Y,Z],[a,b],[d,g,h,j],[]), all_union([X,Y,Z],U), #(U,4), #(Y,C), fd:dom(C,DomC).\nDomC = [2,3,4]\n\nSee Also\n   `= / 2, all_disjoint / 1"},"cardinal:card_labeling/1":{"prefix":"card_labeling","body":"card_labeling(${1:SetVars})$2\n$0","description":"card_labeling(?SetVars)\n\n   Label cardinality of set variables\n\nArguments\n   SetVars    A list of set variables.\n\nType\n   library(cardinal)\n\nDescription\nInstantiate all cardinalities of variables in SetVars from first to\n\t\tlast, using indomain/1 predicate of fd library.\n\t\tcard_labeling/1 is defined as:\n\n  card_labeling([]).\n  card_labeling([H|T]):-\n\tcardinality(H, C),\n\tindomain(C),\n\tcard_labeling(T).\n\nFail Conditions\n   Fails if cardinalities of SetVars can not be labeled (because constraint\n\t\tpropagation leads to a failure).\n\nResatisfiable\n   Yes.\n\nExamples\n   \n?- S `:: [a]+[b,c]:CS, T `:: [1] + [2], card_labeling([S, T]).\nCS = 1, S = [a], T = [1] ;\nCS = 1, S = [a], T = [1, 2] ;\nCS = 2, T = [1] ;\nCS = 2, T = [1, 2] ;\nCS = 3, S = [a,b,c], T = [1] ;\nCS = 3, S = [a,b,c], T = [1, 2] ;\nno\n\n?- S `:: [a] + [b,c,d,e,f]:[2,3,6,9], card_labeling([S]), cardinality(S,C).\nC = 2 ;\nC = 3 ;\nC = 6, S = [a,b,c,d,e,f] ;\nno\n\nSee Also\n   set_labeling / 2, refine / 2, cardinality / 2"},"cardinal:cardinal_desc":{"prefix":"lib","body":"lib(${1:cardinal})$2\n$0","description":"lib(cardinal)\n\nCardinal is a sets constraints library with especial inferences\n\ton sets cardinality and other optional set functions (minimum and maximum for\n\tsets of integers, and union for sets of sets.)\n\t\n\tA set is naturally used to collect distinct elements sharing some property.\n\tCombinatorial search problems over these data structures can thus be naturally\n\tmodelled by high level languages with set abstraction facilities, and efficiently\n\tsolved if constraint reasoning prunes search space when the sets are not fully\n\tknown a priori (i.e. they are variables ranging over a set domain).\n\t\n\tMany complex relations between sets can be expressed with constraints such as set\n\tinclusion, disjointness and equality over set expressions that may include such\n\toperators as intersection, union or difference of sets. Also, as it is often the\n\tcase, one is not interested simply on these relations but on some attribute or\n\tfunction of one or more sets (e.g. the cardinality of a set). For instance, the\n\tgoal of many problems is to maximise or minimise the cardinality of a set. Even\n\tfor satisfaction problems, some sets, although still variables, may be constrained\n\tto a fixed cardinality or a stricter cardinality domain than just the one inferred\n\tby the domain of a set variable (for instance, the cardinality of a set may have\n\tto be restricted to be an even number).\n\t\n\tCardinal represents set variables by set intervals with a lower and an upper bound\n\tconsidering set inclusion as a partial ordering. Consistency techniques are then\n\tapplied to set constraints by interval reasoning. A set domain variable S may be\n\tspecified by an interval [A,B] where A and B are known sets ordered by set inclusion,\n\trepresenting the greatest lower bound and the lowest upper bound of S, respectively.\n\t\n\tThe cardinality of a set S, given as a finite domain variable C (#S=C), is not a\n\tbijective function since two distinct sets may have the same cardinality. Still,\n\tit can be constrained by the cardinalities of the set bounds.\n\t\n\tA simple inference that can be done using cardinality information is to instantiate\n\tthe set to one of the set bounds, when it is known that the set cardinality must be\n\tequal to the cardinality of that bound. But Cardinal does much more than that.\n\tFor instance, consider two set variables\n\tS1,S2, that can assume either set value {} (empty set) or {a,b}. Their set domain\n\tis thus [{},{a,b}] with cardinality 0 or 2. The intersection of S1 and S2 also\n\tyelds set domain [{},{a,b}]. But we need a special inference to conclude that the\n\tintersection cardinality is also either 0 or 2 (it can not be 1). Set solvers\n\tother than Cardinal do not make such inferences.\n\t\n\tInferences using cardinalities can be very useful to deduce more rapidly the\n\tnon-satisfiability of a set of constraints, thus improving efficiency of\n\tcombinatorial search problem solving. As another simple example, if Z is known to be\n\tthe set difference between Y and X, both contained in set {a,b,c,d}, and it is known\n\tthat X has exactly 2 elements, it should be inferred that the cardinality of Z can\n\tnever exceed 2 elements (i.e. from X,Y in {a,b,c,d}, #X=2, Z=Y\\X it should be\n\tinferred that #Z =\n\tInference capabilities such as these are particularly important when solving set\n\tproblems where cardinality plays a special role. Cardinal thus fully uses\n\tconstraint propagation on sets cardinality.\n\t\n\nIntervals and Lattices\n\t\n\tSet intervals define a lattice of sets. The set inclusion relation between two\n\tsets defines a partial order on P(U), the powerset over a certain universe U,\n\tthe set of all subsets of U.\n\t\n\tDue to the transitivity rule, the top set, U, includes all sets of P(U);\n\twhile the bottom set, {}, is included in all sets of P(U). Consequently,\n\tsets U and {} constitute an upper bound and a lower bound of P(U), respectively.\n\tIn addition, they are the least upper bound (lub) or join, and the greatest lower\n\tbound (glb) or meet of P(U), since there is no other upper bound contained in\n\t(less than) U  nor other lower bound containing (greater than) the empty set {}.\n\t\n\tLet us now consider for U={a,b,c,d}, the sub-lattice connecting {a,b,d} and {b}\n\t(thus also including sets {a,b} and {b,d}). Sets {} and {a,b,c,d} are still a\n\tlower and an upper bound, but this time the glb is {b} and the lub is {a,b,d}.\n\t\n\tThe two bounds (glb and lub) define a set interval (e.g. [{b},{a,b,d}]) and may\n\tform the domain of a set variable S, meaning that set S is one of those defined\n\tby its interval (lattice); all other sets outside this domain are excluded from\n\tthe solution. Thus, b is definitely an element of S, while a and d are the only\n\tother possible elements.\n\t\n\tSet interval reasoning allows us to apply consistency techniques such as Bounded\n\tArc Consistency, due to the monotonic property of set inclusion.\n\t\n\tAny set variable must then have a domain consisting of a set interval. In addition,\n\tthis interval should be kept as small as possible, in order to discard all sets\n\tthat are known not to belong to the solution, while not loosing any of the still\n\tpossible values (sets). The smallest such domain is the one with equal glb and lub,\n\ti.e. a domain of the form [B,B], corresponding to a constant set B. For a set\n\tvariable that can assume any set value from a collection of known sets, such as\n\t{{a,b},{a,c},{d}}, the corresponding interval is the convex closure of such\n\tcollection (which in this case is the set interval [{},{a,b,c,d}]). In general,\n\tfor n possible arbitrary sets S1...Sn, the corresponding set variable X has an\n\tinterval domain [glb, lub] where glb is the intersection of all S1...Sn, and lub\n\tis their union.\n\t\nImplementation Notes\n\t\n\tIn Cardinal, all sets are represented as sorted lists, which eases working with\n\tsets and lists interchangeably.\n\t\n\tSet variable bounds are represented by its glb and its lub\\glb, the set of\n\tadditional possible elements, which we refer to as poss.\n\t\n\tCardinal implements a number of set constraints such as inclusion, equality,\n\tinequality, membership, disjointness, and even complement, together with set\n\toperations (union, intersection and difference), as built-in.\n\t\n\tAs mentioned, Cardinal also allows the definition and use of optional set functions\n\t(other than cardinality): minimum and maximum, for sets of integers, and union,\n\tfor sets of sets. Refer to the available predicates for details."},"cardinal:cardinal/s":{"prefix":"struct","body":"struct","description":"struct cardinal(domain, cardinality, minimum, maximum, union, bounded, glb, lub, bound)\n\n   Cardinal attributes of a set variable\n\nFields\n   domain    Set domain in the form [Glb:NIn,Poss:NMax], where Glb is the set's\n\t\t\tglb, NIn its cardinality, Poss is its poss (i.e. its lub\\glb),\n\t\t\tand NMax is the lub's cardinality (i.e. NIn + #(Poss)).\n\t\t\tIf it is a set of sets and a union function attribute has been\n\t\t\tdeclared, then each element of Poss comes annotated with its\n\t\t\trespective length.\n   cardinality    Cardinality function (an integer or an FD variable).\n   minimum    Minimum function (an integer or an FD variable),\n\t\t\tfor sets of integers. Free variable if unused.\n   maximum    Maximum function (an integer or an FD variable),\n\t\t\tfor sets of integers. Free variable if unused.\n   union    Union function, for sets of sets. Free variable if unused;\n\t\t\totherwise, a list in the form\n\t\t\t[UnionVar, GlbU+PossU, Singles, Lengths], where:\nUnionVar: A set (variable or ground) corresponding to the union of the set's elements\n\t(sets themselves);\nGlbU: Set union of the set's glb;\nPossU: Set of possible union elements with counters (X:N), i.e. an ordered\n\tlist of all elements in the sets in set's poss (lub\\glb)\n\twith the number of occurrences attached\nSingles: Set of elements where N=1 in PossU\n   bounded    Suspension list.\n   glb    Suspension list.\n   lub    Suspension list.\n   bound    Suspension list.\n\nType\n   library(cardinal)"},"cardinal:cardinality/2":{"prefix":"cardinality","body":"cardinality(${1:SetVariable}, ${2:Cardinality})$3\n$0","description":"cardinality(?SetVariable, ?Cardinality)\n\n   Cardinality of a set\n\nArguments\n   SetVariable    A Set (variable or ground).\n   Cardinality    An integer or an FD variable.\n\nType\n   library(cardinal)\n\nDescription\nCardinality is the cardinality of SetVariable. If Cardinality is given\n\t\t(as an integer or FD variable), then SetVariable is constrained to have such cardinality.\n\t\tIf Cardinality is a free variable, then it is unified with the set's cardinality as\n\t\tan FD variable or an integer (if it is already known).\n\nFail Conditions\n   Fails if Cardinality can not be the cardinality of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[]..[a,b], cardinality(S,C).\n?- S `::[]..[a,b], cardinality(S,1).\n?- S `::[]+[a,b]:1, cardinality(S,C).\nC = 1\n\n?- cardinality([a,b],C).\nC = 2\n\n?- S `::[c]+[a,b]:[1,3], C #> 1, cardinality(S,C).\nS = [a,b,c]\nC = 3\n\nSee Also\n   # / 2"},"cardinal:complement/2":{"prefix":"complement","body":"complement(${1:SetVar}, ${2:Complement})$3\n$0","description":"complement(?SetVar, ?Complement)\n\n   Set complement constraint\n\nArguments\n   SetVar    A variable.\n   Complement    A variable\n\nType\n   library(cardinal)\n\nDescription\nConstrain sets so that Complement is the complement set of SetVar.\n\t\t(The universe is taken as the union of their LUBs.).\n\nFail Conditions\n   Fails if Complement can not be the set complement of SetVar (in their universe).\n\nResatisfiable\n   No.\n\nExamples\n   \n?- complement([8,9], []), complement([8,9], [t]).\nyes\n\n?- complement([8,9], [8]).\nno\n\n?- complement([8,9], N).\nN = []\n\n?- sets([X,Y], [],[7,8,9], []), complement(X,Y), 8 `@ Y, glb_poss(X,GX,PX), glb_poss(Y,GY,PY).\nGX = [], PX = [7,9], GY = [8], PY = [7,9]\n\n?- sets([X,Y], [],[7,8,9], [cardinality:C]), complement(X,Y), card_labeling([X]).\nno\n\n?- sets([X,Y], [],[7,8,9], []), complement(X,Y), X `>= Y, set_labeling(up,[Y]).\nY = [], X = [7,8,9] ;\nno\n\n?- sets([X,Y], [],[7,8,9], [minimum:Min]), complement(X,Y), refine(up,X).\nno\n\n?- sets([X,Y], [],[7,8,9], []), complement(X,Y), #(X,1), #(Y,CY).\nCY = 2\n\nSee Also\n   complement / 3, `$ / 2, `= / 2"},"cardinal:complement/3":{"prefix":"complement","body":"complement(${1:SetVar}, ${2:Universe}, ${3:Complement})$4\n$0","description":"complement(?SetVar, ++Universe, ?Complement)\n\n   Set complement constraint\n\nArguments\n   SetVar    A variable.\n   Universe    A ground set.\n   Complement    A variable\n\nType\n   library(cardinal)\n\nDescription\nConstrain sets so that Complement is the complement set of SetVar,\n\t\twith respect to the given Universe. I.e. Complement is Universe \\ SetVar.\n\t\tIf a variable (SetVar or Complement) is not yet a set domain variable,\n\t\tit is declared as such, limited by the Universe.\n\t\tThis constraint is usually more efficient (stronger) than posting an\n\t\tequivalent set difference constraint, due to specific inferences.\n\nFail Conditions\n   Fails if Complement can not be the set complement of SetVar in set universe Universe.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- complement([7,8], [1,7,8,9], N).\nN = [1,9]\n\n?- complement(N, [1,7,8,9], [7,8]).\nN = [1,9]\n\n?- X `:: [a]+[b,c,d], Y `:: []+[a,b,c,d,e,f], complement(X, [a,b,c,d,e,f,g], Y).\nno\n\n?- X `:: [a]+[b,c,d], Y `:: []+[a,b,c,d,e,f], complement(X,[a,b,f],Y), domain(X,DX),domain(Y,DY).\nDX = [[a]:1,[b]:2], DY = [[f]:1,[b]:2]\n\n?- X `:: [a]+[b,c,d], Y `:: []+[a,b,c,d,e,f], complement(X, [a,b,c,d,e,f], Y), domain(Y,DY).\nDY = [[e,f]:2,[b,c,d]:5]\n\nSee Also\n   complement / 2, `$ / 2, `= / 2"},"cardinal:domain/3":{"prefix":"domain","body":"domain(${1:SetVariable}, ${2:Cardinality}, ${3:Domain})$4\n$0","description":"domain(?SetVariable, ?Cardinality, ?Domain)\n\n   Accessing the domain of a set\n\nArguments\n   SetVariable    A set variable.\n   Cardinality    An FD variable\n   Domain    A list (pair) with glb and poss.\n\nType\n   library(cardinal)\n\nDescription\nDomain is unified with the domain of SetVariable (which has cardinality\n\t\tCardinality) in the form [Glb:NIn,Poss:NMax],\n\t\twhere Glb is the (greatest) lower bound of SetVariable, and NIn its length,\n\t\tPoss is the set of still possible elements of SetVariable (i.e. its lub\\glb),\n\t\tand NMax is the lub's cardinality (i.e. NIn + #(Poss)).\n\t\t\n\t\tIf SetVariable is a set of sets and a union function attribute has been set,\n\t\tthen each element of Poss comes annotated with its respective length.\n\t\t\n\t\tUse domain/3 instead of domain/2 whenever Cardinality variable is available,\n\t\tfor efficiency reasons, since in the case of SetVariable being already\n\t\tground, it is not neccessary to recalculate its length (to retrieve\n\t\t[Setvariable:Cardinality,[]:Cardinality]. This is due to the loss of\n\t\tattributes of variables when these become instantiated.\n\t\t\n\t\tCardinality should be input to domain/3. Do not use this predicate to\n\t\tretrieve the cardinality of a set, for it will only work when set is ground.\n\nFail Conditions\n   Fails if Domain can not be unified with the current domain of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b]:C, domain(S,C,D).\nD = [[c]:1, [a,b]:3]\n\n?- S `::[c]+[a,b]:C, S=[a,c], domain(S,C,D).\nD = [[a,c]:2, []:2]\n\n?- set(S, [],[[a,b],[b,c],[a,c],[b]],[union:[a,b,c],cardinality:C]), domain(S,C,D).\nD = [[]:0, [[a,b]:2, [a,c]:2, [b]:1, [b,c]:2]:4]\n\nSee Also\n   domain / 2, glb / 2, poss / 2, glb_poss / 3, lub / 2, lub / 4, cardinality / 2, # / 2"},"cardinal:domain/2":{"prefix":"domain","body":"domain(${1:SetVariable}, ${2:Domain})$3\n$0","description":"domain(?SetVariable, -Domain)\n\n   Accessing the domain of a set\n\nArguments\n   SetVariable    A set variable.\n   Domain    A list (pair) with glb and poss.\n\nType\n   library(cardinal)\n\nDescription\nDomain is unified with the domain of SetVariable in the form [Glb:NIn,Poss:NMax],\n\t\twhere Glb is the (greatest) lower bound of SetVariable, and NIn its length,\n\t\tPoss is the set of still possible elements of SetVariable (i.e. its lub\\glb),\n\t\tand NMax is the lub's cardinality (i.e. NIn + #(Poss)).\n\t\tIf SetVariable is a set of sets and a union function attribute has been set,\n\t\tthen each element of Poss comes annotated with its respective length.\n\nFail Conditions\n   Fails if Domain can not be unified with the current domain of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], domain(S,D).\nD = [[c]:1, [a,b]:3]\n\n?- set(S, [],[[a,b],[b,c],[a,c],[b]],[union:[a,b,c]]), domain(S,D).\nD = [[]:0, [[a,b]:2, [a,c]:2, [b]:1, [b,c]:2]:4]\n\nSee Also\n   domain / 3, glb / 2, poss / 2, glb_poss / 3, lub / 2, lub / 4"},"cardinal:glb/2":{"prefix":"glb","body":"glb(${1:SetVariable}, ${2:Glb})$3\n$0","description":"glb(?SetVariable, -Glb)\n\n   Obtaining a set's glb\n\nArguments\n   SetVariable    A set variable.\n   Glb    A set.\n\nType\n   library(cardinal)\n\nDescription\nGlb is unified with the (greatest) lower bound of SetVariable.\n\nFail Conditions\n   Fails if Glb can not be unified with the current glb of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], glb(S,G).\nG = [c]\n\nSee Also\n   glb_poss / 3, domain / 2, domain / 3, lub / 2, lub / 4, poss / 2"},"cardinal:glb_poss/3":{"prefix":"glb_poss","body":"glb_poss(${1:SetVariable}, ${2:Glb}, ${3:Poss})$4\n$0","description":"glb_poss(?SetVariable, -Glb, -Poss)\n\n   Obtaining both the glb and the still possible elements of a set\n\nArguments\n   SetVariable    A set variable.\n   Glb    A set.\n   Poss    A set.\n\nType\n   library(cardinal)\n\nDescription\nGlb is unified with the (greatest) lower bound of SetVariable.\n\t\tPoss is unified with the set of still possible elements of SetVariable\n\t\t(i.e. its lub\\glb).\n\t\tIf SetVariable is a set of sets and a union function attribute has been set,\n\t\tthen each element of Poss comes annotated with its respective length.\n\nFail Conditions\n   Fails if Glb can not be unified with the current glb of SetVariable or\n\t\tif Poss can not be unified with the current poss (lub\\glb) of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], glb_poss(S,G,P).\nG = [c]\nP = [a,b]\n\n?- set(S, [],[[a,b],[b,c],[a,c],[b]],[union:[a,b,c]]), glb_poss(S,G,P).\nG = []\nP = [[a, b] : 2, [a, c] : 2, [b] : 1, [b, c] : 2]\n\nSee Also\n   glb / 2, poss / 2, domain / 2, domain / 3, lub / 2, lub / 4"},"cardinal:lub/2":{"prefix":"lub","body":"lub(${1:SetVariable}, ${2:Lub})$3\n$0","description":"lub(?SetVariable, -Lub)\n\n   Obtaining a set's lub\n\nArguments\n   SetVariable    A set variable.\n   Lub    A set.\n\nType\n   library(cardinal)\n\nDescription\nLub is unified with the (least) upper bound of SetVariable.\n\nFail Conditions\n   Fails if Lub can not be unified with the current lub of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], lub(S,L).\nL = [a,b,c]\n\nSee Also\n   lub / 4, glb / 2, poss / 2, glb_poss / 3, domain / 2, domain / 3"},"cardinal:lub/4":{"prefix":"lub","body":"lub(${1:SetVariable}, ${2:Glb}, ${3:Poss}, ${4:Lub})$5\n$0","description":"lub(?SetVariable, -Glb, -Poss, -Lub)\n\n   Obtaining a set's lub, together with its glb and poss (lub\\glb)\n\nArguments\n   SetVariable    A set variable.\n   Glb    A set.\n   Poss    A set.\n   Lub    A set.\n\nType\n   library(cardinal)\n\nDescription\nLub is unified with the (least) upper bound of SetVariable.\n\t\tGlb is unified with the (greatest) lower bound of SetVariable.\n\t\tPoss is unified with the set of still possible elements of SetVariable\n\t\t(i.e. its lub\\glb).\n\t\tIf SetVariable is a set of sets and a union function attribute has been set,\n\t\tthen each element of Poss comes annotated with its respective length.\n\nFail Conditions\n   Fails if Lub can not be unified with the current lub of SetVariable or\n\t\tif Glb can not be unified with the current glb of SetVariable or\n\t\tif Poss can not be unified with the current poss (lub\\glb) of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], lub(S,G,P,L).\nG = [c]\nP = [a,b]\nL = [a,b,c]\n\n?- set(S, [],[[a,b],[b,c],[a,c],[b]],[union:[a,b,c]]), lub(S,G,P,L).\nG = []\nP = [[a, b] : 2, [a, c] : 2, [b] : 1, [b, c] : 2]\nL = [[a, b], [a, c], [b], [b, c]]\n\nSee Also\n   lub / 2, glb_poss / 3, glb / 2, poss / 2, domain / 2, domain / 3"},"cardinal:maximum/2":{"prefix":"maximum","body":"maximum(${1:SetVariable}, ${2:Max})$3\n$0","description":"maximum(?SetVariable, ?Max)\n\n   Maximum of a set of integers\n\nArguments\n   SetVariable    A Set (variable or ground) of integers.\n   Max    An integer or an FD variable.\n\nType\n   library(cardinal)\n\nDescription\nMax is the maximum (i.e. the highest element) of SetVariable.\n\t\tIf Max is given (as an integer or FD variable) then SetVariable is\n\t\tconstrained to have such maximum.\n\t\tIf Max is a free variable, then it is unified with the set's maximum as\n\t\tan FD variable or an integer (if it is already known).\n\t\tmaximum/2 can thus be used either to declare (or constrain) a maximum\n\t\tfunction or to retrieve it.\n\nFail Conditions\n   Fails if Max can not be the maximum of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S`::[]..[1,2], maximum(S,M).\n?- set(S,[],[1,2],[maximum:2], maximum(S,M).\nM = 2\n\n?- S`::[]+[1,2], maximum(S,1).\nS = [1]\n\n?- set(S,[],[1,2],[maximum:1], maximum(S,M).\nS = [1]\nM = 1\n\nSee Also\n   minimum / 2, set / 4, sets / 4, cardinality / 2"},"cardinal:minimum/2":{"prefix":"minimum","body":"minimum(${1:SetVariable}, ${2:Min})$3\n$0","description":"minimum(?SetVariable, ?Min)\n\n   Minimum of a set of integers\n\nArguments\n   SetVariable    A Set (variable or ground) of integers.\n   Min    An integer or an FD variable.\n\nType\n   library(cardinal)\n\nDescription\nMin is the minimum (i.e. the lowest element) of SetVariable.\n\t\tIf Min is given (as an integer or FD variable) then SetVariable is\n\t\tconstrained to have such minimum.\n\t\tIf Min is a free variable, then it is unified with the set's minimum as\n\t\tan FD variable or an integer (if it is already known).\n\t\tminimum/2 can thus be used either to declare (or constrain) a minimum\n\t\tfunction or to retrieve it.\n\nFail Conditions\n   Fails if Min can not be the minimum of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S`::[]..[1,2], minimum(S,M).\n?- set(S,[],[1,2],[minimum:1], minimum(S,M).\nM = 1\n\n?- S`::[]+[1,2], minimum(S,2).\nS = [2]\n\n?- set(S,[],[1,2],[minimum:2], minimum(S,M).\nS = [2]\nM = 2\n\nSee Also\n   maximum / 2, set / 4, sets / 4, cardinality / 2"},"cardinal:poss/2":{"prefix":"poss","body":"poss(${1:SetVariable}, ${2:Poss})$3\n$0","description":"poss(?SetVariable, -Poss)\n\n   Obtaining the still possible elements of a set (lub\\glb)\n\nArguments\n   SetVariable    A set variable.\n   Poss    A set.\n\nType\n   library(cardinal)\n\nDescription\nPoss is unified with the set of still possible elements of SetVariable\n\t\t(i.e. its lub\\glb).\n\t\tIf SetVariable is a set of sets and a union function attribute has been set,\n\t\tthen each element of Poss comes annotated with its respective length.\n\nFail Conditions\n   Fails if Poss can not be unified with the current poss (lub\\glb) of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[c]+[a,b], poss(S,P).\nP = [a,b]\n\n?- S `::[[c]]+[[a,b]], poss(S,P).\nP = [[a,b]]\n\n?- set(S, [],[[a,b],[b,c],[a,c],[b]],[union:[a,b,c]]), poss(S,P).\nP = [[a, b] : 2, [a, c] : 2, [b] : 1, [b, c] : 2]\n\nSee Also\n   glb / 2, glb_poss / 3, domain / 2, domain / 3, lub / 2, lub / 4"},"cardinal:refine/2":{"prefix":"refine","body":"refine(${1:UpDown}, ${2:SetVar})$3\n$0","description":"refine(++UpDown, ?SetVar)\n\n   Refine a set variable's domain\n\nArguments\n   UpDown    Atom ('up' or 'down').\n   SetVar    A set variable.\n\nType\n   library(cardinal)\n\nDescription\nPick the first element of SetVar's poss (lub\\glb) and try to include it\n\t\tin its glb, or to definitely exclude it from the domain.\n\t\tIf heuristic UpDown is 'up' then inclusion is tried first; otherwise (down)\n\t\texclusion is tried first.\n\nFail Conditions\n   Fails if Var can not be refined (it is either ground or both the inclusion\n\t\tand exclusion of the first element of its poss leads to a failure due to\n\t\tunsatisfied constraints).\n\nResatisfiable\n   Yes.\n\nExamples\n   \n?- S `:: [a]+[b,c], refine(up,S), glb_poss(S,G,P).\nG = [a,b], P = [c] ;\nG = [a], P = [c] ;\nno\n\n?- S `:: [a]+[b,c], refine(down,S), glb_poss(S,G,P).\nG = [a], P = [c] ;\nG = [a,b], P = [c] ;\nno\n\nSee Also\n   set_labeling / 2, set_labeling / 1"},"cardinal:set/4":{"prefix":"set","body":"set(${1:SetVariable}, ${2:Glb}, ${3:Poss}, ${4:Functions})$5\n$0","description":"set(?SetVariable, ++Glb, ++Poss, +Functions)\n\n   Set variable declaration with optional functions\n\nArguments\n   SetVariable    A variable.\n   Glb    A ground set.\n   Poss    A ground set.\n   Functions    A list.\n\nType\n   library(cardinal)\n\nDescription\nDeclare or constrain a set domain variable to have Glb as assured\n\t\telements and Poss as the possible additional elements.\n\t\tFunctions is a list of functions over SetVariable in the form\n\t\tFunctionName:FunctionValue, where FunctionName can be 'cardinality',\n\t\t'minimum', 'maximum' or 'union':\n\n  cardinality: FunctionValue can be an integer, an FD variable or an integer domain (list or range)\n  union: (SetVariable must be a set of sets.) FunctionValue can be a set, a set variable\n\tor a set domain in the form GlbUnion+PossUnion, representing the glb and poss of\n\tthe union of SetVariable\n  minimum and maximum: (SetVariable must be a nonempty set of integers.)\n\tFunctionValue can be an integer, an FD variable or an integer domain\n\n\t\tCardinal inferences over SetVariable and its union, minimum and maximum\n\t\tfunctions will be performed only if these functions are explicitly\n\t\tdeclared, whereas the cardinality function and respective inferences\n\t\twill always be present even if this (cardinality) function is not\n\t\texplicitly declared. Note that a simple function declaration such as\n\t\tminimum:_ is sufficient to make it 'active'.\n\nFail Conditions\n   Fails if SetVariable can not be constrained accordingly.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- set(S,[],[a,b],[]).\n?- set(S,[],[a,b],[cardinality:1]).\n?- set(S,[],[a,b],[cardinality:C]).\n?- set(S,[],[a,b],[cardinality:[0,2]]).\n?- set(S,[c],[a,b,d,e,f,g,h,i,j,k],[cardinality:[2,4..7]]).\n?- set(S,[],[1,3,4,5,7],[minimum:Min,maximum:Max]), fd:(Max #> Min+2).\n?- set(S, [], [[1,2,5],[2,4],[3,5],[1,3,4]],\n\t[cardinality:2, union:[1,2,3,4,5]]).   %set-covering\n?- set(S, [], [[1,2,5],[2,4],[3,5],[1,3,4]], [union:[1]+[2,4,5]]).\n\nSee Also\n   sets / 4, `:: / 2, cardinality / 2, union_var / 2, minimum / 2, maximum / 2, set_labeling / 1"},"cardinal:set_labeling/1":{"prefix":"set_labeling","body":"set_labeling(${1:SetVars})$2\n$0","description":"set_labeling(?SetVars)\n\n   Label set variable(s)\n\nArguments\n   SetVars    A variable or a list of set variables.\n\nType\n   library(cardinal)\n\nDescription\nInstantiate all variables in SetVars from first to last, with\n\t\tconsecutive refinements of their domains until they are ground.\n\t\tFor each set variable, for each element in its poss (lub\\glb), inclusion\n\t\tis tried first.\n\t\tSetVars can be a set variable instead of a list. Labeling a single set\n\t\tvariable S can thus be done both with set_labeling([S]) or with\n\t\tset_labeling(S).\n\nFail Conditions\n   Fails if SetVars can not be labeled (there is no solution to the CSP).\n\nResatisfiable\n   Yes.\n\nExamples\n   \n?- S `:: [a] + [b, c], T `:: [1] + [2], set_labeling([S, T]).\nS = [a, b, c], T = [1, 2] ;\nS = [a, b, c], T = [1] ;\nS = [a, b], T = [1, 2] ;\nS = [a, b], T = [1] ;\nS = [a, c], T = [1, 2] ;\nS = [a, c], T = [1] ;\nS = [a], T = [1, 2] ;\nS = [a], T = [1] ;\nno\n\n?- S `:: [a] + [b, c], T `:: [1] + [2], set_labeling(S).\nS = [a, b, c] ;\nS = [a, b] ;\nS = [a, c] ;\nS = [a] ;\nno\n\nSee Also\n   set_labeling / 2, refine / 2"},"cardinal:set_labeling/2":{"prefix":"set_labeling","body":"set_labeling(${1:UpDown}, ${2:SetVars})$3\n$0","description":"set_labeling(++UpDown, +SetVars)\n\n   Label set variables\n\nArguments\n   UpDown    Atom: 'up' or 'down'.\n   SetVars    List of set variables.\n\nType\n   library(cardinal)\n\nDescription\nInstantiate all variables in SetVars from first to last, with\n\t\tconsecutive refinements of their domains until they are ground.\n\t\tIf heuristic UpDown is 'up' then, for each set variable, for each element\n\t\tin its poss (lub\\glb), inclusion is tried first; otherwise (down)\n\t\texclusion is tried first.\n\nFail Conditions\n   Fails if SetVars can not be labeled (there is no solution to the CSP).\n\nResatisfiable\n   Yes.\n\nExamples\n   \n?- S `:: [a] + [b, c], T `:: [1] + [2], set_labeling(up, [S, T]).\nS = [a, b, c], T = [1, 2] ;\nS = [a, b, c], T = [1] ;\nS = [a, b], T = [1, 2] ;\nS = [a, b], T = [1] ;\nS = [a, c], T = [1, 2] ;\nS = [a, c], T = [1] ;\nS = [a], T = [1, 2] ;\nS = [a], T = [1] ;\nno\n\n?- S `:: [a] + [b, c], T `:: [1] + [2], set_labeling(down, [S, T]).\nS = [a], T = [1] ;\nS = [a], T = [1, 2] ;\nS = [a, c], T = [1] ;\nS = [a, c], T = [1, 2] ;\nS = [a, b], T = [1] ;\nS = [a, b], T = [1, 2] ;\nS = [a, b, c], T = [1] ;\nS = [a, b, c], T = [1, 2] ;\nno\n\nSee Also\n   set_labeling / 1, refine / 2"},"cardinal:sets/4":{"prefix":"sets","body":"sets(${1:SetVariables}, ${2:Glb}, ${3:Poss}, ${4:Functions})$5\n$0","description":"sets(+SetVariables, ++Glb, ++Poss, +Functions)\n\n   Set variables declaration with optional functions\n\nArguments\n   SetVariables    A list of variables.\n   Glb    A ground set.\n   Poss    A ground set.\n   Functions    A list.\n\nType\n   library(cardinal)\n\nDescription\nDeclare or constrain set domain variables to have Glb as assured\n\t\telements and Poss as the possible additional elements.\n\t\tFunctions is a list of functions over each SetVariable in SetVariables in the form\n\t\tFunctionName:FunctionValue, where FunctionName can be 'cardinality',\n\t\t'minimum', 'maximum' or 'union':\n\n  cardinality: FunctionValue can be an integer, an FD variable or an integer domain (list or range)\n  union: (SetVariable must be a set of sets.) FunctionValue can be a set, a set variable\n\tor a set domain in the form GlbUnion+PossUnion, representing the glb and poss of\n\tthe union of SetVariable\n  minimum and maximum: (SetVariable must be a nonempty set of integers.)\n\tFunctionValue can be an integer, an FD variable or an integer domain\n\n\t\tCardinal inferences over SetVariable and its union, minimum and maximum\n\t\tfunctions will be performed only if these functions are explicitly\n\t\tdeclared, whereas the cardinality function and respective inferences\n\t\twill always be present even if this (cardinality) function is not\n\t\texplicitly declared. Note that a simple function declaration such as\n\t\tminimum:_ is sufficient to make it 'active'.\n\t\tIf a FunctionValue is given as a variable or as a fixed (integer or set)\n\t\tvalue, then it will be the same for all of SetVariables. If it is given\n\t\tas a domain, then function values for SetVariables may be different\n\t\t(a different domain variable is created for each SetVariable).\n\nFail Conditions\n   Fails if SetVariables can not be constrained accordingly.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- sets([S],[],[a,b],[]).\n?- sets([S,T],[],[a,b],[cardinality:1]).\n?- sets([X,Y,Z],[],[a,b],[cardinality:C]).\n?- sets([X,Y,Z],[],[a,b],[cardinality:[0,2]]).\n?- sets([X,Y,Z],[c],[a,b,d,e,f,g,h,i,j,k],[cardinality:[2,4..7]]).\n?- sets([X,Y,Z],[],[1,3,4,5,7],[minimum:Min,maximum:1..9]), fd:(Max #> Min+2).\n?- sets([X,Y,Z], [], [[1,2,5],[2,4],[3,5],[1,3,4]], [union:[1]+[2,4,5]]).\n\nSee Also\n   set / 4, `:: / 2, cardinality / 2, union_var / 2, minimum / 2, maximum / 2, set_labeling / 1"},"cpviz:viztool/0":{"prefix":"viztool","body":"viztool","description":"viztool\n\n   Launch the CP-Viz viztool for viewing trace log visualisations. In TkECLiPSe, this can be done from the Tools menu.\n\nType\n   library(cpviz)"},"cardinal:union_var/2":{"prefix":"union_var","body":"union_var(${1:SetVariable}, ${2:UnionVar})$3\n$0","description":"union_var(?SetVariable, ?UnionVar)\n\n   Union of a set of sets\n\nArguments\n   SetVariable    A Set (variable or ground) of sets.\n   UnionVar    A Set (variable or ground).\n\nType\n   library(cardinal)\n\nDescription\nUnionVar is the union of sets in SetVariable. If UnionVar is given\n\t\t(as a ground set or a set variable), then SetVariable is constrained to have such union.\n\t\tIf UnionVar is a free variable, then it is unified with the set's union as\n\t\ta set variable or a ground set (if it is already known).\n\t\tunion_var/2 can thus be used either to declare (or constrain) a union\n\t\tfunction or to retrieve it.\n\nFail Conditions\n   Fails if UnionVar can not be the union of SetVariable.\n\nResatisfiable\n   No.\n\nExamples\n   \n?- S `::[]..[[a],[b]], union_var(S,U).\n?- S `::[]..[[a],[b],[a,b]], union_var(S,[a,b]).\n?- union_var([[a,b],[b,c]], U).\nU = [a,b,c]\n\nSee Also\n   set / 4, sets / 4, cardinality / 2"},"cpviz:cpviz_desc":{"prefix":"lib","body":"lib(${1:cpviz})$2\n$0","description":"lib(cpviz)\n\n\r\n    This library loads and reexports library(visualization) and\r\n    library(visualize_tree), making all features of CP-Viz available.\r\n    In addition, it provides convenience predicates viz/2 and viztool/0\r\n    for executing CP-Viz's Java-based tools from within ECLiPSe.\r\n\r\n    Usage examples can be found under doc/examples/cpviz/ in your ECLiPSe\r\n    installation.  The document 'CP Visualizer Format' is in the doc/\r\n    directory.  Further background documents on CP-Viz are\r\n    http://4c.ucc.ie/~hsimonis/cpviz-cp2010-paper.pdf,\r\n    http://4c.ucc.ie/~hsimonis/cpviz-cp2010-slides.pdf\r\n    and the project web site is http://sourceforge.net/projects/cpviz .\r\n\r\n    The following is a code example.  After running sudoku(M), launch viztool\r\n    and open the file aaa.idx in the OUTPUT subdirectory.\r\n\r\n:-lib(ic).\r\n:-import alldifferent/1 from ic_global_gac.\r\n:-lib(cpviz).\r\n\r\nsudoku(Matrix):-\r\n    problem(Matrix),\r\n    Matrix :: 1..9,\r\n    create_visualization([],Handle),\r\n    add_visualizer(Handle, domain_matrix(Matrix), [display:expanded]),\r\n    draw_visualization(Handle),\r\n    ( for(I,1,9), param(Matrix,Handle) do\r\n    alldifferent(Matrix[I,1..9]),\r\n    draw_visualization(Handle,[focus(1,row(I))]),\r\n    alldifferent(Matrix[1..9,I]),\r\n    draw_visualization(Handle,[focus(1,col(I))])\r\n    ),\r\n    ( multifor([I,J],[1,1],[7,7],[3,3]), param(Matrix,Handle) do\r\n    alldifferent(flatten(Matrix[I..I+2,J..J+2])),\r\n    draw_visualization(Handle,[focus(1,block(I,J,3,3))])\r\n    ),\r\n    extract_array(Handle,row,Matrix,NamedList),\r\n    root(Handle),\r\n    search(NamedList,1,input_order,tree_indomain(Handle,Handle), complete,[]),\r\n    solution(Handle),\r\n    close_visualization(Handle),\r\n    viz(Handle, _).\r\n    \r\nproblem([]([](4, _, 8, _, _, _, _, _, _), \r\n    [](_, _, _, 1, 7, _, _, _, _), \r\n    [](_, _, _, _, 8, _, _, 3, 2), \r\n    [](_, _, 6, _, _, 8, 2, 5, _), \r\n    [](_, 9, _, _, _, _, _, 8, _), \r\n    [](_, 3, 7, 6, _, _, 9, _, _), \r\n    [](2, 7, _, _, 5, _, _, _, _), \r\n    [](_, _, _, _, 1, 4, _, _, _), \r\n    [](_, _, _, _, _, _, 6, _, 4)))."},"cpviz:viz/2":{"prefix":"viz","body":"viz(${1:Handle}, ${2:ToolSpecs})$3\n$0","description":"viz(+Handle, ?ToolSpecs)\n\n   Run the CP-Viz viz program to convert xml traces to graphics\n\nArguments\n   Handle    A (just closed) visualisation handle\n   ToolSpecs    Configuration options for the output to produce\n\nType\n   library(cpviz)\n\nDescription\n\r\n    This predicate provides a convenient interface to CP-Viz's 'viz' program,\r\n    which converts XML trace log files into various drawing formats.  It is\r\n    meant to be invoked just after the trace files have been produced.\r\n    Afterwards, the resulting output may be viewed using viztool.\r\n\r\n    The Handle argument should be the handle of a finished tracing session,\r\n    which must have been closed already via close_visualization/1.\r\n\r\n    The 'viz' program needs a configuration.xml file with options.  If such\r\n    a file is present in the directory where the trace log files are located,\r\n    and you want to use it, then set ToolSpecs to [].\r\n    Otherwise, a configuration file will be created from the ToolSpecs.\r\n    ToolSpecs is a list of tool-structures with the following arguments\r\n    (all arguments except 'show' are optional):\r\n\r\n    show\r\n    tree or viz\r\n\r\n    type\r\n    layout (default), distribution, treemap, graph, values\r\n\r\n    display\r\n    compact (default) or expanded.  This controls whether failed\r\n\tsubtrees are displayed in compact form.\r\n\r\n    repeat\r\n    all, final, or a positive or negative integer\r\n\r\n    width\r\n    positive integer (width of SVG canvas in pixels, default 700)\r\n\r\n    height\r\n    positive integer (height of SVG canvas in pixels, default 700)\r\n\r\n\r\n    Alternatively, ToolSpecs can remain completely uninstantiated,\r\n    in which case it defaults to the following two-element list:\r\n\r\n    [tool{show:tree},tool{show:viz}]\r\n\r\n    For the meaning of the options refer to the CP-Viz documentation.\r\n\r\n    After processing the log files with viz/2, you can start viztool/0 and\r\n    view the results, which are located in the directory specified by Handle\r\n    (default 'OUTPUT'). Open the aaa.idx file.\r\n\nModes and Determinism\n   viz(+, ?) is det\n\nExamples\n   \r\n    % for using default configuration settings:\r\n    ...\r\n    close_visualization(Handle),\r\n    viz(Handle, _).\r\n\r\n    % with specific configuration settings:\r\n    ...\r\n    close_visualization(Handle),\r\n    viz(Handle, [\r\n    tool{show:tree,display:expanded},\r\n    tool{show:viz,width:1000,height:1000}\r\n    ]).\r\n\nSee Also\n   visualization : create_visualization / 2, close_visualisation / 1, viztool / 0"},"cycle:cycle/3":{"prefix":"cycle","body":"cycle(${1:Edges}, ${2:EdgeWeights}, ${3:CycleCost})$4\n$0","description":"cycle(+Edges, ++EdgeWeights, -CycleCost)\n\n   A constraint that forces a Hamiltonian cycle in a directed graph\n\nArguments\n   Edges    A list of ic variables\n   EdgeWeights    A square matrix of integers\n   CycleCost    The cost of the cycle\n\nType\n   library(cycle)\n\nDescription\n\r\n\tEdges is a list of length VertexCount of ic variables, where VertexCount is the number of \r\n\tvertices in the graph. Each variable needs to have a domain which is the subset of \r\n\t[1..VertexCount]. The values in the i-th variable's domain correspond to edges in the \r\n\tgraph, so the domain value j of the i-th variable corresponds to an edge (i,j). \r\n\r\n\tEdgeWeights is a square matrix (array of arrays) of size VertexCount*VertexCount of nonnegative \r\n\tintegers. The value indexed [i,j] corresponds to the cost of the edge (i,j). Values on the diagonal\r\n\t([i,i]) are unimportant since the correspond to edges (i,i) which are automatically removed by\r\n\tthe constraint.\r\n\r\n\tCycleCost is an ic variable that corresponds to the cost of the cycle. \r\n\r\n\tThis version of the constraint uses the maximal propagation level. For more details and \r\n\tconfiguration of different propagation levels see cycle/4. \r\n\t\t\n\nModes and Determinism\n   cycle(+, ++, -) is semidet\n\nFail Conditions\n   It is impossible to find any Hamiltonian cycle in the graph\n\nExceptions\n     1 --- Wrong edge weigh matrix size.\n     1 --- Wrong edge list length.\n     6 --- Wrong edge domain values.\n     1 --- Wrong weight value.\n     8 --- Unknown options\n\nSee Also\n   cycle / 4"},"cycle:cycle/4":{"prefix":"cycle","body":"cycle(${1:Edges}, ${2:EdgeWeights}, ${3:CycleCost}, ${4:Configuration})$5\n$0","description":"cycle(+Edges, ++EdgeWeights, -CycleCost, ++Configuration)\n\n   A constraint that forces a Hamiltonian cycle in a directed graph\n\nArguments\n   Edges    A list of ic variables\n   EdgeWeights    A square matrix of integers\n   CycleCost    The cost of the cycle\n   Configuration       A list of key:value configuration elements\n\nType\n   library(cycle)\n\nDescription\n\r\n\tEdges is a list of length VertexCount of ic variables, where VertexCount is the number of \r\n\tvertices in the graph. Each variable needs to have a domain which is the subset of \r\n\t[1..VertexCount]. The values in the i-th variable's domain correspond to edges in the \r\n\tgraph, so the domain value j of the i-th variable corresponds to an edge (i,j). \r\n\r\n\tEdgeWeights is a square matrix (array of arrays) of size VertexCount*VertexCount of nonnegative \r\n\tintegers. The value indexed [i,j] corresponds to the cost of the edge (i,j). Values on the diagonal\r\n\t([i,i]) are unimportant since the correspond to edges (i,i) which are automatically removed by\r\n\tthe constraint.\r\n\r\n\tCycleCost is an ic variable that corresponds to the cost of the cycle. \r\n\r\n\tConfiguration is a list of key:value pairs that configure the filtering level of the constraint. \r\n\trc_varfix:yes/no (default is yes), enables or disables the propagation of reduced cost variable \r\n\tfixing constraints. These constraints are based on the solution of the LP relaxation for the cycle. \r\n\tcut_planes:yes/no (default is yes), enables or disables the iterative strengthening of the LP \r\n\trelaxation by generation of cutting planes for the LP model. \r\n\tbound_upd:yes/no (default is yes), enables or disables the tightening of the upper bound on cost \r\n\tby solving a LP relaxation. \r\n\topt_dir:min/max (default is min), the propagation is optimised for minimisation (min) \r\n\tor maximisation (max) of the CycleCost. \r\n\r\n\tThe default configuration for the constraint is to use the maximal available propagation \r\n\tand cost tightening. This setting is also used by the cycle/3. \r\n\r\n\tThe most basic propagation level for cycle is achieved by setting\r\n\tConfiguration=[rc_varfix:no,cut_planes:no,bound_upd:no].\r\n\t\r\n\t\t\n\nModes and Determinism\n   cycle(+, ++, -, ++) is semidet\n\nFail Conditions\n   It is impossible to find any Hamiltonian cycle in the graph\n\nExceptions\n     1 --- Wrong edge weigh matrix size.\n     1 --- Wrong edge list length.\n     6 --- Wrong edge domain values.\n     1 --- Wrong weight value.\n     8 --- Unknown options\n\nSee Also\n   cycle / 3"},"cycle:cycle_desc":{"prefix":"lib","body":"lib(${1:cycle})$2\n$0","description":"lib(cycle)\n\n   \r\n\tA configurable constraint that forces the existence of a Hamiltonian cycle in a directed graph.\r\n\tThe constraint uses the ic and eplex libraries to achieve different levels of filtering. For more \r\n\tdetails see cycle/4.\r\n\tParts of the filtering algorithm have been inspired by or are implementations of ideas presented by\r\n\tJohn H.Hooker in \"Rossi F., van Beek P., Walsh T. (Eds.), Handbook of Constraint Programming, \r\n\tchap. 15. 2006 Elsevier.\".\r\n\t\r\n\tThe constraint will be refined and new filtering techniques will be added as time will allow to\r\n\twork on the subject."},"fd_global_gac:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:L})$2\n$0","description":"alldifferent(+L)\n\n   GAC version of alldifferent\n\nArguments\n   L    List of integers or domain variables, or a collection a la collection_to_list/2\n\nType\n   library(fd_global_gac)\n\nDescription\nThis predicate implements a GAC (generalized arc consistency) version of the alldifferent constraint. It uses the classical bitpartite matching implementation using the graph_algorithms library. This version often removes more values than the bound consistent alldifferent in the ic_global library, or the forward checking variant in the ic library, but may spend much more time doing this.\n\nFail Conditions\n   fails if there is no bipartite matching between all variables and the possible values\n\nSee Also\n   matching / 2, ic : alldifferent / 1, ic_global : alldifferent / 1"},"fd_global_gac:alldifferent_matrix/1":{"prefix":"alldifferent_matrix","body":"alldifferent_matrix(${1:Matrix})$2\n$0","description":"alldifferent_matrix(+Matrix)\n\n   Constrain the rows and columns of Matrix to be different values\n\nArguments\n   Matrix    A two dimensional square matrix of Variables or integer\n\nType\n   library(fd_global_gac)\n\nDescription\n\n    This constraint is a matrix version of alldifferent. Matrix is a two\n    dimensional square (NxN) matrix, and the constraint ensures that the \n    elements in each row and column of the matrix are different. The same\n    value can occur in different rows and columns. It is logically \n    equivalent to imposing 2N alldifferent constraints on each row and column,\n    but it allows more reasoning because it consider the rows and columns \n    together. The version uses alldifferent from lib(fd_global_gac), but the \n    extra inferences performed between the rows and columns themselves not be\n    fully domain consistent. The maximum propagation occurs when the \n    variables' domains also have N values. \n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   alldifferent / 1, ic_global : alldifferent_matrix / 1, fd_global : alldifferent_matrix / 1, ic_global_gac : alldifferent_matrix / 1"},"fd_global_gac:fd_global_gac_desc":{"prefix":"lib","body":"lib(${1:fd_global_gac})$2\n$0","description":"lib(fd_global_gac)\n\n   This library is intended for global constraints for which GAC (generalized arc consistency, also called hyper arc consistency, or domain consistency) is maintained. The first example is a version of the alldifferent constraint which performs more pruning than the bound consistent version in the fd_global library."},"fd_global_gac:gcc/2":{"prefix":"gcc","body":"gcc(${1:Bounds}, ${2:Vars})$3\n$0","description":"gcc(++Bounds, +Vars)\n\n   Constrain the cardinality of each Value specified in Bound's gcc(Low,High,Value) to be between Low and High in Vars\n\nArguments\n   Bounds    A list of elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values\n   Vars    A collection of different variables or integers\n\nType\n   library(fd_global_gac)\n\nDescription\n\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in Vars conforms to the specifications in Bounds. Bounds is a\n    list of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in Bounds, and whose cardinality |Value| is specified by \n    Low =\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as global_cardinality_low_up in the global\n    constraint catalog. The algorithm implemented is described in \n    J.-C. Regin's paper 'Generalized Arc Consistency for Global Cardinality\n    Constraint', published in AAAI-1996."},"fd_global_gac:gcc_matrix/3":{"prefix":"gcc_matrix","body":"gcc_matrix(${1:RowBounds}, ${2:ColBounds}, ${3:Matrix})$4\n$0","description":"gcc_matrix(++RowBounds, ++ColBounds, +Matrix)\n\n   Constrain the cardinality of values taken in the rows and columns of Matrix as specified by RowBounds and ColBounds, respectively\n\nArguments\n   RowBounds    A list of M sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in RowBounds\n   ColBounds    A list of N sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in ColBounds\n   Matrix    A two dimensional MxN matrix of Variables or integer\n\nType\n   library(fd_global_gac)\n\nDescription\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in each row and column of Matrix conforms to the specifications\n    in RowBounds and ColBounds, respectively. RowBounds and ColBounds are \n    lists of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in the row/column, and whose cardinality |Value| is specified by \n    Low =\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   gcc / 2"},"fd_global_gac:inverse/2":{"prefix":"inverse","body":"inverse(${1:Succ}, ${2:Pred})$3\n$0","description":"inverse(+Succ, +Pred)\n\n   Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph\n\nArguments\n   Succ    A collection of N different variables or integers\n   Pred    A collection  of N different variables or integers\n\nType\n   library(fd_global_gac)\n\nDescription\n\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predessor node, and\n     that if node y is the successor of node x, then node x is the\n     predecessor of node y.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list."},"fd_global_gac:lex_le/2":{"prefix":"lex_le","body":"lex_le(${1:List1}, ${2:List2})$3\n$0","description":"lex_le(+List1, +List2)\n\n   List1 is lexicographically less or equal to List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(fd_global_gac)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e. either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as lex_lesseq in the global constraint\n    catalog. The implementation here maintains generalised arc\n    consistency and uses the algorithm described in:\n    Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n    Uppsala University, 2004."},"fd_global_gac:lex_lt/2":{"prefix":"lex_lt","body":"lex_lt(${1:List1}, ${2:List2})$3\n$0","description":"lex_lt(+List1, +List2)\n\n   List1 is lexicographically less than  List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(fd_global_gac)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as lex_less in the global constraint\n    catalog. The implementation here maintains generalised arc\n    consistency and uses the algorithm described in:\n    Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n    Uppsala University, 2004."},"fd_global_gac:matching/2":{"prefix":"matching","body":"matching(${1:L}, ${2:K})$3\n$0","description":"matching(+L, -K)\n\n   Get a matching between a list of domain variables and their possible values\n\nArguments\n   L    A list of integers or domain variables, or a collection a la collection_to_list/2\n   K    A free variable, will be bound to a list of integers\n\nType\n   library(fd_global_gac)\n\nDescription\nThis predicate can be used to get the matching into the user program. Sometimes it is a good starting point for heuristics. It only gets the current matching and does not do any propagation, the matching is not updated when values are removed, the predicate must be called again in the user program if this is required\n\nFail Conditions\n   The predicate fails if no matching exists\n\nSee Also\n   alldifferent / 1"},"fd_global_gac:same/2":{"prefix":"same","body":"same(${1:Vars1}, ${2:Vars2})$3\n$0","description":"same(+Vars1, +Vars2)\n\n   Vars1 and Vars2 are constrained to be a permutation of each other in the values taken by the variables.\n\nArguments\n   Vars1    A collection of N different variables or integers\n   Vars2    A collection of N different variables or integers\n\nType\n   library(fd_global_gac)\n\nDescription\n\n    This constraint ensures that the values taken by the variables in Vars1\n    and Vars2 are permutations of each other. Vars1 and Vars must be the same\n    length.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is also known as same in the global constraint catalog. \n    The implementation is the generalised arc-consistent version described\n    in the catalog."},"fd_global_gac:sequence/4":{"prefix":"sequence","body":"sequence(${1:Low}, ${2:High}, ${3:K}, ${4:ZeroOnes})$5\n$0","description":"sequence(+Low, +High, +K, +ZeroOnes)\n\n   The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes\n\nArguments\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   ZeroOnes    A collection of 0/1 variables or integers\n\nType\n   library(fd_global_gac)\n\nDescription\n\n    This constraint ensures that the number of occurrences of the value 1\n    is at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes. ZeroOnes are 0/1 variables (or itnegers), \n    i.e. they have the domain [0,1]. \n\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. For example,\n    sequence/5 is implemented by linking the N ZeroOnes variables to a \n    matching collection of N finite domain `original' variables using \n    element/3 constraints to constrain the ZeroOnes to be 1 if the \n    corresponding original value takes one of the specified values. The\n    ZeroOnes can then be used in further constraint reasoning.\n\n    Note: this constraint is different from sequence/4 in lib(fd).\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence / 5, fd : element / 3, fd_global : sequence_total / 6, fd_global : sequence_total / 7"},"fd_global_gac:sequence/5":{"prefix":"sequence","body":"sequence(${1:Low}, ${2:High}, ${3:K}, ${4:Vars}, ${5:Values})$6\n$0","description":"sequence(+Low, +High, +K, +Vars, ++Values)\n\n   The number of values taken from Values is between Low and High for all sequences of K variables in Vars.\n\nArguments\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   Vars    A list of variables or integers\n   Values    A list of (different) integers\n\nType\n   library(fd_global_gac)\n\nDescription\n\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars. \n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as among_seq in the global constraint catalog.\n    The algorithm implemented is described in M. Maher et al.'s paper \n    'Flow-Based Propagators for the SEQUENCE and Related Global Constraints' \n    in CP'2008.\n\nSee Also\n   sequence / 5, fd : element / 3, fd_global : sequence_total / 6, fd_global : sequence_total / 7"},"flatzinc:flatzinc_desc":{"prefix":"lib","body":"lib(${1:flatzinc})$2\n$0","description":"lib(flatzinc)\n\n\r\n\r\nOverview\r\n\r\n\r\nThe core of this module is an interpreter for FlatZinc models, based\r\non 'Specification of FlatZinc 1.0' (May 2009).  It uses\r\nlib(flatzinc_parser) to read a FlatZinc model one item at a time, and\r\nimmediately interprets it.  The mapping from FlatZinc built-in\r\noperations to actual ECLiPSe solver operations is in separate modules\r\ncalled fzn_ic, fzn_fd, fzn_eplex, etc.\r\n\r\n\r\n\r\nRunning FlatZinc Models\r\n\r\n\r\nIf you have a file containing a FlatZinc model, it can be loaded and\r\nexecuted from ECLiPSE by calling\r\n\r\n    ?- fzn_run(\"model.fzn\", fzn_ic).\r\n\r\nwhere model.fzn is the file name (the .fzn extension can be omitted)\r\nand fzn_ic is the name of the chosen solver mapping.  It is also\r\npossible to read a model from the standard input using fzn_run/1, or\r\nfrom an arbitrary ECLiPSe input stream using fzn_run_stream/2.\r\n\r\nIf finer control is needed, the processing of a FlatZinc model can be\r\nsplit up into initialization, loading and constraint-set-up, search,\r\nand output.  The primitives that perform these steps are exported\r\nand can be invoked separately, e.g.\r\n\r\nmy_fzn_run_stream(ModelStream, Options) :-\r\n\r\n\t% initialize the solver state\r\n\tfzn_init(Options, State),\r\n\r\n\t% load the model and set up the constraints\r\n\tfzn_load_stream(ModelStream, State),\r\n\r\n\t% perform the search\r\n\tfzn_search(State),\r\n\r\n\t% output solution, if found\r\n\tfzn_output(State).\r\n\r\n\r\n\r\n\r\nCreating FlatZinc Models\r\n\r\n\r\nNote that FlatZinc is not intended to be written by humans, but\r\ncreated by translating models written in Zinc or MiniZinc.  A\r\ntranslator for MiniZinc to FlatZinc called mzn2fzn is available at\r\n\r\nhttp://www.g12.csse.unimelb.edu.au/minizinc\r\n\r\n\r\nThe use of an intermediate FlatZinc file can be avoided by\r\npiping the result of the MiniZinc to FlatZinc converter directly\r\ninto the ECLiPSe-FlatZinc interpreter, e.g. via\r\n\r\n% mzn2fzn --output-to-stdout model.mzn | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\r\n\r\nThe file lib/fzn_ic/globals.mzn contains specialised global constraint\r\ndefinitinions for the use of fzn_ic.\r\nFor alternative ways to run MiniZinc models, see library(minizinc).\r\n\r\n\r\n\r\nHow to write a new solver mapping\r\n\r\n\r\nThe mapping from FlatZinc built-in operations to actual ECLiPSe solver\r\noperations is defined in separate modules called fzn_ic, fzn_eplex, etc. \r\nTo add a new mapping, create a new module file called fzn_xxx.ecl, and\r\nplace it in your library_path.\r\nThese modules should export predicates corresponding to the \"built-in\"\r\noperations defined by FlatZinc, i.e.\r\n\r\nint_lin_le/3, float_times/3,\r\n\r\netc.  See the FlatZinc specification for a complete list.\r\n\r\nIn addition to those, we require the following interface predicates:\r\n\r\nFor initialising variables:\r\n\r\nbool_declare(-var),\r\nint_declare(-var),\r\nint_declare(-var, +list),\r\nint_declare(-var, +min, +max),\r\nfloat_declare(-var),\r\nfloat_declare(-var, +min, +max),\r\nset_declare(-var, +min, +max),\r\nset_declare(-var, +list)\r\n\r\n\r\nFor initialising arrays:\r\n\r\nbool_declare_array(-array),\r\nint_declare_array(-array),\r\nint_declare_array(-array, +list),\r\nint_declare_array(-array, +min, +max),\r\nfloat_declare_array(-array),\r\nfloat_declare_array(-array, +min, +max),\r\nset_declare_array(-array, +min, +max),\r\nset_declare_array(-array, +list)\r\n\r\n\r\nFor invoking search:\r\n\r\nsatisfy(+annotations),\r\nminimize(+objective, +annotations, -cost),\r\nmaximize(+objective, +annotations, -cost)\r\n\r\n\r\nFor converting constants in the Zinc model to the appropriate solver\r\ntype in ECLiPSe (e.g. floats to breals when using lib(ic)):\r\n\r\nbool_fzn_to_solver(+atom, -bool),\r\nbool_solver_to_fzn(+bool, -atom),\r\nfloat_fzn_to_solver(+float, -real),\r\nfloat_solver_to_fzn(+real, -float),\r\nset_fzn_to_solver(+list, -set),\r\nset_solver_to_fzn(+set, -list),\r\nrange_fzn_to_solver(+min, +max, -set).\r\n\r\n\r\n\r\n\r\nTODO\r\n\r\n\r\ninterpret more variable annotations\r\nconstraint annotations (currently ignored)\r\nstricter checking of the FlatZinc input?"},"flatzinc:fzn_init/2":{"prefix":"fzn_init","body":"fzn_init(${1:SolverOrOptions}, ${2:FznState})$3\n$0","description":"fzn_init(++SolverOrOptions, -FznState)\n\n   Initialize a FlatZinc solver\n\nArguments\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n   FznState    Output: a FlatZinc state descriptor\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tInitialize a FlatZinc solver and return a descriptor, ready\r\n\tfor loading the model.  The given solver options are taken\r\n\tinto account and remembered in the descriptor.\r\n    \n\nModes and Determinism\n   fzn_init(++, -) is det\n\nExamples\n   \r\n    my_fzn_run_stream(ModelStream, Options) :-\r\n\tfzn_init(Options, State),\r\n\tfzn_load_stream(ModelStream, State),\r\n\tfzn_search(State),\r\n\tfzn_output(State).\r\n\nSee Also\n   fzn_load_stream / 2, fzn_search / 1, fzn_output / 1, struct(zn_options)"},"flatzinc:fzn_last/1":{"prefix":"fzn_last","body":"fzn_last(${1:FznState})$2\n$0","description":"fzn_last(+FznState)\n\n   Increments solutions count, and succeeds if last one reached\n\nArguments\n   FznState    a FlatZinc state descriptor\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tAssuming a model has previously been loaded successfully\r\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive can be used\r\n\tto limit the number of solutions produced.  It increments a\r\n\tnonlogical counter and fails as long as the number of solutions\r\n\tthat were requested in the zn_options has not yet been reached.\r\n    \n\nModes and Determinism\n   fzn_last(+) is semidet\n\nFail Conditions\n   Fails if not enough solutions found yet\n\nExamples\n   \r\n    my_fzn_run_stream(ModelStream, Options) :-\r\n\tfzn_init(Options, State),\r\n\tfzn_load_stream(ModelStream, State),\r\n\tfzn_search(State),\r\n\tfzn_output(State),\r\n\tfzn_last(State),\r\n\t!.\r\n    \n\nSee Also\n   struct(zn_options), fzn_init / 2, fzn_search / 1"},"flatzinc:fzn_load_stream/2":{"prefix":"fzn_load_stream","body":"fzn_load_stream(${1:ModelStream}, ${2:FznState})$3\n$0","description":"fzn_load_stream(+ModelStream, -FznState)\n\n   Load a FlatZinc model and set up its constraints\n\nArguments\n   ModelStream    An ECLiPSe stream name or handle\n   FznState    a FlatZinc state descriptor\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tLoad a FlatZinc model and set up its constraints.  The options\r\n\tthat were used in fzn_init/2 will be taken into account.\r\n\tIf fzn_load_stream/2 succeeds, all constraints have been\r\n\tsuccessfully set up, and the search phase can begin.\r\n    \r\n    \tThis predicate will always close ModelStream on success,\r\n\tfailure or abort.\r\n    \n\nModes and Determinism\n   fzn_load_stream(+, -) is semidet\n\nFail Conditions\n   Fails if any constraint fails during setup\n\nExamples\n   \r\n    my_fzn_run_stream(ModelStream, Options) :-\r\n\tfzn_init(Options, State),\r\n\tfzn_load_stream(ModelStream, State),\r\n\tfzn_search(State),\r\n\tfzn_output(State).\r\n\nSee Also\n   fzn_init / 2, fzn_search / 1, fzn_output / 1, fzn_var_lookup / 3, struct(zn_options)"},"flatzinc:fzn_obj_lookup/2":{"prefix":"fzn_obj_lookup","body":"fzn_obj_lookup(${1:FznState}, ${2:Obj})$3\n$0","description":"fzn_obj_lookup(+FznState, -Obj)\n\n   Find ECLiPSe term representing the Mini/FlatZinc model's objective\n\nArguments\n   FznState    a FlatZinc state descriptor\n   Obj    Output: ECLiPSe constant or domain variable\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tAssuming a model has previously been loaded successfully\r\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive returns\r\n\tthe ECLiPSe term that represents the model's objective.\r\n\tThis can be used for instance by a branch-and-bound primitive.\r\n    \n\nModes and Determinism\n   fzn_obj_lookup(+, -) is semidet\n\nFail Conditions\n   Fails if the model has no objective\n\nSee Also\n   fzn_load_stream / 2, fzn_var_lookup / 3, library(minizinc)"},"flatzinc:fzn_output/1":{"prefix":"fzn_output","body":"fzn_output(${1:FznState})$2\n$0","description":"fzn_output(+FznState)\n\n   Perform a FlatZinc model's output actions\n\nArguments\n   FznState    a FlatZinc state descriptor\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tAssuming that a FlatZinc model has previously been set up\r\n\tand solved, this predicate will perform the output actions\r\n\tspecified by the model's output annotations.  If no output\r\n\tannotations were given, no variable bindings will be printed.\r\n\tIn addition, statistics information will be printed to the\r\n\tlog_output stream.\r\n    \n\nModes and Determinism\n   fzn_output(+) is det\n\nExamples\n   \r\n    my_fzn_run_stream(ModelStream, Options) :-\r\n\tfzn_init(Options, State),\r\n\tfzn_load_stream(ModelStream, State),\r\n\tfzn_search(State),\r\n\tfzn_output(State).\r\n\nSee Also\n   fzn_init / 2, fzn_load_stream / 2, fzn_search / 1"},"flatzinc:fzn_run/1":{"prefix":"fzn_run","body":"fzn_run(${1:SolverOrOptions})$2\n$0","description":"fzn_run(+SolverOrOptions)\n\n   Run a FlatZinc model from standard input\n\nArguments\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tReads a FlatZinc model from the input stream, and interprets it using\r\n\tthe solver mapping defined in SolverOrOptions.  At the end of\r\n\tsolving, results are printed to the output stream, timing and\r\n\tprogress messages are printed to the log_output stream, warnings\r\n\tto the warning_output stream, and error messages the error stream.\r\n\tThis predicate always succeeds. It is equivalent to:\r\n    \r\n    fzn_run(SolverOrOptions) :-\r\n\tfzn_run_stream(input, SolverOrOptions).\r\n    \r\n    \n\nModes and Determinism\n   fzn_run(+) is det\n\nExamples\n   \r\n    % generate_model | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\r\n\nSee Also\n   fzn_run / 2, fzn_run_stream / 2"},"flatzinc:fzn_run/2":{"prefix":"fzn_run","body":"fzn_run(${1:File}, ${2:SolverOrOptions})$3\n$0","description":"fzn_run(+File, ++SolverOrOptions)\n\n   Run a FlatZinc model from a given file\n\nArguments\n   File    File name (extension defaults to .fzn)\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tReads a FlatZinc model from a file, and interprets it using\r\n\tthe solver mapping defined in SolverOrOptions.  At the end of\r\n\tsolving, results are printed to the output stream, timing and\r\n\tprogress messages are printed to the log_output stream, warnings\r\n\tto the warning_output stream, and error messages the error stream.\r\n\tThis predicate always succeeds.\r\n    \n\nModes and Determinism\n   fzn_run(+, ++) is det\n\nExamples\n   \r\n    ?- fzn_run(\"mymodel.fzn\", fzn_ic).\r\n\tFound a solution with cost 10\r\n\tFound no solution with cost 7.0 .. 9.0\r\n\tend = 10\r\n\tb1 = 1\r\n\tb2 = 0\r\n\tb3 = 1\r\n\tb4 = 0\r\n\tObjective value = 10\r\n\tTotal time 0.031s cpu (0.016 setup + 0.000 search)\r\n\nSee Also\n   fzn_run / 1, fzn_run_stream / 2"},"flatzinc:fzn_run_stream/2":{"prefix":"fzn_run_stream","body":"fzn_run_stream(${1:Stream}, ${2:SolverOrOptions})$3\n$0","description":"fzn_run_stream(+Stream, ++SolverOrOptions)\n\n   Run a FlatZinc model from a given open input stream\n\nArguments\n   Stream    ECLiPSe stream name or handle\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tReads a FlatZinc model from a stream, and interprets it using\r\n\tthe solver mapping defined in SolverOrOptions.  At the end of\r\n\tsolving, results are printed to the output stream, timing and\r\n\tprogress messages are printed to the log_output stream, warnings\r\n\tto the warning_output stream, and error messages the error stream.\r\n\tThis predicate always succeeds and closes the stream.\r\n    \n\nModes and Determinism\n   fzn_run_stream(+, ++) is det\n\nExamples\n   \r\n    ?- open(\"mymodel.fzn\",read,S), fzn_run_stream(S, fzn_ic).\r\n\tFound a solution with cost 10\r\n\tFound no solution with cost 7.0 .. 9.0\r\n\tend = 10\r\n\tb1 = 1\r\n\tb2 = 0\r\n\tb3 = 1\r\n\tb4 = 0\r\n\tObjective value = 10\r\n\tTotal time 0.031s cpu (0.016 setup + 0.000 search)\r\n\nSee Also\n   fzn_run / 1, fzn_run / 2"},"flatzinc:fzn_search/1":{"prefix":"fzn_search","body":"fzn_search(${1:FznState})$2\n$0","description":"fzn_search(+FznState)\n\n   Run the search part of a FlatZinc model\n\nArguments\n   FznState    FlatZinc state descriptor\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tPerform the search part of a FlatZinc model, as specified in\r\n\tthe model's solve-item.  The model must previously have been\r\n\tloaded successfully using fzn_load_xxx or mzn_load_xxx.\r\n\tIf the solve item was 'satisfy', multiple solutions may be\r\n\treturned on backtracking.\r\n    \n\nModes and Determinism\n   fzn_search(+) is nondet\n\nFail Conditions\n   Fails if no (further) solution is found\n\nExamples\n   \r\n    my_fzn_run_stream(ModelStream, Options) :-\r\n\tfzn_init(Options, State),\r\n\tfzn_load_stream(ModelStream, State),\r\n\tfzn_search(State),\r\n\tfzn_output(State).\r\n\nSee Also\n   fzn_init / 2, fzn_load_stream / 2, fzn_output / 1"},"flatzinc:fzn_var_lookup/3":{"prefix":"fzn_var_lookup","body":"fzn_var_lookup(${1:FznState}, ${2:Id}, ${3:Value})$4\n$0","description":"fzn_var_lookup(+FznState, +Id, -Value)\n\n   Find ECLiPSe term corresponding to Mini/FlatZinc identifier\n\nArguments\n   FznState    a FlatZinc state descriptor\n   Id    Mini/FlatZinc identifier (atom)\n   Value    Output: ECLiPSe constant, array or domain variable\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tAssuming a model has previously been loaded successfully\r\n\tusing fzn_load_xxx or mzn_load_xxx, this primitive provides\r\n\tthe mapping from Mini/FlatZinc identifier to the ECLiPSe\r\n\tterm that it is mapped to.\r\n    \n\nModes and Determinism\n   fzn_var_lookup(+, +, -) is semidet\n\nFail Conditions\n   Fails if there is no such identifier\n\nSee Also\n   fzn_load_stream / 2, fzn_obj_lookup / 2, library(minizinc)"},"flatzinc:zn_options/s":{"prefix":"struct","body":"struct","description":"struct zn_options(solver, fzn_tmp, output, parser, setup_prio, solutions, var_names)\n\n   Options for Mini/FlatZinc solving\n\nFields\n   solver    \r\n    \tDetermines which ECLiPSe solver(s) the FlatZinc variables and\r\n\tconstraints get mapped to. The name is the name of a library\r\n\timplementing the mapping, e.g. fzn_ic, fzn_fd or fzn_eplex.\r\n\tThe default is 'fzn_ic'.\n   fzn_tmp    \r\n\tOne of the atoms 'file' or 'pipe', determining if intermediate\r\n\tFlatZinc code is piped from the generator to the interpreter,\r\n\tor passed through an intermediate file. Default is 'file'.\n   output    \r\n    A stream (name or handle) to which the results are printed.\r\n    The default is 'output'.\n   parser    \r\n\tOne of the atoms 'strict' or 'fast', giving the choice between\r\n\ta stricter, but slower dedicated FlatZinc parser (in\r\n\tlib(flatzinc_parser)), or a faster parsing method (which\r\n\tdetects less errors because it uses the normal, but\r\n\treconfigured ECLiPSe parser).  Since FlatZinc input is\r\n\tnormally automatically generated, the default is to use the\r\n\tfaster and more permissive method 'fast'.\n   setup_prio    \r\n\tThe priority under which the constraint setup will be executed\r\n\t(see call_priority/2 and get_priority/1). Possible values are\r\n\tthe ECLiPSe priorities 1 to 12, or 0 (the default) which stands\r\n\tfor the current priority of the calling code.  A sensible value\r\n\tfor this option is 2, which means that the setup code is executed\r\n\tunder high priority (still allowing debug/visualisation goals).\r\n\tThe effect of such a setting is that no propagation occurs until\r\n\tall constraints are fully set up, possibly leading to time savings.\n   solutions    \r\n\tThe maximum number of solutions computed (and possibly output).\r\n\tOnly effective if no minimization/maximization is done.\r\n\tOnly effective for toplevel predicates like fzn_run/mzn_run\r\n\tthat are deterministic and do not succeed once per solution.\r\n\tDefault is 1, 'all' (or 0) means no limit.\n   var_names    \r\n\tIf this option is set to 'on', the ECLiPSe variables representing\r\n\tZinc variables will be marked with their Zinc names, using the\r\n\tfacilities of lib(var_name).  This is mainly useful for debugging.\r\n\tThe default is 'off' to save space and time.\n\nType\n   library(flatzinc)\n\nDescription\n\r\n\tUsed to specify options for Mini/FlatZinc solving.\r\n    \r\n    \tAll predicates that accept the zn_options structure also accept\r\n\tthe name of a solver mapping library alone. In this case, all\r\n\tother options take their default values.\r\n    \n\nExamples\n   \r\n    ?- fzn_run(\"queens.fzn\", fzn_ic).\r\n    ?- fzn_run(\"queens.fzn\", zn_options{solver:fzn_ic,solutions:3}).\r\n    \n\nSee Also\n   fzn_run / 1, fzn_run / 2, fzn_run_stream / 2, fzn_init / 2"},"flatzinc:zn_var/s":{"prefix":"struct","body":"struct","description":"struct zn_var(id, ann, type, group, eclvar, num)\n\n   Descriptor for a Mini/FlatZinc variable\n\nFields\n   id    (atom) Mini/FlatZinc name\n   ann    List of variable annotations\n   type    FlatZinc type descriptor (structure)\n   group    simplified type descriptor (atom)\n   eclvar    Corresponding ECLiPSe variable\n   num    Variable number in input order\n\nType\n   library(flatzinc)\n\nSee Also\n   fzn_var_lookup / 3"},"flatzinc_parser:flatzinc_parser_desc":{"prefix":"lib","body":"lib(${1:flatzinc_parser})$2\n$0","description":"lib(flatzinc_parser)\n\nA parser for FlatZinc, based on 'Specification of FlatZinc' (Nov 7 2007).\nIt reads and returns one item at a time, as an ECLiPSe structure which\nclosely resembles the FZ input.\n\nFor FlatZinc, it seems an item-wise parser is a good idea, since the\nitems can be processed one at a time by ECLiPSe to set up the model."},"flatzinc_parser:read_item/2":{"prefix":"read_item","body":"read_item(${1:Stream}, ${2:Item})$3\n$0","description":"read_item(+Stream, -Item)\n\n   Read one item from a FlatZinc input stream\n\nArguments\n   Stream    ECLiPSe stream name or handle\n   Item    Output: an ECLiPSe term that describes the FlatZinc item\n\nType\n   library(flatzinc_parser)\n\nDescription\n\n\tReads one FlatZinc item (up to and including the terminating\n\tsemicolon) from Stream, and returns it as an ECLiPSe structure.\n\tFails when end_of_file has been reached.\n    \n\nModes and Determinism\n   read_item(+, -) is semidet\n\nFail Conditions\n   Fails if end_of_file is reached\n\nExceptions\n   fz_abort --- syntax error\n\nExamples\n   \n    ?- read_item(input, Item).\n    > float: x=3.14;\n    Item = float : x = 3.14\n    Yes (0.00s cpu)\n\n    ?- read_item(input, Item).\n    > solve minimize x;\n    Item = minimize(solve, x)\n    Yes (0.03s cpu)\n\n    ?- read_item(input, Item).\n    > var int: i::foo::bar;\n    Item = var(int) : (i :: (foo :: bar))\n    Yes (0.02s cpu)\n\n    ?- read_item(input, Item).\n    > constraint int_lt(x[2], 3);\n    Item = constraint(int_lt(subscript(x, [2]), 3))\n    Yes (0.00s cpu)\n\n    ?- read_item(input, Item).\n    > set of  int: s={1,2,3};\n    Item = (set of int) : s = {[1, 2, 3]}\n    Yes (0.05s cpu)\n\n    ?- read_item(input, Item).\n    > array [1..3] of var int: a;\n    Item = (array([1 .. 3]) of var(int)) : a\n    Yes (0.03s cpu)\n\n    ?- read_item(input, Item).\n    > var 1..5: i;\n    Item = var(1 .. 5) : i\n    Yes (0.03s cpu)"},"fzn_eplex:fzn_eplex_desc":{"prefix":"lib","body":"lib(${1:fzn_eplex})$2\n$0","description":"lib(fzn_eplex)\n\nThis module defines a mapping from FlatZinc operations to lib(eplex)\nand is intended to be used in conjunction with lib(flatzinc).\n\nTODO:\tAdd a mapping for sets as array of booleans.\nAdd an appropriate globals.mzn."},"fzn_fd:fzn_fd_desc":{"prefix":"lib","body":"lib(${1:fzn_fd})$2\n$0","description":"lib(fzn_fd)\n\nThis module defines a mapping from FlatZinc operations to lib(fd),\nlib(fd_sets) and lib(fd_global), and is intended to be used in\nconjunction with lib(flatzinc).  It uses lib(propia) to implement\nvariants of the element constraint that are not supported by lib(fd).\nMoreover, lib(branch_and_bound) is used to provide optimization.\n\nThis mapping supports bool, integer and set variables.\nIt does currently not support all constraints in reified form,\nin particular set constraints, according to the limitations of\nthe underlying solvers.\n\nThe following extra annotations are supported by this mapping:\n\nannotation strategy(string:s)\n    the branch-and-bound strategy (default: \"continue\"). Valid names\n    are \"continue\", \"restart\", \"dichotomic\", See bb_min/3.\nannotation delta(float:f)\n    minimal absolute improvement for branch-and-bound steps (default 1.0).\n    See bb_min/3.\nannotation factor(float:f)\n    minimal improvement ratio (with respect to the lower cost bound)\n    for strategies 'continue' and 'restart' (default 1.0), or split factor\n    for strategy 'dichotomic' (default 0.5). See bb_min/3.\nannotation timeout(float:f)\n    timeout for branch-and-bound in seconds (default: unlimited).\n    See bb_min/3.\n\nYou must include \"eclipse.mzn\" in your MiniZinc model to use these\nannotations."},"fzn_ic:fzn_ic_desc":{"prefix":"lib","body":"lib(${1:fzn_ic})$2\n$0","description":"lib(fzn_ic)\n\nThis module defines a mapping from FlatZinc operations to lib(ic), \nlib(ic_sets) and lib(ic_global), and is intended to be used in\nconjunction with lib(flatzinc).  It uses lib(propia) to implement\nvariants of the element constraint that are not supported by lib(ic).\nMoreover, lib(branch_and_bound) is used to provide optimization.\n\nThis mapping supports bool, integer, float and set variables.\nIt does currently not support all constraints in reified form,\nin particular set constraints, according to the limitations of\nthe underlying solvers.\n\nThe following extra annotations are supported by this mapping:\n\nannotation strategy(string:s)\n    the branch-and-bound strategy (default: \"continue\"). Valid names\n    are \"continue\", \"restart\", \"dichotomic\", See bb_min/3.\nannotation delta(float:f)\n    minimal absolute improvement for branch-and-bound steps (default 1.0).\n    See bb_min/3.\nannotation factor(float:f)\n    minimal improvement ratio (with respect to the lower cost bound)\n    for strategies 'continue' and 'restart' (default 1.0), or split factor\n    for strategy 'dichotomic' (default 0.5). See bb_min/3.\nannotation timeout(float:f)\n    timeout for branch-and-bound in seconds (default: unlimited).\n    See bb_min/3.\n\nYou must include \"eclipse.mzn\" in your MiniZinc model to use these\nannotations."},"grasper:asymmetric/1":{"prefix":"asymmetric","body":"asymmetric(${1:Graph})$2\n$0","description":"asymmetric(+Graph)\n\n   Ensures Graph is asymmetric\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nEnsures that for every edge (x,y) added to the Graph the symmetric edge (y,x) is removed.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be enforced to be asymmetric.\r\n\t\t\t\n\nResatisfiable\n   ?\n\nExamples\n   \r\n?- asymmetric(G).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[2,3],[3,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), asymmetric(G).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), asymmetric(G).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _658, fd:[0..3]}, _550, _551, _552, [], [], ['SUSP-_2571-susp'], ['SUSP-_2181-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _867, fd:[0..6]}, _759, _760, _761, [], ['SUSP-_3006-susp', 'SUSP-_2581-susp'], [], ['SUSP-_2882-dead'])}\r\nG = dirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _658, fd:[0..3]}, _550, _551, _552, [], [], ['SUSP-_2571-susp'], ['SUSP-_2181-dead'])}, E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _867, fd:[0..6]}, _759, _760, _761, [], ['SUSP-_3006-susp', 'SUSP-_2581-susp'], [], ['SUSP-_2882-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), asymmetric(G).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _688, fd : [2, 3]}, _580, _581, _582, [], [], ['SUSP-_2633-susp'], ['SUSP-_2243-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 3], [3, 1], [3, 2]] : 5], Card{cardinal : _902, fd : [1 .. 5]}, _794, _795, _796, [], ['SUSP-_3117-susp', 'SUSP-_2643-susp'], [], ['SUSP-_2970-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _688, fd : [2, 3]}, _580, _581, _582, [], [], ['SUSP-_2633-susp'], ['SUSP-_2243-dead'])}, E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 3], [3, 1], [3, 2]] : 5], Card{cardinal : _902, fd : [1 .. 5]}, _794, _795, _796, [], ['SUSP-_3117-susp', 'SUSP-_2643-susp'], [], ['SUSP-_2970-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1]], dirgraph(G,V,E), asymmetric(G).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _658, fd : [2, 3]}, _550, _551, _552, [], [], ['SUSP-_2556-susp'], ['SUSP-_2166-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 3], [3, 1]] : 4], Card{cardinal : _864, fd : [1 .. 4]}, _756, _757, _758, [], ['SUSP-_3040-susp', 'SUSP-_2566-susp'], [], ['SUSP-_2893-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _658, fd : [2, 3]}, _550, _551, _552, [], [], ['SUSP-_2556-susp'], ['SUSP-_2166-dead'])}, E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 3], [3, 1]] : 4], Card{cardinal : _864, fd : [1 .. 4]}, _756, _757, _758, [], ['SUSP-_3040-susp', 'SUSP-_2566-susp'], [], ['SUSP-_2893-dead'])})"},"grasper:complementary_graph/2":{"prefix":"complementary_graph","body":"complementary_graph(${1:Graph}, ${2:ComplementaryGraph})$3\n$0","description":"complementary_graph(+Graph, ?ComplementaryGraph)\n\n   Obtains the complementary graph of a given graph.\n\nArguments\n   Graph    A graph.\n   ComplementaryGraph  The complementary graph of Graph.\n\nType\n   library(grasper)\n\nDescription\nObtains the complementary graph of a given graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be constrained to have ComplementaryGraph as its complementary graph (ComplementarGraph is a graph variable).\r\n\t\t\t\n\nExamples\n   \r\n?- complementary_graph(G,CG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], CE`::[]..[[1,2],[3,2],[1,3]], dirgraph(G,V,E), dirgraph(CG,V,CE), complementary_graph(G,CG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), complementary_graph(G,CG), graph_labeling(G).\r\nV = [1, 2]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2], [[1, 2]])\r\nCG = dirgraph([1, 2], [[1, 1], [2, 1], [2, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2, 3], [[1, 2]])\r\nCG = dirgraph([1, 2, 3], [[1, 1], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [3, 1]])\r\nCG = dirgraph([1, 2, 3], [[1, 1], [1, 3], [2, 1], [2, 2], [2, 3], [3, 2], [3, 3]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3]])\r\nCG = dirgraph([1, 2, 3], [[1, 1], [1, 3], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3], [3, 1]])\r\nCG = dirgraph([1, 2, 3], [[1, 1], [1, 3], [2, 1], [2, 2], [3, 2], [3, 3]])\r\nYes\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], CE`::[[2,3],[3,2]]..[[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]], dirgraph(G,V,E), dirgraph(CG,V,CE), complementary_graph(G,CG), graph_labeling(G).\r\nV = [2, 3]\r\nE = []\r\nCE = [[2, 2], [2, 3], [3, 2], [3, 3]]\r\nG = dirgraph([2, 3], [])\r\nCG = dirgraph([2, 3], [[2, 2], [2, 3], [3, 2], [3, 3]])\r\nYes"},"grasper:connected/1":{"prefix":"connected","body":"connected(${1:Graph})$2\n$0","description":"connected(+Graph)\n\n   Guarantees that an undirected graph Graph is connected.\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nGuarantees that an undirected graph Graph is connected, i.e., that each vertex is reachable from any other one.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not an undirected graph variable or\r\n\t\t\t if Graph can not be constrained to be connected.\r\n\t\t\t\n\nExamples\n   \r\n?- connected(G).\r\nNo.\r\n\r\n?- V`::[1,2]..[1,2,3,4], E`::[]..[[1,3],[2,4],[3,1],[4,2]], undirgraph(G,V,E), connected(G).\r\nNo.\r\n\r\n?- V`::[1,2]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E), connected(G), graph_labeling(G).\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = undirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 3], [2, 3], [3, 1], [3, 2]]\r\nG = undirgraph([1, 2, 3], [[1, 3], [2, 3], [3, 1], [3, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 1], [2, 3], [3, 2]]\r\nG = undirgraph([1, 2, 3], [[1, 2], [2, 1], [2, 3], [3, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [1, 3], [2, 1], [3, 1]]\r\nG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [3, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\r\nG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]])\r\nYes"},"grasper:dirgraph/3":{"prefix":"dirgraph","body":"dirgraph(${1:Graph}, ${2:VertexSet}, ${3:EdgeSet})$4\n$0","description":"dirgraph(-Graph, +VertexSet, +EdgeSet)\n\n   Directed graph constructor.\n\nArguments\n   Graph    A directed graph.\n   VertexSet    The vertex-set that constitutes Graph.\n   EdgeSet    The edge-set that constitutes Graph.\n\nType\n   library(grasper)\n\nDescription\nCreates Graph as a directed graph variable composed by the vertexes in VertexSet and the edges in EdgeSet.\n\nFail Conditions\n   Fails \r\n\t\t\t if VertexSet is not a set variable,\r\n\t\t\t if EdgeSet is not a set variable or\r\n\t\t\t if EdgeSet cannot be contained in (VertexSet x VertexSet).\r\n\t\t\t\n\nExamples\n   \r\n?- E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], dirgraph(G,V,E).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[[4,5]]..[[1,2],[2,3],[3,1],[4,5]], dirgraph(G,V,E).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _543, fd:[0..3]}, _435, _436, _437, [], [], ['SUSP-_2315-susp'], ['SUSP-_1925-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [2, 3], [3, 1]]:3], Card{cardinal : _728, fd:[0..3]}, _620, _621, _622, [], ['SUSP-_2325-susp'], [], ['SUSP-_1641-dead'])}\r\nG = dirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _543, fd:[0..3]}, _435, _436, _437, [], [], ['SUSP-_2315-susp'], ['SUSP-_1925-dead'])}, E{cardinal([[]:0, [[1, 2], [2, 3], [3, 1]]:3], Card{cardinal : _728, fd:[0..3]}, _620, _621, _622, [], ['SUSP-_2325-susp'], [], ['SUSP-_1641-dead'])})\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1],[4,5]], dirgraph(G,V,E).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _573, fd:[0..3]}, _465, _466, _467, [], [], ['SUSP-_2391-susp'], ['SUSP-_2001-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [2, 3], [3, 1]]:3], Card{cardinal : _766, fd:[0..3]}, _658, _659, _660, [], ['SUSP-_2401-susp'], [], ['SUSP-_1717-dead'])}\r\nG = dirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _573, fd:[0..3]}, _465, _466, _467, [], [], ['SUSP-_2391-susp'], ['SUSP-_2001-dead'])}, E{cardinal([[]:0, [[1, 2], [2, 3], [3, 1]]:3], Card{cardinal : _766, fd:[0..3]}, _658, _659, _660, [], ['SUSP-_2401-susp'], [], ['SUSP-_1717-dead'])})\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E).\r\nV = V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _573, fd:[2, 3]}, _465, _466, _467, [], [], ['SUSP-_2363-susp'], ['SUSP-_1987-dead'])}\r\nE = E{cardinal([[[1, 2]]:1, [[2, 3], [3, 1]]:3], Card{cardinal : _763, fd:[1..3]}, _655, _656, _657, [], ['SUSP-_2373-susp'], [], ['SUSP-_1681-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _573, fd:[2, 3]}, _465, _466, _467, [], [], ['SUSP-_2363-susp'], ['SUSP-_1987-dead'])}, E{cardinal([[[1, 2]]:1, [[2, 3], [3, 1]]:3], Card{cardinal : _763, fd:[1..3]}, _655, _656, _657, [], ['SUSP-_2373-susp'], [], ['SUSP-_1681-dead'])})"},"grasper:export_graph/2":{"prefix":"export_graph","body":"export_graph(${1:Graph}, ${2:File})$3\n$0","description":"export_graph(+Graph, ++File)\n\n   Exports Graph to Filename in a .dot format which can then be loaded by GraphViz.\n\nArguments\n   Graph    A graph.\n   File    Name of the file where a GraphViz 'dot' format of the graph is to be exported.\n\nType\n   library(grasper)\n\nDescription\nExports Graph to Filename in a .dot format which can then be loaded by GraphViz."},"grasper:getEdgeSet/2":{"prefix":"getEdgeSet","body":"getEdgeSet(${1:Graph}, ${2:EdgeSet})$3\n$0","description":"getEdgeSet(+Graph, ?EdgeSet)\n\n   Obtains a graph's edge-set.\n\nArguments\n   Graph    A graph.\n   EdgeSet    Graph's edge-set.\n\nType\n   library(grasper)\n\nDescription\nObtains a graph's edge-set.\n\nFail Conditions\n   Fails\r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if EdgeSet can not be matched with Graph's edge-set.\r\n\t\t\t\n\nExamples\n   \r\n?- getEdgeSet(G,E).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getEdgeSet(G,[[2,3],[3,2]]).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getEdgeSet(G,E_1).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}\r\nE = E_1{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}, E_1{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])})\r\nE_1 = E_1{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getEdgeSet(G,[[1,2],[2,3],[3,1]]).\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3], [3, 1]])\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), E_1`::[]..[[1,2],[2,3],[3,1]], getEdgeSet(G,E_1).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _830, fd : [2, 3]}, _722, _723, _724, [], [], ['SUSP-_2775-susp'], ['SUSP-_2385-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _1044, fd : [1 .. 3]}, Min1, Max1, Union2, [], ['SUSP-_2785-susp'], [], [])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _830, fd : [2, 3]}, _722, _723, _724, [], [], ['SUSP-_2775-susp'], ['SUSP-_2385-dead'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _1044, fd : [1 .. 3]}, Min1, Max1, Union2, [], ['SUSP-_2785-susp'], [], [])})\r\nE_1 = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _1044, fd : [1 .. 3]}, Min1, Max1, Union2, [], ['SUSP-_2785-susp'], [], [])}"},"grasper:getVertexSet/2":{"prefix":"getVertexSet","body":"getVertexSet(${1:Graph}, ${2:VertexSet})$3\n$0","description":"getVertexSet(+Graph, ?VertexSet)\n\n   Obtains a graph's vertex-set.\n\nArguments\n   Graph    A graph.\n   VertexSet    Graph's vertex-set.\n\nType\n   library(grasper)\n\nDescription\nObtains a graph's vertex-set.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if VertexSet can not be matched with Graph's vertex-set.\r\n\t\t\t\n\nExamples\n   \r\n?- getVertexSet(G,V).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getVertexSet(G,[2,3]).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getVertexSet(G,V_1).\r\nV = V_1{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])}\r\nG = dirgraph(V_1{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}, E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])})\r\nV_1 = V_1{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), getVertexSet(G,[1,2]).\r\nV = [1, 2]\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 1]] : 2], Card{cardinal : _962, fd : [1, 2]}, _854, _855, _856, [], ['SUSP-_3006-dead', 'SUSP-_2703-susp'], [], ['SUSP-_3312-dead'])}\r\nG = dirgraph([1, 2], E{cardinal([[[1, 2]] : 1, [[2, 1]] : 2], Card{cardinal : _962, fd : [1, 2]}, _854, _855, _856, [], ['SUSP-_3006-dead', 'SUSP-_2703-susp'], [], ['SUSP-_3312-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), V_1`::[]..[1,2], getVertexSet(G,V_1).\r\nV = V{cardinal([[] : 0, [1, 2] : 2], Card{cardinal : _730, fd : [0 .. 2]}, Min1, Max1, Union2, [], [], ['SUSP-_2643-susp'], [])}\r\nE = E{cardinal([[] : 0, [[1, 2], [2, 1]] : 2], Card{cardinal : _939, fd : [0 .. 2]}, _831, _832, _833, [], ['SUSP-_3239-dead', 'SUSP-_2653-susp'], [], ['SUSP-_3547-dead'])}\r\nG = dirgraph(V{cardinal([[] : 0, [1, 2] : 2], Card{cardinal : _730, fd : [0 .. 2]}, Min1, Max1, Union2, [], [], ['SUSP-_2643-susp'], [])}, E{cardinal([[] : 0, [[1, 2], [2, 1]] : 2], Card{cardinal : _939, fd : [0 .. 2]}, _831, _832, _833, [], ['SUSP-_3239-dead', 'SUSP-_2653-susp'], [], ['SUSP-_3547-dead'])})\r\nV_1 = V{cardinal([[] : 0, [1, 2] : 2], Card{cardinal : _730, fd : [0 .. 2]}, Min1, Max1, Union2, [], [], ['SUSP-_2643-susp'], [])}"},"grasper:graph_labeling/1":{"prefix":"graph_labeling","body":"graph_labeling(${1:Graph})$2\n$0","description":"graph_labeling(+Graph)\n\n   Labels a graph variable.\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nLabels a graph variable.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable.\r\n\t\t\t\n\nExamples\n   \r\n?- graph_labeling(G).\r\nNo.\r\n\r\n?- V`::[]..[1,2], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), graph_labeling(G).\r\nV = []\r\nE = []\r\nG = dirgraph([], [])\r\nYes ? ;\r\n\r\nV = [2]\r\nE = []\r\nG = dirgraph([2], [])\r\nYes ? ;\r\n\r\nV = [1]\r\nE = []\r\nG = dirgraph([1], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = []\r\nG = dirgraph([1, 2], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[2, 1]]\r\nG = dirgraph([1, 2], [[2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2], [[1, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = dirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes\r\n\r\n?- V`::[]..[1,2], E`::[]..[[1,2],[2,1]], undirgraph(G,V,E), graph_labeling(G).\r\nV = []\r\nE = []\r\nG = undirgraph([], [])\r\nYes ? ;\r\n\r\nV = [2]\r\nE = []\r\nG = undirgraph([2], [])\r\nYes ? ;\r\n\r\nV = [1]\r\nE = []\r\nG = undirgraph([1], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = []\r\nG = undirgraph([1, 2], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = undirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes"},"grasper:graph_labeling/3":{"prefix":"graph_labeling","body":"graph_labeling(${1:Graph}, ${2:VertexHeuristic}, ${3:EdgeHeuristic})$4\n$0","description":"graph_labeling(+Graph, ++VertexHeuristic, ++EdgeHeuristic)\n\n   Labels a graph variable using VertexHeuristic and EdgeHeuristic.\n\nArguments\n   Graph    A graph.\n   VertexHeuristic     'up' for starting vertex inclusion first / 'down' for starting vertex exclusion first.\n   EdgeHeuristic       'up' for starting edge inclusion first / 'down' for starting edge exclusion first.\n\nType\n   library(grasper)\n\nDescription\nLabels a graph variable using VertexHeuristic and EdgeHeuristic.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if VertexHeuristic is not in {down,up} or\r\n\t\t\t if EdgeHeuristic is not in {down,up}.\r\n\t\t\t\n\nExamples\n   \r\n?- graph_labeling(G,down,up).\r\nNo.\r\n\r\n?- V`::[]..[1,2], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), graph_labeling(G,d,up).\r\nNo.\r\n\r\n?- V`::[]..[1,2], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), graph_labeling(G,down,u).\r\nNo.\r\n\r\n?- V`::[]..[1,2], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), graph_labeling(G,down,up).\r\nV = []\r\nE = []\r\nG = dirgraph([], [])\r\nYes ? ;\r\n\r\nV = [2]\r\nE = []\r\nG = dirgraph([2], [])\r\nYes ? ;\r\n\r\nV = [1]\r\nE = []\r\nG = dirgraph([1], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = dirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2], [[1, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[2, 1]]\r\nG = dirgraph([1, 2], [[2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = []\r\nG = dirgraph([1, 2], [])\r\nYes"},"grasper:grasper_desc":{"prefix":"lib","body":"lib(${1:grasper})$2\n$0","description":"lib(grasper)\n\n\r\n    Graph-based constraint programming can be declaratively used for path\r\n    and circuit finding problems, to routing, scheduling and allocation\r\n    problems, among others.  CP(Graph) was proposed by G.  Dooms et al. \r\n    as a general approach to solve graph-based constraint problems.  It\r\n    provides a key set of basic constraints which represent the\r\n    framework's core, and higher level constraints for solving path\r\n    finding and optimization problems, and to enforce graph properties.\r\n    \r\n    The GRASPER (GRAph constraint Satisfaction Problem solvER) library\r\n    is an alternative framework for graph-based constraint solving\r\n    based on Cardinal, a finite sets constraint solver with extra\r\n    inferences developed in Universidade Nova de Lisboa.  It provides\r\n    a set of basic constraints which represent the core of our\r\n    framework and functionality for directed graphs, graph weighting,\r\n    graph matching, graph path optimization problems and some of the\r\n    most common graph properties.\r\n    \r\n    More information in this\r\n    background paper."},"grasper:order/2":{"prefix":"order","body":"order(${1:Graph}, ${2:Order})$3\n$0","description":"order(+Graph, ?Order)\n\n   Obtains a graph's order.\n\nArguments\n   Graph    A graph.\n   Order    The order of the graph.\n\nType\n   library(grasper)\n\nDescription\nDetermines the number of vertices composing a graph variable.\n\nFail Conditions\n   Fails\r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be constrained to have a vertex-set with a cardinality delimited by Order.\r\n\t\t\t\n\nExamples\n   \r\n?- order(Graph,Order).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), order(G,0).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), order(G,4).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), order(G,Order).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Order{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Order{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}, E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])})\r\nOrder = Order{cardinal : _700, fd : [2, 3]}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), order(G,2).\r\nV = [1, 2]\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 1]] : 2], Card{cardinal : _909, fd : [1, 2]}, _801, _802, _803, [], ['SUSP-_2957-dead', 'SUSP-_2650-susp'], [], ['SUSP-_3263-dead'])}\r\nG = dirgraph([1, 2], E{cardinal([[[1, 2]] : 1, [[2, 1]] : 2], Card{cardinal : _909, fd : [1, 2]}, _801, _802, _803, [], ['SUSP-_2957-dead', 'SUSP-_2650-susp'], [], ['SUSP-_3263-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), order(G,3).\r\nV = [1, 2, 3]\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _909, fd : [1 .. 6]}, _801, _802, _803, [], ['SUSP-_2650-susp'], [], ['SUSP-_1944-dead'])}\r\nG = dirgraph([1, 2, 3], E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _909, fd : [1 .. 6]}, _801, _802, _803, [], ['SUSP-_2650-susp'], [], ['SUSP-_1944-dead'])})"},"grasper:oriented_graph/2":{"prefix":"oriented_graph","body":"oriented_graph(${1:UndirectedGraph}, ${2:DirectedGraph})$3\n$0","description":"oriented_graph(+UndirectedGraph, ?DirectedGraph)\n\n   Obtains an oriented graph of a given undirected graph.\n\nArguments\n   UndirectedGraph     An undirected graph.\n   DirectedGraph       The oriented directed graph of UndirectedGraph.\n\nType\n   library(grasper)\n\nDescription\nObtains an oriented graph of a given undirected graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if UndirectedGraph is not an undirected graph variable or\r\n\t\t\t if UndirectedGraph can not be contrained to have DirectedGraph as an oriented graph (DirectedGraph is a directed graph variable).\r\n\t\t\t\n\nExamples\n   \r\n?- oriented_graph(UG,DG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], DE`::[[3,1]]..[[1,2],[2,3],[3,1]], UE`::[]..[[1,2],[2,1],[2,3],[3,2]], dirgraph(DG,V,DE), undirgraph(UG,V,UE), oriented_graph(UG,DG).\r\nNo.\r\n\r\n?- undirgraph(UG,[1,2,3],[[1,2],[2,1]]), oriented_graph(UG,DG), graph_labeling(DG).\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nDG = dirgraph([1, 2, 3], [[2, 1]])\r\nYes ? ;\r\n\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nDG = dirgraph([1, 2, 3], [[1, 2]])\r\nYes ? ;\r\n\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nDG = dirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nYes\r\n\r\n?- V`::[]..[1,2,3], DE`::[]..[[1,2],[3,1]], UE`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(DG,V,DE), undirgraph(UG,V,UE), oriented_graph(UG,DG), size(DG,Size), Size #> 0, graph_labeling(DG).\r\nV = [1, 3]\r\nDE = [[3, 1]]\r\nUE = [[1, 3], [3, 1]]\r\nDG = dirgraph([1, 3], [[3, 1]])\r\nUG = undirgraph([1, 3], [[1, 3], [3, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nDE = [[1, 2]]\r\nUE = [[1, 2], [2, 1]]\r\nDG = dirgraph([1, 2], [[1, 2]])\r\nUG = undirgraph([1, 2], [[1, 2], [2, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[3, 1]]\r\nUE = [[1, 3], [3, 1]]\r\nDG = dirgraph([1, 2, 3], [[3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 3], [3, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2]]\r\nUE = [[1, 2], [2, 1]]\r\nDG = dirgraph([1, 2, 3], [[1, 2]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2], [3, 1]]\r\nUE = [[1, 2], [1, 3], [2, 1], [3, 1]]\r\nDG = dirgraph([1, 2, 3], [[1, 2], [3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [3, 1]])\r\nSize = 2\r\nYes"},"grasper:path/3":{"prefix":"path","body":"path(${1:Graph}, ${2:OriginVertex}, ${3:TerminusVertex})$4\n$0","description":"path(+Graph, +OriginVertex, +TerminusVertex)\n\n   Ensures Graph represents a path between OriginVertex and TerminusVertex in Graph.\n\nArguments\n   Graph    A graph.\n   OriginVertex    Initial vertex in the path between OriginVertex and TerminusVertex in Graph.\n   TerminusVertex      Final vertex in the path between OriginVertex and TerminusVertex in Graph.\n\nType\n   library(grasper)\n\nDescription\nEnsures Graph represents a path between OriginVertex and TerminusVertex in Graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if OriginVertex does not belong to Graph's vertex-set,\r\n\t\t\t if TerminusVertex does not belong to Graph's vertex-set or\r\n\t\t\t if Graph can not be constrained to define a path between OriginVertex and TerminusVertex.\r\n\t\t\t\n\nExamples\n   \r\n?- path(G,Origin,Terminus).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3,4], E`::[]..[[1,2],[1,3],[1,4],[2,4],[3,4]], dirgraph(G,V,E), path(G, 1, 5).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3,4], E`::[]..[[1,2],[1,3],[1,4],[2,4],[3,4]], dirgraph(G,V,E), path(G, 5, 1).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3,4], E`::[]..[[1,2],[1,3],[1,4],[2,4],[3,4]], dirgraph(G,V,E), path(G, 4, 1).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3,4], E`::[]..[[1,2],[1,3],[1,4],[2,4],[3,4]], dirgraph(G,V,E), path(G, 1, 4), graph_labeling(G).\r\nV = [1, 4]\r\nE = [[1, 4]]\r\nG = dirgraph([1, 4], [[1, 4]])\r\nYes ? ;\r\n\r\nV = [1, 3, 4]\r\nE = [[1, 3], [3, 4]]\r\nG = dirgraph([1, 3, 4], [[1, 3], [3, 4]])\r\nYes ? ;\r\n\r\nV = [1, 2, 4]\r\nE = [[1, 2], [2, 4]]\r\nG = dirgraph([1, 2, 4], [[1, 2], [2, 4]])\r\nYes\r\n\r\n?- V`::[]..[1,2,3,4], E`::[]..[[1,2],[1,3],[1,4],[2,1],[2,4],[3,1],[3,4],[4,1],[4,2],[4,3]], undirgraph(G,V,E), path(G, 1, 4), graph_labeling(G).\r\nV = [1, 3, 4]\r\nE = [[1, 3], [3, 1], [3, 4], [4, 3]]\r\nG = undirgraph([1, 3, 4], [[1, 3], [3, 1], [3, 4], [4, 3]])\r\nYes ? ;\r\n\r\nV = [1, 3, 4]\r\nE = [[1, 3], [1, 4], [3, 1], [3, 4], [4, 1], [4, 3]]\r\nG = undirgraph([1, 3, 4], [[1, 3], [1, 4], [3, 1], [3, 4], [4, 1], [4, 3]])\r\nYes ? ;\r\n\r\nV = [1, 2, 4]\r\nE = [[1, 2], [2, 1], [2, 4], [4, 2]]\r\nG = undirgraph([1, 2, 4], [[1, 2], [2, 1], [2, 4], [4, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 4]\r\nE = [[1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2]]\r\nG = undirgraph([1, 2, 4], [[1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3, 4]\r\nE = [[1, 2], [1, 3], [2, 1], [2, 4], [3, 1], [3, 4], [4, 2], [4, 3]]\r\nG = undirgraph([1, 2, 3, 4], [[1, 2], [1, 3], [2, 1], [2, 4], [3, 1], [3, 4], [4, 2], [4, 3]])\r\nYes"},"grasper:predecessors/3":{"prefix":"predecessors","body":"predecessors(${1:Graph}, ${2:Vertex}, ${3:PredSet})$4\n$0","description":"predecessors(+Graph, +Vertex, ?PredSet)\n\n   Determines the predecessor-set of a vertex in a graph.\n\nArguments\n   Graph    A graph.\n   Vertex    A vertex of Graph.\n   PredSet    Set of predecessors of Vertex in Graph.\n\nType\n   library(grasper)\n\nDescription\nDetermines the predecessor-set of a vertex in a graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if Vertex does not belong to Graph's vertex-set or\r\n\t\t\t if Graph can not be constrained to have the vertices in PredSet as predecessors of Vertex.\r\n\t\t\t\n\nExamples\n   \r\n?- predecessors(G,V,Preds).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), predecessors(G,4,Preds).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), predecessors(G,2,[1,3,4]).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), predecessors(G,2,Preds).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2921-susp', 'SUSP-_2484-susp'], ['SUSP-_3073-susp'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3506-susp', 'SUSP-_2494-susp'], ['SUSP-_3518-susp'], ['SUSP-_1802-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2921-susp', 'SUSP-_2484-susp'], ['SUSP-_3073-susp'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3506-susp', 'SUSP-_2494-susp'], ['SUSP-_3518-susp'], ['SUSP-_1802-dead'])})\r\nPreds = Preds{cardinal([[1] : 1, [3] : 2], PredCard{cardinal : _2731, fd : [1, 2]}, _2623, _2624, _2625, [], ['SUSP-_3530-susp', 'SUSP-_2803-susp'], ['SUSP-_3542-susp'], ['SUSP-_3073-susp'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), predecessors(G,2,[1]).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _652, fd : [2, 3]}, _544, _545, _546, [], [], ['SUSP-_2798-dead', 'SUSP-_2489-susp'], ['SUSP-_2879-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _850, fd : [1 .. 4]}, _742, _743, _744, [], ['SUSP-_2939-susp', 'SUSP-_2499-susp'], ['SUSP-_2951-susp'], ['SUSP-_1807-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _652, fd : [2, 3]}, _544, _545, _546, [], [], ['SUSP-_2798-dead', 'SUSP-_2489-susp'], ['SUSP-_2879-dead'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _850, fd : [1 .. 4]}, _742, _743, _744, [], ['SUSP-_2939-susp', 'SUSP-_2499-susp'], ['SUSP-_2951-susp'], ['SUSP-_1807-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), predecessors(G,2,[1,3]).\r\nV = [1, 2, 3]\r\nE = E{cardinal([[[1, 2], [3, 2]]:2, [[2, 3], [3, 1]]:4], Card{cardinal : _860, fd:[2..4]}, _752, _753, _754, [], ['SUSP-_4324-susp', 'SUSP-_2509-susp'], ['SUSP-_4336-susp'], ['SUSP-_4141-dead'])}\r\nG = dirgraph([1, 2, 3], E{cardinal([[[1, 2], [3, 2]]:2, [[2, 3], [3, 1]]:4], Card{cardinal : _860, fd:[2..4]}, _752, _753, _754, [], ['SUSP-_4324-susp', 'SUSP-_2509-susp'], ['SUSP-_4336-susp'], ['SUSP-_4141-dead'])})"},"grasper:reachables/3":{"prefix":"reachables","body":"reachables(${1:Graph}, ${2:SourceVertex}, ${3:ReachSet})$4\n$0","description":"reachables(+Graph, +SourceVertex, ?ReachSet)\n\n   Determines the reachables-set of a vertex in a graph.\n\nArguments\n   Graph    A graph.\n   SourceVertex    A vertex of Graph.\n   ReachSet    Set of vertices reachable from SourceVertex in Graph.\n\nType\n   library(grasper)\n\nDescription\nDetermines the reachables-set of a vertex in a graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if SourceVertex does not belong to Graph's vertex-set or\r\n\t\t\t if Graph can not be constrained to have the vertices in ReachSet reachable from Vertex.\r\n\t\t\t\n\nExamples\n   \r\n?- reachables(G,V,Reachs).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), reachables(G,4,Reachs).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), reachables(G,3,[1,3,4]).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), reachables(G,3,Reachs).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2484-susp'], ['SUSP-_2108-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3145-susp', 'SUSP-_2494-susp'], ['SUSP-_3133-susp'], ['SUSP-_1802-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2484-susp'], ['SUSP-_2108-dead'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3145-susp', 'SUSP-_2494-susp'], ['SUSP-_3133-susp'], ['SUSP-_1802-dead'])})\r\nReachs = Reachs{cardinal([[3] : 1, [1, 2] : 3], Card{cardinal : _3086, fd : [1 .. 3]}, _2978, _2979, _2980, [], ['SUSP-_3121-susp'], ['SUSP-_3110-susp'], [])}\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), reachables(G,3,Reachs), 1 `@ Reachs.\r\nV = [1, 2, 3]\r\nE = E{cardinal([[[1, 2], [3, 1]] : 2, [[2, 3], [3, 2]] : 4], Card{cardinal : _873, fd : [2 .. 4]}, _765, _766, _767, [], ['SUSP-_3173-susp', 'SUSP-_2522-susp'], ['SUSP-_5570-dead', 'SUSP-_3161-susp'], ['SUSP-_5651-dead'])}\r\nG = dirgraph([1, 2, 3], E{cardinal([[[1, 2], [3, 1]] : 2, [[2, 3], [3, 2]] : 4], Card{cardinal : _873, fd : [2 .. 4]}, _765, _766, _767, [], ['SUSP-_3173-susp', 'SUSP-_2522-susp'], ['SUSP-_5570-dead', 'SUSP-_3161-susp'], ['SUSP-_5651-dead'])})\r\nReachs = [1, 2, 3]\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), reachables(G,3,Reachs), 1 `-@ Reachs.\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _675, fd : [2, 3]}, _567, _568, _569, [], [], ['SUSP-_2512-susp'], ['SUSP-_2136-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 2]] : 3], Card{cardinal : _873, fd : [1 .. 3]}, _765, _766, _767, [], ['SUSP-_3480-dead', 'SUSP-_3173-susp', 'SUSP-_2522-susp'], ['SUSP-_3161-susp'], ['SUSP-_3665-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _675, fd : [2, 3]}, _567, _568, _569, [], [], ['SUSP-_2512-susp'], ['SUSP-_2136-dead'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 2]] : 3], Card{cardinal : _873, fd : [1 .. 3]}, _765, _766, _767, [], ['SUSP-_3480-dead', 'SUSP-_3173-susp', 'SUSP-_2522-susp'], ['SUSP-_3161-susp'], ['SUSP-_3665-dead'])})\r\nReachs = Reachs{cardinal([[3] : 1, [2] : 2], Card{cardinal : _3114, fd : [1, 2]}, _3006, _3007, _3008, [], ['SUSP-_4091-dead', 'SUSP-_3149-susp'], ['SUSP-_3138-susp'], ['SUSP-_4317-dead'])}"},"grasper:reverse_graph/2":{"prefix":"reverse_graph","body":"reverse_graph(${1:Graph}, ${2:ReverseGraph})$3\n$0","description":"reverse_graph(+Graph, ?ReverseGraph)\n\n   Obtains the reverse graph of a given graph.\n\nArguments\n   Graph    A graph.\n   ReverseGraph    The reverse graph of Graph.\n\nType\n   library(grasper)\n\nDescription\nObtains the reverse graph of a given graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be contrained to have ReverseGraph as its reverse graph (ReverseGraph is a graph variable).\r\n\t\t\t\n\nExamples\n   \r\n?- reverse_graph(G,RG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), dirgraph(RG,V,E), reverse_graph(G,RG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), reverse_graph(G,RG), size(G,2), graph_labeling(G).\r\nV = [1, 2, 3]\r\nE = [[2, 3], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[2, 3], [3, 1]])\r\nRG = dirgraph([1, 2, 3], [[1, 3], [3, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [3, 1]])\r\nRG = dirgraph([1, 2, 3], [[1, 3], [2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3]])\r\nRG = dirgraph([1, 2, 3], [[2, 1], [3, 2]])\r\nYes\r\n\r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], RE`::[[3,2]]..[[1,3],[2,1],[3,2]], dirgraph(G,V,E), dirgraph(RG,V,RE), reverse_graph(G,RG), graph_labeling(G).\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3]]\r\nRE = [[2, 1], [3, 2]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3]])\r\nRG = dirgraph([1, 2, 3], [[2, 1], [3, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3], [3, 1]]\r\nRE = [[1, 3], [2, 1], [3, 2]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3], [3, 1]])\r\nRG = dirgraph([1, 2, 3], [[1, 3], [2, 1], [3, 2]])\r\nYes"},"grasper:size/2":{"prefix":"size","body":"size(${1:Graph}, ${2:Size})$3\n$0","description":"size(+Graph, ?Size)\n\n   Obtains a graph's size.\n\nArguments\n   Graph    A graph.\n   Size    The size of the graph.\n\nType\n   library(grasper)\n\nDescription\nDetermines the number of edges composing a graph variable.\n\nFail Conditions\n   Fails\r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be constrained to have an edge-set with a cardinality delimited by Size.\r\n\t\t\t\n\nExamples\n   \r\n?- size(Graph,Size).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), size(G,0).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), size(G,7).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), size(G,Size).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Size{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_2645-susp'], ['SUSP-_2255-dead'])}, E{cardinal([[[1, 2]] : 1, [[1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] : 6], Size{cardinal : _914, fd : [1 .. 6]}, _806, _807, _808, [], ['SUSP-_2655-susp'], [], ['SUSP-_1949-dead'])})\r\nSize = Size{cardinal : _914, fd : [1 .. 6]}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E), size(G,Size).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_3898-susp'], ['SUSP-_3508-dead'])}\r\nE = E{cardinal([[[1, 2], [2, 1]] : 2, [[1, 3], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [2 .. 6]}, _806, _807, _808, [], ['SUSP-_3908-susp', 'SUSP-_1758-susp'], ['SUSP-_1767-susp'], ['SUSP-_2823-dead'])}\r\nG = undirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _700, fd : [2, 3]}, _592, _593, _594, [], [], ['SUSP-_3898-susp'], ['SUSP-_3508-dead'])}, E{cardinal([[[1, 2], [2, 1]] : 2, [[1, 3], [2, 3], [3, 1], [3, 2]] : 6], Card{cardinal : _914, fd : [2 .. 6]}, _806, _807, _808, [], ['SUSP-_3908-susp', 'SUSP-_1758-susp'], ['SUSP-_1767-susp'], ['SUSP-_2823-dead'])})\r\nSize = _4017{cardinal : _4022, fd : [1 .. 3]}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), size(G,1).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _695, fd : [2, 3]}, _587, _588, _589, [], [], ['SUSP-_2640-susp'], ['SUSP-_2250-dead'])}\r\nE = [[1, 2]]\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _695, fd : [2, 3]}, _587, _588, _589, [], [], ['SUSP-_2640-susp'], ['SUSP-_2250-dead'])}, [[1, 2]])\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E), size(G,1).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _695, fd : [2, 3]}, _587, _588, _589, [], [], ['SUSP-_3893-susp'], ['SUSP-_3503-dead'])}\r\nE = [[1, 2], [2, 1]]\r\nG = undirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _695, fd : [2, 3]}, _587, _588, _589, [], [], ['SUSP-_3893-susp'], ['SUSP-_3503-dead'])}, [[1, 2], [2, 1]])\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), size(G,6).\r\nV = [1, 2, 3]\r\nE = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]])\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E), size(G,3).\r\nV = [1, 2, 3]\r\nE = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\r\nG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]])"},"grasper:strongly_connected/1":{"prefix":"strongly_connected","body":"strongly_connected(${1:Graph})$2\n$0","description":"strongly_connected(+Graph)\n\n   Guarantees that a directed graph Graph is strongly connected.\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nGuarantees that a directed graph Graph is strongly connected, i.e., that each vertex is reachable from any other one.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a directed graph variable or\r\n\t\t\t if Graph can not be constrained to be strongly connected.\r\n\t\t\t\n\nExamples\n   \r\n?- strongly_connected(G).\r\nNo.\r\n\r\n?- V`::[1,2]..[1,2,3,4], E`::[]..[[1,3],[2,4],[4,1],[4,3]], dirgraph(G,V,E), strongly_connected(G).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), strongly_connected(G), graph_labeling(G).\r\nV = []\r\nE = []\r\nG = dirgraph([], [])\r\nYes ? ;\r\n\r\nV = [3]\r\nE = []\r\nG = dirgraph([3], [])\r\nYes ? ;\r\n\r\nV = [2]\r\nE = []\r\nG = dirgraph([2], [])\r\nYes ? ;\r\n\r\nV = [1]\r\nE = []\r\nG = dirgraph([1], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = dirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes"},"grasper:subgraph/2":{"prefix":"subgraph","body":"subgraph(${1:SubGraph}, ${2:Graph})$3\n$0","description":"subgraph(?SubGraph, +Graph)\n\n   Constraints SubGraph to be a subgraph of Graph.\n\nArguments\n   SubGraph    A subgraph of Graph.\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nConstraints SubGraph to be a subgraph of Graph.\n\nFail Conditions\n   Fails\r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if SubGraph can not be constrained to be contained in Graph.\r\n\t\t\t\n\nExamples\n   \r\n?- subgraph(SG,G).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], SE`::[[4,5]]..[[1,2],[2,3],[3,1],[4,5]], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(SG,V,SE), dirgraph(G,V,E), subgraph(SG,G).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), subgraph(SG,G).\r\nV = V{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _580, fd : [0 .. 3]}, _472, _473, _474, [], [], ['SUSP-_2766-susp', 'SUSP-_2352-susp'], ['SUSP-_2926-susp'])}\r\nE = E{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _765, fd : [0 .. 3]}, _657, _658, _659, [], ['SUSP-_2362-susp'], ['SUSP-_3323-susp'], ['SUSP-_3483-susp'])}\r\nG = dirgraph(V{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _580, fd : [0 .. 3]}, _472, _473, _474, [], [], ['SUSP-_2766-susp', 'SUSP-_2352-susp'], ['SUSP-_2926-susp'])}, E{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _765, fd : [0 .. 3]}, _657, _658, _659, [], ['SUSP-_2362-susp'], ['SUSP-_3323-susp'], ['SUSP-_3483-susp'])})\r\nSG = dirgraph(SubVertexSet{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _2576, fd : [0 .. 3]}, _2468, _2469, _2470, [], ['SUSP-_2648-susp'], ['SUSP-_5069-susp'], ['SUSP-_4679-dead', 'SUSP-_2926-susp'])}, SubEdgeSet{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _3133, fd : [0 .. 3]}, _3025, _3026, _3027, [], ['SUSP-_5079-susp', 'SUSP-_3205-susp'], [], ['SUSP-_4395-dead', 'SUSP-_3483-susp'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), subgraph(SG,G), getVertexSet(G,VSet), 1 `-@ VSet.\r\nV = VSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _645, fd : [0 .. 2]}, _537, _538, _539, [], [], ['SUSP-_2831-susp', 'SUSP-_2417-susp'], ['SUSP-_2991-susp'])}\r\nE = E{cardinal([[] : 0, [[2, 3]] : 1], Card{cardinal : _830, fd : [0, 1]}, _722, _723, _724, [], ['SUSP-_6162-dead', 'SUSP-_2427-susp'], ['SUSP-_3388-susp'], ['SUSP-_6513-dead', 'SUSP-_3548-susp'])}\r\nG = dirgraph(VSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _645, fd : [0 .. 2]}, _537, _538, _539, [], [], ['SUSP-_2831-susp', 'SUSP-_2417-susp'], ['SUSP-_2991-susp'])}, E{cardinal([[] : 0, [[2, 3]] : 1], Card{cardinal : _830, fd : [0, 1]}, _722, _723, _724, [], ['SUSP-_6162-dead', 'SUSP-_2427-susp'], ['SUSP-_3388-susp'], ['SUSP-_6513-dead', 'SUSP-_3548-susp'])})\r\nSG = dirgraph(SubVertexSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _2641, fd : [0 .. 2]}, _2533, _2534, _2535, [], ['SUSP-_2713-susp'], ['SUSP-_5134-susp'], ['SUSP-_4744-dead', 'SUSP-_2991-susp'])}, SubEdgeSet{cardinal([[] : 0, [[2, 3]] : 1], Card{cardinal : _3198, fd : [0, 1]}, _3090, _3091, _3092, [], ['SUSP-_5697-dead', 'SUSP-_5144-susp', 'SUSP-_3270-susp'], [], ['SUSP-_5949-dead', 'SUSP-_3548-susp'])})\r\nVSet = VSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _645, fd : [0 .. 2]}, _537, _538, _539, [], [], ['SUSP-_2831-susp', 'SUSP-_2417-susp'], ['SUSP-_2991-susp'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), subgraph(SG,G), getVertexSet(SG,VSet), 1 `-@ VSet.\r\nV = V{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _645, fd : [0 .. 3]}, _537, _538, _539, [], [], ['SUSP-_2831-susp', 'SUSP-_2417-susp'], ['SUSP-_2991-susp'])}\r\nE = E{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _830, fd : [0 .. 3]}, _722, _723, _724, [], ['SUSP-_2427-susp'], ['SUSP-_3388-susp'], ['SUSP-_3548-susp'])}\r\nG = dirgraph(V{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _645, fd : [0 .. 3]}, _537, _538, _539, [], [], ['SUSP-_2831-susp', 'SUSP-_2417-susp'], ['SUSP-_2991-susp'])}, E{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _830, fd : [0 .. 3]}, _722, _723, _724, [], ['SUSP-_2427-susp'], ['SUSP-_3388-susp'], ['SUSP-_3548-susp'])})\r\nSG = dirgraph(VSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _2641, fd : [0 .. 2]}, _2533, _2534, _2535, [], ['SUSP-_2713-susp'], ['SUSP-_5134-susp'], ['SUSP-_4744-dead', 'SUSP-_2991-susp'])}, SubEdgeSet{cardinal([[] : 0, [[2, 3]] : 1], Card{cardinal : _3198, fd : [0, 1]}, _3090, _3091, _3092, [], ['SUSP-_5481-dead', 'SUSP-_5144-susp', 'SUSP-_3270-susp'], [], ['SUSP-_5733-dead', 'SUSP-_3548-susp'])})\r\nVSet = VSet{cardinal([[] : 0, [2, 3] : 2], Card{cardinal : _2641, fd : [0 .. 2]}, _2533, _2534, _2535, [], ['SUSP-_2713-susp'], ['SUSP-_5134-susp'], ['SUSP-_4744-dead', 'SUSP-_2991-susp'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), subgraph(SG,G), getEdgeSet(G,ESet), [1,2] `@ ESet.\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _665, fd : [2, 3]}, _557, _558, _559, [], [], ['SUSP-_5574-dead', 'SUSP-_2851-susp', 'SUSP-_2437-susp'], ['SUSP-_5655-dead', 'SUSP-_3011-susp'])}\r\nE = ESet{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _850, fd : [1 .. 3]}, _742, _743, _744, [], ['SUSP-_2447-susp'], ['SUSP-_3408-susp'], ['SUSP-_3568-susp'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _665, fd : [2, 3]}, _557, _558, _559, [], [], ['SUSP-_5574-dead', 'SUSP-_2851-susp', 'SUSP-_2437-susp'], ['SUSP-_5655-dead', 'SUSP-_3011-susp'])}, ESet{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _850, fd : [1 .. 3]}, _742, _743, _744, [], ['SUSP-_2447-susp'], ['SUSP-_3408-susp'], ['SUSP-_3568-susp'])})\r\nSG = dirgraph(SubVertexSet{cardinal([[] : 0, [1, 2, 3] : 3], Card{cardinal : _2661, fd : [0 .. 3]}, _2553, _2554, _2555, [], ['SUSP-_2733-susp'], ['SUSP-_5154-susp'], ['SUSP-_4764-dead', 'SUSP-_3011-susp'])}, SubEdgeSet{cardinal([[] : 0, [[1, 2], [2, 3], [3, 1]] : 3], Card{cardinal : _3218, fd : [0 .. 3]}, _3110, _3111, _3112, [], ['SUSP-_5164-susp', 'SUSP-_3290-susp'], [], ['SUSP-_4480-dead', 'SUSP-_3568-susp'])})\r\nESet = ESet{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _850, fd : [1 .. 3]}, _742, _743, _744, [], ['SUSP-_2447-susp'], ['SUSP-_3408-susp'], ['SUSP-_3568-susp'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), subgraph(SG,G), getEdgeSet(SG,ESet), [1,2] `@ ESet.\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _665, fd : [2, 3]}, _557, _558, _559, [], [], ['SUSP-_5768-dead', 'SUSP-_2851-susp', 'SUSP-_2437-susp'], ['SUSP-_5849-dead', 'SUSP-_3011-susp'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _850, fd : [1 .. 3]}, _742, _743, _744, [], ['SUSP-_2447-susp'], ['SUSP-_3408-susp'], ['SUSP-_3568-susp'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _665, fd : [2, 3]}, _557, _558, _559, [], [], ['SUSP-_5768-dead', 'SUSP-_2851-susp', 'SUSP-_2437-susp'], ['SUSP-_5849-dead', 'SUSP-_3011-susp'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _850, fd : [1 .. 3]}, _742, _743, _744, [], ['SUSP-_2447-susp'], ['SUSP-_3408-susp'], ['SUSP-_3568-susp'])})\r\nSG = dirgraph(SubVertexSet{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _2661, fd : [2, 3]}, _2553, _2554, _2555, [], ['SUSP-_2733-susp'], ['SUSP-_6246-dead', 'SUSP-_5154-susp'], ['SUSP-_6327-dead', 'SUSP-_3011-susp'])}, ESet{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _3218, fd : [1 .. 3]}, _3110, _3111, _3112, [], ['SUSP-_5164-susp', 'SUSP-_3290-susp'], [], ['SUSP-_4480-dead', 'SUSP-_3568-susp'])})\r\nESet = ESet{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _3218, fd : [1 .. 3]}, _3110, _3111, _3112, [], ['SUSP-_5164-susp', 'SUSP-_3290-susp'], [], ['SUSP-_4480-dead', 'SUSP-_3568-susp'])}"},"grasper:successors/3":{"prefix":"successors","body":"successors(${1:Graph}, ${2:Vertex}, ${3:SuccSet})$4\n$0","description":"successors(+Graph, +Vertex, ?SuccSet)\n\n   Determines the successor-set of a vertex in a graph.\n\nArguments\n   Graph    A graph.\n   Vertex    A vertex of Graph.\n   SuccSet    Set of successors of Vertex in Graph.\n\nType\n   library(grasper)\n\nDescription\nDetermines the successor-set of a vertex in a graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if Vertex does not belong to Graph's vertex-set or\r\n\t\t\t if Graph can not be constrained to have the vertices in SuccSet as successors of Vertex.\r\n\t\t\t\n\nExamples\n   \r\n?- successors(G,V,Succs).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), successors(G,4,Succs).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), successors(G,3,[1,3,4]).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), successors(G,3,Succs).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2921-susp', 'SUSP-_2484-susp'], ['SUSP-_3073-susp'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3359-susp', 'SUSP-_2494-susp'], ['SUSP-_3371-susp'], ['SUSP-_1802-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _647, fd : [2, 3]}, _539, _540, _541, [], [], ['SUSP-_2921-susp', 'SUSP-_2484-susp'], ['SUSP-_3073-susp'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1], [3, 2]] : 4], Card{cardinal : _845, fd : [1 .. 4]}, _737, _738, _739, [], ['SUSP-_3359-susp', 'SUSP-_2494-susp'], ['SUSP-_3371-susp'], ['SUSP-_1802-dead'])})\r\nSuccs = Succs{cardinal([[] : 0, [1, 2] : 2], SuccCard{cardinal : _2731, fd : [0 .. 2]}, _2623, _2624, _2625, [], ['SUSP-_3383-susp', 'SUSP-_2803-susp'], ['SUSP-_3395-susp'], ['SUSP-_3073-susp'])}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), successors(G,3,[1]).\r\nV = [1, 2, 3]\r\nE = E{cardinal([[[1, 2], [3, 1]]:2, [[2, 3]]:3], Card{cardinal : _850, fd:[2, 3]}, _742, _743, _744, [], ['SUSP-_4597-susp', 'SUSP-_2499-susp'], ['SUSP-_4609-susp'], ['SUSP-_4406-dead'])}\r\nG = dirgraph([1, 2, 3], E{cardinal([[[1, 2], [3, 1]]:2, [[2, 3]]:3], Card{cardinal : _850, fd:[2, 3]}, _742, _743, _744, [], ['SUSP-_4597-susp', 'SUSP-_2499-susp'], ['SUSP-_4609-susp'], ['SUSP-_4406-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1],[3,2]], dirgraph(G,V,E), successors(G,3,[1,2]).\r\nV = [1, 2, 3]\r\nE = E{cardinal([[[1, 2], [3, 1], [3, 2]]:3, [[2, 3]]:4], Card{cardinal : _860, fd:[3, 4]}, _752, _753, _754, [], ['SUSP-_5007-susp', 'SUSP-_2509-susp'], ['SUSP-_5019-susp'], ['SUSP-_4830-dead'])}\r\nG = dirgraph([1, 2, 3], E{cardinal([[[1, 2], [3, 1], [3, 2]]:3, [[2, 3]]:4], Card{cardinal : _860, fd:[3, 4]}, _752, _753, _754, [], ['SUSP-_5007-susp', 'SUSP-_2509-susp'], ['SUSP-_5019-susp'], ['SUSP-_4830-dead'])})"},"grasper:symmetric/1":{"prefix":"symmetric","body":"symmetric(${1:Graph})$2\n$0","description":"symmetric(+Graph)\n\n   Ensures Graph is symmetric\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nEnsures that for every edge (x,y) added to the Graph the symmetric edge (y,x) is also added.\r\n\t\t\t\t\tEnsures that for every edge (x,y) removed from the Graph the symmetric edge (y,x) is also removed.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a graph variable or\r\n\t\t\t if Graph can not be enforced to be symmetric.\r\n\t\t\t\n\nExamples\n   \r\n?- symmetric(G).\r\nNo.\r\n\t\t\t \r\n?- V`::[]..[1,2,3], E`::[[2,3]]..[[1,2],[1,3],[2,1],[2,3],[3,1]], dirgraph(G,V,E), symmetric(G).\r\nNo.\r\n\t\t\t \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), symmetric(G).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _628, fd:[0..3]}, _520, _521, _522, [], [], ['SUSP-_2494-susp'], ['SUSP-_2104-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [3, 1]]:4], Card{cardinal : _829, fd:[0..4]}, _721, _722, _723, [], ['SUSP-_3338-susp', 'SUSP-_2504-susp'], ['SUSP-_3347-susp'], ['SUSP-_3248-dead'])}\r\nG = dirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _628, fd:[0..3]}, _520, _521, _522, [], [], ['SUSP-_2494-susp'], ['SUSP-_2104-dead'])}, E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [3, 1]]:4], Card{cardinal : _829, fd:[0..4]}, _721, _722, _723, [], ['SUSP-_3338-susp', 'SUSP-_2504-susp'], ['SUSP-_3347-susp'], ['SUSP-_3248-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], dirgraph(G,V,E), symmetric(G).\r\nV = V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _688, fd:[2, 3]}, _580, _581, _582, [], [], ['SUSP-_3503-dead', 'SUSP-_2633-susp'], ['SUSP-_3584-dead'])}\r\nE = E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _902, fd:[2..6]}, _794, _795, _796, [], ['SUSP-_4193-susp', 'SUSP-_2643-susp'], ['SUSP-_4202-susp'], ['SUSP-_4109-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _688, fd:[2, 3]}, _580, _581, _582, [], [], ['SUSP-_3503-dead', 'SUSP-_2633-susp'], ['SUSP-_3584-dead'])}, E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _902, fd:[2..6]}, _794, _795, _796, [], ['SUSP-_4193-susp', 'SUSP-_2643-susp'], ['SUSP-_4202-susp'], ['SUSP-_4109-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[1,3],[2,1],[2,3],[3,1]], dirgraph(G,V,E), symmetric(G).\r\nV = V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _658, fd:[2, 3]}, _550, _551, _552, [], [], ['SUSP-_3426-dead', 'SUSP-_2556-susp'], ['SUSP-_3507-dead'])}\r\nE = E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [3, 1]]:4], Card{cardinal : _864, fd:[2..4]}, _756, _757, _758, [], ['SUSP-_4162-susp', 'SUSP-_2566-susp'], ['SUSP-_4171-susp'], ['SUSP-_4052-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _658, fd:[2, 3]}, _550, _551, _552, [], [], ['SUSP-_3426-dead', 'SUSP-_2556-susp'], ['SUSP-_3507-dead'])}, E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [3, 1]]:4], Card{cardinal : _864, fd:[2..4]}, _756, _757, _758, [], ['SUSP-_4162-susp', 'SUSP-_2566-susp'], ['SUSP-_4171-susp'], ['SUSP-_4052-dead'])})"},"grasper:underlying_graph/2":{"prefix":"underlying_graph","body":"underlying_graph(${1:DirectedGraph}, ${2:UndirectedGraph})$3\n$0","description":"underlying_graph(+DirectedGraph, ?UndirectedGraph)\n\n   Obtains an underlying graph of a given directed graph.\n\nArguments\n   DirectedGraph       A directed graph.\n   UndirectedGraph     The underlying undirected graph of DirectedGraph.\n\nType\n   library(grasper)\n\nDescription\nObtains an underlying graph of a given directed graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if DirectedGraph is not a directed graph variable or\r\n\t\t\t if DirectedGraph can not be contrained to have UndirectedGraph as its underlying graph (UndirectedGraph is a undirected graph variable).\r\n\t\t\t\n\nExamples\n   \r\n?- underlying_graph(DG,UG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], DE`::[[3,1]]..[[1,2],[2,3],[3,1]], UE`::[]..[[1,2],[2,1],[2,3],[3,2]], dirgraph(DG,V,DE), undirgraph(UG,V,UE), underlying_graph(DG,UG).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], DE`::[[3,1]]..[[1,2],[2,3],[3,1]], dirgraph(DG,V,DE), underlying_graph(DG,UG), graph_labeling(DG).\r\nV = [1, 3]\r\nDE = [[3, 1]]\r\nDG = dirgraph([1, 3], [[3, 1]])\r\nUG = undirgraph([1, 3], [[1, 3], [3, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[3, 1]]\r\nDG = dirgraph([1, 2, 3], [[3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 3], [3, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[2, 3], [3, 1]]\r\nDG = dirgraph([1, 2, 3], [[2, 3], [3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 3], [2, 3], [3, 1], [3, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2], [3, 1]]\r\nDG = dirgraph([1, 2, 3], [[1, 2], [3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [3, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2], [2, 3], [3, 1]]\r\nDG = dirgraph([1, 2, 3], [[1, 2], [2, 3], [3, 1]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]])\r\nYes\r\n\r\n?- V`::[]..[1,2,3], DE`::[]..[[1,2],[2,3],[3,1]], UE`::[]..[[1,2],[2,1],[2,3],[3,2]], dirgraph(DG,V,DE), undirgraph(UG,V,UE), underlying_graph(DG,UG), size(DG,Size), Size #> 0, graph_labeling(DG).\r\nV = [1, 2]\r\nDE = [[1, 2]]\r\nUE = [[1, 2], [2, 1]]\r\nDG = dirgraph([1, 2], [[1, 2]])\r\nUG = undirgraph([1, 2], [[1, 2], [2, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[2, 3]]\r\nUE = [[2, 3], [3, 2]]\r\nDG = dirgraph([1, 2, 3], [[2, 3]])\r\nUG = undirgraph([1, 2, 3], [[2, 3], [3, 2]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2]]\r\nUE = [[1, 2], [2, 1]]\r\nDG = dirgraph([1, 2, 3], [[1, 2]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1]])\r\nSize = 1\r\nYes ? ;\r\n\r\nV = [1, 2, 3]\r\nDE = [[1, 2], [2, 3]]\r\nUE = [[1, 2], [2, 1], [2, 3], [3, 2]]\r\nDG = dirgraph([1, 2, 3], [[1, 2], [2, 3]])\r\nUG = undirgraph([1, 2, 3], [[1, 2], [2, 1], [2, 3], [3, 2]])\r\nSize = 2\r\nYes"},"grasper:undirgraph/3":{"prefix":"undirgraph","body":"undirgraph(${1:Graph}, ${2:VertexSet}, ${3:EdgeSet})$4\n$0","description":"undirgraph(-Graph, +VertexSet, +EdgeSet)\n\n   Unirected graph constructor.\n\nArguments\n   Graph    An undirected graph.\n   VertexSet    The vertex-set that constitutes Graph.\n   EdgeSet    The edge-set that constitutes Graph.\n\nType\n   library(grasper)\n\nDescription\nCreates Graph as an undirected graph variable composed by the vertexes in VertexSet and the edges in EdgeSet.\n\nFail Conditions\n   Fails \r\n\t\t\t if VertexSet is not a set variable,\r\n\t\t\t if EdgeSet is not a set variable or\r\n\t\t\t if EdgeSet can not be contained in (VertexSet x VertexSet).\r\n\t\t\t\n\nExamples\n   \r\n?- E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E).\r\nNo.\r\n\t\t\t \r\n?- V`::[]..[1,2,3], undirgraph(G,V,E).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[4,5]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[4,5],[5,4]], undirgraph(G,V,E).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _633, fd:[0..3]}, _525, _526, _527, [], [], ['SUSP-_2546-susp'], ['SUSP-_2156-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _842, fd:[0..6]}, _734, _735, _736, [], ['SUSP-_2556-susp'], [], ['SUSP-_1872-dead'])}\r\nG = undirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _633, fd:[0..3]}, _525, _526, _527, [], [], ['SUSP-_2546-susp'], ['SUSP-_2156-dead'])}, E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _842, fd:[0..6]}, _734, _735, _736, [], ['SUSP-_2556-susp'], [], ['SUSP-_1872-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[4,5],[5,4]], undirgraph(G,V,E).\r\nV = V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _693, fd:[0..3]}, _585, _586, _587, [], [], ['SUSP-_2692-susp'], ['SUSP-_2302-dead'])}\r\nE = E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _918, fd:[0..6]}, _810, _811, _812, [], ['SUSP-_2702-susp'], [], ['SUSP-_2018-dead'])}\r\nG = undirgraph(V{cardinal([[]:0, [1, 2, 3]:3], Card{cardinal : _693, fd:[0..3]}, _585, _586, _587, [], [], ['SUSP-_2692-susp'], ['SUSP-_2302-dead'])}, E{cardinal([[]:0, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _918, fd:[0..6]}, _810, _811, _812, [], ['SUSP-_2702-susp'], [], ['SUSP-_2018-dead'])})\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2],[2,1]]..[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]], undirgraph(G,V,E).\r\nV = V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _693, fd:[2, 3]}, _585, _586, _587, [], [], ['SUSP-_3041-susp'], ['SUSP-_2651-dead'])}\r\nE = E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _917, fd:[2..6]}, _809, _810, _811, [], ['SUSP-_3051-susp'], [], ['SUSP-_1966-dead'])}\r\nG = undirgraph(V{cardinal([[1, 2]:2, [3]:3], Card{cardinal : _693, fd:[2, 3]}, _585, _586, _587, [], [], ['SUSP-_3041-susp'], ['SUSP-_2651-dead'])}, E{cardinal([[[1, 2], [2, 1]]:2, [[1, 3], [2, 3], [3, 1], [3, 2]]:6], Card{cardinal : _917, fd:[2..6]}, _809, _810, _811, [], ['SUSP-_3051-susp'], [], ['SUSP-_1966-dead'])})"},"grasper:weakly_connected/1":{"prefix":"weakly_connected","body":"weakly_connected(${1:Graph})$2\n$0","description":"weakly_connected(+Graph)\n\n   Guarantees that a directed graph Graph is weakly connected.\n\nArguments\n   Graph    A graph.\n\nType\n   library(grasper)\n\nDescription\nGuarantees that a directed graph Graph is weakly connected, i.e., that each vertex is reachable from any other one in the underlying graph of Graph.\n\nFail Conditions\n   Fails \r\n\t\t\t if Graph is not a directed graph variable or\r\n\t\t\t if Graph can not be constrained to be strongly connected.\r\n\t\t\t\n\nExamples\n   \r\n?- weakly_connected(G).\r\nNo.\r\n\r\n?- V`::[1,2]..[1,2,3,4], E`::[]..[[1,3],[2,4],[3,1],[4,2]], dirgraph(G,V,E), weakly_connected(G).\r\nNo.\r\n\r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,1]], dirgraph(G,V,E), weakly_connected(G), graph_labeling(G).\r\nV = []\r\nE = []\r\nG = dirgraph([], [])\r\nYes ? ;\r\n\r\nV = [3]\r\nE = []\r\nG = dirgraph([3], [])\r\nYes ? ;\r\n\r\nV = [2]\r\nE = []\r\nG = dirgraph([2], [])\r\nYes ? ;\r\n\r\nV = [1]\r\nE = []\r\nG = dirgraph([1], [])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[2, 1]]\r\nG = dirgraph([1, 2], [[2, 1]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2], [[1, 2]])\r\nYes ? ;\r\n\r\nV = [1, 2]\r\nE = [[1, 2], [2, 1]]\r\nG = dirgraph([1, 2], [[1, 2], [2, 1]])\r\nYes"},"grasper:weight/3":{"prefix":"weight","body":"weight(${1:Graph}, ${2:WeightHash}, ${3:Weight})$4\n$0","description":"weight(+Graph, +WeightHash, ?Weight)\n\n   Calculates the Weight of Graph given a WeightHash.\n\nArguments\n   Graph    A graph.\n   WeightHash    An hashtable an hashtable matching some elements (vertex or edge) of Graph to a positive weight. An unweighed element will be considered to have weight 0.\n   Weight    The sum of the graph's vertices' and edges' weights.\n\nType\n   library(grasper)\n\nDescription\nCalculates the Weight of Graph given a WeightHash.\n\nFail Conditions\n   Fails\r\n\t\t\t if Graph is not a graph variable,\r\n\t\t\t if Weight is not an hash variable (lib(hash)) with positive integer weights or\r\n\t\t\t if Graph can not be constrained to have a weight delimited by Weight.\r\n\t\t\t\n\nExamples\n   \r\n?- weight(G,WH,W).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), weight(G,WH,W).\r\ninstantiation fault in term_hash(1, -1, Size, _2486)\r\nAbort\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), hash_create(WH), hash_add(WH,1,1), hash_add(WH,2,1), hash_add(WH,3,1), hash_add(WH,[1,2],1), hash_add(WH,[2,3],1), hash_add(WH,[3,1],1), weight(G,WH,0).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), hash_create(WH), hash_add(WH,1,1), hash_add(WH,2,1), hash_add(WH,3,1), hash_add(WH,[1,2],1), hash_add(WH,[2,3],1), hash_add(WH,[3,1],1), weight(G,WH,7).\r\nNo.\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), hash_create(WH), hash_add(WH,1,1), hash_add(WH,2,1), hash_add(WH,3,1), hash_add(WH,[1,2],1), hash_add(WH,[2,3],1), hash_add(WH,[3,1],1), weight(G,WH,W).\r\nV = V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _941, fd : [2, 3]}, _833, _834, _835, [], ['SUSP-_3104-susp'], ['SUSP-_3130-susp', 'SUSP-_2731-susp'], ['SUSP-_2355-dead'])}\r\nE = E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _1131, fd : [1 .. 3]}, _1023, _1024, _1025, [], ['SUSP-_3117-susp', 'SUSP-_2741-susp'], ['SUSP-_3143-susp'], ['SUSP-_2049-dead'])}\r\nG = dirgraph(V{cardinal([[1, 2] : 2, [3] : 3], Card{cardinal : _941, fd : [2, 3]}, _833, _834, _835, [], ['SUSP-_3104-susp'], ['SUSP-_3130-susp', 'SUSP-_2731-susp'], ['SUSP-_2355-dead'])}, E{cardinal([[[1, 2]] : 1, [[2, 3], [3, 1]] : 3], Card{cardinal : _1131, fd : [1 .. 3]}, _1023, _1024, _1025, [], ['SUSP-_3117-susp', 'SUSP-_2741-susp'], ['SUSP-_3143-susp'], ['SUSP-_2049-dead'])})\r\nWH = hash(4, 6, [[3, 1] -> 1, [2, 3] -> 1, 1 -> 1, 2 -> 1, [1, 2] -> 1, 3 -> 1])\r\nW = W{cardinal : _3033, fd : [3 .. 6]}\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), hash_create(WH), hash_add(WH,1,1), hash_add(WH,2,1), hash_add(WH,3,1), hash_add(WH,[1,2],1), hash_add(WH,[2,3],1), hash_add(WH,[3,1],1), weight(G,WH,3).\r\nV = [1, 2]\r\nE = [[1, 2]]\r\nG = dirgraph([1, 2], [[1, 2]])\r\nWH = hash(4, 6, [[3, 1] -> 1, [2, 3] -> 1, 1 -> 1, 2 -> 1, [1, 2] -> 1, 3 -> 1])\r\n \r\n?- V`::[]..[1,2,3], E`::[[1,2]]..[[1,2],[2,3],[3,1]], dirgraph(G,V,E), hash_create(WH), hash_add(WH,1,1), hash_add(WH,2,1), hash_add(WH,3,1), hash_add(WH,[1,2],1), hash_add(WH,[2,3],1), hash_add(WH,[3,1],1), weight(G,WH,6).\r\nV = [1, 2, 3]\r\nE = [[1, 2], [2, 3], [3, 1]]\r\nG = dirgraph([1, 2, 3], [[1, 2], [2, 3], [3, 1]])\r\nWH = hash(4, 6, [[3, 1] -> 1, [2, 3] -> 1, 1 -> 1, 2 -> 1, [1, 2] -> 1, 3 -> 1])"},"ic_global_gac:alldifferent/1":{"prefix":"alldifferent","body":"alldifferent(${1:L})$2\n$0","description":"alldifferent(+L)\n\n   GAC version of alldifferent\n\nArguments\n   L    List of integers or domain variables, or a collection a la collection_to_list/2\n\nType\n   library(ic_global_gac)\n\nDescription\nThis predicate implements a GAC (generalized arc consistency) version of the alldifferent constraint. It uses the classical bitpartite matching implementation using the graph_algorithms library. This version often removes more values than the bound consistent alldifferent in the ic_global library, or the forward checking variant in the ic library, but may spend much more time doing this.\n\nFail Conditions\n   fails if there is no bipartite matching between all variables and the possible values\n\nSee Also\n   matching / 2, ic : alldifferent / 1, ic_global : alldifferent / 1"},"ic_global_gac:alldifferent_matrix/1":{"prefix":"alldifferent_matrix","body":"alldifferent_matrix(${1:Matrix})$2\n$0","description":"alldifferent_matrix(+Matrix)\n\n   Constrain the rows and columns of Matrix to be different values\n\nArguments\n   Matrix    A two dimensional square matrix of Variables or integer\n\nType\n   library(ic_global_gac)\n\nDescription\n\n    This constraint is a matrix version of alldifferent. Matrix is a two\n    dimensional square (NxN) matrix, and the constraint ensures that the \n    elements in each row and column of the matrix are different. The same\n    value can occur in different rows and columns. It is logically \n    equivalent to imposing 2N alldifferent constraints, on each row and column,\n    but it allows more reasoning because it consider the rows and columns \n    together. This version uses alldifferent from lib(ic_global_gac), but the \n    extra inferences performed between the rows and columns themselves may be not\n    fully domain consistent. The maximum propagation occurs when the \n    variables' domains also have N values. \n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   alldifferent / 1, ic_global : alldifferent_matrix / 1, fd_global : alldifferent_matrix / 1, fd_global_gac : alldifferent_matrix / 1"},"ic_global_gac:gcc/2":{"prefix":"gcc","body":"gcc(${1:Bounds}, ${2:Vars})$3\n$0","description":"gcc(++Bounds, +Vars)\n\n   Constrain the cardinality of each Value specified in Bound's gcc(Low,High,Value) to be between Low and High in Vars\n\nArguments\n   Bounds    A list of elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values\n   Vars    A collection of different variables or integers\n\nType\n   library(ic_global_gac)\n\nDescription\n\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in Vars conforms to the specifications in Bounds. Bounds is a\n    list of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in Bounds, and whose cardinality |Value| is specified by \n    Low =\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as global_cardinality_low_up in the global\n    constraint catalog. The algorithm implemented is described in \n    J.-C. Regin's paper 'Generalized Arc Consistency for Global Cardinality\n    Constraint', published in AAAI-1996."},"ic_global_gac:gcc_matrix/3":{"prefix":"gcc_matrix","body":"gcc_matrix(${1:RowBounds}, ${2:ColBounds}, ${3:Matrix})$4\n$0","description":"gcc_matrix(++RowBounds, ++ColBounds, +Matrix)\n\n   Constrain the cardinality of values taken in the rows and columns of Matrix as specified by RowBounds and ColBounds, respectively\n\nArguments\n   RowBounds    A list of M sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in RowBounds\n   ColBounds    A list of N sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in ColBounds\n   Matrix    A two dimensional MxN matrix of Variables or integer\n\nType\n   library(ic_global_gac)\n\nDescription\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in each row and column of Matrix conforms to the specifications\n    in RowBounds and ColBounds, respectively. RowBounds and ColBounds are \n    lists of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in the row/column, and whose cardinality |Value| is specified by \n    Low =\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n\nSee Also\n   gcc / 2"},"ic_global_gac:ic_global_gac_desc":{"prefix":"lib","body":"lib(${1:ic_global_gac})$2\n$0","description":"lib(ic_global_gac)\n\n   This library is intended for global constraints for which GAC (generalized arc consistency, also called hyper arc consistency, or domain consistency) is maintained. The first example is a version of the alldifferent constraint which performs more pruning than the bound consistent version in the ic_global library."},"ic_global_gac:inverse/2":{"prefix":"inverse","body":"inverse(${1:Succ}, ${2:Pred})$3\n$0","description":"inverse(+Succ, +Pred)\n\n   Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph\n\nArguments\n   Succ    A collection of N different variables or integers\n   Pred    A collection  of N different variables or integers\n\nType\n   library(ic_global_gac)\n\nDescription\n\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predessor node, and\n     that if node y is the successor of node x, then node x is the\n     predecessor of node y.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list."},"ic_global_gac:lex_le/2":{"prefix":"lex_le","body":"lex_le(${1:List1}, ${2:List2})$3\n$0","description":"lex_le(+List1, +List2)\n\n   List1 is lexicographically less or equal to List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(ic_global_gac)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e. either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as lex_lesseq in the global constraint\n    catalog. The implementation here maintains generalised arc\n    consistency and uses the algorithm described in:\n    Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n    Uppsala University, 2004."},"ic_global_gac:lex_lt/2":{"prefix":"lex_lt","body":"lex_lt(${1:List1}, ${2:List2})$3\n$0","description":"lex_lt(+List1, +List2)\n\n   List1 is lexicographically less than  List2\n\nArguments\n   List1    List of integers or domain variables\n   List2    List of integers or domain variables\n\nType\n   library(ic_global_gac)\n\nDescription\n    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n    reached)is strictly smaller than any existing element.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as lex_less in the global constraint\n    catalog. The implementation here maintains generalised arc\n    consistency and uses the algorithm described in:\n    Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n    Uppsala University, 2004."},"ic_global_gac:matching/2":{"prefix":"matching","body":"matching(${1:L}, ${2:K})$3\n$0","description":"matching(+L, -K)\n\n   Get a matching between a list of domain variables and their possible values\n\nArguments\n   L    A list of integers or domain variables, or a collection a la collection_to_list/2\n   K    A free variable, will be bound to a list of integers\n\nType\n   library(ic_global_gac)\n\nDescription\nThis predicate can be used to get the matching into the user program. Sometimes it is a good starting point for heuristics. It only gets the current matching and does not do any propagation, the matching is not updated when values are removed, the predicate must be called again in the user program if this is required\n\nFail Conditions\n   The predicate fails if no matching exists\n\nSee Also\n   alldifferent / 1"},"ic_global_gac:same/2":{"prefix":"same","body":"same(${1:Vars1}, ${2:Vars2})$3\n$0","description":"same(+Vars1, +Vars2)\n\n   Vars1 and Vars2 are constrained to be a permutation of each other in the values taken by the variables.\n\nArguments\n   Vars1    A collection of N different variables or integers\n   Vars2    A collection of N different variables or integers\n\nType\n   library(ic_global_gac)\n\nDescription\n\n    This constraint ensures that the values taken by the variables in Vars1\n    and Vars2 are permutations of each other. Vars1 and Vars must be the same\n    length.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is also known as same in the global constraint catalog. \n    The implementation is the generalised arc-consistent version described\n    in the catalog."},"ic_global_gac:sequence/4":{"prefix":"sequence","body":"sequence(${1:Low}, ${2:High}, ${3:K}, ${4:ZeroOnes})$5\n$0","description":"sequence(+Low, +High, +K, +ZeroOnes)\n\n   The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes\n\nArguments\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   ZeroOnes    A collection of 0/1 variables or integers\n\nType\n   library(ic_global_gac)\n\nDescription\n\n    This constraint ensures that the number of occurrences of the value 1\n    is at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes. ZeroOnes are 0/1 variables (or integers), \n    i.e. they have the domain [0,1]. \n\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. For example,\n    sequence/5 is implemented by linking the N ZeroOnes variables to a \n    matching collection of N finite domain `original' variables using \n    element/3 constraints to constrain the ZeroOnes to be 1 if the \n    corresponding original value takes one of the specified values. The\n    ZeroOnes can then be used in further constraint reasoning.\n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\nSee Also\n   sequence / 5, ic : element / 3, ic_global : sequence_total / 6, ic_global : sequence_total / 7"},"ic_global_gac:sequence/5":{"prefix":"sequence","body":"sequence(${1:Low}, ${2:High}, ${3:K}, ${4:Vars}, ${5:Values})$6\n$0","description":"sequence(+Low, +High, +K, +Vars, ++Values)\n\n   The number of values taken from Values is between Low and High for all sequences of K variables in Vars.\n\nArguments\n   Low    Non-negative integer\n   High    Positive integer\n   K    Postive integer\n   Vars    A list of variables or integers\n   Values    A list of (different) integers\n\nType\n   library(ic_global_gac)\n\nDescription\n\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars. \n\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n\n    This constraint is known as among_seq in the global constraint catalog.\n    The algorithm implemented is described in M. Maher et al.'s paper \n    'Flow-Based Propagators for the SEQUENCE and Related Global Constraints' \n    in CP'2008.\n\nSee Also\n   sequence / 4, ic : element / 3, ic_global : sequence_total / 6, ic_global : sequence_total / 7"},"ldsb:ldsb_desc":{"prefix":"lib","body":"lib(${1:ldsb})$2\n$0","description":"lib(ldsb)\n\n   The LDSB (lightweight dynamic symmetry breaking) library adds\n   symmetry breaking to search.  Its aim is to provide easy-to-use\n   symmetry breaking to their finite domain constraint models.  The\n   method is described in \"Lightweight Dynamic Symmetry\n   Breaking. C. Mears, M. Garcia de la Banda, B. Demoen,\n   M. Wallace.  SymCon'08\".\n    \n   \n\n   To use LDSB, first call ldsb_initialise/2 with the search variables\n   for which you want to use symmetry breaking and a specification of\n   the symmetries.  LDSB supports binary search branching of the form\n   Var = Val and Var /= Val, or Val in Var\n   and Val notin Var for sets.  Use ldsb_indomain/1 and\n   ldsb_indomain_set/1 to instantiate variables during search, or\n   ldsb_try/3 and ldsb_try_set/3 for a custom branching."},"ldsb:ldsb_indomain/1":{"prefix":"ldsb_indomain","body":"ldsb_indomain(${1:X})$2\n$0","description":"ldsb_indomain(?X)\n\n   Instantiates an LDSB integer variable to an\n    element of its domain.\n\nArguments\n   X    Variable or integer\n\nType\n   library(ldsb)\n\nDescription\n Simple predicate for instantiating an\n    integer LDSB variable to an element of its domain. It\n    starts with the smallest element, and upon backtracking\n    tries successive elements until the entire domain has\n    been explored, at which point the predicate fails.\n\n    If X is already a ground integer, then this predicate\n    simply succeeds exactly once without leaving a\n    choicepoint.\n\n    This predicate can be used with the search/6\n    predicate (see example).\n\nResatisfiable\n   yes\n\nExamples\n   \ngo :-\n    dim(Xs, [3]),\n    Xs #:: 1..5,\n    collection_to_list(Xs, L), sum(L) #= 10,\n    ldsb_initialise(Xs, [variables_interchange]),\n    ( search(Xs, 0, input_order, ldsb_indomain, complete, []),\n    writeln(Xs),\n    fail\n    ; true ).\n\nSee Also\n   ldsb_indomain_set / 1, ldsb_initialise / 2"},"ldsb:ldsb_indomain_set/1":{"prefix":"ldsb_indomain_set","body":"ldsb_indomain_set(${1:X})$2\n$0","description":"ldsb_indomain_set(?X)\n\n   Instantiates an LDSB set variable to an element\n    of its domain.\n\nArguments\n   X    Set variable or set\n\nType\n   library(ldsb)\n\nDescription\n Simple predicate for instantiating a set\n    LDSB variable to an element of its domain.  If a set\n    value is considered a binary number, where 1 is inclusion\n    and 0 is exclusion, the value ordering is descending.\n    For example:\n\n    \ngo :-\n    intset(S, 1, 3),\n    Xs = [](S),\n    ldsb_initialise(Xs, []),\n    ( ldsb_indomain_set(S), writeln(S), fail\n    ; true).\n    \n\n    would produce the following output:\n\n    \n[1, 2, 3]\n[1, 2]\n[1, 3]\n[1]\n[2, 3]\n[2]\n[3]\n[]\n    \n\n    If X is already a ground set, then this predicate\n    simply succeeds exactly once without leaving a\n    choicepoint.\n\n    This predicate can be used with the search/6\n    predicate (see example).\n\nResatisfiable\n   yes\n\nExamples\n   \ngo :-\n    intsets(L, 3, 1, 10),\n    ( foreach(S, L) do #(S, 3) ),\n    ( fromto(L, [X|Xs], Xs, []) do\n    ( foreach(Y, Xs), param(X) do\n    #(X /\\ Y, 0) ) ),\n    Xs =.. [[]|L],\n    ldsb_initialise(Xs, [values_interchange]),\n    ( search(Xs, 0, input_order, ldsb_indomain_set, complete, []),\n    writeln(Xs),\n    fail\n    ; true ).\n\nSee Also\n   ldsb_indomain / 1, ldsb_initialise / 2"},"ldsb:ldsb_initialise/2":{"prefix":"ldsb_initialise","body":"ldsb_initialise(${1:Xs}, ${2:Syms})$3\n$0","description":"ldsb_initialise(+Xs, +Syms)\n\n   Initialise LDSB search variables.\n\nArguments\n   Xs    Array of search variables\n   Syms    List of symmetries\n\nType\n   library(ldsb)\n\nDescription\n  Initialise an array of search variables\nto use LDSB with the given symmetries.  A variables must be\ninitialised with ldsb_initialise before it can be used with ldsb_try\nor any predicate that relies on it such as ldsb_indomain.\n\n Each element of Syms must be a symmetry specifier from the\nfollowing set:\n\n variable_interchange(L).  This specifies that the variables in\nthe list L are interchangeable.\n\n value_interchange(L).  This specifies that the values in the list\nL are interchangeable.\n\n parallel_variable_interchange(Ls).  This specifies that the lists\nof variables in the list L are interchangeable.  Each list in Ls must\nhave the same length.  For example,\nparallel_variable_interchange([A,B,C],[D,E,F],[G,H,I]) says that the\nsequence A-B-C can be interchanged with the sequence D-E-F and the\nsequence G-H-I.\n\n parallel_value_interchange(Ls).  This specifies that the lists of\nvalues in the list L are interchangeable.  It is the same as\nparallel_variable_interchange, but for values.\n\n variables_interchange.  This specifies that all variables in Xs\nare interchangeable.\n\n values_interchange.  This specifies that all values in the\ndomains of the variables in Xs are interchangeable.  Note that for\nthis specifier it is assumed that all variables in Xs have the same\ndomain.\n\n rows_interchange.  This specifies that the rows of variables in\nXs are interchangeable.  Assumes that Xs is a 2D matrix of variables.\n\n columns_interchange.  This specifies that the columns of\nvariables in Xs are interchangeable.  Assumes that Xs is a 2D matrix\nof variables.\n\n diagonal_reflection.  This specifies that the variables of Xs can\nbe reflected around the main diagonal.  Assumes that Xs is a 2D matrix\nof variables.\n\n row_reflection.  This specifies that the rows of Xs can be\nreflected around their centre.  Assumes that Xs is a 2D matrix of\nvariables.\n\n column_reflection.  This specifies that the columns of Xs can be\nreflected around their centre.  Assumes that Xs is a 2D matrix of\nvariables.\n\n value_reflection(L, U).  This specifies that the values in the\nsequence L..U can be reflected; i.e. value L+i maps to U-i.\n\n value_reflection.  This is the same as value_reflection(L,U),\nwhere L and U are taken from the minimum and maximum values in the\ndomain of the first variable in Xs.\n\n \n\nModes and Determinism\n   ldsb_initialise(+, +) is det\n\nResatisfiable\n   no\n\nExamples\n   \n% A vector of interchangeable variables.\ndim(Xs, [N]),\n[...]\nldsb_initialise(Xs, [variables_interchange])\n\n% Vector of piecewise interchangeable variables.\nXs = [](A,B,C,D,E,F),\n[...]\n% A,B,C are interchangeable; D,E,F are interchangeable.\nldsb_initialise(Xs, [variable_interchange([A,B,C]),\n    variable_interchange([D,E,F])])\n\n% Variables with interchangeable values.\ndim(Xs, [N]),\nXs #:: 1..M,\nldsb_initialise(Xs, [values_interchange])\n\n% N-queens, with one boolean variable per square.\ndim(A, [N,N]),\nA #:: 0..1,\n[...]\nldsb_initialise(A, [row_reflection, column_reflection, diagonal_reflection])\n\n% N-queens with one integer variable per queen.\n% Note that only half of the symmetries are represented.\ndim(Xs, [1,N]),    % make Xs a 1xN matrix.\nXs #:: 1..N,\n[...]\nldsb_initialise(Xs, [column_reflection, value_reflection])\n\n% Latin square of order N.\ndim(Xs, [N,N]),\nXs #:: 1..N,\n[...]\nldsb_initialise(Xs, [rows_interchange, columns_interchange, values_interchange, diagonal_reflection])\n\n% Social Golfers problem with one set variable per group.\ndim(Xs, [W,G]),\n[...]\n% Within each week, the groups are interchangeable.\n( for(I, 1, W), foreach(Subsym, Subsyms), param(Xs,G) do\n    subscript(Xs, [I, 1..G], Submatrix),\n    variables_interchange(Submatrix, Subsym) ),\n% rows_interchange: weeks are interchangeable\n% values_interchange: golfers are interchangeable\nldsb_initialise(Xs, [rows_interchange, values_interchange | Subsyms])\n\nSee Also\n   ldsb_try / 3, ldsb_indomain / 1, ldsb_indomain_set / 1"},"ldsb:ldsb_try/3":{"prefix":"ldsb_try","body":"ldsb_try(${1:X}, ${2:Value}, ${3:Success})$4\n$0","description":"ldsb_try(+X, ++Value, ?Success)\n\n   Try assigning a value to an LDSB variable.\n\nArguments\n   X    Variable to try\n   Value    Value to try\n   Success    Whether the assignment succeeded or not\n\nType\n   library(ldsb)\n\nDescription\n Tries to assign Value to X.  Upon\n    backtracking, excludes Value from the domain of X.  The\n    value of Success tells whether the assignment succeeded;\n    Success is 1 if X #= Value and 0 if X #\\= Value.\n\nResatisfiable\n   yes\n\nExamples\n   \nldsb_indomain(X) :- nonvar(X), !.\nldsb_indomain(X) :-\n    ic:is_solver_var(X), !,\n    get_min(X,V),\n    ldsb_try(X, V, _),\n    ldsb_indomain(X).\n\nSee Also\n   ldsb_indomain / 1, ldsb_initialise / 2, ldsb_try_set / 3"},"ldsb:ldsb_try_set/3":{"prefix":"ldsb_try_set","body":"ldsb_try_set(${1:X}, ${2:Value}, ${3:Success})$4\n$0","description":"ldsb_try_set(+X, ++Value, ?Success)\n\n   Try including a value in an LDSB set variable.\n\nArguments\n   X    Variable to try\n   Value    Value to try\n   Success    Whether the inclusion succeeded or not\n\nType\n   library(ldsb)\n\nDescription\n Tries to include Value in X.  Upon\n    backtracking, excludes Value from X.  The value of\n    Success tells whether the inclusion succeeded; Success is\n    1 if (Value in X) and 0 if Value has been excluded.\n\n    Note that due to the interaction between set\n    variable searching and value symmetries, using this\n    predicate in discouraged.  Use ldsb_indomain_set/1\n    instead.\n\nResatisfiable\n   yes\n\nSee Also\n   ldsb_indomain_set / 1, ldsb_initialise / 2, ldsb_try / 3"},"list_collection:append_element/3":{"prefix":"append_element","body":"append_element(${1:LCOL}, ${2:Index}, ${3:Elem})$4\n$0","description":"append_element(+LCOL, ++Index, +Elem)\n\n   Append an Elem to the internal list identified by Index.\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   Elem    Term or variable\n\nType\n   library(list_collection)\n\nDescription\nComplexity O(1).\n\nModes and Determinism\n   append_element(+, ++, +) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n     1 --- List identified by Index is closed.\n\nSee Also\n   append_list / 3, prefix_element / 3, prefix_list / 3"},"list_collection:append_list/3":{"prefix":"append_list","body":"append_list(${1:LCOL}, ${2:Index}, ${3:List})$4\n$0","description":"append_list(+LCOL, ++Index, +List)\n\n   Append a List to the internal list identified by Index.\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   List    A list of terms or variables\n\nType\n   library(list_collection)\n\nDescription\nComplexity O(|List|).\n\nModes and Determinism\n   append_list(+, ++, +) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n     1 --- List identified by Index is closed.\n\nSee Also\n   append_element / 3, prefix_element / 3, prefix_list / 3"},"list_collection:create/2":{"prefix":"create","body":"create(${1:Type}, ${2:LCOL})$3\n$0","description":"create(++Type, -LCOL)\n\n   Creates a list collection\n\nArguments\n   Type    A ground term\n   LCOL    A list collection\n\nType\n   library(list_collection)\n\nDescription\n\r\n    If (Type==hash) a LCOL internally uses a hashtable, this is useful when the number of lists is unknown.\r\n    If (Type=array(Size)) where Size is a natural number, the LCOL internally uses an array to collect lists,\r\n    the access to any of the lists is faster, but the Size has to be known in advance and only number \r\n    indexes can be used to identify lists. 0<Index=<Size.\n\nModes and Determinism\n   create(++, -) is det\n\nExceptions\n     5 --- Not supported Type.\n\nSee Also\n   append_element / 3, terminate_all_lists / 2, get_list / 3"},"list_collection:get_indexes/2":{"prefix":"get_indexes","body":"get_indexes(${1:LCOL}, ${2:Indexes})$3\n$0","description":"get_indexes(+LCOL, -Indexes)\n\n   Retrieves the list of indexes\n\nArguments\n   LCOL    A list collection\n   Indexes    List of indexes\n\nType\n   library(list_collection)\n\nDescription\nComplexity O(ListCount).\n\nModes and Determinism\n   get_indexes(+, -) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n\nSee Also\n   get_list / 3, terminate_and_get_list / 3, terminate_all_lists / 2"},"list_collection:get_list/3":{"prefix":"get_list","body":"get_list(${1:LCOL}, ${2:Index}, ${3:List})$4\n$0","description":"get_list(+LCOL, ++Index, -List)\n\n   Retrieves the list of elements identified by Index\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   List    A list of terms\n\nType\n   library(list_collection)\n\nDescription\nIf the internal list identified by Index is open, the elements from the list are copied to a closed List and returned. The internal list remains open. Complexity O(|List|).\r\n    If the internal list identified by Index is closed, the internal list is returned immediately as List. Complexity O(1).\n\nModes and Determinism\n   get_list(+, ++, -) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n\nSee Also\n   terminate_all_lists / 2, terminate_and_get_list / 3"},"list_collection:list_collection_desc":{"prefix":"lib","body":"lib(${1:list_collection})$2\n$0","description":"lib(list_collection)\n\n   \r\n    A library for creation and management of list collections (LCOL).\r\n    Internally the library uses either the a hashtable or arrays to store lists and their tails. \r\n    The advantage of a hash LCOL is that its size does not have to be known in advance and that \r\n    non number indexes can be used to address lists in the collection. The drawback of a hash LCOL \r\n    is that access to collection elements is slower than for array LCOL. Elements of array LCOL \r\n    can be addressed only by positive integers which internally are array indexes. See create/2 \r\n    for more details.\r\n    \r\n    The motivation for creating this library was to be able to easily build input lists for global \r\n    constraints from collections of input structures (see example). For this purpose an array(3) LCOL \r\n    was usually sufficient, and only a limited set of predicates needed (create/2 , append_element/3, \r\n    terminate_all_lists/2, get_list/3).\r\n    \r\n    But the idea was extended, additional predicates were added for prefixing the lists, and \r\n    reinitialisation of lists. The support for hash LCOL has been added. Hash LCOL may be useful for \r\n    some filtering, grouping predicates in cases when the number of lists may vary or indexing by \r\n    atoms/ground terms is more readable/convenient."},"list_collection:prefix_element/3":{"prefix":"prefix_element","body":"prefix_element(${1:LCOL}, ${2:Index}, ${3:Elem})$4\n$0","description":"prefix_element(+LCOL, ++Index, +Elem)\n\n   Prefixes the internal list identified by Index with an Elem.\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   Elem    Term or variable\n\nType\n   library(list_collection)\n\nDescription\n Complexity O(1)\n\nModes and Determinism\n   prefix_element(+, ++, +) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n\nSee Also\n   append_element / 3, append_list / 3, prefix_list / 3"},"list_collection:prefix_list/3":{"prefix":"prefix_list","body":"prefix_list(${1:LCOL}, ${2:Index}, ${3:List})$4\n$0","description":"prefix_list(+LCOL, ++Index, +List)\n\n   Prefixes the internal list identified by Index with a List.\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   List    A list of terms or variables\n\nType\n   library(list_collection)\n\nDescription\nComplexity O(|List|).\n\nModes and Determinism\n   prefix_list(+, ++, +) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n\nSee Also\n   append_element / 3, append_list / 3, prefix_list / 3"},"list_collection:reinit/2":{"prefix":"reinit","body":"reinit(${1:LCOL}, ${2:Index})$3\n$0","description":"reinit(+LCOL, ++Index)\n\n   Creates a new list identified by Index\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n\nType\n   library(list_collection)\n\nDescription\nDiscards the internal list of elements identified by Index, and replaces with a new list. Complexity O(1).\n\nModes and Determinism\n   reinit(+, ++) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n\nSee Also\n   terminate_all_lists / 2, terminate_and_get_list / 3"},"list_collection:terminate_all_lists/2":{"prefix":"terminate_all_lists","body":"terminate_all_lists(${1:LCOL}, ${2:Indexes})$3\n$0","description":"terminate_all_lists(+LCOL, -Indexes)\n\n   Terminates all internal lists in the collection, and gets the list of indexes\n\nArguments\n   LCOL    A list collection\n   Indexes    List of indexes\n\nType\n   library(list_collection)\n\nDescription\nComplexity O(ListCount).\n\nModes and Determinism\n   terminate_all_lists(+, -) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n\nSee Also\n   get_list / 3, terminate_and_get_list / 3, reinit / 2, get_indexes / 2"},"list_collection:terminate_and_get_list/3":{"prefix":"terminate_and_get_list","body":"terminate_and_get_list(${1:LCOL}, ${2:Index}, ${3:List})$4\n$0","description":"terminate_and_get_list(+LCOL, ++Index, -List)\n\n   Retrieves the List of elements identified by Index\n\nArguments\n   LCOL    A list collection\n   Index    A ground term or number\n   List    A list of terms\n\nType\n   library(list_collection)\n\nDescription\nEnsures that the internal List of elements identified by Index is terminated, and returns the internal List. Complexity O(1).\n\nModes and Determinism\n   terminate_and_get_list(+, ++, -) is det\n\nExceptions\n     5 --- LCOL is not a list collection.\n     5 --- Index is not a number or is out of range.\n     5 --- Index is not ground.\n\nSee Also\n   get_list / 3, terminate_all_lists / 2, reinit / 2"},"listut:nth0/3":{"prefix":"nth0","body":"nth0(${1:I}, ${2:List}, ${3:Elem})$4\n$0","description":"nth0(?I, ?List, -Elem)\n\n   Access nth element of a list\n\nArguments\n   I    Integer position index, counting from 0\n   List    A list\n   Elem    Any term\n\nType\n   library(listut)\n\nDescription\n\tSucceeds when Elem is the Nth member of List, counting the\n\tfirst as element 0.  (That is, throw away the first N elements\n\tand unify Elem with the next.)\n    \n\nModes and Determinism\n   nth0(+, +, -) is det\n   nth0(-, +, -) is nondet\n   nth0(-, -, -) is nondet\n\nSee Also\n   nth1 / 3, nth0 / 4, nth1 / 4"},"listut:nth0/4":{"prefix":"nth0","body":"nth0(${1:I}, ${2:List}, ${3:Elem}, ${4:Rest})$5\n$0","description":"nth0(?I, ?List, -Elem, -Rest)\n\n   Access nth element and remainder of a list\n\nArguments\n   I    Integer position index, counting from 0\n   List    A list\n   Elem    Any term\n   Rest    A list\n\nType\n   library(listut)\n\nDescription\n\tUnifies Elem with the Nth element of List, counting from 0,\n\tand Rest with the other elements.  It can be used to select\n\tthe Nth (counting from 0) element of List (yielding Elem and\n\tRest), or to insert Elem after the Nth (counting from 1)\n\telement of Rest, when it yields List, e.g. nth0(2, List, c,\n\t[a,b,d,e]) unifies List with [a,b,c,d,e].\n    \n\nModes and Determinism\n   nth0(+, +, -, -) is det\n   nth0(-, +, -, -) is nondet\n   nth0(-, -, -, -) is nondet\n\nSee Also\n   nth0 / 3, nth1 / 3, nth1 / 4"},"listut:nth1/3":{"prefix":"nth1","body":"nth1(${1:I}, ${2:List}, ${3:Elem})$4\n$0","description":"nth1(?I, ?List, -Elem)\n\n   Access nth element of a list\n\nArguments\n   I    Integer position index, counting from 1\n   List    A list\n   Elem    Any term\n\nType\n   library(listut)\n\nDescription\n\tSucceeds when Elem is the Nth member of List, counting the\n\tfirst as element 1.\n    \n\nModes and Determinism\n   nth1(+, +, -) is det\n   nth1(-, +, -) is nondet\n   nth1(-, -, -) is nondet\n\nSee Also\n   nth0 / 3, nth0 / 4, nth1 / 4"},"listut:nth1/4":{"prefix":"nth1","body":"nth1(${1:I}, ${2:List}, ${3:Elem}, ${4:Rest})$5\n$0","description":"nth1(?I, ?List, -Elem, -Rest)\n\n   Access nth element and remainder of a list\n\nArguments\n   I    Integer position index, counting from 1\n   List    A list\n   Elem    Any term\n   Rest    A list\n\nType\n   library(listut)\n\nDescription\n\tUnifies Elem with the Nth element of List, counting from 1,\n\tand Rest with the other elements.  It can be used to select\n\tthe Nth element of List (yielding Elem and Rest), or to insert\n\tElem before the Nth (counting from 1) element of Rest, when it\n\tyields List, e.g. nth1(3, List, c, [a,b,d,e]) unifies List\n\twith [a,b,c,d,e].\n    \n\nModes and Determinism\n   nth1(+, +, -, -) is det\n   nth1(-, +, -, -) is nondet\n   nth1(-, -, -, -) is nondet\n\nSee Also\n   nth0 / 3, nth1 / 3, nth0 / 4"},"m_map:apply_to_list/3":{"prefix":"apply_to_list","body":"apply_to_list(${1:KeyList}, ${2:Map}, ${3:ValueList})$4\n$0","description":"apply_to_list(++KeyList, +Map, ?ValueList)\n\n   Map a list of keys to their corresponding values.\n\nArguments\n   KeyList    A list of keys to map\n   Map    The map to apply\n   ValueList    The list of corresponding values\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate applies the map Map to a list of keys KeyList to\n\tproduce the list of values ValueList; i.e. it maps a list of keys\n\tto their corresponding values.  If one of the keys in KeyList is\n\tnot found in Map, then the predicate aborts witha runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if ValueList does not unify with the list of values corresponding to KeyList.\n\nResatisfiable\n   no\n\nSee Also\n   lookup / 3"},"m_map:contains/2":{"prefix":"contains","body":"contains(${1:Map}, ${2:Key})$3\n$0","description":"contains(+Map, ++Key)\n\n   Check whether a map contains a key.\n\nArguments\n   Map    A map\n   Key    The key to look for\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate checks the map Map to see whether it contains an\n\tentry with key Key.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key does not appear in Map.\n\nResatisfiable\n   no\n\nSee Also\n   search / 3, keys / 2, sorted_keys / 2"},"m_map:count/2":{"prefix":"count","body":"count(${1:Map}, ${2:Count})$3\n$0","description":"count(+Map, ?Count)\n\n   Count the number of elements in a map.\n\nArguments\n   Map    A map\n   Count    The number of elements in Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tCounts the number of elements in the map Map, and attempts to\n\tunify the result with Count.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Count does not unify with the number of elements in Map.\n\nResatisfiable\n   no"},"m_map:delete/3":{"prefix":"delete","body":"delete(${1:Map0}, ${2:Key}, ${3:Map})$4\n$0","description":"delete(+Map0, ++Key, -Map)\n\n   Delete a key/value pair from a map.\n\nArguments\n   Map0    A map\n   Key    The key to delete\n   Map    The map after deletion\n\nType\n   library(m_map)\n\nDescription\n\t\n\tIf the key Key appears in the map Map0, then remove it and its\n\tcorresponding value, resulting in the map Map.  If the key Key\n\tdoes not appear, Map is simply bound to Map0.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   delete_list / 3, remove / 4"},"m_map:delete_list/3":{"prefix":"delete_list","body":"delete_list(${1:Map0}, ${2:KeyList}, ${3:Map})$4\n$0","description":"delete_list(+Map0, ++KeyList, -Map)\n\n   Delete a list of key/value pairs from a map.\n\nArguments\n   Map0    A map\n   KeyList    A list of keys to delete\n   Map    The map after deletions\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate takes a map Map0, and for each key in KeyList,\n\tcalls delete/3 to delete the key and its corresponding\n\tvalue.  The result after all the deletions is the map Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   delete / 3, remove / 4"},"m_map:det_insert/4":{"prefix":"det_insert","body":"det_insert(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"det_insert(+Map0, ++Key, ?Value, -Map)\n\n   Insert a key/value pair into a map, aborting if the key already exists.\n\nArguments\n   Map0    A map\n   Key    A key to insert\n   Value    The value corresponding to Key\n   Map    The map after insertion\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate inserts the key Key with corresponding value Value\n\tinto the map Map0, resulting in the map Map.  If the key Key is\n\talready in the map, then the predicate aborts with a runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   insert / 4, update / 4, det_update / 4, set / 4"},"m_map:det_insert_from_assoc_list/3":{"prefix":"det_insert_from_assoc_list","body":"det_insert_from_assoc_list(${1:Map0}, ${2:List}, ${3:Map})$4\n$0","description":"det_insert_from_assoc_list(+Map0, +List, -Map)\n\n   Insert key/value pairs into a map, aborting if any of the keys already exist.\n\nArguments\n   Map0    A map\n   List    A list of Key-Value pairs to insert\n   Map    The map after insertion\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate takes a map Map0, and for each entry in List (of\n\tthe form Key-Value), calls det_insert/4 to insert the\n\tKey/Value pair into the map.  The result after all the insertions\n\tis the map Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   det_insert / 4, det_insert_from_corresponding_lists / 4, from_assoc_list / 2, from_sorted_assoc_list / 2"},"m_map:det_insert_from_corresponding_lists/4":{"prefix":"det_insert_from_corresponding_lists","body":"det_insert_from_corresponding_lists(${1:Map0}, ${2:KeyList}, ${3:ValueList}, ${4:Map})$5\n$0","description":"det_insert_from_corresponding_lists(+Map0, ++KeyList, ?ValueList, -Map)\n\n   Insert key/value pairs into a map, aborting if any of the keys already exist.\n\nArguments\n   Map0    A map\n   KeyList    A list of keys to insert\n   ValueList    A list of values corresponding to the keys in KeyList\n   Map    The map after insertion\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate takes a map Map0, and for each key Key in KeyList\n\tand corresponding value Value from ValueList, calls\n\tdet_insert/4 to insert the Key/Value pair into the map.\n\tThe result after all the insertions is the map Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if the lists aren't the same length.\n\nResatisfiable\n   no\n\nSee Also\n   det_insert / 4, det_insert_from_assoc_list / 3, from_corresponding_lists / 3"},"m_map:det_remove/4":{"prefix":"det_remove","body":"det_remove(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"det_remove(+Map0, ++Key, ?Value, -Map)\n\n   Remove a key/value pair from a map, aborting if the key is not present.\n\nArguments\n   Map0    A map\n   Key    The key to remove\n   Value    The value corresponding to Key\n   Map    The map after removal\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate removes the key Key and its corresponding value from\n\tthe map Map0, resulting in the map Map.  It then attempts to\n\tunify the removed value with Value.  If the key Key was not in the\n\tmap Map0, then the predicate aborts with a runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Value does not unify with the value corresponding to Key.\n\nResatisfiable\n   no\n\nSee Also\n   delete / 3, remove / 4"},"m_map:det_update/4":{"prefix":"det_update","body":"det_update(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"det_update(+Map0, ++Key, ?Value, -Map)\n\n   Update the value corresponding to a key in a map, aborting if it doesn't exist.\n\nArguments\n   Map0    A map\n   Key    A key to update\n   Value    The value corresponding to Key\n   Map    The map after updating\n\nType\n   library(m_map)\n\nDescription\n\t\n\tIf the key Key already exists in the map Map0, then this\n\tpredicate updates the corresponding value to be Value, resulting\n\tin the map Map.  If the key Key is not already in the map,\n\tthen the predicate aborts with a runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   update / 4, insert / 4, det_insert / 4, set / 4"},"m_map:from_assoc_list/2":{"prefix":"from_assoc_list","body":"from_assoc_list(${1:AssocList}, ${2:Map})$3\n$0","description":"from_assoc_list(+AssocList, -Map)\n\n   Converts an association list into a map.\n\nArguments\n   AssocList    A list of key-value pairs\n   Map    A map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tAssocList is a list of key/value pairs of the form Key-Value, \n\tand Map is a map containing these key/value pairs.  If a key\n\tappears more than once in AssocList, then its corresponding value\n\tin the map Map will be the last one appearing in AssocList.  \n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   to_assoc_list / 2, from_sorted_assoc_list / 2"},"m_map:from_corresponding_lists/3":{"prefix":"from_corresponding_lists","body":"from_corresponding_lists(${1:KeyList}, ${2:ValueList}, ${3:Map})$4\n$0","description":"from_corresponding_lists(++KeyList, ?ValueList, -Map)\n\n   Converts a corresponding pair of lists into a map.\n\nArguments\n   KeyList    A list of keys\n   ValueList    A list of values corresponding to the keys in KeyList\n   Map    The created map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tConverts a list of keys KeyList and a corresponding list of values\n\tValueList into a map Map.  If a key appears more than once in\n\tKeyList, then its corresponding value in the map Map will be\n\tthe last one appearing in AssocList.\n\t\n\t\n\nFail Conditions\n   Fails if the lists aren't the same length.\n\nResatisfiable\n   no\n\nSee Also\n   from_assoc_list / 2, det_insert_from_corresponding_lists / 4"},"m_map:from_sorted_assoc_list/2":{"prefix":"from_sorted_assoc_list","body":"from_sorted_assoc_list(${1:AssocList}, ${2:Map})$3\n$0","description":"from_sorted_assoc_list(+AssocList, -Map)\n\n   Converts a sorted association list into a map.\n\nArguments\n   AssocList    A sorted list of key-value pairs\n   Map    A map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tAssocList is a sorted list of key/value pairs of the form Key-Value,\n\tand Map is a map containing these key/value pairs.  If a key\n\tappears more than once in AssocList, then its corresponding value\n\tin the map Map will be the last one appearing in AssocList.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   to_sorted_assoc_list / 2, from_assoc_list / 2"},"m_map:init/1":{"prefix":"init","body":"init(${1:Map})$2\n$0","description":"init(-Map)\n\n   Initialise a new (empty) map.\n\nArguments\n   Map    The new map\n\nType\n   library(m_map)\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   is_empty / 1"},"m_map:insert/4":{"prefix":"insert","body":"insert(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"insert(+Map0, ++Key, ?Value, -Map)\n\n   Insert a key/value pair into a map, failing if the key already exists.\n\nArguments\n   Map0    A map\n   Key    A key to insert\n   Value    The value corresponding to Key\n   Map    The map after insertion\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate inserts the key Key with corresponding value Value\n\tinto the map Map0, resulting in the map Map.  If the key Key is\n\talready in the map, then the predicate fails.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key already appears in Map0.\n\nResatisfiable\n   no\n\nSee Also\n   det_insert / 4, update / 4, det_update / 4, set / 4"},"m_map:inverse_search/3":{"prefix":"inverse_search","body":"inverse_search(${1:Map}, ${2:Value}, ${3:Key})$4\n$0","description":"inverse_search(+Map, ?Value, ?Key)\n\n   Search a map for a value.\n\nArguments\n   Map    A map\n   Value    A value to search for\n   Key    A key corresponding to Value\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for value entries which unify\n\twith Value.  If such a value is found, then it attempts to unify the\n\tcorresponding key with Key.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Value does not appear in Map or if Key does not unify with any corresponding keys found.\n\nResatisfiable\n   yes\n\nSee Also\n   search / 3, member / 3"},"m_map:is_empty/1":{"prefix":"is_empty","body":"is_empty(${1:Map})$2\n$0","description":"is_empty(+Map)\n\n   Check whether a map is empty.\n\nArguments\n   Map    A map\n\nType\n   library(m_map)\n\nFail Conditions\n   Fails if Map is not an empty map.\n\nResatisfiable\n   no\n\nSee Also\n   init / 1"},"m_map:keys/2":{"prefix":"keys","body":"keys(${1:Map}, ${2:KeyList})$3\n$0","description":"keys(+Map, -KeyList)\n\n   Return all the keys from a map.\n\nArguments\n   Map    A map\n   KeyList    A list of all the keys from Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tKeyList is a list of all the keys appearing in the map Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   sorted_keys / 2, values / 2"},"m_map:lookup/3":{"prefix":"lookup","body":"lookup(${1:Map}, ${2:Key}, ${3:Value})$4\n$0","description":"lookup(+Map, ++Key, ?Value)\n\n   Search a map for a key.\n\nArguments\n   Map    A map\n   Key    A key to search for\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for an entry with key Key.\n\tIf the key is found, then it attempts to unify the corresponding\n\tvalue with Value.  If the key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Value does not unify with the value corresponding to Key.\n\nResatisfiable\n   no\n\nSee Also\n   member / 3, search / 3"},"m_map:lower_bound_lookup/4":{"prefix":"lower_bound_lookup","body":"lower_bound_lookup(${1:Map}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"lower_bound_lookup(+Map, ++SearchKey, ?Key, ?Value)\n\n   Search a map for the smallest key no smaller than SearchKey.\n\nArguments\n   Map    A map\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for the entry with the\n\tsmallest key which is no smaller than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.  If such a key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, upper_bound_search / 4, upper_bound_lookup / 4"},"m_map:m_map_desc":{"prefix":"lib","body":"lib(${1:m_map})$2\n$0","description":"lib(m_map)\n\n\t\n\tThis module provides the `map' abstract data type.  A map, also\n\tknown as a dictionary or an associative array, is a collection of\n\tkey/value pairs which allows you to look up any data item given its\n\tkey.\n\t\n\t\n\tNote that keys must be ground, but values are allowed to be \n\tvariables."},"m_map:member/3":{"prefix":"member","body":"member(${1:Map}, ${2:Key}, ${3:Value})$4\n$0","description":"member(+Map, ?Key, ?Value)\n\n   Succeeds if Key and Value unify with a key/value pair from Map.\n\nArguments\n   Map    A map\n   Key    A key from Map\n   Value    The value in Map corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tTries to unify Key and Value with key/value pairs from the map Map.\n\t\n\t\n\tIf Key and Value are variables and Map is a map, then all\n\tmembers of the map Map are found on backtracking.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with a key/value pair from Map.\n\nResatisfiable\n   yes\n\nSee Also\n   search / 3, lookup / 3"},"m_map:merge/3":{"prefix":"merge","body":"merge(${1:MapA}, ${2:MapB}, ${3:Map})$4\n$0","description":"merge(+MapA, +MapB, -Map)\n\n   Merges two maps into one.\n\nArguments\n   MapA    A map to merge\n   MapB    The other map to merge\n   Map    The merged map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThe map Map is the result of merging the map MapA and the map MapB;\n\ti.e. Map contains all the key/value pairs from both MapA and MapB.\n\tIf MapA and MapB have a key in common, then it is not defined\n\twhich corresponding value will end up associated with that key\n\tin Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   overlay / 3"},"m_map:lower_bound_search/4":{"prefix":"lower_bound_search","body":"lower_bound_search(${1:Map}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"lower_bound_search(+Map, ++SearchKey, ?Key, ?Value)\n\n   Search a map for the smallest key no smaller than SearchKey.\n\nArguments\n   Map    A map\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for the entry with the\n\tsmallest key which is no smaller than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if there are no keys at least as large as SearchKey in Map or if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_lookup / 4, upper_bound_search / 4, upper_bound_lookup / 4"},"m_map:optimize/2":{"prefix":"optimize","body":"optimize(${1:Map0}, ${2:Map})$3\n$0","description":"optimize(+Map0, -Map)\n\n   Optimize a map for many lookups but few/no modification.\n\nArguments\n   Map0    A map to optimize\n   Map    The optimized map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tDeclaratively, this predicate does nothing (i.e. the map Map is\n\tequivalent to the map Map0).  However, operationally it suggests to\n\tthe implementation that the representation of the map be optimised\n\tfor lookups, with few or no modifications to be expected.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no"},"m_map:overlay/3":{"prefix":"overlay","body":"overlay(${1:MapA}, ${2:MapB}, ${3:Map})$4\n$0","description":"overlay(+MapA, +MapB, -Map)\n\n   Overlays one map over another.\n\nArguments\n   MapA    A map\n   MapB    The map to overlay\n   Map    The resulting map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThe map Map contains a key/value pair for every key that appears in\n\teither the map MapA or the map MapB.  If a key Key appears in MapB,\n\tthen its corresponding value in Map is that appearing in MapB;\n\totherwise it is that appearing in MapA.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   merge / 3"},"m_map:remove/4":{"prefix":"remove","body":"remove(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"remove(+Map0, ++Key, ?Value, -Map)\n\n   Remove a key/value pair from a map, failing if the key is not present.\n\nArguments\n   Map0    A map\n   Key    The key to remove\n   Value    The value corresponding to Key\n   Map    The map after removal\n\nType\n   library(m_map)\n\nDescription\n\t\n\tIf the key Key appears in the map Map0, then remove it and attempt\n\tto unify its corresponding value with Value.  Map is Map0 with the\n\tkey removed.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails is Key does not appear in Map0 or if Value does not unify with the corresponding value.\n\nResatisfiable\n   no\n\nSee Also\n   delete / 3, det_remove / 4, remove_smallest / 4"},"m_map:remove_smallest/4":{"prefix":"remove_smallest","body":"remove_smallest(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"remove_smallest(+Map0, ?Key, ?Value, -Map)\n\n   Remove the smallest key and its corresponding value from a map.\n\nArguments\n   Map0    A map\n   Key    The key removed\n   Value    The value corresponding to Key\n   Map    The map after removal\n\nType\n   library(m_map)\n\nDescription\n\t\n\tRemoves the smallest key in the map Map0 (resulting in the\n\tmap Map), and attempts to unify the removed key with Key and\n\tits corresponding value with Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Map0 is empty or if Key and Value do not unify with the key and value removed.\n\nResatisfiable\n   no\n\nSee Also\n   remove / 4"},"m_map:search/3":{"prefix":"search","body":"search(${1:Map}, ${2:Key}, ${3:Value})$4\n$0","description":"search(+Map, ++Key, ?Value)\n\n   Search a map for a key.\n\nArguments\n   Map    A map\n   Key    A key to search for\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for an entry with key Key.\n\tIf the key is found, then it attempts to unify the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key does not appear in Map or if Value does not unify with the corresponding value found.\n\nResatisfiable\n   no\n\nSee Also\n   member / 3, lookup / 3, inverse_search / 3"},"m_map:set/4":{"prefix":"set","body":"set(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"set(+Map0, ++Key, ?Value, -Map)\n\n   Update the value corresponding to a key in a map, inserting the key if it doesn't exist already.\n\nArguments\n   Map0    A map\n   Key    A key to set\n   Value    The value corresponding to Key\n   Map    The map after setting\n\nType\n   library(m_map)\n\nDescription\n\t\n\tIf the key Key already exists in the map Map0, then this predicate\n\tupdates the corresponding value to be Value.  Otherwise it inserts\n\tthe key Key into the map with value Value.  The resulting map is\n\tMap.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   insert / 4, det_insert / 4, update / 4, det_update / 4"},"m_map:select/3":{"prefix":"select","body":"select(${1:Map0}, ${2:KeyList}, ${3:Map})$4\n$0","description":"select(+Map0, ++KeyList, -Map)\n\n   Creates a new map containing just those entries corresponding to a given list of keys.\n\nArguments\n   Map0    A map\n   KeyList    A list of keys to select\n   Map    The resulting map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThe map Map contains the key/value pairs from the map Map0 where\n\tthe key appears in the list KeyList.  Keys in KeyList which do not\n\tappear in Map0 are ignored.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no"},"m_map:sorted_keys/2":{"prefix":"sorted_keys","body":"sorted_keys(${1:Map}, ${2:KeyList})$3\n$0","description":"sorted_keys(+Map, -KeyList)\n\n   Return all the keys from a map, in sorted order.\n\nArguments\n   Map    A map\n   KeyList    A list of all the keys from Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tKeyList is a list of all the keys appearing in the map Map, in\n\tsorted order.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   keys / 2, values / 2"},"m_map:to_assoc_list/2":{"prefix":"to_assoc_list","body":"to_assoc_list(${1:Map}, ${2:AssocList})$3\n$0","description":"to_assoc_list(+Map, -AssocList)\n\n   Converts a map into an association list.\n\nArguments\n   Map    A map\n   AssocList    A list of the key-value pairs from Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tAssocList is a list containing the key/value pairs from the map\n\tMap, in the form Key-Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   to_sorted_assoc_list / 2, from_assoc_list / 2"},"m_map:to_sorted_assoc_list/2":{"prefix":"to_sorted_assoc_list","body":"to_sorted_assoc_list(${1:Map}, ${2:AssocList})$3\n$0","description":"to_sorted_assoc_list(+Map, -AssocList)\n\n   Converts a map into a (sorted) association list.\n\nArguments\n   Map    A map\n   AssocList    A sorted list of the key-value pairs from Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tAssocList is a sorted list containing the key/value pairs from the\n\tmap Map, in the form Key-Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   to_assoc_list / 2, from_sorted_assoc_list / 2"},"m_map:update/4":{"prefix":"update","body":"update(${1:Map0}, ${2:Key}, ${3:Value}, ${4:Map})$5\n$0","description":"update(+Map0, ++Key, ?Value, -Map)\n\n   Update the value corresponding to a key in a map.\n\nArguments\n   Map0    A map\n   Key    A key to update\n   Value    The value corresponding to Key\n   Map    The map after updating\n\nType\n   library(m_map)\n\nDescription\n\t\n\tIf the key Key already exists in the map Map0, then this predicate\n\tupdates the corresponding value to be Value.  The resulting map is\n\tMap.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key does not appear in Map0.\n\nResatisfiable\n   no\n\nSee Also\n   det_update / 4, insert / 4, det_insert / 4, set / 4"},"m_map:upper_bound_lookup/4":{"prefix":"upper_bound_lookup","body":"upper_bound_lookup(${1:Map}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"upper_bound_lookup(+Map, ++SearchKey, ?Key, ?Value)\n\n   Search a map for the largest key no larger than SearchKey.\n\nArguments\n   Map    A map\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for the entry with the\n\tlargest key which is no larger than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.  If such a key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, lower_bound_lookup / 4, upper_bound_search / 4"},"m_map:upper_bound_search/4":{"prefix":"upper_bound_search","body":"upper_bound_search(${1:Map}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"upper_bound_search(+Map, ++SearchKey, ?Key, ?Value)\n\n   Search a map for the largest key no larger than SearchKey.\n\nArguments\n   Map    A map\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_map)\n\nDescription\n\t\n\tThis predicate searches the map Map for the entry with the\n\tlargest key which is no larger than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Fails if there are no keys at least as large as SearchKey in Map or if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, lower_bound_lookup / 4, upper_bound_lookup / 4"},"m_map:values/2":{"prefix":"values","body":"values(${1:Map}, ${2:ValueList})$3\n$0","description":"values(+Map, -ValueList)\n\n   Return all the values from a map.\n\nArguments\n   Map    A map\n   ValueList    A list of all the values from Map\n\nType\n   library(m_map)\n\nDescription\n\t\n\tValueList is a list of all the values appearing in the map Map.\n\t\n\t\n\tThis predicate should only be called with maps created by other\n\tpredicates from the map module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   values / 2"},"m_tree234:assoc_list_to_tree234/2":{"prefix":"assoc_list_to_tree234","body":"assoc_list_to_tree234(${1:AssocList}, ${2:Tree})$3\n$0","description":"assoc_list_to_tree234(+AssocList, -Tree)\n\n   Converts an association list into a tree.\n\nArguments\n   AssocList    A list of key-value pairs\n   Tree    A 2-3-4 tree\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tAssocList is a list of key/value pairs of the form Key-Value,\n\tand Tree is a tree containing these key/value pairs.  If a key\n\tappears more than once in AssocList, then its corresponding value\n\tin the tree Tree will be the last one appearing in AssocList.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   tree234_to_assoc_list / 2"},"m_tree234:count/2":{"prefix":"count","body":"count(${1:Tree}, ${2:Count})$3\n$0","description":"count(+Tree, ?Count)\n\n   Count the number of elements in a tree.\n\nArguments\n   Tree    A 2-3-4 tree\n   Count    The number of elements in Tree\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tCounts the number of elements in the tree Tree, and attempts to\n\tunify the result with Count.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Count does not unify with the number of elements in Tree.\n\nResatisfiable\n   no"},"m_tree234:delete/3":{"prefix":"delete","body":"delete(${1:Tree0}, ${2:Key}, ${3:Tree})$4\n$0","description":"delete(+Tree0, ++Key, -Tree)\n\n   Delete a key/value pair from a tree.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    The key to delete\n   Tree    The tree after deletion\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tIf the key Key appears in the tree Tree0, then remove it and its\n\tcorresponding value, resulting in the tree Tree.  If the key Key\n\tdoes not appear, Tree is simply bound to Tree0.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   remove / 4"},"m_tree234:init/1":{"prefix":"init","body":"init(${1:Tree})$2\n$0","description":"init(-Tree)\n\n   Initialise a new (empty) 2-3-4 tree.\n\nArguments\n   Tree    The new tree\n\nType\n   library(m_tree234)\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   is_empty / 1"},"m_tree234:insert/4":{"prefix":"insert","body":"insert(${1:Tree0}, ${2:Key}, ${3:Value}, ${4:Tree})$5\n$0","description":"insert(+Tree0, ++Key, ?Value, -Tree)\n\n   Insert a key/value pair into a tree, failing if the key already exists.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    A key to insert\n   Value    The value corresponding to Key\n   Tree    The tree after insertion\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate inserts the key Key with corresponding value Value\n\tinto the tree Tree0, resulting in the tree Tree.  If the key Key is\n\talready in the tree, then the predicate fails.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key already appears in Tree0.\n\nResatisfiable\n   no\n\nSee Also\n   update / 4, set / 4"},"m_tree234:is_empty/1":{"prefix":"is_empty","body":"is_empty(${1:Tree})$2\n$0","description":"is_empty(+Tree)\n\n   Check whether a tree is empty.\n\nArguments\n   Tree    A 2-3-4 tree\n\nType\n   library(m_tree234)\n\nFail Conditions\n   Fails if Tree is not an empty tree.\n\nResatisfiable\n   no\n\nSee Also\n   init / 1"},"m_tree234:lookup/3":{"prefix":"lookup","body":"lookup(${1:Tree}, ${2:Key}, ${3:Value})$4\n$0","description":"lookup(+Tree, ++Key, ?Value)\n\n   Search a tree for a key.\n\nArguments\n   Tree    A 2-3-4 tree\n   Key    A key to search for\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for an entry with key Key.\n\tIf the key is found, then it attempts to unify the corresponding\n\tvalue with Value.  If the key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Value does not unify with the value corresponding to Key.\n\nResatisfiable\n   no\n\nSee Also\n   member / 3, search / 3"},"m_tree234:keys/2":{"prefix":"keys","body":"keys(${1:Tree}, ${2:KeyList})$3\n$0","description":"keys(+Tree, -KeyList)\n\n   Return all the keys from a tree.\n\nArguments\n   Tree    A 2-3-4 tree\n   KeyList    A list of all the keys from Tree\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tKeyList is a list of all the keys appearing in the tree Tree.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   values / 2"},"m_tree234:lower_bound_lookup/4":{"prefix":"lower_bound_lookup","body":"lower_bound_lookup(${1:Tree}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"lower_bound_lookup(+Tree, ++SearchKey, ?Key, ?Value)\n\n   Search a tree for the smallest key no smaller than SearchKey.\n\nArguments\n   Tree    A 2-3-4 tree\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for the entry with the\n\tsmallest key which is no smaller than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.  If such a key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, upper_bound_search / 4, upper_bound_lookup / 4"},"m_tree234:lower_bound_search/4":{"prefix":"lower_bound_search","body":"lower_bound_search(${1:Tree}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"lower_bound_search(+Tree, ++SearchKey, ?Key, ?Value)\n\n   Search a tree for the smallest key no smaller than SearchKey.\n\nArguments\n   Tree    A 2-3-4 tree\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for the entry with the\n\tsmallest key which is no smaller than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if there are no keys at least as large as SearchKey in Tree or if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_lookup / 4, upper_bound_search / 4, upper_bound_lookup / 4"},"m_tree234:m_tree234_desc":{"prefix":"lib","body":"lib(${1:m_tree234})$2\n$0","description":"lib(m_tree234)\n\n\t\n\tThis module implements 2-3-4 trees.  They can be used to manage and\n\tindex a collection of key/value pairs.  You probably want to use the\n\tinterface provided by `map.pl' instead of using this module\n\tdirectly.\n\t\n\t\n\tNote that keys must be ground, but values are allowed to be\n\tvariables."},"m_tree234:member/3":{"prefix":"member","body":"member(${1:Tree}, ${2:Key}, ${3:Value})$4\n$0","description":"member(+Tree, ?Key, ?Value)\n\n   Succeeds if Key and Value unify with a key/value pair from Tree.\n\nArguments\n   Tree    A 2-3-4 tree\n   Key    A key from Tree\n   Value    The value in Tree corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tTries to unify Key and Value with key/value pairs from the tree Tree.\n\t\n\t\n\tIf Key and Value are variables and Tree is a 2-3-4 tree, then all\n\tmembers of the tree Tree are found on backtracking.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with a key/value pair from Tree.\n\nResatisfiable\n   yes\n\nSee Also\n   search / 3, lookup / 3"},"m_tree234:remove/4":{"prefix":"remove","body":"remove(${1:Tree0}, ${2:Key}, ${3:Value}, ${4:Tree})$5\n$0","description":"remove(+Tree0, ++Key, ?Value, -Tree)\n\n   Remove a key/value pair from a tree, failing if the key is not present.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    The key to remove\n   Value    The value corresponding to Key\n   Tree    The tree after removal\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tIf the key Key appears in the tree Tree0, then remove it and attempt\n\tto unify its corresponding value with Value.  Tree is Tree0 with the\n\tkey removed.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails is Key does not appear in Tree0 or if Value does not unify with the corresponding value.\n\nResatisfiable\n   no\n\nSee Also\n   delete / 3, remove_smallest / 4"},"m_tree234:remove_smallest/4":{"prefix":"remove_smallest","body":"remove_smallest(${1:Tree0}, ${2:Key}, ${3:Value}, ${4:Tree})$5\n$0","description":"remove_smallest(+Tree0, ?Key, ?Value, -Tree)\n\n   Remove the smallest key and its corresponding value from a tree.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    The key removed\n   Value    The value corresponding to Key\n   Tree    The tree after removal\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tRemoves the smallest key in the tree Tree0 (resulting in the\n\ttree Tree), and attempts to unify the removed key with Key and \n\tits corresponding value with Value.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Tree0 is empty or if Key and Value do not unify with the key and value removed.\n\nResatisfiable\n   no\n\nSee Also\n   remove / 4"},"m_tree234:search/3":{"prefix":"search","body":"search(${1:Tree}, ${2:Key}, ${3:Value})$4\n$0","description":"search(+Tree, ++Key, ?Value)\n\n   Search a tree for a key.\n\nArguments\n   Tree    A 2-3-4 tree\n   Key    A key to search for\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for an entry with key Key.\n\tIf the key is found, then it attempts to unify the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key does not appear in Tree or if Value does not unify with the corresponding value found.\n\nResatisfiable\n   no\n\nSee Also\n   member / 3, lookup / 3"},"m_tree234:set/4":{"prefix":"set","body":"set(${1:Tree0}, ${2:Key}, ${3:Value}, ${4:Tree})$5\n$0","description":"set(+Tree0, ++Key, ?Value, -Tree)\n\n   Update the value corresponding to a key in a tree, inserting the key if it doesn't exist already.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    A key to set\n   Value    The value corresponding to Key\n   Tree    The tree after setting\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tIf the key Key already exists in the tree Tree0, then this predicate\n\tupdates the corresponding value to be Value.  Otherwise it inserts\n\tthe key Key into the tree with value Value.  The resulting tree is\n\tTree.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   insert / 4, update / 4"},"m_tree234:tree234_to_assoc_list/2":{"prefix":"tree234_to_assoc_list","body":"tree234_to_assoc_list(${1:Tree}, ${2:AssocList})$3\n$0","description":"tree234_to_assoc_list(+Tree, -AssocList)\n\n   Converts a tree into an association list.\n\nArguments\n   Tree    A 2-3-4 tree\n   AssocList    A list of the key-value pairs from Tree\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tAssocList is a list containing the key/value pairs from the tree\n\tTree, in the form Key-Value.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   assoc_list_to_tree234 / 2"},"m_tree234:update/4":{"prefix":"update","body":"update(${1:Tree0}, ${2:Key}, ${3:Value}, ${4:Tree})$5\n$0","description":"update(+Tree0, ++Key, ?Value, -Tree)\n\n   Update the value corresponding to a key in a tree.\n\nArguments\n   Tree0    A 2-3-4 tree\n   Key    A key to update\n   Value    The value corresponding to Key\n   Tree    The tree after updating\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tIf the key Key already exists in the tree Tree0, then this predicate\n\tupdates the corresponding value to be Value.  The resulting tree is\n\tTree.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key does not appear in Tree0.\n\nResatisfiable\n   no\n\nSee Also\n   insert / 4, set / 4"},"m_tree234:upper_bound_lookup/4":{"prefix":"upper_bound_lookup","body":"upper_bound_lookup(${1:Tree}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"upper_bound_lookup(+Tree, ++SearchKey, ?Key, ?Value)\n\n   Search a tree for the largest key no larger than SearchKey.\n\nArguments\n   Tree    A 2-3-4 tree\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for the entry with the\n\tlargest key which is no larger than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.  If such a key is not found, then it aborts with\n\ta runtime error.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, lower_bound_lookup / 4, upper_bound_search / 4"},"m_tree234:upper_bound_search/4":{"prefix":"upper_bound_search","body":"upper_bound_search(${1:Tree}, ${2:SearchKey}, ${3:Key}, ${4:Value})$5\n$0","description":"upper_bound_search(+Tree, ++SearchKey, ?Key, ?Value)\n\n   Search a tree for the largest key no larger than SearchKey.\n\nArguments\n   Tree    A 2-3-4 tree\n   SearchKey    A key to search for\n   Key    The key found\n   Value    The value corresponding to Key\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tThis predicate searches the tree Tree for the entry with the\n\tlargest key which is no larger than SearchKey.  If such a key is\n\tfound, then it attempts to unify it with Key and the corresponding\n\tvalue with Value.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Fails if there are no keys at least as large as SearchKey in Tree or if Key and Value do not unify with the key and value found.\n\nResatisfiable\n   no\n\nSee Also\n   lower_bound_search / 4, lower_bound_lookup / 4, upper_bound_lookup / 4"},"m_tree234:values/2":{"prefix":"values","body":"values(${1:Tree}, ${2:ValueList})$3\n$0","description":"values(+Tree, -ValueList)\n\n   Return all the values from a tree.\n\nArguments\n   Tree    A 2-3-4 tree\n   ValueList    A list of all the values from Tree\n\nType\n   library(m_tree234)\n\nDescription\n\t\n\tValueList is a list of all the values appearing in the tree Tree.\n\t\n\t\n\tThis predicate should only be called with trees created by other\n\tpredicates from the tree234 module.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no\n\nSee Also\n   values / 2"},"max_flow_eplex:max_flow_eplex/5":{"prefix":"max_flow_eplex","body":"max_flow_eplex(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue})$6\n$0","description":"max_flow_eplex(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue)\n\n   Linear programming solution for maximum flow problem\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n\nType\n   library(max_flow_eplex)\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex / 5, max_flow_eplex_dual / 5, max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"max_flow_eplex:max_flow_eplex_dual/5":{"prefix":"max_flow_eplex_dual","body":"max_flow_eplex_dual(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue})$6\n$0","description":"max_flow_eplex_dual(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue)\n\n   Linear programming solution for maximum flow problem, dual linear program\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n\nType\n   library(max_flow_eplex)\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex / 5, max_flow_eplex_dual / 5, max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"max_flow_eplex:max_flow_eplex_dual/7":{"prefix":"max_flow_eplex_dual","body":"max_flow_eplex_dual(${1:Graph}, ${2:CapacityArg}, ${3:SourceNode}, ${4:SinkNode}, ${5:MaxFlowValue}, ${6:MinCutNodes}, ${7:MinCutEdges})$8\n$0","description":"max_flow_eplex_dual(+Graph, +CapacityArg, +SourceNode, +SinkNode, -MaxFlowValue, -MinCutNodes, -MinCutEdges)\n\n   Linear programming solution for maximum flow problem, dual linear program. Outputs the cut as nodes and edges.\n\nArguments\n   Graph    a graph structure, no parallel edges, e(Src,Dest,EdgeData)\n   CapacityArg    which argument of EdgeData to use as edge capacity (integer), (0 if EdgeData is a single number and -1 if every edge capacity is 1)\n   SourceNode    source node number (integer)\n   SinkNode    sink node number (integer)\n   MaxFlowValue    value of the maximum flow\n   MinCutNodes    List of nodes that belong to the source side of the minimum cost cut\n   MinCutEdges    List of edges of the minimum cost cut\n\nType\n   library(max_flow_eplex)\n\nSee Also\n   max_flow : max_flow / 5, max_flow : max_flow / 7, max_flow_eplex / 5, max_flow_eplex_dual / 5, max_flow_eplex_dual / 7, all_min_cuts : all_min_cuts / 8, all_min_cuts : all_min_cuts / 9, all_min_cuts : all_min_cuts_list / 5, all_min_cuts_eplex : all_min_cuts_eplex / 7, all_min_cuts_eplex : all_min_cuts_eplex / 8"},"mercury:error/1":{"prefix":"error","body":"error(${1:Message})$2\n$0","description":"error(++Message)\n\n   Abort, printing an error message.\n\nArguments\n   Message    A string giving the error message to display\n\nType\n   library(mercury)\n\nDescription\n\t\n\tCorresponds to Mercury's require:error/1 predicate.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no"},"mercury:mercury_desc":{"prefix":"lib","body":"lib(${1:mercury})$2\n$0","description":"lib(mercury)\n\n\t\n\tThis module provides (a few) Mercury compatibility predicates,\n\tuseful for when porting Mercury modules to ECLiPSe."},"mercury:report_lookup_error/3":{"prefix":"report_lookup_error","body":"report_lookup_error(${1:Message}, ${2:Key}, ${3:Value})$4\n$0","description":"report_lookup_error(++Message, ++Key, ?Value)\n\n   Report a lookup error and abort.\n\nArguments\n   Message    A string giving the error message to display\n   Key    The key that wasn't found\n   Value    The corresponding value, if supplied\n\nType\n   library(mercury)\n\nDescription\n\t\n\tCorresponds to Mercury's require:report_lookup_error/3 predicate.\n\t\n\t\n\nFail Conditions\n   Never fails.\n\nResatisfiable\n   no"},"minizinc:minizinc_desc":{"prefix":"lib","body":"lib(${1:minizinc})$2\n$0","description":"lib(minizinc)\n\nOverview\n\nThis module allows to run MiniZinc models with ECLiPSe.\nMiniZinc models can be either read from a file or stream,\nor they can be embedded as strings into ECLiPSe code.\nThe implementation relies on an external MiniZinc-to-FlatZinc converter,\ne.g. mzn2fzn, and on the FlatZinc interpreter lib(flatzinc).\nMappings to different ECLiPSe solvers are possible via the solver\nmapping libraries fzn_ic, fzn_fd, fzn_eplex, etc.\n\nRunning MiniZinc Models without using this Library\n\nYou can run a MiniZinc model by first converting it to FlatZinc yourself,\nand then using the lib(flatzinc) library. This can be done either via\nan intermediate .fzn file, or by piping the resulting FlatZinc model\ninto the ECLiPSe-FlatZinc interpreter using e.g.\n\n% mzn2fzn --output-to-stdout model.mzn | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\n\nThis should work as long as the mzn2fzn command is in your PATH.\nNote that mzn2fzn is currently not included with ECLiPSe but comes\nwith the Melbourne MiniZinc distribution.  You must also make sure that\nthe correct specialised global constraint definitions are used,\nby including e.g. lib/fzn_ic in mzn2fzn's search path via its -I option.\nFor more details see lib(flatzinc).\n\nRunning MiniZinc Models using this Library\n\nThis library allows you to do everything from within ECLiPSe and let ECLiPSe\ninvoke the MiniZinc to FlatZinc translator (mzn2fzn) internally with the\ncorrect arguments.  The model can be contained in a file:\n\n?- mzn_run(\"model.mzn\", fzn_ic).\n\nor, if a data instance file is used\n\n?- mzn_run(\"model.mzn\", \"instance.dzn\", fzn_ic).\n\nSince MiniZinc models are typically small, they can also be embedded as\na string into ECLiPSe code. For example:\n\n    queens8 :-\n\tmzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n\nNote that, because of the rules for escaping characters within\nECLiPSe strings, the backslashes had to be doubled!\n\nInstallation\n\nThis version is intended to to work with Minizinc 1.1 or later!\n\nIn order to be found by lib(minizinc), the Melbourne Minizinc-to-Flatzinc\nconverter mzn2fzn must be installed in a directory called minizinc-<version>\nin one of the following locations (where we write <ECLIPSEDIR> for\nthe ECLiPSe installation directory, and <ECLIPSEARCH> for\nthe name for the machine architecture, e.g. i386_nt for Windows, i386_linux\nfor Linux):\n\nDirectory specified by $ECLIPSEMZN environment variable\nThe user's home directory, as indicated by $HOME or $HOMEPATH\n<location of lib(minizinc)>/<ECLIPSEARCH>\n<ECLIPSEDIR>/lib_public/<ECLIPSEARCH>\n<ECLIPSEDIR>/lib/<ECLIPSEARCH>\n<ECLIPSEDIR>\nParent of <ECLIPSEDIR> (e.g. \"C:/Program Files\" on Windows)\nDirectory specified by $PROGRAMFILES environment variable\n\nYou can also set the environment variable ECLIPSEMZN (on Windows alternatively\nthe registry entry HKLM/SOFTWARE/IC-Parc/Eclipse//ECLIPSEMZN)\nto the Minizinc installation directory (or to its parent).\n\nCombining a MiniZinc model with Search or I/O in ECLiPSe\n\nThere are several reasons why one might want to embed a MiniZinc model\ninto an ECLiPSe program:\n\nPassing parameters from the ECLiPSe program to the MiniZinc model\nGetting the model solutions back into ECLiPSe\nProgramming custom search in ECLiPSe\nDoing custom output beyond what the Zinc output annotations can do\n\nTo pass a parameter into a MiniZinc model, a generic MiniZinc model must\nbe provided, together with a parameter map.\nThis map is an ECLiPSe list that corresponds to a MiniZinc (actually\nFlatZinc) instance file:\n\nqueens(N) :-\n\tmzn_run_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    [n=N],\t% parameter map: ZincId=EclipseValue\n\t    fzn_ic).\n\nAlternatively, the generic model can be kept separately in a MiniZinc file:\n\nqueens(N) :-\n\tmzn_run(\"n_queens.mzn\", [n=N], fzn_ic).\n\nWith the above exmples, search and output are still completely specified\nin MiniZinc.\n\nTo add your own search routine and/or output, use mzn_load_string/5 or\nmzn_load/5. This has the effect of only loading the MiniZinc model\n(i.e. setting up the constraints), but then returning to ECLiPSe without\nexecuting any MiniZinc solve or output primitives.  The rest of the work\ncan then be done in ECLiPSe:\n\nqueens(N, Q) :-\n\tmzn_load(\"n_queens.mzn\", fzn_ic, [n=N], [q=Q], FznState),\n\tlabeling(Q),\n\tfzn_output(FznState).\n\nThe [q=Q] mapping gives access to the ECLiPSe array Q corresponding to\nthe MiniZinc array q. This is a normal ECLiPSe array of lib(ic) domain\nvariables, and can be used for doing search, or outputting the results.\nIn the example however, we have fallen back onto the FlatZinc output\nroutine to display the results after search has finished.\n\nNote that even if you do your own search in ECLiPSe, your MiniZinc model\nmust contain a solve item to be syntactically correct (and to specify\nthe objective, if any).\n\nOptions\n\nInstead of just the name of the solver mapping (fzn_ic in\nour examples), a zn_options{} structure can be given to\ncustomize the behaviour further, e.g.\n\n\tmzn_run(File, zn_options{solver:fzn_eplex,var_names:on}.\n\nsolver (default: fzn_ic)\n    Determines which ECLiPSe solvers are used.  The name is the\n    name of a library implementing the mapping, e.g. fzn_ic,\n    fzn_fd or fzn_eplex.\n\nsolutions (default: 1)\n    The maximum number of solutions computed. Only effective if using\n    builtin search and not optimizing. (0 or all = all solutions)\n\nsetup_prio (default: 0)\n    The priority under which the constraint setup will be executed\n    (see call_priority/2 and get_priority/1). Possible values are\n    the ECLiPSe priorities 1 to 12, or 0 (the default) which stands\n    for the current priority of the calling code.  A sensible value\n    for this option is 2, which means that the setup code is executed\n    under high priority (still allowing debug/visualisation goals).\n    The effect of such a setting is that no propagation occurs until\n    all constraints are fully set up, possibly leading to time savings.\n\nparser (default: fast)\n    Whether to use a 'strict' or 'fast' parser for FlatZinc input.\n\nvar_names (default: off)\n    Use lib(var_name) to label ECLiPSe variables with their Zinc names.\n    This is useful for debugging.\n\nfzn_tmp (default: file)\n    Use a 'pipe' or intermediate 'file' for FlatZinc.\n\nMapping between MiniZinc/FlatZinc Data and ECLiPSe Data\n\nWhen using ECLiPSe with a Mini/FlatZinc model, one needs to be aware of\nthe mapping from MiniZinc to FlatZinc (e.g. flattening of arrays),\nand the representation of FlatZinc data in ECLiPSe.\n\nNote that the ECLiPSe-side representation depends in part on the chosen\nsolver mapping. The following table shows the mapping used with fzn_ic\n(which employs the lib(ic) and lib(ic_sets) solver libraries):\n\n\tFlatZinc Type/Syntax\t\tECLiPSe Type/Syntax\n\t-----------------------------------------------------------\n\tstring\t\t\t\tstring\n\te.g.\t\"abc\"\t\t\t\"abc\"\n\n\tbool (false/true)\t\tinteger (0/1)\n\te.g.\tfalse\t\t\t0\n\n\tint\t\t\t\tinteger\n\te.g.\t33\t\t\t33\n\n\tfloat\t\t\t\tfloat or breal\n\te.g.\t3.4\t\t\t3.399__3.401\n\n\tset of int\t\t\tordered list of integer\n\te.g.\t{1,5,4}\t\t\t[1,4,5]\n\t\t1..3\t\t\t[1,2,3]\n\n\tarray[1..N] of T\t\tstructure with functor []/N\n\te.g.\t[23,54,0]\t\t[](23,54,0)\n\n\tvar bool\t\t\tlib(ic) integer variable\n\n\tvar int\t\t\t\tlib(ic) integer variable\n\n\tvar float\t\t\tlib(ic) continuous variable\n\n\tvar set of int\t\t\tlib(ic_sets) set variable"},"minizinc:mzn2fzn/4":{"prefix":"mzn2fzn","body":"mzn2fzn(${1:ModelFile}, ${2:InstFileOrParMap}, ${3:SolverOrOptions}, ${4:FznFile})$5\n$0","description":"mzn2fzn(+ModelFile, +InstFileOrParMap, ++SolverOrOptions, ?FznFile)\n\n   Convert a MiniZinc model into a FlatZinc model\n\nArguments\n   ModelFile    File name (extension defaults to .mzn)\n   InstFileOrParMap    Instance file name (extension defaults to .dzn, then .mzn), or list of Id=Term correspondences\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n   FznFile    Name of generated FlatZinc file (will be generated if variable)\n\nType\n   library(minizinc)\n\nDescription\n\n\tConverts a MiniZinc model (given a model file and an instance\n\tfile or parameter map) into a FlatZinc model, by invoking the\n\texternal mzn2fzn converter with the appropriate arguments.\n\tIf no output file name is specified (FznFile uninstantiated),\n\tthe name of the output file is the same as the input file, with\n\tthe extension changed to .fzn.  The options should specify the\n\tsolver that is intended to be used on the FlatZinc model (so that\n\tthe correct version of globals.mzn is used), and the fzn_tmp\n\toption should be set to 'file' (the default).\n    \n\nModes and Determinism\n   mzn2fzn(+, +, ++, ?) is det\n\nExamples\n   \n    ?- mzn2fzn(mymodel, [], zn_options{solver:fzn_ic,fzn_tmp:file}, FznFile).\n    FznFile = \"mymodel.fzn\"\n    Yes (0.00s cpu)\n\nSee Also\n   mzn_run / 3, flatzinc : fzn_run / 2, flatzinc : struct(zn_options)"},"minizinc:mzn_load/5":{"prefix":"mzn_load","body":"mzn_load(${1:ModelFile}, ${2:SolverOrOptions}, ${3:InstFileOrParMap}, ${4:VarMap}, ${5:FznState})$6\n$0","description":"mzn_load(++ModelFile, ++SolverOrOptions, ++InstFileOrParMap, +VarMap, -FznState)\n\n   Load a MiniZinc model from a file\n\nArguments\n   ModelFile    File name (extension defaults to .mzn)\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n   InstFileOrParMap    Instance file name (extension defaults to .dzn, then .mzn), or list of FznId=ECLiPSeGroundTerm correspondences\n   VarMap    List of FznId=ECLiPSeVarTerm correspondences\n   FznState    FlatZinc state descriptor\n\nType\n   library(minizinc)\n\nDescription\n\n\tLoads a MiniZinc from ModelFile.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    \n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n\tAlternatively, an instance file can be specified.\n    \n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    \n    \tThe mzn_load/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    \n\nModes and Determinism\n   mzn_load(++, ++, ++, +, -) is semidet\n\nFail Conditions\n   Fails if the constraint setup fails\n\nExamples\n   \n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4];\n    % Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n\nSee Also\n   mzn_run / 2, mzn_run / 3, mzn_load_string / 5, flatzinc : struct(zn_options)"},"minizinc:mzn_load_string/5":{"prefix":"mzn_load_string","body":"mzn_load_string(${1:MznModel}, ${2:SolverOrOptions}, ${3:ParMap}, ${4:VarMap}, ${5:FznState})$6\n$0","description":"mzn_load_string(++MznModel, ++SolverOrOptions, ++ParMap, +VarMap, -FznState)\n\n   Load a MiniZinc model given as a string or list\n\nArguments\n   MznModel    String, Atom or List of constants\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n   ParMap    List of FznId=ECLiPSeGroundTerm correspondences\n   VarMap    List of FznId=ECLiPSeVarTerm correspondences\n   FznState    FlatZinc state descriptor\n\nType\n   library(minizinc)\n\nDescription\n\n\tLoads the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZinc syntax.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    \n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    \n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n    \n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    \n    \tThe mzn_load_string/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    \n\nModes and Determinism\n   mzn_load_string(++, ++, ++, +, -) is semidet\n\nFail Conditions\n   Fails if the constraint setup fails\n\nExamples\n   \n    ?- mzn_load_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    fzn_ic,\n\t    [n=8],\n\t    [q=Q],\n\t    FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4];\n    % Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n\nSee Also\n   mzn_run / 2, mzn_run / 3, mzn_run_string / 2, flatzinc : struct(zn_options)"},"minizinc:mzn_run/3":{"prefix":"mzn_run","body":"mzn_run(${1:ModelFile}, ${2:InstFileOrParMap}, ${3:SolverOrOptions})$4\n$0","description":"mzn_run(+ModelFile, +InstFileOrParMap, ++SolverOrOptions)\n\n   Run a MiniZinc model from a given model and instance file\n\nArguments\n   ModelFile    File name (extension defaults to .mzn)\n   InstFileOrParMap    Instance file name (extension defaults to .dzn, then .mzn), or list of Id=Term correspondences\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(minizinc)\n\nDescription\n\n\tReads a MiniZinc model (given a model file and an instance\n\tfile) and interprets it using the solver mapping defined in\n\tSolverOrOptions.  At the end of solving, results are printed\n\tto the output stream, timing and progress messages are printed\n\tto the log_output stream, warnings to the warning_output\n\tstream, and error messages the error stream.  This predicate\n\talways succeeds.\n    \n\nModes and Determinism\n   mzn_run(+, +, ++) is det\n\nExamples\n   \n    ?- mzn_run(\"mymodel.mzn\", \"myinstance.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(\"queens.mzn\", [n=8], fzn_ic).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.015s cpu (0.000 setup + 0.000 search)\n\nSee Also\n   mzn_run / 2, mzn_run_string / 2, flatzinc : struct(zn_options)"},"minizinc:mzn_run/2":{"prefix":"mzn_run","body":"mzn_run(${1:File}, ${2:SolverOrOptions})$3\n$0","description":"mzn_run(+File, ++SolverOrOptions)\n\n   Run a MiniZinc model from a given file\n\nArguments\n   File    File name (extension defaults to .mzn)\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(minizinc)\n\nDescription\n\n\tReads a MiniZinc model from a file, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, results are printed to the output stream, timing and\n\tprogress messages are printed to the log_output stream, warnings\n\tto the warning_output stream, and error messages the error stream.\n\tThis predicate always succeeds.\n    \n\nModes and Determinism\n   mzn_run(+, ++) is det\n\nExamples\n   \n    ?- mzn_run(\"mymodel.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(queens8, zn_options{solver:fzn_ic,solutions:3}).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,6,8,3,7,4,2,5]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,7,4,6,8,2,5,3]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n\nSee Also\n   flatzinc : fzn_run / 2, mzn_run / 3, mzn_run_string / 2, flatzinc : struct(zn_options)"},"minizinc:mzn_run_string/2":{"prefix":"mzn_run_string","body":"mzn_run_string(${1:MznModel}, ${2:SolverOrOptions})$3\n$0","description":"mzn_run_string(++MznModel, ++SolverOrOptions)\n\n   Run a MiniZinc model given as a string or list\n\nArguments\n   MznModel    String, Atom or List of constants\n   SolverOrOptions     Name of solver mapping module, or zn_options-structure\n\nType\n   library(minizinc)\n\nDescription\n\n\tSolves the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZInc syntax.  The problem is solved using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Search and output are done according\n\tto the model's solve and output items.\n    \n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    \n\tObviously, one would like to pass parameters into a model.  The\n\tmodel can therefore  be given as a list of strings in MiniZinc\n\tsyntax, interleaved with ECLiPSe ground terms that serve as \n\tparameter instantiations.  The actual MiniZinc model then\n\tconsists of the concatenation of all these parts.\n    \n\nModes and Determinism\n   mzn_run_string(++, ++) is det\n\nExamples\n   \n    ?- mzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    Yes (0.02s cpu, solution 1, maybe more)\n\n    ?- N=8, mzn_run_string([\"\n\t\tint: n = \",\n\t    N, \";\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \"], fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    N = 8\n    Yes (0.02s cpu, solution 1, maybe more)\n</PRE>\n\nSee Also\n   mzn_run / 2, mzn_run / 3, flatzinc : struct(zn_options)"},"vis_structures:argument_number/4":{"prefix":"argument_number","body":"argument_number(${1:Functor}, ${2:AttributeName}, ${3:AttributeNumber}, ${4:Default})$5\n$0","description":"argument_number(++Functor, ++AttributeName, -AttributeNumber, -Default)\n\n   Helper to access attributes of visualization and visualizer terms\n\nArguments\n   Functor    returns the current node id number\n   AttributeName       atom, attribute name\n   AttributeNumber     variable, will be instantiated to the argument number of the attribute name searched for\n   Default    default value used for attribute; value system(_) states that value is set by system not user,\n\nType\n   library(vis_structures)\n\nDescription\nInternal use only\n\nSee Also"},"vis_structures:visualization/s":{"prefix":"struct","body":"struct","description":"struct visualization(root, tree_root, output, ignore_fixed, var_arg, name_arg, focus_arg, parent, stream, schema_path, range_from, range_to, tree_stream, visualizers)\n\n   Defines the data structure for the visualization\n\nFields\n   root    atom (default vis), rootname of the visualization files\n   tree_root    atom (default tree)\n   output    atom/string (default OUTPUT), name of directory where log files will be placed \n   ignore_fixed    yes/no (default yes), states if fixed assignments will be ignored and not create tree nodes\n   var_arg    integer, argument number used to retrieve variables to be assigned\n   name_arg    integer, argument number used to retrieve name of variable to be assigned\n   focus_arg    integer, argument number used to retrieve index number of variables to be assigned\n   parent    integer, current parent node id\n   stream    file descriptor of visualization log file\n   schema_path    Path to the schema description, can be URI or path relative to output directory\n   range_from    integer, only start visualization from this step on\n   range_to    integer, stop visualization when this step is reached\n   tree_stream    file descriptor of tree log file\n   visualizers    open list of visualizer terms attached to visualization\n\nType\n   library(vis_structures)\n\nDescription\nThis structure is used to contain all information about the visualization. The visualizers list is an open list, e.g. it ends with a variable, not the empty list. This allows to add more visualizers at any time point, but requires care when iterating over the visualizers.\n\nSee Also\n   argument_number / 4"},"vis_structures:visualizer/s":{"prefix":"struct","body":"struct","description":"struct visualizer(id, type, type_name, display, x, y, group, width, height, min, max)\n\n   describes the data structures for the visualizers\n\nFields\n   id    integer number of visualizer\n   type    term, contains call pattern to be visualized\n   type_name    atom, name of item to be visualized\n   display    atom (default minimal), influences how the visualizer will be shown\n   x    integer (default 0), x position in visualization where visualizer will be placed\n   y    integer (default 0),y position in visualiation where visualizer will be placed\n   group    group id number used for this visualizer\n   width    optional width of visualizer\n   height    optional height of visualizer\n   min    optional minimal value of variables\n   max    optional maximal value of variable\n\nType\n   library(vis_structures)\n\nDescription\nThis structure is used to store information about each visualizer. Some attributes can be set by the user (defined through argument_number/4\n\nSee Also\n   argument_number / 4"},"visualization:add_visualizer/3":{"prefix":"add_visualizer","body":"add_visualizer(${1:Handle}, ${2:Visualizer}, ${3:Options})$4\n$0","description":"add_visualizer(+Handle, ++Visualizer, ++Options)\n\n   Add a visualizer to the visualisation\n\nArguments\n   Handle    an opaque data structure for the visualization\n   Visualizer    a term, defining the visualizer\n   Options    a list of option:value pairs describing the options to be applied to the visualizer\n\nType\n   library(visualization)\n\nDescription\n\r\nThis predicate is used to add a visualizer to an existing\r\nvisualization.  It can be called after the visualization has been\r\ncreated with a create_visualization/2 call.  The second argument is\r\nthe description of the visualizer, either for variables or for\r\nconstraints.\r\n\r\nVariable visualizers display the state and/or evolution of a\r\ncollection of variables.  At the moment this can be one of the\r\nfollowing entries:\r\n\r\n\r\n\r\nVariable Visualizer  Description\r\n\r\n\r\nvector(L)  The visualizer shows the current state of a\r\ncollection of variables.  It marks which variables have been assigned,\r\nwhich values have been removed and which values remain in the domain.\r\n\r\n\r\nvector_waterfall(L)  This visualizer shows the changes of\r\nthe collection of variables on the path from the root node to the\r\ncurrent node.  It marks if a variable is assigned, changed (min and\r\nmax, min, max or size only), or if it is not modified in each step.\r\n\r\n\r\nvector_size(L)  This visualizer shows the change of the\r\ndomain sizes for a collection of variables from the root node to the\r\ncurrent node in the search.\r\n\r\n\r\nbinary_vector(Bool)  This visualizer is a special variant\r\nof the vector visualizer for a collection of 0/1 vairables.  Values\r\nare marked either as unassigned, or as assigned to zero or to one.\r\n\r\n\r\ndomain_matrix(Matrix)  This visualizer shows a 2D matrix of\r\ndomain variables.  Depending on the options, it only shows the\r\nassigned values, or displayed the values remaining in the domain.\r\n\r\n\r\nbinary_matrix(BoolMatrix)  A specialized version of the\r\nmatrix visualizer for 0/1 variables.\r\n\r\n\r\n\r\n\r\nConstraint visualizers show the state and/or evolution of a global\r\nconstraint.  At the moment, visualizers for the following global\r\nconstraints are provided.\r\n\r\n\r\n\r\nConstraint Visualizer\r\n\r\n\r\nalldifferent(Xs)\r\n\r\n\r\nalldifferent_matrix(Matrix)\r\n\r\n\r\nbin_packing(Items,Sizes,Bins)\r\n\r\n\r\nbool_channeling(X,Bool,Start)\r\n\r\n\r\ncumulative(Starts,Durations,Resources,Limit)\r\n\r\n\r\ncumulative(Starts,Durationss,Resources,Limit,End)\r\n\r\n\r\ndisjoint2(Rectangles)\r\n\r\n\r\nelement(X,Vs,Y)\r\n\r\n\r\ngcc(Limits,Vars)\r\n\r\n\r\ngcc_matrix(RowLimits,ColLimits,Matrix)\r\n\r\n\r\ninverse(Succ,Pred)\r\n\r\n\r\nlex_le(Xs,Ys)\r\n\r\n\r\nlex_lt(Xs,Ys)\r\n\r\n\r\nsame(Xs,Ys)\r\n\r\n\r\nsequence_total(Min,Max,Low,Hi,K,ZeroOnes)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nPossible Options are:\r\n\r\ndisplay\r\n    influences how the visualizer will be drawn (expanded, text, gantt, ...),\r\n    default: minimal\r\ngroup\r\n    group id number for the visualizer (integer, or 'other')\r\nx,y\r\n    position at which the visualizer will be placed (default 0,0)\r\n\r\n\r\n\r\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   fd : alldifferent / 1, ic_global : alldifferent / 1, ic_symbolic : alldifferent / 1, sd : alldifferent / 1, ic : alldifferent / 1, gfd : alldifferent / 1, fd_global : alldifferent / 1, ic_global_gac : alldifferent / 1, fd_global_gac : alldifferent / 1, ic_global : alldifferent_matrix / 1, fd_global : alldifferent_matrix / 1, ic_global_gac : alldifferent_matrix / 1, fd_global_gac : alldifferent_matrix / 1, ic_global : bin_packing / 3, gfd : bin_packing / 3, fd_global : bin_packing / 3, ic_global : bool_channeling / 3, gfd : bool_channeling / 3, fd_global : bool_channeling / 3, cumulative / 3, fd : element / 3, ic_global : element / 3, ic_symbolic : element / 3, ic : element / 3, gfd : element / 3, gfd : gcc / 2, ic_global_gac : gcc / 2, fd_global_gac : gcc / 2, ic_global_gac : gcc_matrix / 3, fd_global_gac : gcc_matrix / 3, ic_global : inverse / 2, gfd : inverse / 2, fd_global : inverse / 2, ic_global_gac : inverse / 2, fd_global_gac : inverse / 2, ic_global : lex_le / 2, gfd : lex_le / 2, fd_global : lex_le / 2, ic_global_gac : lex_le / 2, fd_global_gac : lex_le / 2, ic_global : lex_lt / 2, gfd : lex_lt / 2, fd_global : lex_lt / 2, ic_global_gac : lex_lt / 2, fd_global_gac : lex_lt / 2, ic_global_gac : same / 2, fd_global_gac : same / 2, ic_global : sequence_total / 6, fd_global : sequence_total / 6, create_visualization / 2, close_visualization / 1, visualize_tree : solution / 1, visualize_tree : try / 4, visualize_tree : failure / 4, visualize_tree : tree_indomain / 3, draw_visualization / 1"},"visualization:close_visualization/1":{"prefix":"close_visualization","body":"close_visualization(${1:Handle})$2\n$0","description":"close_visualization(+Handle)\n\n   Stop the visualization, close all log files and flush all file output\n\nArguments\n   Handle    an opaque data structure for the visualization\n\nType\n   library(visualization)\n\nDescription\nThis predicate should be called at the end of a program to close the visualization logs, flush all file output and reset the internal data structures.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   visualize_tree : solution / 1, visualize_tree : try / 4, visualize_tree : failure / 4, visualize_tree : tree_indomain / 3, draw_visualization / 1"},"visualization:create_visualization/2":{"prefix":"create_visualization","body":"create_visualization(${1:Options}, ${2:Handle})$3\n$0","description":"create_visualization(+Options, -Handle)\n\n   Prepare to generate visualization output\n\nArguments\n   Options    a list of option pairs of form option:value\n   Handle    a free variable, will be bound to an opaque data structure for the visualization\n\nType\n   library(visualization)\n\nDescription\nThis predicate prepares the system for visualization output and create a data structure Handle which is used by all other visualization predicates. For every run, the predicate should only be called once. It can not be called again, until the current visualization is closed with close_visualization/1. The predicate only prepares the system, it does not record a execution state on its own.Possible options are:output   atom/string (default 'OUTPUT'), name of directory where log files will be placedignore_fixed    yes/no (default yes), states if fixed assignments will be ignored and not create tree nodes\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   visualize_tree : root / 1, visualize_tree : solution / 1, visualize_tree : try / 4, visualize_tree : failure / 4, visualize_tree : tree_indomain / 3, draw_visualization / 1, close_visualization / 1"},"visualization:draw_visualization/1":{"prefix":"draw_visualization","body":"draw_visualization(${1:Handle})$2\n$0","description":"draw_visualization(+Handle)\n\n   Log the current state of the constraint system\n\nArguments\n   Handle    an opaque data structure for the visualization\n\nType\n   library(visualization)\n\nDescription\nThis predicate is used to explicitely log the state of the constraint systems for visualization. It is used by the application programmer to show the effect of some setup steps, before the search is started. It is also called automatically by the tree logging predicates, so that a user rarely needs to call it inside a search routine.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    draw_visualization(Handle),\n    close_visualization(Handle).\n\nSee Also\n   visualize_tree : root / 1, visualize_tree : solution / 1, visualize_tree : try / 4, visualize_tree : failure / 4, visualize_tree : tree_indomain / 3, draw_visualization / 2"},"visualization:draw_visualization/2":{"prefix":"draw_visualization","body":"draw_visualization(${1:Handle}, ${2:Options})$3\n$0","description":"draw_visualization(+Handle, +Options)\n\n   Log the current state of the constraint system\n\nArguments\n   Handle    an opaque data structure for the visualization\n   Options    a list of option:value pairs\n\nType\n   library(visualization)\n\nDescription\nThis predicate is used to explicitely log the state of the constraint systems for visualization, i.e. create a visualisation time point. It is used by the application programmer to show the effect of some setup steps, before the search is started. It is also called automatically by the tree logging predicates, so that a user rarely needs to call it inside a search routine.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    draw_visualization(Handle,[]),\n    close_visualization(Handle).\n\nSee Also\n   visualize_tree : root / 1, visualize_tree : solution / 1, visualize_tree : try / 4, visualize_tree : failure / 4, visualize_tree : tree_indomain / 3, draw_visualization / 1"},"visualize_tree:extract_array/5":{"prefix":"extract_array","body":"extract_array(${1:Handle}, ${2:RowCol}, ${3:Group}, ${4:Matrix}, ${5:List})$6\n$0","description":"extract_array(+Handle, ++RowCol, ++Group, +Matrix, -List)\n\n   Convert a matrix into a list for search inside a visualization\n\nArguments\n   Handle    an opaque data structure for the visualization\n   RowCol    atom row or col, controlling the order of items in the list\n   Group    integer, a group identifier\n   Matrix    a 2D matrix\n   List    a variable, will be unified with a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nExtract the elements of a matrix inot a list in row or column order. The entries of the list will be terms which can be used inside a search routine with visualization.\n\nExamples\n   model(Matrix):-\r\n    Matrix[1..9,1..9] :: 1..9,\r\n    create_visualization([],Handle),\r\n    add_visualizer(Handle,\r\n    domain_matrix(Matrix),\r\n    [group:1]),\r\n    (for(I,1,9),\r\n     param(Matrix,Method) do\r\n    alldifferent(Matrix[I,1..9]),\r\n    alldifferent(Matrix[1..9,I])\r\n    ),\r\n    (multifor([I,J],[1,1],[7,7],[3,3]),\r\n     param(Matrix) do\r\n    alldifferent(flatten(Matrix[I..I+2,J..J+2]))\r\n    ),\r\n    extract_array(Handle,row,1,Matrix,NamedList),\r\n    root(Handle),\r\n    search(NamedList,1,input_order,tree_indomain(Handle,_),\r\n    complete,[]),\r\n    solution(Handle),\r\n    close_visualization(Handle).\r\n\nSee Also\n   extract_array / 4"},"visualize_tree:extract_array/4":{"prefix":"extract_array","body":"extract_array(${1:Handle}, ${2:RowCol}, ${3:Matrix}, ${4:List})$5\n$0","description":"extract_array(+Handle, ++RowCol, +Matrix, -List)\n\n   Convert a matrix into a list for search inside a visualization\n\nArguments\n   Handle    an opaque data structure for the visualization\n   RowCol    atom row or col, controlling the order of items in the list\n   Matrix    a 2D matrix\n   List    a variable, will be unified with a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nExtract the elements of a matrix inot a list in row or column order. The entries of the list will be terms which can be used inside a search routine with visualization.\n\nExamples\n   model(Matrix):-\r\n    Matrix[1..9,1..9] :: 1..9,\r\n    create_visualization([],Handle),\r\n    add_visualizer(Handle,\r\n    domain_matrix(Matrix),\r\n    []),\r\n    (for(I,1,9),\r\n     param(Matrix,Method) do\r\n    alldifferent(Matrix[I,1..9]),\r\n    alldifferent(Matrix[1..9,I])\r\n    ),\r\n    (multifor([I,J],[1,1],[7,7],[3,3]),\r\n     param(Matrix) do\r\n    alldifferent(flatten(Matrix[I..I+2,J..J+2]))\r\n    ),\r\n    extract_array(Handle,row,Matrix,NamedList),\r\n    root(Handle),\r\n    search(NamedList,1,input_order,tree_indomain(Handle,_),\r\n    complete,[]),\r\n    solution(Handle),\r\n    close_visualization(Handle).\r\n\nSee Also\n   extract_array / 5"},"visualize_tree:failure/4":{"prefix":"failure","body":"failure(${1:Handle}, ${2:Name}, ${3:Size}, ${4:Value})$5\n$0","description":"failure(+Handle, ++Name, ++Size, ++Value)\n\n   Create a fail node for the search tree\n\nArguments\n   Handle    an opaque data structure for the visualization\n   Name    atomic value, the name of the variable to be assigned\n   Size    an integer, the size of the domain of the variable being assigned\n   Value    an integer, the value assigned to the variable\n\nType\n   library(visualize_tree)\n\nDescription\nThis is an interface that should only be used by experienced programmers creating their own search routines. It creates a failure node in the search tree, marking that the assignment of a value for a variable has failed. The different versions of tree_indomain/3 automatically call this predicate on failure of an assignment, so that users should only have to call it if their search routine can not be expressed with those primitives. This predicate does not call draw_visualization/1.\n\nExamples\n\nSee Also\n   root / 1, solution / 1, try / 4"},"visualize_tree:name_variables/4":{"prefix":"name_variables","body":"name_variables(${1:Handle}, ${2:L}, ${3:Names}, ${4:Terms})$5\n$0","description":"name_variables(+Handle, +L, ++Names, -Terms)\n\n   Create a list of terms for a search routine, naming the variables with strings\n\nArguments\n   Handle    an opaque data structure for the visualization\n   L    a list of domain variables to be assigned\n   Names    a list of strings, the names of the variables\n   Terms    a variable, will be unified with a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate creates a list of terms for a search routine creating a visualization. \n\nExamples\n   sendmory(L):-\r\n    L=[S,E,N,D,M,O,R,Y],\r\n    L :: 0..9,\r\n    create_visualization([],Handle),\r\n    add_visualizer(Handle,\r\n    vector(L),\r\n    []),\r\n    alldifferent(L),\r\n    S #\\= 0,\r\n    M #\\= 0,\r\n    1000*S+100*E+10*N+D + \r\n    1000*M+100*O+10*R+E #= \r\n    10000*M + 1000*O+100*N+10*E+Y,\r\n\r\n    name_variables(Handle,L,['S','E','N','D','M','O','R','Y'],Terms),\r\n    root(Handle),\r\n    search(Terms,1,input_order,tree_indomain(Handle,_),\r\n    complete,[]),\r\n    solution(Handle),\r\n    close_visualization(Handle).\n\nSee Also\n   number_variables / 4, name_variables / 5"},"visualize_tree:name_variables/5":{"prefix":"name_variables","body":"name_variables(${1:Handle}, ${2:L}, ${3:Names}, ${4:Group}, ${5:Terms})$6\n$0","description":"name_variables(+Handle, +L, ++Names, ++Group, -Terms)\n\n   Create a list of terms for a search routine, naming the variables with strings\n\nArguments\n   Handle    an opaque data structure for the visualization\n   L    a list of domain variables to be assigned\n   Names    a list of strings, the names of the variables\n   Group    id of the group these variables belong to\n   Terms    a variable, will be unified with a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate creates a list of terms for a search routine creating a visualization. \n\nExamples\n   sendmory(L):-\r\n    L=[S,E,N,D,M,O,R,Y],\r\n    L :: 0..9,\r\n    create_visualization([],Handle),\r\n    add_visualizer(Handle,\r\n    vector(L),\r\n    [group:1]),\r\n    alldifferent(L),\r\n    S #\\= 0,\r\n    M #\\= 0,\r\n    1000*S+100*E+10*N+D + \r\n    1000*M+100*O+10*R+E #= \r\n    10000*M + 1000*O+100*N+10*E+Y,\r\n\r\n    name_variables(Handle,L,['S','E','N','D','M','O','R','Y'],1,Terms),\r\n    root(Handle),\r\n    search(Terms,1,input_order,tree_indomain(Handle,_),\r\n    complete,[]),\r\n    solution(Handle),\r\n    close_visualization(Handle).\n\nSee Also\n   number_variables / 4, name_variables / 5"},"visualize_tree:number_variables/3":{"prefix":"number_variables","body":"number_variables(${1:Handle}, ${2:L}, ${3:Terms})$4\n$0","description":"number_variables(+Handle, +L, -Terms)\n\n   Create a list of terms for a search routine, numbering the variables\n\nArguments\n   Handle    a handle to an opaque data structure for the viualization\n   L    a list of variables to be assigned\n   Terms    a variable, will be unified to a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate is used to number the variables before the search, so that the visualizer knows at each step which variable is currently assigned.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   number_variables / 4, name_variables / 4"},"visualize_tree:number_variables/4":{"prefix":"number_variables","body":"number_variables(${1:Handle}, ${2:L}, ${3:Group}, ${4:Terms})$5\n$0","description":"number_variables(+Handle, +L, +Group, -Terms)\n\n   Create a list of terms for a search routine, numbering the variables\n\nArguments\n   Handle    a handle to an opaque data structure for the viualization\n   L    a list of variables to be assigned\n   Group    an integer, the group identifier\n   Terms    a variable, will be unified to a list of terms\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate is used to number the variables before the search, so that the visualizer knows at each step which variable is currently assigned.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[group:1]),\n    number_variables(Handle,1,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   number_variables / 3, name_variables / 4"},"visualize_tree:root/1":{"prefix":"root","body":"root(${1:Handle})$2\n$0","description":"root(+Handle)\n\n   Create the root node of a search tree\n\nArguments\n   Handle    an opaque data structure for the visualization\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate creates the root node of a search tree in a visualization, this should be called before any choices are made. It automatically calls draw_visualization/1 to collect the information about the state of variables and constraints.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   solution / 1, try / 4, failure / 4, tree_indomain / 3, visualization : draw_visualization / 1"},"visualize_tree:solution/1":{"prefix":"solution","body":"solution(${1:Handle})$2\n$0","description":"solution(+Handle)\n\n   Create a solution node for a search tree\n\nArguments\n   Handle    an opaque data structure for the visualization\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be calledn when a solution of the constraint problem has been found. It create a solution node in the tree log, and logs the current state of the constraint model for visualization.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, try / 4, failure / 4, tree_indomain / 3"},"visualize_tree:tree_indomain/3":{"prefix":"tree_indomain","body":"tree_indomain(${1:Term}, ${2:Handle}, ${3:HandleOut})$4\n$0","description":"tree_indomain(+Term, +Handle, ?HandleOut)\n\n   Primitive to assign a variable while creating a search tree\n\nArguments\n   Term    A term containing the variable to be assigned\n   Handle    an opaque data structure for the visualization\n   HandleOut    will be unified with the Handle argument\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be used instead of indomain/1 when visualizing the execution. Instead of a single variable, it expects a term which describes the name and index of the variable for logging purposes.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, solution / 1, fd : indomain / 1, ic_symbolic : indomain / 1, sd : indomain / 1, ic : indomain / 1, gfd : indomain / 1, tree_indomain / 3, tree_indomain_min / 3, tree_indomain_max / 3, tree_indomain_middle / 3, tree_indomain_random / 3"},"visualize_tree:tree_indomain_max/3":{"prefix":"tree_indomain_max","body":"tree_indomain_max(${1:Term}, ${2:Handle}, ${3:HandleOut})$4\n$0","description":"tree_indomain_max(+Term, +Handle, ?HandleOut)\n\n   Primitive to assign a variable while creating a search tree\n\nArguments\n   Term    A term containing the variable to be assigned\n   Handle    an opaque data structure for the visualization\n   HandleOut    will be unified with the Handle argument\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be used instead of indomain/2 when visualizing the execution. Instead of a single variable, it expects a term which describes the name and index of the variable for logging purposes.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain_max(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, solution / 1, fd_search : indomain / 2, gfd_search : indomain / 2, ic : indomain / 2, tree_indomain / 3, tree_indomain_min / 3, tree_indomain_max / 3, tree_indomain_middle / 3, tree_indomain_random / 3"},"visualize_tree:tree_indomain_middle/3":{"prefix":"tree_indomain_middle","body":"tree_indomain_middle(${1:Term}, ${2:Handle}, ${3:HandleOut})$4\n$0","description":"tree_indomain_middle(+Term, +Handle, ?HandleOut)\n\n   Primitive to assign a variable while creating a search tree\n\nArguments\n   Term    A term containing the variable to be assigned\n   Handle    an opaque data structure for the visualization\n   HandleOut    will be unified with the Handle argument\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be used instead of indomain/2 when visualizing the execution. Instead of a single variable, it expects a term which describes the name and index of the variable for logging purposes.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain_middle(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, solution / 1, fd_search : indomain / 2, gfd_search : indomain / 2, ic : indomain / 2, tree_indomain / 3, tree_indomain_min / 3, tree_indomain_max / 3, tree_indomain_middle / 3, tree_indomain_random / 3"},"visualize_tree:tree_indomain_min/3":{"prefix":"tree_indomain_min","body":"tree_indomain_min(${1:Term}, ${2:Handle}, ${3:HandleOut})$4\n$0","description":"tree_indomain_min(+Term, +Handle, ?HandleOut)\n\n   Primitive to assign a variable while creating a search tree\n\nArguments\n   Term    A term containing the variable to be assigned\n   Handle    an opaque data structure for the visualization\n   HandleOut    will be unified with the Handle argument\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be used instead of indomain/2 when visualizing the execution. Instead of a single variable, it expects a term which describes the name and index of the variable for logging purposes.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain_min(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, solution / 1, fd_search : indomain / 2, gfd_search : indomain / 2, ic : indomain / 2, tree_indomain / 3, tree_indomain_min / 3, tree_indomain_max / 3, tree_indomain_middle / 3, tree_indomain_random / 3"},"visualize_tree:tree_indomain_random/3":{"prefix":"tree_indomain_random","body":"tree_indomain_random(${1:Term}, ${2:Handle}, ${3:HandleOut})$4\n$0","description":"tree_indomain_random(+Term, +Handle, ?HandleOut)\n\n   Primitive to assign a variable while creating a search tree\n\nArguments\n   Term    A term containing the variable to be assigned\n   Handle    an opaque data structure for the visualization\n   HandleOut    will be unified with the Handle argument\n\nType\n   library(visualize_tree)\n\nDescription\nThis predicate should be used instead of indomain/2 when visualizing the execution. Instead of a single variable, it expects a term which describes the name and index of the variable for logging purposes.\n\nExamples\n   top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,\n    tree_indomain_random(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n\nSee Also\n   root / 1, solution / 1, fd_search : indomain / 2, gfd_search : indomain / 2, ic : indomain / 2, tree_indomain / 3, tree_indomain_min / 3, tree_indomain_max / 3, tree_indomain_middle / 3, tree_indomain_random / 3"},"visualize_tree:try/4":{"prefix":"try","body":"try(${1:Handle}, ${2:Name}, ${3:Size}, ${4:Value})$5\n$0","description":"try(+Handle, ++Name, ++Size, ++Value)\n\n   Create a try node for the search tree\n\nArguments\n   Handle    an opaque data structure for the visualization\n   Name    atomic value, the name of the variable to be assigned\n   Size    an integer, the size of the domain of the variable being assigned\n   Value    an integer, the value assigned to the variable\n\nType\n   library(visualize_tree)\n\nDescription\nThis is an interface that should only be used by experienced programmers creating their own search routines. It creates a try node in the search tree, marking that the assignment of a value for a variable has succeeded. The different versions of tree_indomain/3 automatically call this predicate, so that users should only have to call it if their search routine can not be expressed with those primitives. This predicate does not call draw_visualization/1.\n\nExamples\n\nSee Also\n   root / 1, solution / 1, failure / 4"},"xml:xml_desc":{"prefix":"lib","body":"lib(${1:xml})$2\n$0","description":"lib(xml)\n\nNote for ECLiPSe users\n\nThis code creates and accepts character lists rather than ECLiPSe strings. \nTo convert between character lists and (UTF8 or ASCII) strings, use the\nECLiPSe built-in string_list/3. For example, to parse a UTF-8 encoded\nXML file, use the following code:\n\nxml_parse_file(File, Document) :-\n\topen(File, read, Stream),\n\tread_string(Stream, end_of_file, _, Utf8String),\n\tclose(Stream),\n\tstring_list(Utf8String, Chars, utf8),\n\txml_parse(Chars, Document).\n\nThis is Revision 2.0 of John Fletcher's code.\nMost of the subsequent text is taken literally from\n\nhttp://www.binding-time.co.uk/xmlpl.html.\n\nTERMS AND CONDITIONS\n\nThis program is offered free of charge, as unsupported source code. You may\nuse it, copy it, distribute it, modify it or sell it without restriction,\nbut entirely at your own risk.\n\nWe hope that it will be useful to you, but it is provided \"as is\" without\nany warranty express or implied, including but not limited to the warranty\nof non-infringement and the implied warranties of merchantability and fitness\nfor a particular purpose.\n\nHistory:\n$Log: xml_comments.ecl,v $\nRevision 1.4  2009/07/16 09:11:23  jschimpf\nMerged patches_6_0 branch up to merge_2009_07_16\n\nRevision 1.3.2.2  2009/04/09 02:11:38  jschimpf\nUpdated the url in documentation\n\nRevision 1.3.2.1  2009/02/19 06:26:40  jschimpf\nAdded comment(categories,...) annotations for better documentation\n\nRevision 1.3  2006/10/17 22:06:22  jschimpf\nReinserted lost licensing paragraph.\n\nRevision 1.2  2006/10/17 22:02:21  jschimpf\nUpgraded to John Fletcher's revision 2.0, released 2006/06/18,\navailable at http://www.zen37763.zen.co.uk/xml_download.html\n\nRevision 1.1  2003/03/31 13:58:02  js10\nUpgraded to latest version from John Fletcher's web site\n\nRevision 1.2  2002/03/26 22:56:55  js10\nAdded John Fletcher's public domain XML parser/generator\n\nRevision 1.1  2002/03/26 22:50:07  js10\nAdded John Fletcher's public domain XML parser/generator\n\n  Background\n  xml.pl is a module for parsing XML with Prolog, which provides\nProlog applications with a simple \"Document Value Model\"\ninterface to XML documents. It has been used successfully in a number of applications.\n  It supports a subset of XML suitable\nfor XML Data and Worldwide Web applications. It is not as strict nor as\ncomprehensive as the XML 1.0 Specification mandates.\n  It is not as strict, because, while the\nspecification must eliminate ambiguities, not all errors need to be regarded as\nfaults, and some reasonable examples of real XML usage would have to be\nrejected if they were.\n  It is not as comprehensive, because,\nwhere the XML specification makes provision for more or less complete DTDs to be provided as part of a\ndocument, xml.pl actions the local definition of ENTITIES only. Other DTD extensions are treated as\ncommentary.\n  \n   The code, and a\nsmall Windows application which embodies it, has been placed into the public domain, to\nencourage the use of Prolog with XML.\n  I hope that they will be useful to\nyou, but they are not supported, and they are provided without any warranty of any kind.\n  Specification\n  Three predicates are exported by the\nmodule: xml_parse/[2,3], xml_subterm/2 and xml_pp/1.\n  \n   xml_parse( {+Controls}, +?Chars,\n?+Document ) parses Chars, a list of character codes,\nto/from a data structure of the form \nxml(\n<attributes>, \n<content>)\n , where:\n  \n   \n    \n<attributes>\n    is a list of \n\n<name>=\n<char data>\n attributes from the (possibly implicit) XML signature of the\ndocument.\n  \n   \n    \n<content>\n    is a (possibly empty) list comprising occurrences of :\n  \n   \n    \npcdata(\n<char data>)\n\n   \n   Text\n   \n    \ncomment(\n<char data>)\n\n   \n   An xml comment;\n   \n    \nnamespace(\n<URI>,\n<prefix>,\n<element>)\n\n   \n   a Namespace\n   \n    \nelement(\n<tag>, \n<attributes>, \n<content>)\n\n   \n   \n    \n     \n<tag>..</tag>\n     encloses \n<content> or \n<tag /> if empty.\n   \n    \ninstructions(\n<name>, \n<char data>)\n\n   \n   A PI  \n<?\n<name>\n<char data>\n?>\n   \n    \ncdata(\n<char data>)\n\n   \n   <![CDATA[\n<char data>]]>\n\n   \n    \ndoctype(\n<tag>, \n<doctype id>)\n\n   \n   \n    \nDTD <!DOCTYPE .. >\n   \n  \n  The conversions are not completely\nsymmetrical, in that weaker XML is accepted than can be generated.\nSpecifically, in-bound (Chars ->\nDocument) parsing does not require strictly well-formed XML. If Chars does not represent well-formed\nXML, Document is instantiated\nto the term malformed(\n<attributes>, \n<content>)\n\n .\n  The \n<content> of a malformed/2\nstructure can include:\n  \n   \n    \nunparsed( \n<char data> )\n\n   \n   Text which has not been parsed\n   \n    \nout_of_context( \n<tag> )\n\n   \n   \n    \n     \n<tag>\n     is not closed\n\n  \n  in addition to the parsed term\ntypes.\n  Out-bound (Document -> Chars) parsing does require that Document defines well-formed XML. If\nan error is detected a 'domain' exception is raised.\n  The domain exception will attempt to\nidentify the particular sub-term in error and the message will show a list of\nits ancestor elements in the form \n<tag>{(id)}* where \n\n<id>\n is the value of any attribute named id.\n  At this release, the Controls applying\nto in-bound (Chars ->\nDocument) parsing are:\n  \n   \n    \nextended_characters(\n<bool>)\n\n   \n   Use the extended character entities for XHTML (default true).\n   \n    \nformat(\n<bool>)\n\n   \n   Remove layouts\nwhen no non-layout character data appears between elements (default true).\n   \n    \nremove_attribute_prefixes(\n<bool>)\n\n   \n   Remove redundant prefixes from attributes - i.e. prefixes\n   denoting the namespace of the parent element (default false).\n   \n    \nallow_ampersand(\n<bool>)\n\n   \n   Allow unescaped ampersand characters (&) to occur in PCDATA\n(default false).\n  \n  For out-bound (Document -> Chars) parsing, the\nonly available option is:\n  \n   \n    \nformat(\n<bool>)\n\n   \n   Indent the element content, (default true)\n  \n  Types\n  \n   \n    \n     \n<tag>\n    \n   \n   An atom naming an element\n   \n    \n     \n<name>\n    \n   \n   An atom, not naming an element\n   \n    \n     \n<URI>\n    \n   \n   An atom giving the URI of a Namespace\n   \n    \n     \n<char data>\n    \n   \n   A \"string\": list of character codes.\n   \n    \n     \n<doctype id>\n    \n   \n   one of \npublic(\n<char data>, \n<char data>)\n,\npublic(\n<char data>,\n\n<char data>,\n\n<dtd literals>),\nsystem(\n<char data>),\nsystem(\n<char data>,\n\n<dtd literals>),\nlocal or local(\n<dtd literals>)\n   \n    \n     \n<dtd literals>\n    \n   \n   A non-empty list of\n\tdtd_literal(\n<char data>) terms - e.g. attribute-list\ndeclarations.\n   \n    \n     \n<bool>\n    \n   \n   one of true\nor false\n  \n  \n   xml_subterm( +XMLTerm, ?Subterm ) unifies Subterm\n   with a sub-term\nof Term. This can be especially\nuseful when trying to test or retrieve a deeply-nested subterm from a document\n- as demonstrated in this example program.\nNote that XMLTerm is a sub-term of itself.\n  \n   xml_pp( +XMLDocument )\"pretty\nprints\" XMLDocument on the\ncurrent output stream.\n  Availability\n  The module is available from this site, and is supplied as a library with the following Prologs:\n  \n   It is available in the ECLiPSe Constraint Programming System, as a\nthird-party library;\n   It has been ported to B-Prolog\nby Neng-Fa Zhou.\n   It has been adapted for SICStus Prolog version 3.11+\nby Mats Carlsson.\n   It is included in Quintus Prolog Release 3.5.\n  \n  Features of xml.pl\n  The xml/2 data structure has some useful properties.\n  Reusability\n  Using an \"abstract\" Prolog\nrepresentation of XML, in which terms represent document \"nodes\", makes the\nparser reuseable for any XML application.\n  In effect, xml.pl encapsulates the\napplication-independent tasks of document parsing and generation, which is\nessential where documents have components from more than one Namespace.\n  Same Structure\n  The Prolog term representing a document\nhas the same structure as the document itself, which makes the correspondence\nbetween the literal representation of the Prolog term and the XML source\nreadily apparent.\n  For example, this simple SVG image:\n     \n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\" \"http://www.w3.org/.../svg10.dtd\"\n    [\n    <!ENTITY redblue \"fill: red; stroke: blue; stroke-width: 1\">\n    ]>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\">\n <circle cx=\" 25 \" cy=\" 25 \" r=\" 24 \" style=\"&redblue;\"/>\n</svg>\n  \n  ... translates into this Prolog\nterm:\n     \nxml( [version=\"1.0\", standalone=\"no\"],\n    [\n    doctype( svg, public( \"-//W3C//DTD SVG 1.0//EN\", \"http://www.w3.org/.../svg10.dtd\" ) ),\n    namespace( 'http://www.w3.org/2000/svg', \"\",\n    element( svg,\n    [width=\"500\", height=\"500\"],\n    [\n    element( circle,\n    [cx=\"25\", cy=\"25\", r=\"24\", style=\"fill: red; stroke: blue; stroke-width: 1\"],\n    [] )\n    ] )\n    )\n    ] ).\n  \n  Efficient Manipulation\n  Each type of node in an XML document is\nrepresented by a different Prolog functor, while data, (PCDATA, CDATA and\nAttribute Values), are left as \"strings\", (lists of character codes).\n  The use of distinct functors for\nmark-up structures enables the efficient recursive traversal of a document,\nwhile leaving the data as strings facilitates application-specific parsing of\ndata content (aka Micro-parsing).\n  \n   For example, to turn every CDATA node\ninto a PCDATA node with tabs expanded into spaces:\n       \ncdata_to_pcdata( cdata(CharsWithTabs), pcdata(CharsWithSpaces) ) :-\n    tab_expansion( CharsWithTabs, CharsWithSpaces ).\ncdata_to_pcdata( xml(Attributes, Content1), xml(Attributes, Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( namespace(URI,Prefix,Content1), namespace(URI,Prefix,Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( element(Name,Attrs,Content1), element(Name,Attrs,Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( [], [] ).\ncdata_to_pcdata( [H1|T1], [H2|T2] ) :-\n    cdata_to_pcdata( H1, H2 ),\n    cdata_to_pcdata( T1, T2 ).\ncdata_to_pcdata( pcdata(Chars), pcdata(Chars) ).\ncdata_to_pcdata( comment(Chars), comment(Chars) ).\ncdata_to_pcdata( instructions(Name, Chars), instructions(Name, Chars) ).\ncdata_to_pcdata( doctype(Tag, DoctypeId), doctype(Tag, DoctypeId) ).\n   \n  \n  The above uses no 'cuts', but will not\ncreate any choice points with ground input.\n  Elegance\n  The resolution of entity references and\nthe decomposition of the document into distinct nodes means that the calling\napplication is not concerned with the occasionally messy syntax of XML\ndocuments.\n  For example, the clean separation of\nnamespace nodes means that Namespaces, which are useful in combining\nspecifications developed separately, have similar usefulness in combining\napplications developed separately.\n  \n   The source code is available here.\nAlthough it is unsupported, please feel free to e-mail queries and suggestions. I\nwill respond as time allows."},"xml:xml_parse/2":{"prefix":"xml_parse","body":"xml_parse(${1:Chars}, ${2:Document})$3\n$0","description":"xml_parse(?Chars, ?Document)\n\n   Parse or generate XML documents\n\nArguments\n   Chars    List of characters\n   Document    Document as structured term\n\nType\n   library(xml)\n\nModes and Determinism\n   xml_parse(+, -)\n   xml_parse(-, +)\n\nSee Also\n   xml_parse / 3, xml_subterm / 2, xml_pp / 1"},"xml:xml_parse/3":{"prefix":"xml_parse","body":"xml_parse(${1:Controls}, ${2:Chars}, ${3:Document})$4\n$0","description":"xml_parse(+Controls, ?Chars, ?Document)\n\n   Parse or generate XML documents\n\nArguments\n   Controls    List of options\n   Chars    List of characters (XML text)\n   Document    Document as structured term\n\nType\n   library(xml)\n\nDescription\n\nxml_parse( {+Controls}, +?Chars, ?+Document ) parses Chars to/from a data\nstructure of the form xml(<atts>, <content>). <atts> is a list of\n<atom>=<string> attributes from the (possibly implicit) XML signature of the\ndocument. <content> is a (possibly empty) list comprising occurrences of :\n\npcdata(<string>)\t\t:\tText\ncomment(<string>)\t\t:\tAn xml comment;\nelement(<tag>,<atts>,<content>)\t:\t<tag>..</tag> encloses <content>\n\t\t\t\t:       <tag /> if empty\ninstructions(<atom>, <string>)\t:\tProcessing <? <atom> <params> ?>\ncdata( <string> )\t\t:\t<![CDATA[ <string> ]]>\ndoctype(<atom>, <doctype id>)\t:\tDTD <!DOCTYPE .. >\n\nThe conversions are not completely symmetrical, in that weaker XML is\naccepted than can be generated. Specifically, in-bound (Chars -> Document)\ndoes not  require strictly well-formed XML. Document is instantiated to the\nterm malformed(Attributes, Content) if Chars does not represent well-formed\nXML. The Content of a malformed/2 structure can contain:\n\nunparsed( <string> )\t\t:\tText which has not been parsed\nout_of_context( <tag> )\t\t:\t<tag> is not closed\n\nin addition to the standard term types.\n\nOut-bound (Document -> Chars) parsing _does_ require that Document defines\nstrictly well-formed XML. If an error is detected a 'domain' exception is\nraised.\n\nThe domain exception will attempt to identify the particular sub-term in\nerror and the message will show a list of its ancestor elements in the form\n<tag>{(id)}* where <id> is the value of any attribute _named_ id.\n\nAt this release, the Controls applying to in-bound (Chars -> Document)\nparsing are:\n\nextended_characters(<bool>)\t    :\tUse the extended character\n\t\t\t\t    :\tentities for XHTML (default true)\n\nformat(<bool>)\t\t\t    :\tStrip layouts when no character data\n\t\t\t\t    :\tappears between elements.\n\t\t\t\t    :\t(default true)\n\nremove_attribute_prefixes(<bool>)   :  Remove namespace prefixes from\n    :  attributes when it's the same as the\n    :  prefix of the parent element\n    :  (default false).\n\nallow_ampersand(<bool>)    :  Allow unescaped ampersand\n    :  characters (&) to occur in PCDATA.\n    :  (default false).\n\n[<bool> is one of 'true' or 'false']\n\nFor out-bound (Document -> Chars) parsing, the only available option is:\n\nformat(<Bool>)\t\t\t    :\tIndent the element content\n\t\t\t\t    :\t(default true)\n\nDifferent DCGs for input and output are used because input parsing is\nmore flexible than output parsing. Errors in input are recorded as part\nof the data structure. Output parsing throws an exception if the document\nis not well-formed, diagnosis tries to identify the specific culprit term.\n\nModes and Determinism\n   xml_parse(+, +, -)\n   xml_parse(+, -, +)\n\nSee Also\n   xml_parse / 2"},"xml:xml_pp/1":{"prefix":"xml_pp","body":"xml_pp(${1:XMLDocument})$2\n$0","description":"xml_pp(+XMLDocument)\n\n   Pretty-prints XMLDocument on the current output stream\n\nArguments\n   XMLDocument    Document as structured term\n\nType\n   library(xml)\n\nSee Also\n   xml_parse / 2, xml_parse / 3, xml_subterm / 2"},"xml:xml_subterm/2":{"prefix":"xml_subterm","body":"xml_subterm(${1:XMLTerm}, ${2:Subterm})$3\n$0","description":"xml_subterm(+XMLTerm, ?Subterm)\n\n   Unifies Subterm with a sub-term of Term.\n\nArguments\n   XMLTerm    Structured term\n   Subterm    Structured term\n\nType\n   library(xml)\n\nDescription\n\n    This can be especially useful when trying to test or retrieve a\n    deeply-nested subterm from a document - as demonstrated in this\n    example\n    program.  Note that XMLTerm is a sub-term of itself.\n\nSee Also\n   xml_parse / 2, xml_parse / 3, xml_pp / 1"}}
